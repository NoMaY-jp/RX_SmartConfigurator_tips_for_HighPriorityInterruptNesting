
RXv3_RegBankSave_GCC.elf:     file format elf32-rx-le


Disassembly of section .text:

ffc00000 <_PowerON_Reset>:


_PowerON_Reset_PC :
_PowerON_Reset :
;;initialise user stack pointer
    mvtc    #_ustack,USP
ffc00000:	fd 73 02 00 1e 00 00          	mvtc	#0x1e00, usp

;;initialise interrupt stack pointer
    mvtc    #_istack,ISP
ffc00007:	fd 73 0a 00 0e 00 00          	mvtc	#0xe00, isp

;;jump to Power ON Reset main function in RESETPRG.C
    bra     _PowerON_Reset_PC_Prg
ffc0000e:	04 07 42 00                   	bra.a	ffc04215 <_Reset_Vector+0xffc04219>

ffc00012 <__INITSCT>:
    .global __INITSCT
    .type   __INITSCT,@function
__INITSCT:

;;load data section from ROM to RAM
    pushm   r1-r3
ffc00012:	6e 13                         	pushm	r1-r3
    mov     #_mdata,r2      ;;src ROM address of data section in R2
ffc00014:	fb 22 70 6e c0 ff             	mov.l	#0xffc06e70, r2
    mov     #_data,r1       ;;dest start RAM address of data section in R1
ffc0001a:	fb 12 04 00 00 00             	mov.l	#4, r1
    mov     #_edata,r3      ;;end RAM address of data section in R3
ffc00020:	fb 32 5c 04 00 00             	mov.l	#0x45c, r3
    sub     r1,r3           ;;size of data section in R3 (R3=R3-R1)
ffc00026:	43 13                         	sub	r1, r3
    smovf                   ;;block copy R3 bytes from R2 to R1
ffc00028:	7f 8f                         	smovf

;;bss initialisation : zero out bss
    mov    #00h,r2          ;;load R2 reg with zero
ffc0002a:	66 02                         	mov.l	#0, r2
    mov    #_ebss, r3       ;;store the end address of bss in R3
ffc0002c:	fb 32 b8 08 00 00             	mov.l	#0x8b8, r3
    mov    #_bss, r1        ;;store the start address of bss in R1
ffc00032:	fb 12 5c 04 00 00             	mov.l	#0x45c, r1
    sub    r1,r3            ;;size of bss section in R3 (R3=R3-R1)
ffc00038:	43 13                         	sub	r1, r3
    sstr.b
ffc0003a:	7f 88                         	sstr.b
    popm    r1-r3
ffc0003c:	6f 13                         	popm	r1-r3
    rts
ffc0003e:	02                            	rts

ffc0003f <_exit>:

#endif

;;call to exit
_exit:
    bra  _loop_here
ffc0003f:	2e 02                         	bra.b	ffc00041 <_Reset_Vector+0xffc00045>

ffc00041 <_loop_here>:
_loop_here:
    bra _loop_here
ffc00041:	2e 00                         	bra.b	ffc00041 <_Reset_Vector+0xffc00045>

ffc00043 <___ieee754_sqrtf>:
ffc00043:	74 01 00 00 80 7f             	cmp	#0x7f800000, r1
ffc00049:	23 05                         	bnc.b	ffc0004e <_Reset_Vector+0xffc00052>
ffc0004b:	38 8f 00                      	bra.w	ffc000da <_Reset_Vector+0xffc000de>
ffc0004e:	fd 97 1f                      	shlr	#23, r1, r15
ffc00051:	3a 92 00                      	beq.w	ffc000e3 <_Reset_Vector+0xffc000e7>
ffc00054:	77 21 ff ff 7f                	and	#0x7fffff, r1
ffc00059:	79 71                         	bset	#23, r1
ffc0005b:	71 ff 81                      	add	#-127, r15, r15
ffc0005e:	6a 1f                         	shar	#1, r15
ffc00060:	22 10                         	bc.b	ffc00070 <_Reset_Vector+0xffc00074>
ffc00062:	fb e2 c6 4b 37 49             	mov.l	#0x49374bc6, r14
ffc00068:	fc 27 1e                      	divu	r1, r14
ffc0006b:	71 ee 6e                      	add	#110, r14, r14
ffc0006e:	2e 10                         	bra.b	ffc0007e <_Reset_Vector+0xffc00082>
ffc00070:	6c 11                         	shll	#1, r1
ffc00072:	fb e2 72 68 91 6d             	mov.l	#0x6d916872, r14
ffc00078:	fc 27 1e                      	divu	r1, r14
ffc0007b:	71 ee 4a                      	add	#74, r14, r14
ffc0007e:	fd 82 12                      	shlr	#2, r1, r2
ffc00081:	4f e2                         	mul	r14, r2
ffc00083:	68 82                         	shlr	#8, r2
ffc00085:	4f e2                         	mul	r14, r2
ffc00087:	fd 81 23                      	shlr	#1, r2, r3
ffc0008a:	4b 23                         	add	r2, r3
ffc0008c:	70 33 00 00 00 60             	add	#0x60000000, r3, r3
ffc00092:	7e 13                         	neg	r3
ffc00094:	fc 1f 32                      	emulu	r3, r2
ffc00097:	fb 22 00 00 00 1e             	mov.l	#0x1e000000, r2
ffc0009d:	43 32                         	sub	r3, r2
ffc0009f:	68 52                         	shlr	#5, r2
ffc000a1:	4f e2                         	mul	r14, r2
ffc000a3:	ef 2e                         	mov.l	r2, r14
ffc000a5:	fc 1f 22                      	emulu	r2, r2
ffc000a8:	6c 13                         	shll	#1, r3
ffc000aa:	fd c7 12                      	shll	#7, r1, r2
ffc000ad:	fc 1f 32                      	emulu	r3, r2
ffc000b0:	6c 12                         	shll	#1, r2
ffc000b2:	7e 53                         	rolc	r3
ffc000b4:	7e 12                         	neg	r2
ffc000b6:	fb 22 00 00 00 c0             	mov.l	#0xc0000000, r2
ffc000bc:	fc 03 32                      	sbb	r3, r2
ffc000bf:	fc 1f e2                      	emulu	r14, r2
ffc000c2:	6c 21                         	shll	#2, r1
ffc000c4:	fc 1f 31                      	emulu	r3, r1
ffc000c7:	71 ff 7f                      	add	#127, r15, r15
ffc000ca:	6d 7f                         	shll	#23, r15
ffc000cc:	7b 72                         	bclr	#23, r2
ffc000ce:	70 11 ff ff ff 7f             	add	#0x7fffffff, r1, r1
ffc000d4:	fc 0b f2                      	adc	r15, r2
ffc000d7:	ef 21                         	mov.l	r2, r1
ffc000d9:	02                            	rts
ffc000da:	10                            	beq.s	ffc000e2 <_Reset_Vector+0xffc000e6>
ffc000db:	fd c1 12                      	shll	#1, r1, r2
ffc000de:	14                            	beq.s	ffc000e2 <_Reset_Vector+0xffc000e6>
ffc000df:	fb 16 ff                      	mov.l	#-1, r1
ffc000e2:	02                            	rts
ffc000e3:	61 01                         	cmp	#0, r1
ffc000e5:	20 fd                         	beq.b	ffc000e2 <_Reset_Vector+0xffc000e6>
ffc000e7:	0d                            	bra.s	ffc000ec <_Reset_Vector+0xffc000f0>
ffc000e8:	6c 11                         	shll	#1, r1
ffc000ea:	60 1f                         	sub	#1, r15
ffc000ec:	7d 71                         	btst	#23, r1
ffc000ee:	20 fa                         	beq.b	ffc000e8 <_Reset_Vector+0xffc000ec>
ffc000f0:	62 1f                         	add	#1, r15
ffc000f2:	38 69 ff                      	bra.w	ffc0005b <_Reset_Vector+0xffc0005f>

ffc000f5 <___ieee754_sqrt>:
ffc000f5:	6e 67                         	pushm	r6-r7
ffc000f7:	74 02 00 00 f0 7f             	cmp	#0x7ff00000, r2
ffc000fd:	23 05                         	bnc.b	ffc00102 <_Reset_Vector+0xffc00106>
ffc000ff:	38 32 01                      	bra.w	ffc00231 <_Reset_Vector+0xffc00235>
ffc00102:	fd 94 2f                      	shlr	#20, r2, r15
ffc00105:	2a 05                         	bgt.b	ffc0010a <_Reset_Vector+0xffc0010e>
ffc00107:	38 37 01                      	bra.w	ffc0023e <_Reset_Vector+0xffc00242>
ffc0010a:	76 0f ff 07                   	cmp	#0x7ff, r15
ffc0010e:	3a 2d 01                      	beq.w	ffc0023b <_Reset_Vector+0xffc0023f>
ffc00111:	fd 95 14                      	shlr	#21, r1, r4
ffc00114:	fd cb 16                      	shll	#11, r1, r6
ffc00117:	fd cb 27                      	shll	#11, r2, r7
ffc0011a:	4b 47                         	add	r4, r7
ffc0011c:	79 f7                         	bset	#31, r7
ffc0011e:	fd 90 74                      	shlr	#16, r7, r4
ffc00121:	7c 0f                         	btst	#0, r15
ffc00123:	20 16                         	beq.b	ffc00139 <_Reset_Vector+0xffc0013d>
ffc00125:	76 14 14 54                   	mul	#0x5414, r4
ffc00129:	68 f4                         	shlr	#15, r4
ffc0012b:	fb 3e 13 54 01                	mov.l	#0x15413, r3
ffc00130:	ff 04 43                      	sub	r4, r3, r4
ffc00133:	68 17                         	shlr	#1, r7
ffc00135:	7e 46                         	rorc	r6
ffc00137:	2e 10                         	bra.b	ffc00147 <_Reset_Vector+0xffc0014b>
ffc00139:	76 14 ec 2b                   	mul	#0x2bec, r4
ffc0013d:	68 f4                         	shlr	#15, r4
ffc0013f:	fb 3e d8 d7 00                	mov.l	#0xd7d8, r3
ffc00144:	ff 04 43                      	sub	r4, r3, r4
ffc00147:	7e af                         	push.l	r15
ffc00149:	ff 35 44                      	mul 	r4, r4, r5
ffc0014c:	69 05                         	shlr	#16, r5
ffc0014e:	fd 90 71                      	shlr	#16, r7, r1
ffc00151:	4f 51                         	mul	r5, r1
ffc00153:	70 11 00 00 00 40             	add	#0x40000000, r1, r1
ffc00159:	7e 11                         	neg	r1
ffc0015b:	69 01                         	shlr	#16, r1
ffc0015d:	4f 14                         	mul	r1, r4
ffc0015f:	68 f4                         	shlr	#15, r4
ffc00161:	ff 35 44                      	mul 	r4, r4, r5
ffc00164:	69 05                         	shlr	#16, r5
ffc00166:	fd 90 73                      	shlr	#16, r7, r3
ffc00169:	4f 53                         	mul	r5, r3
ffc0016b:	70 33 00 00 00 40             	add	#0x40000000, r3, r3
ffc00171:	7e 13                         	neg	r3
ffc00173:	69 03                         	shlr	#16, r3
ffc00175:	4f 43                         	mul	r4, r3
ffc00177:	68 f3                         	shlr	#15, r3
ffc00179:	ff 34 33                      	mul 	r3, r3, r4
ffc0017c:	fc 1f 74                      	emulu	r7, r4
ffc0017f:	fd 81 51                      	shlr	#1, r5, r1
ffc00182:	4b 51                         	add	r5, r1
ffc00184:	68 11                         	shlr	#1, r1
ffc00186:	70 11 00 00 00 60             	add	#0x60000000, r1, r1
ffc0018c:	7e 11                         	neg	r1
ffc0018e:	6c 11                         	shll	#1, r1
ffc00190:	6c 14                         	shll	#1, r4
ffc00192:	7e 55                         	rolc	r5
ffc00194:	ef 5e                         	mov.l	r5, r14
ffc00196:	fc 1f 1e                      	emulu	r1, r14
ffc00199:	fc 1f 41                      	emulu	r4, r1
ffc0019c:	4b 2e                         	add	r2, r14
ffc0019e:	fd 74 2f 00                   	adc	#0, r15
ffc001a2:	fb 42 00 00 00 f0             	mov.l	#0xf0000000, r4
ffc001a8:	7e 1e                         	neg	r14
ffc001aa:	fc 03 f4                      	sbb	r15, r4
ffc001ad:	6d 03                         	shll	#16, r3
ffc001af:	fc 1f 3e                      	emulu	r3, r14
ffc001b2:	fc 1f 34                      	emulu	r3, r4
ffc001b5:	4b f4                         	add	r15, r4
ffc001b7:	fd 74 25 00                   	adc	#0, r5
ffc001bb:	6c 14                         	shll	#1, r4
ffc001bd:	7e 55                         	rolc	r5
ffc001bf:	ef 53                         	mov.l	r5, r3
ffc001c1:	fc 1f 53                      	emulu	r5, r3
ffc001c4:	ef 4e                         	mov.l	r4, r14
ffc001c6:	fc 1f 7e                      	emulu	r7, r14
ffc001c9:	ef 41                         	mov.l	r4, r1
ffc001cb:	fc 1f 73                      	emulu	r7, r3
ffc001ce:	4b 4e                         	add	r4, r14
ffc001d0:	fd 74 2f 00                   	adc	#0, r15
ffc001d4:	fc 1f 61                      	emulu	r6, r1
ffc001d7:	4b 2e                         	add	r2, r14
ffc001d9:	fd 74 2f 00                   	adc	#0, r15
ffc001dd:	fb 32 00 00 00 c0             	mov.l	#0xc0000000, r3
ffc001e3:	7e 1e                         	neg	r14
ffc001e5:	fc 03 f3                      	sbb	r15, r3
ffc001e8:	fc 1f 5e                      	emulu	r5, r14
ffc001eb:	fc 1f 53                      	emulu	r5, r3
ffc001ee:	4b f3                         	add	r15, r3
ffc001f0:	fd 74 24 00                   	adc	#0, r4
ffc001f4:	ef 71                         	mov.l	r7, r1
ffc001f6:	fc 1f 41                      	emulu	r4, r1
ffc001f9:	fc 1f 64                      	emulu	r6, r4
ffc001fc:	4b 51                         	add	r5, r1
ffc001fe:	fd 74 22 00                   	adc	#0, r2
ffc00202:	fc 1f 73                      	emulu	r7, r3
ffc00205:	ec 03                         	mov.l	[r0], r3
ffc00207:	4b 41                         	add	r4, r1
ffc00209:	fd 74 22 00                   	adc	#0, r2
ffc0020d:	72 33 ff 03                   	add	#0x3ff, r3, r3
ffc00211:	68 13                         	shlr	#1, r3
ffc00213:	72 11 00 01                   	add	#256, r1, r1
ffc00217:	fd 74 22 00                   	adc	#0, r2
ffc0021b:	fd 74 23 00                   	adc	#0, r3
ffc0021f:	fd d7 24                      	shll	#23, r2, r4
ffc00222:	68 92                         	shlr	#9, r2
ffc00224:	68 91                         	shlr	#9, r1
ffc00226:	4b 41                         	add	r4, r1
ffc00228:	7b 42                         	bclr	#20, r2
ffc0022a:	6d 43                         	shll	#20, r3
ffc0022c:	4b 32                         	add	r3, r2
ffc0022e:	3f 67 03                      	rtsd	#12, r6-r7
ffc00231:	12                            	beq.s	ffc0023b <_Reset_Vector+0xffc0023f>
ffc00232:	fd c1 23                      	shll	#1, r2, r3
ffc00235:	57 13                         	or	r1, r3
ffc00237:	14                            	beq.s	ffc0023b <_Reset_Vector+0xffc0023f>
ffc00238:	fb 26 ff                      	mov.l	#-1, r2
ffc0023b:	3f 67 02                      	rtsd	#8, r6-r7
ffc0023e:	ff 53 21                      	or	r2, r1, r3
ffc00241:	20 fa                         	beq.b	ffc0023b <_Reset_Vector+0xffc0023f>
ffc00243:	0f                            	bra.s	ffc0024a <_Reset_Vector+0xffc0024e>
ffc00244:	6c 11                         	shll	#1, r1
ffc00246:	7e 52                         	rolc	r2
ffc00248:	60 1f                         	sub	#1, r15
ffc0024a:	7d 42                         	btst	#20, r2
ffc0024c:	20 f8                         	beq.b	ffc00244 <_Reset_Vector+0xffc00248>
ffc0024e:	62 1f                         	add	#1, r15
ffc00250:	38 c1 fe                      	bra.w	ffc00111 <_Reset_Vector+0xffc00115>

ffc00253 <_sci_iic_int_sci_iic1_tei_isr>:
 * Arguments    : None
 * Return Value : None
 **********************************************************************************************************************/
void sci_iic_int_sci_iic1_tei_isr (void)
{
    r_sci_iic_tei_isr_processing(SCI_IIC_NUM_CH1);
ffc00253:	66 11                         	mov.l	#1, r1
ffc00255:	05 7b 10 00                   	bsr.a	ffc012d0 <_Reset_Vector+0xffc012d4>

ffc00259 <.LVL0>:

    /* Calls advance function */
    r_sci_iic_advance(g_sci_iic_handles[SCI_IIC_NUM_CH1]->psci_iic_info_ch);
ffc00259:	fb 52 04 00 00 00             	mov.l	#4, r5
ffc0025f:	a9 d1                         	mov.l	24[r5], r1
ffc00261:	04 a7 0e 00                   	bra.a	ffc01108 <_Reset_Vector+0xffc0110c>

ffc00265 <_riic1_eei_isr>:
 * Arguments    : None
 * Return Value : None
 **********************************************************************************************************************/
void riic1_eei_isr (void * vect)
{
    riic1_eei_sub();
ffc00265:	04 53 2d 00                   	bra.a	ffc02fb8 <_Reset_Vector+0xffc02fbc>

ffc00269 <_riic1_tei_isr>:
 * Arguments    : None
 * Return Value : None
 **********************************************************************************************************************/
void riic1_tei_isr (void * vect)
{
    riic1_tei_sub();
ffc00269:	04 57 30 00                   	bra.a	ffc032c0 <_Reset_Vector+0xffc032c4>

ffc0026d <.LFE25>:
ffc0026d:	00                            	brk
	...

ffc00270 <_excep_supervisor_inst_isr>:
* Description  : Supervisor Instruction Violation ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_supervisor_inst_isr(void)
{
ffc00270:	6e ef                         	pushm	r14-r15
ffc00272:	6e 15                         	pushm	r1-r5
ffc00274:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffc00277:	fd 1f 02                      	mvfachi	#0, a0, r2
ffc0027a:	7e a1                         	push.l	r1
ffc0027c:	7e a2                         	push.l	r2
ffc0027e:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffc00281:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffc00284:	7e a1                         	push.l	r1
ffc00286:	7e a2                         	push.l	r2
ffc00288:	fd 1f 81                      	mvfachi	#0, a1, r1
ffc0028b:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffc0028e:	7e a1                         	push.l	r1
ffc00290:	7e a2                         	push.l	r2
ffc00292:	60 40                         	sub	#4, r0

ffc00294 <.LBB342>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc00294:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc0029a:	ec 55                         	mov.l	[r5], r5
ffc0029c:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffc002a3:	10                            	beq.s	ffc002ab <_Reset_Vector+0xffc002af>
                g_bsp_vectors[vector](&cb_args);
ffc002a4:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffc002a6:	f8 06 00                      	mov.l	#0, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc002a9:	7f 15                         	jsr	r5

ffc002ab <.LVL161>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_SUPERVISOR_INSTR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_supervisor_inst_isr() */
ffc002ab:	62 40                         	add	#4, r0
ffc002ad:	7e b2                         	pop	r2
ffc002af:	7e b1                         	pop	r1
ffc002b1:	fd 17 81                      	mvtachi	r1, a1
ffc002b4:	fd 17 b2                      	mvtacgu	r2, a1
ffc002b7:	7e b2                         	pop	r2
ffc002b9:	7e b1                         	pop	r1
ffc002bb:	fd 17 31                      	mvtacgu	r1, a0
ffc002be:	fd 17 92                      	mvtaclo	r2, a1
ffc002c1:	7e b2                         	pop	r2
ffc002c3:	7e b1                         	pop	r1
ffc002c5:	fd 17 11                      	mvtaclo	r1, a0
ffc002c8:	fd 17 02                      	mvtachi	r2, a0
ffc002cb:	6f 15                         	popm	r1-r5
ffc002cd:	6f ef                         	popm	r14-r15
ffc002cf:	7f 95                         	rte

ffc002d1 <.LFE11>:
ffc002d1:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc002d8 <_excep_access_isr>:
* Description  : Access exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_access_isr(void)
{
ffc002d8:	6e ef                         	pushm	r14-r15
ffc002da:	6e 15                         	pushm	r1-r5
ffc002dc:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffc002df:	fd 1f 02                      	mvfachi	#0, a0, r2
ffc002e2:	7e a1                         	push.l	r1
ffc002e4:	7e a2                         	push.l	r2
ffc002e6:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffc002e9:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffc002ec:	7e a1                         	push.l	r1
ffc002ee:	7e a2                         	push.l	r2
ffc002f0:	fd 1f 81                      	mvfachi	#0, a1, r1
ffc002f3:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffc002f6:	7e a1                         	push.l	r1
ffc002f8:	7e a2                         	push.l	r2
ffc002fa:	60 40                         	sub	#4, r0

ffc002fc <.LBB346>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc002fc:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc00302:	a9 55                         	mov.l	16[r5], r5
ffc00304:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffc0030b:	10                            	beq.s	ffc00313 <_Reset_Vector+0xffc00317>
                g_bsp_vectors[vector](&cb_args);
ffc0030c:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffc0030e:	f8 06 04                      	mov.l	#4, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc00311:	7f 15                         	jsr	r5

ffc00313 <.LVL163>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_ACCESS, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_access_isr() */
ffc00313:	62 40                         	add	#4, r0
ffc00315:	7e b2                         	pop	r2
ffc00317:	7e b1                         	pop	r1
ffc00319:	fd 17 81                      	mvtachi	r1, a1
ffc0031c:	fd 17 b2                      	mvtacgu	r2, a1
ffc0031f:	7e b2                         	pop	r2
ffc00321:	7e b1                         	pop	r1
ffc00323:	fd 17 31                      	mvtacgu	r1, a0
ffc00326:	fd 17 92                      	mvtaclo	r2, a1
ffc00329:	7e b2                         	pop	r2
ffc0032b:	7e b1                         	pop	r1
ffc0032d:	fd 17 11                      	mvtaclo	r1, a0
ffc00330:	fd 17 02                      	mvtachi	r2, a0
ffc00333:	6f 15                         	popm	r1-r5
ffc00335:	6f ef                         	popm	r14-r15
ffc00337:	7f 95                         	rte

ffc00339 <.LFE12>:
ffc00339:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc00340 <_excep_undefined_inst_isr>:
* Description  : Undefined instruction exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_undefined_inst_isr(void)
{
ffc00340:	6e ef                         	pushm	r14-r15
ffc00342:	6e 15                         	pushm	r1-r5
ffc00344:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffc00347:	fd 1f 02                      	mvfachi	#0, a0, r2
ffc0034a:	7e a1                         	push.l	r1
ffc0034c:	7e a2                         	push.l	r2
ffc0034e:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffc00351:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffc00354:	7e a1                         	push.l	r1
ffc00356:	7e a2                         	push.l	r2
ffc00358:	fd 1f 81                      	mvfachi	#0, a1, r1
ffc0035b:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffc0035e:	7e a1                         	push.l	r1
ffc00360:	7e a2                         	push.l	r2
ffc00362:	60 40                         	sub	#4, r0

ffc00364 <.LBB350>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc00364:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc0036a:	a8 5d                         	mov.l	4[r5], r5
ffc0036c:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffc00373:	10                            	beq.s	ffc0037b <_Reset_Vector+0xffc0037f>
                g_bsp_vectors[vector](&cb_args);
ffc00374:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffc00376:	f8 06 01                      	mov.l	#1, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc00379:	7f 15                         	jsr	r5

ffc0037b <.LVL165>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_UNDEFINED_INSTR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_undefined_inst_isr() */
ffc0037b:	62 40                         	add	#4, r0
ffc0037d:	7e b2                         	pop	r2
ffc0037f:	7e b1                         	pop	r1
ffc00381:	fd 17 81                      	mvtachi	r1, a1
ffc00384:	fd 17 b2                      	mvtacgu	r2, a1
ffc00387:	7e b2                         	pop	r2
ffc00389:	7e b1                         	pop	r1
ffc0038b:	fd 17 31                      	mvtacgu	r1, a0
ffc0038e:	fd 17 92                      	mvtaclo	r2, a1
ffc00391:	7e b2                         	pop	r2
ffc00393:	7e b1                         	pop	r1
ffc00395:	fd 17 11                      	mvtaclo	r1, a0
ffc00398:	fd 17 02                      	mvtachi	r2, a0
ffc0039b:	6f 15                         	popm	r1-r5
ffc0039d:	6f ef                         	popm	r14-r15
ffc0039f:	7f 95                         	rte

ffc003a1 <.LFE13>:
ffc003a1:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc003a8 <_excep_floating_point_isr>:
* Description  : Floating point exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_floating_point_isr(void)
{
ffc003a8:	6e ef                         	pushm	r14-r15
ffc003aa:	6e 15                         	pushm	r1-r5
ffc003ac:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffc003af:	fd 1f 02                      	mvfachi	#0, a0, r2
ffc003b2:	7e a1                         	push.l	r1
ffc003b4:	7e a2                         	push.l	r2
ffc003b6:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffc003b9:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffc003bc:	7e a1                         	push.l	r1
ffc003be:	7e a2                         	push.l	r2
ffc003c0:	fd 1f 81                      	mvfachi	#0, a1, r1
ffc003c3:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffc003c6:	7e a1                         	push.l	r1
ffc003c8:	7e a2                         	push.l	r2
ffc003ca:	60 40                         	sub	#4, r0

ffc003cc <.LBB354>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc003cc:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc003d2:	a8 dd                         	mov.l	12[r5], r5
ffc003d4:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffc003db:	10                            	beq.s	ffc003e3 <_Reset_Vector+0xffc003e7>
                g_bsp_vectors[vector](&cb_args);
ffc003dc:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffc003de:	f8 06 03                      	mov.l	#3, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc003e1:	7f 15                         	jsr	r5

ffc003e3 <.LVL167>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_FPU, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);

#ifdef __FPU
    /* Get current FPSW. */
    tmp_fpsw = (uint32_t)R_BSP_GET_FPSW();
ffc003e3:	fd 6a 35                      	mvfc	fpsw, r5

ffc003e6 <.LVL168>:

    /* Clear only the FPU exception flags. */
    R_BSP_SET_FPSW(tmp_fpsw & ((uint32_t)~BSP_PRV_FPU_CAUSE_FLAGS));
ffc003e6:	76 25 03 ff                   	and	#-253, r5

ffc003ea <.LVL169>:
ffc003ea:	fd 68 53                      	mvtc	r5, fpsw
#endif
} /* End of function excep_floating_point_isr() */
ffc003ed:	62 40                         	add	#4, r0
ffc003ef:	7e b2                         	pop	r2
ffc003f1:	7e b1                         	pop	r1
ffc003f3:	fd 17 81                      	mvtachi	r1, a1
ffc003f6:	fd 17 b2                      	mvtacgu	r2, a1
ffc003f9:	7e b2                         	pop	r2
ffc003fb:	7e b1                         	pop	r1
ffc003fd:	fd 17 31                      	mvtacgu	r1, a0
ffc00400:	fd 17 92                      	mvtaclo	r2, a1
ffc00403:	7e b2                         	pop	r2
ffc00405:	7e b1                         	pop	r1
ffc00407:	fd 17 11                      	mvtaclo	r1, a0
ffc0040a:	fd 17 02                      	mvtachi	r2, a0
ffc0040d:	6f 15                         	popm	r1-r5
ffc0040f:	6f ef                         	popm	r14-r15
ffc00411:	7f 95                         	rte

ffc00413 <.LFE14>:
ffc00413:	77 10 01 00 00                	nop	; mul	#1, r0

ffc00418 <_excep_address_isr>:
* Arguments    : none
* Return Value : none
* Note         : This function is supported by only CCRX and GCC.
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_address_isr(void)
{
ffc00418:	6e ef                         	pushm	r14-r15
ffc0041a:	6e 15                         	pushm	r1-r5
ffc0041c:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffc0041f:	fd 1f 02                      	mvfachi	#0, a0, r2
ffc00422:	7e a1                         	push.l	r1
ffc00424:	7e a2                         	push.l	r2
ffc00426:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffc00429:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffc0042c:	7e a1                         	push.l	r1
ffc0042e:	7e a2                         	push.l	r2
ffc00430:	fd 1f 81                      	mvfachi	#0, a1, r1
ffc00433:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffc00436:	7e a1                         	push.l	r1
ffc00438:	7e a2                         	push.l	r2
ffc0043a:	60 40                         	sub	#4, r0

ffc0043c <.LBB358>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc0043c:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc00442:	aa d5                         	mov.l	40[r5], r5
ffc00444:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffc0044b:	10                            	beq.s	ffc00453 <_Reset_Vector+0xffc00457>
                g_bsp_vectors[vector](&cb_args);
ffc0044c:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffc0044e:	f8 06 0a                      	mov.l	#10, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc00451:	7f 15                         	jsr	r5

ffc00453 <.LVL171>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_ADDRESS, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_address_isr() */
ffc00453:	62 40                         	add	#4, r0
ffc00455:	7e b2                         	pop	r2
ffc00457:	7e b1                         	pop	r1
ffc00459:	fd 17 81                      	mvtachi	r1, a1
ffc0045c:	fd 17 b2                      	mvtacgu	r2, a1
ffc0045f:	7e b2                         	pop	r2
ffc00461:	7e b1                         	pop	r1
ffc00463:	fd 17 31                      	mvtacgu	r1, a0
ffc00466:	fd 17 92                      	mvtaclo	r2, a1
ffc00469:	7e b2                         	pop	r2
ffc0046b:	7e b1                         	pop	r1
ffc0046d:	fd 17 11                      	mvtaclo	r1, a0
ffc00470:	fd 17 02                      	mvtachi	r2, a0
ffc00473:	6f 15                         	popm	r1-r5
ffc00475:	6f ef                         	popm	r14-r15
ffc00477:	7f 95                         	rte

ffc00479 <.LFE15>:
ffc00479:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc00480 <_non_maskable_isr>:
* Description  : Non-maskable interrupt ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void non_maskable_isr(void)
{
ffc00480:	6e 1f                         	pushm	r1-r15
ffc00482:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffc00485:	fd 1f 02                      	mvfachi	#0, a0, r2
ffc00488:	6e 12                         	pushm	r1-r2
ffc0048a:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffc0048d:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffc00490:	6e 12                         	pushm	r1-r2
ffc00492:	fd 1f 81                      	mvfachi	#0, a1, r1
ffc00495:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffc00498:	6e 12                         	pushm	r1-r2
    /* Determine what is the cause of this interrupt. */

#ifdef BSP_MCU_NMI_EXC_NMI_PIN
    /* EXC_NMI_PIN */
    if ((1 == ICU.NMISR.BIT.NMIST) && (1 == ICU.NMIER.BIT.NMIEN))
ffc0049a:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc0049f:	ce 75 80 05                   	mov.b	1408[r7], r5
ffc004a3:	7c 05                         	btst	#0, r5
ffc004a5:	21 63                         	bne.b	ffc00508 <_Reset_Vector+0xffc0050c>
ffc004a7:	03                            	nop
    }
#endif

#ifdef BSP_MCU_NMI_OSC_STOP_DETECT
    /* OSC_STOP_DETECT */
    if ((1 == ICU.NMISR.BIT.OSTST) && (1 == ICU.NMIER.BIT.OSTEN))
ffc004a8:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc004ad:	ce 75 80 05                   	mov.b	1408[r7], r5
ffc004b1:	7c 15                         	btst	#1, r5
ffc004b3:	3b f5 00                      	bne.w	ffc005a8 <_Reset_Vector+0xffc005ac>
ffc004b6:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_WDT_ERROR
    /* WDT_ERROR */
    if ((1 == ICU.NMISR.BIT.WDTST) && (1 == ICU.NMIER.BIT.WDTEN))
ffc004b8:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc004bd:	ce 75 80 05                   	mov.b	1408[r7], r5
ffc004c1:	7c 25                         	btst	#2, r5
ffc004c3:	3b cf 00                      	bne.w	ffc00592 <_Reset_Vector+0xffc00596>
ffc004c6:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_IWDT_ERROR
    /* IWDT_ERROR */
    if ((1 == ICU.NMISR.BIT.IWDTST) && (1 == ICU.NMIER.BIT.IWDTEN))
ffc004c8:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc004cd:	ce 75 80 05                   	mov.b	1408[r7], r5
ffc004d1:	7c 35                         	btst	#3, r5
ffc004d3:	3b a9 00                      	bne.w	ffc0057c <_Reset_Vector+0xffc00580>
ffc004d6:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_LVD1
    /* LVD1 */
    if ((1 == ICU.NMISR.BIT.LVD1ST) && (1 == ICU.NMIER.BIT.LVD1EN))
ffc004d8:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc004dd:	ce 75 80 05                   	mov.b	1408[r7], r5
ffc004e1:	7c 45                         	btst	#4, r5
ffc004e3:	3b 83 00                      	bne.w	ffc00566 <_Reset_Vector+0xffc0056a>
ffc004e6:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_LVD2
    /* LVD2 */
    if ((1 == ICU.NMISR.BIT.LVD2ST) && (1 == ICU.NMIER.BIT.LVD2EN))
ffc004e8:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc004ed:	ce 75 80 05                   	mov.b	1408[r7], r5
ffc004f1:	7c 55                         	btst	#5, r5
ffc004f3:	21 5f                         	bne.b	ffc00552 <_Reset_Vector+0xffc00556>
ffc004f5:	fc 13 00                      	nop	; max	r0, r0
    }
#endif /* BSP_MCU_NMI_RAM */

#ifdef BSP_MCU_NMI_EXNMI
    /* EXNMI */
    if ((1 == ICU.NMISR.BIT.EXNMIST) && (1 == ICU.NMIER.BIT.EXNMIEN))
ffc004f8:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc004fd:	ce 75 80 05                   	mov.b	1408[r7], r5
ffc00501:	7c 65                         	btst	#6, r5
ffc00503:	21 19                         	bne.b	ffc0051c <_Reset_Vector+0xffc00520>
    {
        /* Infinite loop. Return from Non-maskable interrupt handlling routine is prohibited.
           Never use the non-maskable interrupt with an attempt to return to the program that was being executed at 
           the time of interrupt generation after the exception handling routine is ended.
         */
         R_BSP_NOP();
ffc00505:	03                            	nop
ffc00506:	2e ff                         	bra.b	ffc00505 <_Reset_Vector+0xffc00509>
    if ((1 == ICU.NMISR.BIT.NMIST) && (1 == ICU.NMIER.BIT.NMIEN))
ffc00508:	ce 75 81 05                   	mov.b	1409[r7], r5
ffc0050c:	7c 05                         	btst	#0, r5
ffc0050e:	20 9a                         	beq.b	ffc004a8 <_Reset_Vector+0xffc004ac>
        R_BSP_InterruptControl(BSP_INT_SRC_EXC_NMI_PIN, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc00510:	66 21                         	mov.l	#2, r1
ffc00512:	05 b0 37 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc00516 <.LVL172>:
        ICU.NMICLR.BIT.NMICLR = 1;
ffc00516:	f2 70 82 05                   	bset	#0, 1410[r7].b
ffc0051a:	2e 8e                         	bra.b	ffc004a8 <_Reset_Vector+0xffc004ac>
    if ((1 == ICU.NMISR.BIT.EXNMIST) && (1 == ICU.NMIER.BIT.EXNMIEN))
ffc0051c:	ce 75 81 05                   	mov.b	1409[r7], r5
ffc00520:	7c 65                         	btst	#6, r5
ffc00522:	20 e3                         	beq.b	ffc00505 <_Reset_Vector+0xffc00509>
        if ((1 == ICU.EXNMISR.BIT.RAMST) && (1 == ICU.EXNMIER.BIT.RAMEN))
ffc00524:	ce 75 84 05                   	mov.b	1412[r7], r5
ffc00528:	7c 05                         	btst	#0, r5
ffc0052a:	3b 94 00                      	bne.w	ffc005be <_Reset_Vector+0xffc005c2>
ffc0052d:	fc 13 00                      	nop	; max	r0, r0
    if ((1 == ICU.EXNMISR.BIT.DPFPUST) && (1 == ICU.EXNMIER.BIT.DPFPUEN))
ffc00530:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc00535:	ce 75 84 05                   	mov.b	1412[r7], r5
ffc00539:	7c 15                         	btst	#1, r5
ffc0053b:	20 ca                         	beq.b	ffc00505 <_Reset_Vector+0xffc00509>
ffc0053d:	ce 75 85 05                   	mov.b	1413[r7], r5
ffc00541:	7c 15                         	btst	#1, r5
ffc00543:	20 c2                         	beq.b	ffc00505 <_Reset_Vector+0xffc00509>
            R_BSP_InterruptControl(BSP_INT_SRC_DPFPUEX, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc00545:	75 41 11                      	mov.l	#17, r1
ffc00548:	05 7a 37 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc0054c <.LVL173>:
            ICU.EXNMICLR.BIT.DPFPUCLR = 1;
ffc0054c:	f2 71 86 05                   	bset	#1, 1414[r7].b
ffc00550:	2e b5                         	bra.b	ffc00505 <_Reset_Vector+0xffc00509>
    if ((1 == ICU.NMISR.BIT.LVD2ST) && (1 == ICU.NMIER.BIT.LVD2EN))
ffc00552:	ce 75 81 05                   	mov.b	1409[r7], r5
ffc00556:	7c 55                         	btst	#5, r5
ffc00558:	20 a0                         	beq.b	ffc004f8 <_Reset_Vector+0xffc004fc>
        R_BSP_InterruptControl(BSP_INT_SRC_LVD2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc0055a:	66 91                         	mov.l	#9, r1
ffc0055c:	05 66 37 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc00560 <.LVL174>:
        ICU.NMICLR.BIT.LVD2CLR = 1;
ffc00560:	f2 75 82 05                   	bset	#5, 1410[r7].b
ffc00564:	2e 94                         	bra.b	ffc004f8 <_Reset_Vector+0xffc004fc>
    if ((1 == ICU.NMISR.BIT.LVD1ST) && (1 == ICU.NMIER.BIT.LVD1EN))
ffc00566:	ce 75 81 05                   	mov.b	1409[r7], r5
ffc0056a:	7c 45                         	btst	#4, r5
ffc0056c:	3a 7c ff                      	beq.w	ffc004e8 <_Reset_Vector+0xffc004ec>
        R_BSP_InterruptControl(BSP_INT_SRC_LVD1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc0056f:	66 81                         	mov.l	#8, r1
ffc00571:	05 51 37 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc00575 <.LVL175>:
        ICU.NMICLR.BIT.LVD1CLR = 1;
ffc00575:	f2 74 82 05                   	bset	#4, 1410[r7].b
ffc00579:	38 6f ff                      	bra.w	ffc004e8 <_Reset_Vector+0xffc004ec>
    if ((1 == ICU.NMISR.BIT.IWDTST) && (1 == ICU.NMIER.BIT.IWDTEN))
ffc0057c:	ce 75 81 05                   	mov.b	1409[r7], r5
ffc00580:	7c 35                         	btst	#3, r5
ffc00582:	3a 56 ff                      	beq.w	ffc004d8 <_Reset_Vector+0xffc004dc>
        R_BSP_InterruptControl(BSP_INT_SRC_IWDT_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc00585:	66 71                         	mov.l	#7, r1
ffc00587:	05 3b 37 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc0058b <.LVL176>:
        ICU.NMICLR.BIT.IWDTCLR = 1;
ffc0058b:	f2 73 82 05                   	bset	#3, 1410[r7].b
ffc0058f:	38 49 ff                      	bra.w	ffc004d8 <_Reset_Vector+0xffc004dc>
    if ((1 == ICU.NMISR.BIT.WDTST) && (1 == ICU.NMIER.BIT.WDTEN))
ffc00592:	ce 75 81 05                   	mov.b	1409[r7], r5
ffc00596:	7c 25                         	btst	#2, r5
ffc00598:	3a 30 ff                      	beq.w	ffc004c8 <_Reset_Vector+0xffc004cc>
        R_BSP_InterruptControl(BSP_INT_SRC_WDT_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc0059b:	66 61                         	mov.l	#6, r1
ffc0059d:	05 25 37 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc005a1 <.LVL177>:
        ICU.NMICLR.BIT.WDTCLR = 1;
ffc005a1:	f2 72 82 05                   	bset	#2, 1410[r7].b
ffc005a5:	38 23 ff                      	bra.w	ffc004c8 <_Reset_Vector+0xffc004cc>
    if ((1 == ICU.NMISR.BIT.OSTST) && (1 == ICU.NMIER.BIT.OSTEN))
ffc005a8:	ce 75 81 05                   	mov.b	1409[r7], r5
ffc005ac:	7c 15                         	btst	#1, r5
ffc005ae:	3a 0a ff                      	beq.w	ffc004b8 <_Reset_Vector+0xffc004bc>
        R_BSP_InterruptControl(BSP_INT_SRC_OSC_STOP_DETECT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc005b1:	66 51                         	mov.l	#5, r1
ffc005b3:	05 0f 37 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc005b7 <.LVL178>:
        ICU.NMICLR.BIT.OSTCLR = 1;
ffc005b7:	f2 71 82 05                   	bset	#1, 1410[r7].b
ffc005bb:	38 fd fe                      	bra.w	ffc004b8 <_Reset_Vector+0xffc004bc>
        if ((1 == ICU.EXNMISR.BIT.RAMST) && (1 == ICU.EXNMIER.BIT.RAMEN))
ffc005be:	ce 75 85 05                   	mov.b	1413[r7], r5
ffc005c2:	7c 05                         	btst	#0, r5
ffc005c4:	3a 6c ff                      	beq.w	ffc00530 <_Reset_Vector+0xffc00534>
            if(1 == RAM.RAMSTS.BIT.RAMERR)
ffc005c7:	fb 7e 00 12 08                	mov.l	#0x81200, r7
ffc005cc:	88 7d                         	mov.b	1[r7], r5
ffc005ce:	7c 05                         	btst	#0, r5
ffc005d0:	21 4a                         	bne.b	ffc0061a <_Reset_Vector+0xffc0061e>
            if(1 == RAM.EXRAMSTS.BIT.EXRAMERR)
ffc005d2:	fb 7e 00 12 08                	mov.l	#0x81200, r7
ffc005d7:	cd 75 41                      	mov.b	65[r7], r5
ffc005da:	7c 05                         	btst	#0, r5
ffc005dc:	21 33                         	bne.b	ffc0060f <_Reset_Vector+0xffc00613>
ffc005de:	ef 00                         	nop	; mov.l	r0, r0
            if(1 == ECCRAM.ECCRAM1STS.BIT.ECC1ERR)
ffc005e0:	fb 7e c0 12 08                	mov.l	#0x812c0, r7
ffc005e5:	88 fd                         	mov.b	3[r7], r5
ffc005e7:	7c 05                         	btst	#0, r5
ffc005e9:	21 1b                         	bne.b	ffc00604 <_Reset_Vector+0xffc00608>
            if(1 == ECCRAM.ECCRAM2STS.BIT.ECC2ERR)
ffc005eb:	fb 7e c0 12 08                	mov.l	#0x812c0, r7
ffc005f0:	88 7d                         	mov.b	1[r7], r5
ffc005f2:	7c 05                         	btst	#0, r5
ffc005f4:	3a 3c ff                      	beq.w	ffc00530 <_Reset_Vector+0xffc00534>
                R_BSP_InterruptControl(BSP_INT_SRC_ECCRAM_2BIT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc005f7:	75 41 10                      	mov.l	#16, r1
ffc005fa:	05 c8 36 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc005fe <.LVL179>:
                ECCRAM.ECCRAM2STS.BIT.ECC2ERR = 0;
ffc005fe:	f1 78 01                      	bclr	#0, 1[r7].b
ffc00601:	38 2f ff                      	bra.w	ffc00530 <_Reset_Vector+0xffc00534>
                R_BSP_InterruptControl(BSP_INT_SRC_ECCRAM_1BIT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc00604:	66 f1                         	mov.l	#15, r1
ffc00606:	05 bc 36 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc0060a <.LVL180>:
                ECCRAM.ECCRAM1STS.BIT.ECC1ERR = 0;
ffc0060a:	f1 78 03                      	bclr	#0, 3[r7].b
ffc0060d:	2e de                         	bra.b	ffc005eb <_Reset_Vector+0xffc005ef>
                R_BSP_InterruptControl(BSP_INT_SRC_EXRAM, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc0060f:	66 e1                         	mov.l	#14, r1
ffc00611:	05 b1 36 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc00615 <.LVL181>:
                RAM.EXRAMSTS.BIT.EXRAMERR = 0;
ffc00615:	f1 78 41                      	bclr	#0, 65[r7].b
ffc00618:	2e c8                         	bra.b	ffc005e0 <_Reset_Vector+0xffc005e4>
                R_BSP_InterruptControl(BSP_INT_SRC_RAM, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc0061a:	66 d1                         	mov.l	#13, r1
ffc0061c:	05 a6 36 00                   	bsr.a	ffc03cc2 <_Reset_Vector+0xffc03cc6>

ffc00620 <.LVL182>:
                RAM.RAMSTS.BIT.RAMERR = 0;
ffc00620:	f1 78 01                      	bclr	#0, 1[r7].b
ffc00623:	2e af                         	bra.b	ffc005d2 <_Reset_Vector+0xffc005d6>

ffc00625 <.LFE16>:
ffc00625:	fc 13 00                      	nop	; max	r0, r0

ffc00628 <_undefined_interrupt_source_isr>:
*                Set a breakpoint in this function to determine which source is creating unwanted interrupts.
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void undefined_interrupt_source_isr(void)
{
ffc00628:	6e ef                         	pushm	r14-r15
ffc0062a:	6e 15                         	pushm	r1-r5
ffc0062c:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffc0062f:	fd 1f 02                      	mvfachi	#0, a0, r2
ffc00632:	7e a1                         	push.l	r1
ffc00634:	7e a2                         	push.l	r2
ffc00636:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffc00639:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffc0063c:	7e a1                         	push.l	r1
ffc0063e:	7e a2                         	push.l	r2
ffc00640:	fd 1f 81                      	mvfachi	#0, a1, r1
ffc00643:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffc00646:	7e a1                         	push.l	r1
ffc00648:	7e a2                         	push.l	r2
ffc0064a:	60 40                         	sub	#4, r0

ffc0064c <.LBB362>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc0064c:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc00652:	aa dd                         	mov.l	44[r5], r5
ffc00654:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffc0065b:	10                            	beq.s	ffc00663 <_Reset_Vector+0xffc00667>
                g_bsp_vectors[vector](&cb_args);
ffc0065c:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffc0065e:	f8 06 0b                      	mov.l	#11, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc00661:	7f 15                         	jsr	r5

ffc00663 <.LVL184>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_UNDEFINED_INTERRUPT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function undefined_interrupt_source_isr() */
ffc00663:	62 40                         	add	#4, r0
ffc00665:	7e b2                         	pop	r2
ffc00667:	7e b1                         	pop	r1
ffc00669:	fd 17 81                      	mvtachi	r1, a1
ffc0066c:	fd 17 b2                      	mvtacgu	r2, a1
ffc0066f:	7e b2                         	pop	r2
ffc00671:	7e b1                         	pop	r1
ffc00673:	fd 17 31                      	mvtacgu	r1, a0
ffc00676:	fd 17 92                      	mvtaclo	r2, a1
ffc00679:	7e b2                         	pop	r2
ffc0067b:	7e b1                         	pop	r1
ffc0067d:	fd 17 11                      	mvtaclo	r1, a0
ffc00680:	fd 17 02                      	mvtachi	r2, a0
ffc00683:	6f 15                         	popm	r1-r5
ffc00685:	6f ef                         	popm	r14-r15
ffc00687:	7f 95                         	rte

ffc00689 <.LFE17>:
ffc00689:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc00690 <_bus_error_isr>:
*                application.
* Arguments    : none
* Return value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void bus_error_isr (void)
{
ffc00690:	6e ef                         	pushm	r14-r15
ffc00692:	6e 15                         	pushm	r1-r5
ffc00694:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffc00697:	fd 1f 02                      	mvfachi	#0, a0, r2
ffc0069a:	7e a1                         	push.l	r1
ffc0069c:	7e a2                         	push.l	r2
ffc0069e:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffc006a1:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffc006a4:	7e a1                         	push.l	r1
ffc006a6:	7e a2                         	push.l	r2
ffc006a8:	fd 1f 81                      	mvfachi	#0, a1, r1
ffc006ab:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffc006ae:	7e a1                         	push.l	r1
ffc006b0:	7e a2                         	push.l	r2
ffc006b2:	60 40                         	sub	#4, r0
    /* Clear the bus error */
    BSC.BERCLR.BIT.STSCLR = 1;
ffc006b4:	fb 5e 00 13 08                	mov.l	#0x81300, r5
ffc006b9:	f0 50                         	bset	#0, [r5].b

ffc006bb <.LBB366>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc006bb:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc006c1:	ab 55                         	mov.l	48[r5], r5
ffc006c3:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffc006ca:	10                            	beq.s	ffc006d2 <_Reset_Vector+0xffc006d6>
                g_bsp_vectors[vector](&cb_args);
ffc006cb:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffc006cd:	f8 06 0c                      	mov.l	#12, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc006d0:	7f 15                         	jsr	r5

ffc006d2 <.LVL186>:
        The upper 13 bits of this register contain the upper 13-bits of the offending address (in 512K byte units)
    */

    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_BUS_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function bus_error_isr() */
ffc006d2:	62 40                         	add	#4, r0
ffc006d4:	7e b2                         	pop	r2
ffc006d6:	7e b1                         	pop	r1
ffc006d8:	fd 17 81                      	mvtachi	r1, a1
ffc006db:	fd 17 b2                      	mvtacgu	r2, a1
ffc006de:	7e b2                         	pop	r2
ffc006e0:	7e b1                         	pop	r1
ffc006e2:	fd 17 31                      	mvtacgu	r1, a0
ffc006e5:	fd 17 92                      	mvtaclo	r2, a1
ffc006e8:	7e b2                         	pop	r2
ffc006ea:	7e b1                         	pop	r1
ffc006ec:	fd 17 11                      	mvtaclo	r1, a0
ffc006ef:	fd 17 02                      	mvtachi	r2, a0
ffc006f2:	6f 15                         	popm	r1-r5
ffc006f4:	6f ef                         	popm	r14-r15
ffc006f6:	7f 95                         	rte

ffc006f8 <_r_Config_SCI0_transmitend_interrupt>:
* Return Value : None
***********************************************************************************************************************/

void r_Config_SCI0_transmitend_interrupt(void)
{
    if (_80_SCI_IIC_START_CYCLE == g_sci0_iic_cycle_flag)
ffc006f8:	fb 42 89 08 00 00             	mov.l	#0x889, r4
ffc006fe:	58 45                         	movu.b	[r4], r5
ffc00700:	75 55 80                      	cmp	#128, r5
ffc00703:	20 22                         	beq.b	ffc00725 <_Reset_Vector+0xffc00729>
        SCI0.SIMR3.BIT.IICSTIF = 0U;
        SCI0.SIMR3.BIT.IICSCLS = 0U;
        SCI0.SIMR3.BIT.IICSDAS = 0U;
        SCI0.TDR = g_sci0_slave_address;
    }
    else if (_00_SCI_IIC_STOP_CYCLE == g_sci0_iic_cycle_flag)
ffc00705:	58 45                         	movu.b	[r4], r5
ffc00707:	61 05                         	cmp	#0, r5
ffc00709:	21 1b                         	bne.b	ffc00724 <_Reset_Vector+0xffc00728>
    {
        SCI0.SIMR3.BIT.IICSTIF = 0U;
ffc0070b:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
        SCI0.SIMR3.BYTE |= (_30_SCI_SSDA_HIGH_IMPEDANCE | _C0_SCI_SSCL_HIGH_IMPEDANCE);
        if (_80_SCI_IIC_TRANSMISSION == g_sci0_iic_transmit_receive_flag)
ffc00710:	fb 32 84 08 00 00             	mov.l	#0x884, r3
        SCI0.SIMR3.BIT.IICSTIF = 0U;
ffc00716:	f1 5b 0b                      	bclr	#3, 11[r5].b
        SCI0.SIMR3.BYTE |= (_30_SCI_SSDA_HIGH_IMPEDANCE | _C0_SCI_SSCL_HIGH_IMPEDANCE);
ffc00719:	8a dc                         	mov.b	11[r5], r4
ffc0071b:	75 34 f0                      	or	#-16, r4
ffc0071e:	82 dc                         	mov.b	r4, 11[r5]
        if (_80_SCI_IIC_TRANSMISSION == g_sci0_iic_transmit_receive_flag)
ffc00720:	cc 35                         	mov.b	[r3], r5
        {
            r_Config_SCI0_callback_transmitend();
        }
        if (_00_SCI_IIC_RECEPTION == g_sci0_iic_transmit_receive_flag)
ffc00722:	cc 35                         	mov.b	[r3], r5
    }
    else
    {
        /* Do nothing */
    }
}
ffc00724:	02                            	rts
        SCI0.SIMR3.BIT.IICSTIF = 0U;
ffc00725:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffc0072a:	f1 5b 0b                      	bclr	#3, 11[r5].b
        SCI0.SIMR3.BIT.IICSCLS = 0U;
ffc0072d:	8a dc                         	mov.b	11[r5], r4
ffc0072f:	75 24 3f                      	and	#63, r4
ffc00732:	82 dc                         	mov.b	r4, 11[r5]
        SCI0.SIMR3.BIT.IICSDAS = 0U;
ffc00734:	8a dc                         	mov.b	11[r5], r4
ffc00736:	75 24 cf                      	and	#-49, r4
ffc00739:	82 dc                         	mov.b	r4, 11[r5]
        SCI0.TDR = g_sci0_slave_address;
ffc0073b:	fb 42 88 08 00 00             	mov.l	#0x888, r4
ffc00741:	cc 44                         	mov.b	[r4], r4
ffc00743:	80 dc                         	mov.b	r4, 3[r5]
ffc00745:	02                            	rts

ffc00746 <.LFE6>:
	...

ffc00748 <_r_Config_RIIC0_transmitend_interrupt>:
* Return Value : None
***********************************************************************************************************************/

void r_Config_RIIC0_transmitend_interrupt(void)
{
    if (_06_IIC_MASTER_SENDS_END == g_riic0_state)
ffc00748:	fb 42 ac 08 00 00             	mov.l	#0x8ac, r4
ffc0074e:	58 45                         	movu.b	[r4], r5
ffc00750:	61 65                         	cmp	#6, r5
ffc00752:	20 1b                         	beq.b	ffc0076d <_Reset_Vector+0xffc00771>
        {
            RIIC0.ICSR2.BIT.TEND = 0U;
            r_Config_RIIC0_callback_transmitend();
        }
    }
    else if (_0E_IIC_MASTER_RECEIVES_RESTART == g_riic0_state)
ffc00754:	58 45                         	movu.b	[r4], r5
ffc00756:	61 e5                         	cmp	#14, r5
ffc00758:	20 03                         	beq.b	ffc0075b <_Reset_Vector+0xffc0075f>
    }
    else
    {
        /* Do nothing */
    }
}
ffc0075a:	02                            	rts
        RIIC0.ICSR2.BIT.START = 0U;
ffc0075b:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc00760:	f1 5a 09                      	bclr	#2, 9[r5].b
        RIIC0.ICIER.BIT.STIE = 1U;
ffc00763:	f1 52 07                      	bset	#2, 7[r5].b
        RIIC0.ICCR2.BIT.RS = 1U;    /* Set restart condition flag */
ffc00766:	f1 52 01                      	bset	#2, 1[r5].b
        RIIC0.ICSR2.BIT.TEND = 0U;
ffc00769:	f1 5e 09                      	bclr	#6, 9[r5].b
}
ffc0076c:	02                            	rts
        if (1U == g_riic0_stop_generation)
ffc0076d:	fb 52 9c 08 00 00             	mov.l	#0x89c, r5
ffc00773:	58 55                         	movu.b	[r5], r5
ffc00775:	61 15                         	cmp	#1, r5
            RIIC0.ICSR2.BIT.STOP = 0U;
ffc00777:	fb 5e 00 83 08                	mov.l	#0x88300, r5
        if (1U == g_riic0_stop_generation)
ffc0077c:	21 ed                         	bne.b	ffc00769 <_Reset_Vector+0xffc0076d>
            RIIC0.ICSR2.BIT.STOP = 0U;
ffc0077e:	f1 5b 09                      	bclr	#3, 9[r5].b
            RIIC0.ICCR2.BIT.SP = 1U;
ffc00781:	f1 53 01                      	bset	#3, 1[r5].b
            g_riic0_state = _07_IIC_MASTER_SENDS_STOP;
ffc00784:	f8 44 07                      	mov.b	#7, [r4]
ffc00787:	02                            	rts

ffc00788 <_r_Config_RIIC0_error_interrupt>:

void r_Config_RIIC0_error_interrupt(void)
{
    volatile uint8_t dummy;

    if ((1U == RIIC0.ICIER.BIT.ALIE) && (1U == RIIC0.ICSR2.BIT.AL))
ffc00788:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc0078d:	89 dc                         	mov.b	7[r5], r4
ffc0078f:	7c 14                         	btst	#1, r4
ffc00791:	21 6b                         	bne.b	ffc007fc <_Reset_Vector+0xffc00800>
    {
        r_Config_RIIC0_callback_error(MD_ERROR1);
    }
    else if ((1U == RIIC0.ICIER.BIT.TMOIE) && (1U == RIIC0.ICSR2.BIT.TMOF))
ffc00793:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc00798:	89 dc                         	mov.b	7[r5], r4
ffc0079a:	7c 04                         	btst	#0, r4
ffc0079c:	21 6a                         	bne.b	ffc00806 <_Reset_Vector+0xffc0080a>
ffc0079e:	ef 00                         	nop	; mov.l	r0, r0
    {
        r_Config_RIIC0_callback_error(MD_ERROR2);
    }
    else if ((1U == RIIC0.ICIER.BIT.NAKIE) && (1U == RIIC0.ICSR2.BIT.NACKF))
ffc007a0:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc007a5:	89 dc                         	mov.b	7[r5], r4
ffc007a7:	7c 44                         	btst	#4, r4
ffc007a9:	21 72                         	bne.b	ffc0081b <_Reset_Vector+0xffc0081f>
ffc007ab:	77 10 01 00 00                	nop	; mul	#1, r0
            /* Do nothing */
        }

        r_Config_RIIC0_callback_error(MD_ERROR3);
    }
    else if (_0D_IIC_MASTER_TRANSMIT == g_riic0_mode_flag)
ffc007b0:	fb 42 98 08 00 00             	mov.l	#0x898, r4
ffc007b6:	58 45                         	movu.b	[r4], r5
ffc007b8:	61 d5                         	cmp	#13, r5
ffc007ba:	11                            	beq.s	ffc007c3 <_Reset_Vector+0xffc007c7>
        else
        {
            r_Config_RIIC0_callback_error(MD_ERROR4);
        }
    }
    else if (_0C_IIC_MASTER_RECEIVE == g_riic0_mode_flag)
ffc007bb:	58 45                         	movu.b	[r4], r5
ffc007bd:	61 c5                         	cmp	#12, r5
ffc007bf:	3a 8f 00                      	beq.w	ffc0084e <_Reset_Vector+0xffc00852>
ffc007c2:	02                            	rts
        if ((_01_IIC_MASTER_SENDS_ADR_7_W == g_riic0_state) || (_02_IIC_MASTER_SENDS_ADR_10A_W == g_riic0_state))
ffc007c3:	fb 42 ac 08 00 00             	mov.l	#0x8ac, r4
ffc007c9:	58 45                         	movu.b	[r4], r5
ffc007cb:	61 15                         	cmp	#1, r5
ffc007cd:	20 20                         	beq.b	ffc007ed <_Reset_Vector+0xffc007f1>
ffc007cf:	58 45                         	movu.b	[r4], r5
ffc007d1:	61 25                         	cmp	#2, r5
ffc007d3:	20 1a                         	beq.b	ffc007ed <_Reset_Vector+0xffc007f1>
        else if (_07_IIC_MASTER_SENDS_STOP == g_riic0_state)
ffc007d5:	58 45                         	movu.b	[r4], r5
ffc007d7:	61 75                         	cmp	#7, r5
ffc007d9:	21 e9                         	bne.b	ffc007c2 <_Reset_Vector+0xffc007c6>
            RIIC0.ICIER.BIT.STIE = 0U;
            g_riic0_state = _03_IIC_MASTER_SENDS_ADR_10A_R;
        }
        else if (_0B_IIC_MASTER_RECEIVES_STOP == g_riic0_state)
        {
            RIIC0.ICSR2.BIT.NACKF = 0U;
ffc007db:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc007e0:	f1 5c 09                      	bclr	#4, 9[r5].b
            RIIC0.ICSR2.BIT.STOP = 0U;
ffc007e3:	f1 5b 09                      	bclr	#3, 9[r5].b
            RIIC0.ICIER.BIT.SPIE = 0U;
ffc007e6:	f1 5b 07                      	bclr	#3, 7[r5].b
            RIIC0.ICIER.BIT.STIE = 1U;
ffc007e9:	f1 52 07                      	bset	#2, 7[r5].b
    }
    else
    {
        r_Config_RIIC0_callback_error(MD_ERROR4);
    }
}
ffc007ec:	02                            	rts
            RIIC0.ICSR2.BIT.START = 0U;
ffc007ed:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc007f2:	f1 5a 09                      	bclr	#2, 9[r5].b
            RIIC0.ICIER.BIT.STIE = 0U;
ffc007f5:	f1 5a 07                      	bclr	#2, 7[r5].b
            RIIC0.ICIER.BIT.SPIE = 1U;
ffc007f8:	f1 53 07                      	bset	#3, 7[r5].b
ffc007fb:	02                            	rts
    if ((1U == RIIC0.ICIER.BIT.ALIE) && (1U == RIIC0.ICSR2.BIT.AL))
ffc007fc:	8a 5c                         	mov.b	9[r5], r4
ffc007fe:	7c 14                         	btst	#1, r4
ffc00800:	20 93                         	beq.b	ffc00793 <_Reset_Vector+0xffc00797>

ffc00802 <.LBB28>:
        case MD_ERROR1:
        {
            /* Start user code for arbitration-lost error. Do not edit comment generated here */
            /* End user code. Do not edit comment generated here */

            RIIC0.ICSR2.BIT.AL = 0U;
ffc00802:	f1 59 09                      	bclr	#1, 9[r5].b
            break;
ffc00805:	02                            	rts

ffc00806 <.LVL1>:
    else if ((1U == RIIC0.ICIER.BIT.TMOIE) && (1U == RIIC0.ICSR2.BIT.TMOF))
ffc00806:	8a 5c                         	mov.b	9[r5], r4
ffc00808:	7c 04                         	btst	#0, r4
ffc0080a:	20 96                         	beq.b	ffc007a0 <_Reset_Vector+0xffc007a4>

ffc0080c <.LBB30>:
        }
        case MD_ERROR2:
        {
            if (1U == RIIC0.ICCR1.BIT.SCLI)
ffc0080c:	cc 54                         	mov.b	[r5], r4
ffc0080e:	7c 14                         	btst	#1, r4
ffc00810:	21 5e                         	bne.b	ffc0086e <_Reset_Vector+0xffc00872>
            }

            /* Start user code for timeout error. Do not edit comment generated here */
            /* End user code. Do not edit comment generated here */

            RIIC0.ICSR2.BIT.TMOF = 0U;
ffc00812:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc00817:	f1 58 09                      	bclr	#0, 9[r5].b
            break;
ffc0081a:	02                            	rts

ffc0081b <.LBE36>:
    else if ((1U == RIIC0.ICIER.BIT.NAKIE) && (1U == RIIC0.ICSR2.BIT.NACKF))
ffc0081b:	8a 5c                         	mov.b	9[r5], r4
ffc0081d:	7c 44                         	btst	#4, r4
ffc0081f:	20 91                         	beq.b	ffc007b0 <_Reset_Vector+0xffc007b4>
        if (_0D_IIC_MASTER_TRANSMIT == g_riic0_mode_flag)
ffc00821:	fb 32 98 08 00 00             	mov.l	#0x898, r3
ffc00827:	58 34                         	movu.b	[r3], r4
ffc00829:	61 d4                         	cmp	#13, r4
ffc0082b:	3a b1 00                      	beq.w	ffc008dc <_Reset_Vector+0xffc008e0>
        else if (_0C_IIC_MASTER_RECEIVE == g_riic0_mode_flag)
ffc0082e:	58 34                         	movu.b	[r3], r4
ffc00830:	61 c4                         	cmp	#12, r4
ffc00832:	21 90                         	bne.b	ffc007c2 <_Reset_Vector+0xffc007c6>
{
ffc00834:	60 40                         	sub	#4, r0
            RIIC0.ICSR2.BIT.STOP = 0U;
ffc00836:	f1 5b 09                      	bclr	#3, 9[r5].b
            RIIC0.ICCR2.BIT.SP = 1U;
ffc00839:	f1 53 01                      	bset	#3, 1[r5].b
            dummy = RIIC0.ICDRR;
ffc0083c:	8c dc                         	mov.b	19[r5], r4
ffc0083e:	c3 04                         	mov.b	r4, [r0]
            RIIC0.ICSR2.BIT.NACKF = 0U;
ffc00840:	f1 5c 09                      	bclr	#4, 9[r5].b
            g_riic0_state = _0B_IIC_MASTER_RECEIVES_STOP;
ffc00843:	fb 52 ac 08 00 00             	mov.l	#0x8ac, r5
ffc00849:	f8 54 0b                      	mov.b	#11, [r5]
}
ffc0084c:	67 01                         	rtsd	#4
        if ((_00_IIC_MASTER_SENDS_ADR_7_R == g_riic0_state) || (_02_IIC_MASTER_SENDS_ADR_10A_W == g_riic0_state))
ffc0084e:	fb 42 ac 08 00 00             	mov.l	#0x8ac, r4
ffc00854:	58 45                         	movu.b	[r4], r5
ffc00856:	61 05                         	cmp	#0, r5
ffc00858:	20 95                         	beq.b	ffc007ed <_Reset_Vector+0xffc007f1>
ffc0085a:	58 45                         	movu.b	[r4], r5
ffc0085c:	61 25                         	cmp	#2, r5
ffc0085e:	20 8f                         	beq.b	ffc007ed <_Reset_Vector+0xffc007f1>
        else if (_0E_IIC_MASTER_RECEIVES_RESTART == g_riic0_state)
ffc00860:	58 45                         	movu.b	[r4], r5
ffc00862:	61 e5                         	cmp	#14, r5
ffc00864:	20 69                         	beq.b	ffc008cd <_Reset_Vector+0xffc008d1>
        else if (_0B_IIC_MASTER_RECEIVES_STOP == g_riic0_state)
ffc00866:	58 45                         	movu.b	[r4], r5
ffc00868:	61 b5                         	cmp	#11, r5
ffc0086a:	3a 71 ff                      	beq.w	ffc007db <_Reset_Vector+0xffc007df>
ffc0086d:	02                            	rts

ffc0086e <.LBB33>:
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc0086e:	cc 54                         	mov.b	[r5], r4
ffc00870:	7c 04                         	btst	#0, r4
ffc00872:	21 a0                         	bne.b	ffc00812 <_Reset_Vector+0xffc00816>

ffc00874 <.LVL5>:
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc00874:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc00876:	cc 54                         	mov.b	[r5], r4
ffc00878:	7c 04                         	btst	#0, r4
ffc0087a:	21 98                         	bne.b	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc0087c:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc0087e:	cc 54                         	mov.b	[r5], r4
ffc00880:	7c 04                         	btst	#0, r4
ffc00882:	21 90                         	bne.b	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc00884:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc00886:	cc 54                         	mov.b	[r5], r4
ffc00888:	7c 04                         	btst	#0, r4
ffc0088a:	21 88                         	bne.b	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc0088c:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc0088e:	cc 54                         	mov.b	[r5], r4
ffc00890:	7c 04                         	btst	#0, r4
ffc00892:	21 80                         	bne.b	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc00894:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc00896:	cc 54                         	mov.b	[r5], r4
ffc00898:	7c 04                         	btst	#0, r4
ffc0089a:	3b 78 ff                      	bne.w	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc0089d:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc0089f:	cc 55                         	mov.b	[r5], r5
ffc008a1:	7c 05                         	btst	#0, r5
ffc008a3:	3b 6f ff                      	bne.w	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc008a6:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc008ab:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc008ad:	cc 54                         	mov.b	[r5], r4
ffc008af:	7c 04                         	btst	#0, r4
ffc008b1:	3b 61 ff                      	bne.w	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc008b4:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc008b6:	cc 54                         	mov.b	[r5], r4
ffc008b8:	7c 04                         	btst	#0, r4
ffc008ba:	3b 58 ff                      	bne.w	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc008bd:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc008bf:	cc 54                         	mov.b	[r5], r4
ffc008c1:	7c 04                         	btst	#0, r4
ffc008c3:	3b 4f ff                      	bne.w	ffc00812 <_Reset_Vector+0xffc00816>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffc008c6:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffc008c8:	cc 55                         	mov.b	[r5], r5
ffc008ca:	38 48 ff                      	bra.w	ffc00812 <_Reset_Vector+0xffc00816>

ffc008cd <.LBE37>:
            RIIC0.ICSR2.BIT.START = 0U;
ffc008cd:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc008d2:	f1 5a 09                      	bclr	#2, 9[r5].b
            RIIC0.ICIER.BIT.STIE = 0U;
ffc008d5:	f1 5a 07                      	bclr	#2, 7[r5].b
            g_riic0_state = _03_IIC_MASTER_SENDS_ADR_10A_R;
ffc008d8:	f8 44 03                      	mov.b	#3, [r4]
ffc008db:	02                            	rts
            RIIC0.ICSR2.BIT.STOP = 0U;
ffc008dc:	f1 5b 09                      	bclr	#3, 9[r5].b
            RIIC0.ICCR2.BIT.SP = 1U;
ffc008df:	f1 53 01                      	bset	#3, 1[r5].b
            RIIC0.ICSR2.BIT.NACKF = 0U;
ffc008e2:	f1 5c 09                      	bclr	#4, 9[r5].b
            g_riic0_state = _07_IIC_MASTER_SENDS_STOP;
ffc008e5:	fb 52 ac 08 00 00             	mov.l	#0x8ac, r5
ffc008eb:	f8 54 07                      	mov.b	#7, [r5]
ffc008ee:	02                            	rts

ffc008ef <.LFE9>:
ffc008ef:	03                            	nop

ffc008f0 <_r_sci_iic_init_io_register>:
{
ffc008f0:	6e 6c                         	pushm	r6-r12
ffc008f2:	75 b0 02                      	dpushm.d	dr0-dr2
ffc008f5:	75 a0 10                      	dpushm.l	dcmr-dcmr
ffc008f8:	60 80                         	sub	#8, r0
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc008fa:	fb 72 f4 66 c0 ff             	mov.l	#0xffc066f4, r7
ffc00900:	59 1a 03                      	movu.b	3[r1], r10
ffc00903:	fe 6a 7a                      	mov.l	[r10, r7], r10
ffc00906:	ec a4                         	mov.l	[r10], r4
ffc00908:	a8 4d                         	mov.l	4[r4], r5

ffc0090a <.LVL43>:
    pregs->SCR.BYTE = SCI_IIC_SCR_INIT;
ffc0090a:	3c 52 00                      	mov.b	#0, 2[r5]
    sci_iic_set_frequency(p_sci_iic_info);
ffc0090d:	88 9b                         	mov.b	3[r1], r3

ffc0090f <.LBB4>:
    volatile uint16_t brr_n = 32U; /* default: 64*2^(2*0-1) = 32 */
ffc0090f:	3d 02 20                      	mov.w	#32, 4[r0]
    volatile uint8_t cks_value = 0U; /* default: PCLK/1 */
ffc00912:	3c 06 00                      	mov.b	#0, 6[r0]
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00915:	5b 3a                         	movu.b	r3, r10
        (SCI_IIC_NUM_CH9 == p_sci_iic_info->ch_no) || (SCI_IIC_NUM_CH10 == p_sci_iic_info->ch_no) || \
ffc00917:	60 73                         	sub	#7, r3
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00919:	fe 6a 7a                      	mov.l	[r10, r7], r10
    if ((SCI_IIC_NUM_CH7 == p_sci_iic_info->ch_no) || (SCI_IIC_NUM_CH8 == p_sci_iic_info->ch_no) || \
ffc0091c:	5b 37                         	movu.b	r3, r7
    volatile uint32_t brr_value = 0U;
ffc0091e:	f8 06 00                      	mov.l	#0, [r0]
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00921:	ec a3                         	mov.l	[r10], r3
ffc00923:	a8 3a                         	mov.l	4[r3], r2

ffc00925 <.LVL45>:
    if ((SCI_IIC_NUM_CH7 == p_sci_iic_info->ch_no) || (SCI_IIC_NUM_CH8 == p_sci_iic_info->ch_no) || \
ffc00925:	61 47                         	cmp	#4, r7
ffc00927:	25 05                         	bleu.b	ffc0092c <_Reset_Vector+0xffc00930>
ffc00929:	38 22 01                      	bra.w	ffc00a4b <_Reset_Vector+0xffc00a4f>
        brr_value = (uint32_t) ((double) ((double) ((double) BSP_PCLKA_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffc0092c:	f9 03 13 38 9c 9c 41          	dmov.d	#0x419c9c38, drh1
        brr_n_tmp = brr_n;
ffc00933:	98 87                         	mov.w	4[r0], r7

ffc00935 <.LVL46>:
        brr_value = (uint32_t) ((double) ((double) ((double) BSP_PCLKA_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffc00935:	ed 3a 10                      	mov.l	64[r3], r10
ffc00938:	5f 77                         	movu.w	r7, r7

ffc0093a <.LVL47>:
ffc0093a:	4f a7                         	mul	r10, r7

ffc0093c <.LVL48>:
ffc0093c:	fd 77 87 0d                   	utod	r7, dr0
ffc00940:	76 90 15 00                   	ddiv	dr0, dr1, dr0
ffc00944:	f9 03 20 9a 99 99 99          	dmov.l	#0x9999999a, drl2
ffc0094b:	f9 03 22 99 99 b9 3f          	dmov.l	#0x3fb99999, drh2
ffc00952:	76 90 01 02                   	dsub	dr2, dr0, dr0
ffc00956:	76 90 0d 29                   	dtou	dr0, dr2
ffc0095a:	fd 75 87 20                   	dmov.l	drl2, r7
ffc0095e:	e3 07                         	mov.l	r7, [r0]
    while (brr_value > 255)
ffc00960:	ec 07                         	mov.l	[r0], r7
ffc00962:	75 57 ff                      	cmp	#255, r7
ffc00965:	25 7b                         	bleu.b	ffc009e0 <_Reset_Vector+0xffc009e4>
                brr_n = 512; /* 64*(2^(2*2-1))  */
ffc00967:	fb 6a 00 02                   	mov.l	#512, r6
                cks_value = 2; /* clock select: PCLK/16 */
ffc0096b:	66 2a                         	mov.l	#2, r10
                brr_n = 2048; /* 64*(2^(2*3-1)) */
ffc0096d:	fb 7a 00 08                   	mov.l	#0x800, r7
                cks_value = 3; /* clock select: PCLK/64 */
ffc00971:	66 3f                         	mov.l	#3, r15
                brr_n = 128; /* 64*(2^(2*1-1)) */
ffc00973:	75 4e 80                      	mov.l	#128, r14
                cks_value = 1; /* clock select: PCLK/4 */
ffc00976:	66 11                         	mov.l	#1, r1

ffc00978 <.LVL49>:
            brr_value = 255;
ffc00978:	75 4b ff                      	mov.l	#255, r11
ffc0097b:	08                            	bra.s	ffc00983 <_Reset_Vector+0xffc00987>
    while (brr_value > 255)
ffc0097c:	ec 0c                         	mov.l	[r0], r12
ffc0097e:	75 5c ff                      	cmp	#255, r12
ffc00981:	25 5f                         	bleu.b	ffc009e0 <_Reset_Vector+0xffc009e4>
        switch (brr_n)
ffc00983:	5d 0c 02                      	movu.w	4[r0], r12
ffc00986:	75 5c 80                      	cmp	#128, r12
ffc00989:	3a ba 00                      	beq.w	ffc00a43 <_Reset_Vector+0xffc00a47>
ffc0098c:	76 0c 00 02                   	cmp	#512, r12
ffc00990:	3a ab 00                      	beq.w	ffc00a3b <_Reset_Vector+0xffc00a3f>
ffc00993:	75 5c 20                      	cmp	#32, r12
ffc00996:	3a 9d 00                      	beq.w	ffc00a33 <_Reset_Vector+0xffc00a37>
            brr_n_tmp = brr_n;
ffc00999:	dd 0c 02                      	mov.w	4[r0], r12

ffc0099c <.LVL50>:
            brr_value = (uint32_t) ((double) (((double) BSP_PCLKA_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffc0099c:	ed 39 10                      	mov.l	64[r3], r9
ffc0099f:	5f cc                         	movu.w	r12, r12
ffc009a1:	4f 9c                         	mul	r9, r12

ffc009a3 <.LVL51>:
ffc009a3:	fd 77 8c 0d                   	utod	r12, dr0
ffc009a7:	76 90 15 00                   	ddiv	dr0, dr1, dr0
ffc009ab:	f9 03 20 9a 99 99 99          	dmov.l	#0x9999999a, drl2
ffc009b2:	f9 03 22 99 99 b9 3f          	dmov.l	#0x3fb99999, drh2
ffc009b9:	76 90 01 02                   	dsub	dr2, dr0, dr0
ffc009bd:	76 90 0d 29                   	dtou	dr0, dr2
ffc009c1:	fd 75 8c 20                   	dmov.l	drl2, r12
ffc009c5:	e3 0c                         	mov.l	r12, [r0]
        if ((3 == cks_value) && (255 < brr_value))
ffc009c7:	59 0c 06                      	movu.b	6[r0], r12
ffc009ca:	61 3c                         	cmp	#3, r12
ffc009cc:	21 b0                         	bne.b	ffc0097c <_Reset_Vector+0xffc00980>
ffc009ce:	ec 0c                         	mov.l	[r0], r12
ffc009d0:	75 5c ff                      	cmp	#255, r12
ffc009d3:	25 a9                         	bleu.b	ffc0097c <_Reset_Vector+0xffc00980>
            brr_value = 255;
ffc009d5:	e3 0b                         	mov.l	r11, [r0]
    while (brr_value > 255)
ffc009d7:	ec 0c                         	mov.l	[r0], r12
ffc009d9:	75 5c ff                      	cmp	#255, r12
ffc009dc:	24 a7                         	bgtu.b	ffc00983 <_Reset_Vector+0xffc00987>
ffc009de:	ef 00                         	nop	; mov.l	r0, r0
    cks_value_tmp = cks_value;
ffc009e0:	89 83                         	mov.b	6[r0], r3

ffc009e2 <.LVL52>:
    pregs->SMR.BYTE |= cks_value_tmp; /* Sets SMR */
ffc009e2:	cc 21                         	mov.b	[r2], r1
ffc009e4:	57 13                         	or	r1, r3

ffc009e6 <.LVL53>:
ffc009e6:	c3 23                         	mov.b	r3, [r2]

ffc009e8 <.LVL54>:
    pregs->BRR = brr_value; /* Sets BRR */
ffc009e8:	ec 07                         	mov.l	[r0], r7
ffc009ea:	80 2f                         	mov.b	r7, 1[r2]

ffc009ec <.LBE4>:
    pregs->SEMR.BIT.NFEN = prom->df_sel;
ffc009ec:	cd 43 44                      	mov.b	68[r4], r3
ffc009ef:	89 df                         	mov.b	7[r5], r7
ffc009f1:	7c 03                         	btst	#0, r3
ffc009f3:	fd e5 17                      	bmne	#5, r7
ffc009f6:	81 df                         	mov.b	r7, 7[r5]
    pregs->SNFR.BIT.NFCS = prom->df_clk;
ffc009f8:	cd 42 45                      	mov.b	69[r4], r2
ffc009fb:	8a 53                         	mov.b	8[r5], r3
ffc009fd:	64 72                         	and	#7, r2
ffc009ff:	75 23 f8                      	and	#-8, r3
ffc00a02:	57 23                         	or	r2, r3
ffc00a04:	82 53                         	mov.b	r3, 8[r5]
    pregs->SIMR1.BIT.IICM = 0; /* Do not use Simple IIC mode. */
ffc00a06:	f1 58 09                      	bclr	#0, 9[r5].b
    pregs->SIMR1.BIT.IICDL = prom->ssda_delay;
ffc00a09:	cd 43 3f                      	mov.b	63[r4], r3
ffc00a0c:	8a 5c                         	mov.b	9[r5], r4

ffc00a0e <.LVL56>:
ffc00a0e:	75 23 1f                      	and	#31, r3
ffc00a11:	6c 33                         	shll	#3, r3
ffc00a13:	64 74                         	and	#7, r4
ffc00a15:	57 34                         	or	r3, r4
ffc00a17:	82 5c                         	mov.b	r4, 9[r5]
    pregs->SIMR2.BIT.IICACKT = SCI_IIC_NACK_TRANS;
ffc00a19:	f1 55 0a                      	bset	#5, 10[r5].b
    pregs->SIMR2.BIT.IICCSC = SCI_IIC_SYNCHRO;
ffc00a1c:	f1 51 0a                      	bset	#1, 10[r5].b
    pregs->SIMR2.BIT.IICINTM = SCI_IIC_RCV_TRS_INTERRUPT;
ffc00a1f:	f1 50 0a                      	bset	#0, 10[r5].b
    pregs->SISR.BIT.IICACKR = SCI_IIC_ACK_RCV;
ffc00a22:	f1 58 0c                      	bclr	#0, 12[r5].b
    pregs->SPMR.BYTE = 0x00;
ffc00a25:	3c 5d 00                      	mov.b	#0, 13[r5]
} /* End of function r_sci_iic_init_io_register() */
ffc00a28:	62 80                         	add	#8, r0
ffc00a2a:	75 a8 10                      	dpopm.l	dcmr-dcmr
ffc00a2d:	75 b8 02                      	dpopm.d	dr0-dr2
ffc00a30:	6f 6c                         	popm	r6-r12
ffc00a32:	02                            	rts

ffc00a33 <.LBB7>:
                brr_n = 128; /* 64*(2^(2*1-1)) */
ffc00a33:	d7 0e 02                      	mov.w	r14, 4[r0]
                cks_value = 1; /* clock select: PCLK/4 */
ffc00a36:	81 81                         	mov.b	r1, 6[r0]
            break;
ffc00a38:	38 61 ff                      	bra.w	ffc00999 <_Reset_Vector+0xffc0099d>
                brr_n = 2048; /* 64*(2^(2*3-1)) */
ffc00a3b:	90 87                         	mov.w	r7, 4[r0]
                cks_value = 3; /* clock select: PCLK/64 */
ffc00a3d:	c7 0f 06                      	mov.b	r15, 6[r0]
            break;
ffc00a40:	38 59 ff                      	bra.w	ffc00999 <_Reset_Vector+0xffc0099d>
                brr_n = 512; /* 64*(2^(2*2-1))  */
ffc00a43:	90 86                         	mov.w	r6, 4[r0]
                cks_value = 2; /* clock select: PCLK/16 */
ffc00a45:	c7 0a 06                      	mov.b	r10, 6[r0]
            break;
ffc00a48:	38 51 ff                      	bra.w	ffc00999 <_Reset_Vector+0xffc0099d>

ffc00a4b <.LVL58>:
        brr_value = (uint32_t) ((double) ((double) ((double) BSP_PCLKB_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffc00a4b:	f9 03 13 38 9c 8c 41          	dmov.d	#0x418c9c38, drh1
        brr_n_tmp = brr_n;
ffc00a52:	98 87                         	mov.w	4[r0], r7

ffc00a54 <.LVL59>:
        brr_value = (uint32_t) ((double) ((double) ((double) BSP_PCLKB_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffc00a54:	ed 3a 10                      	mov.l	64[r3], r10
ffc00a57:	5f 77                         	movu.w	r7, r7

ffc00a59 <.LVL60>:
ffc00a59:	4f a7                         	mul	r10, r7

ffc00a5b <.LVL61>:
ffc00a5b:	fd 77 87 0d                   	utod	r7, dr0
ffc00a5f:	76 90 15 00                   	ddiv	dr0, dr1, dr0
ffc00a63:	f9 03 20 9a 99 99 99          	dmov.l	#0x9999999a, drl2
ffc00a6a:	f9 03 22 99 99 b9 3f          	dmov.l	#0x3fb99999, drh2
ffc00a71:	76 90 01 02                   	dsub	dr2, dr0, dr0
ffc00a75:	76 90 0d 29                   	dtou	dr0, dr2
ffc00a79:	fd 75 87 20                   	dmov.l	drl2, r7
ffc00a7d:	e3 07                         	mov.l	r7, [r0]
    while (brr_value > 255)
ffc00a7f:	ec 07                         	mov.l	[r0], r7
ffc00a81:	75 57 ff                      	cmp	#255, r7
ffc00a84:	24 05                         	bgtu.b	ffc00a89 <_Reset_Vector+0xffc00a8d>
ffc00a86:	38 5a ff                      	bra.w	ffc009e0 <_Reset_Vector+0xffc009e4>
                brr_n = 512; /* 64*(2^(2*2-1))  */
ffc00a89:	fb ca 00 02                   	mov.l	#512, r12
                cks_value = 2; /* clock select: PCLK/16 */
ffc00a8d:	66 2b                         	mov.l	#2, r11
                brr_n = 2048; /* 64*(2^(2*3-1)) */
ffc00a8f:	fb 6a 00 08                   	mov.l	#0x800, r6
                cks_value = 3; /* clock select: PCLK/64 */
ffc00a93:	66 31                         	mov.l	#3, r1

ffc00a95 <.LVL62>:
                brr_n = 128; /* 64*(2^(2*1-1)) */
ffc00a95:	75 4a 80                      	mov.l	#128, r10
                cks_value = 1; /* clock select: PCLK/4 */
ffc00a98:	66 17                         	mov.l	#1, r7
            brr_value = 255;
ffc00a9a:	75 4e ff                      	mov.l	#255, r14
ffc00a9d:	2e 0c                         	bra.b	ffc00aa9 <_Reset_Vector+0xffc00aad>
    while (brr_value > 255)
ffc00a9f:	ec 09                         	mov.l	[r0], r9
ffc00aa1:	75 59 ff                      	cmp	#255, r9
ffc00aa4:	24 05                         	bgtu.b	ffc00aa9 <_Reset_Vector+0xffc00aad>
ffc00aa6:	38 3a ff                      	bra.w	ffc009e0 <_Reset_Vector+0xffc009e4>
        switch (brr_n)
ffc00aa9:	5d 0f 02                      	movu.w	4[r0], r15
ffc00aac:	75 5f 80                      	cmp	#128, r15
ffc00aaf:	20 5e                         	beq.b	ffc00b0d <_Reset_Vector+0xffc00b11>
ffc00ab1:	76 0f 00 02                   	cmp	#512, r15
ffc00ab5:	20 52                         	beq.b	ffc00b07 <_Reset_Vector+0xffc00b0b>
ffc00ab7:	75 5f 20                      	cmp	#32, r15
ffc00aba:	20 46                         	beq.b	ffc00b00 <_Reset_Vector+0xffc00b04>
ffc00abc:	76 10 01 00                   	nop	; mul	#1, r0
            brr_n_tmp = brr_n;
ffc00ac0:	dd 0f 02                      	mov.w	4[r0], r15

ffc00ac3 <.LVL63>:
            brr_value = (uint32_t) ((double) (((double) BSP_PCLKB_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffc00ac3:	ed 39 10                      	mov.l	64[r3], r9
ffc00ac6:	5f ff                         	movu.w	r15, r15
ffc00ac8:	4f 9f                         	mul	r9, r15

ffc00aca <.LVL64>:
ffc00aca:	fd 77 8f 0d                   	utod	r15, dr0
ffc00ace:	76 90 15 00                   	ddiv	dr0, dr1, dr0
ffc00ad2:	f9 03 20 9a 99 99 99          	dmov.l	#0x9999999a, drl2
ffc00ad9:	f9 03 22 99 99 b9 3f          	dmov.l	#0x3fb99999, drh2
ffc00ae0:	76 90 01 02                   	dsub	dr2, dr0, dr0
ffc00ae4:	76 90 0d 29                   	dtou	dr0, dr2
ffc00ae8:	fd 75 8f 20                   	dmov.l	drl2, r15
ffc00aec:	e3 0f                         	mov.l	r15, [r0]
        if ((3 == cks_value) && (255 < brr_value))
ffc00aee:	59 0f 06                      	movu.b	6[r0], r15
ffc00af1:	61 3f                         	cmp	#3, r15
ffc00af3:	21 ac                         	bne.b	ffc00a9f <_Reset_Vector+0xffc00aa3>
ffc00af5:	ec 09                         	mov.l	[r0], r9
ffc00af7:	75 59 ff                      	cmp	#255, r9
ffc00afa:	25 a5                         	bleu.b	ffc00a9f <_Reset_Vector+0xffc00aa3>
            brr_value = 255;
ffc00afc:	e3 0e                         	mov.l	r14, [r0]
ffc00afe:	2e a1                         	bra.b	ffc00a9f <_Reset_Vector+0xffc00aa3>
                brr_n = 128; /* 64*(2^(2*1-1)) */
ffc00b00:	d7 0a 02                      	mov.w	r10, 4[r0]
                cks_value = 1; /* clock select: PCLK/4 */
ffc00b03:	81 87                         	mov.b	r7, 6[r0]
            break;
ffc00b05:	2e bb                         	bra.b	ffc00ac0 <_Reset_Vector+0xffc00ac4>
                brr_n = 2048; /* 64*(2^(2*3-1)) */
ffc00b07:	90 86                         	mov.w	r6, 4[r0]
                cks_value = 3; /* clock select: PCLK/64 */
ffc00b09:	81 81                         	mov.b	r1, 6[r0]
            break;
ffc00b0b:	2e b5                         	bra.b	ffc00ac0 <_Reset_Vector+0xffc00ac4>
                brr_n = 512; /* 64*(2^(2*2-1))  */
ffc00b0d:	d7 0c 02                      	mov.w	r12, 4[r0]
                cks_value = 2; /* clock select: PCLK/16 */
ffc00b10:	c7 0b 06                      	mov.b	r11, 6[r0]
            break;
ffc00b13:	2e ad                         	bra.b	ffc00ac0 <_Reset_Vector+0xffc00ac4>

ffc00b15 <.LBE7>:
ffc00b15:	fc 13 00                      	nop	; max	r0, r0

ffc00b18 <_r_sci_iic_int_disable>:
{
ffc00b18:	6e 6a                         	pushm	r6-r10
ffc00b1a:	60 80                         	sub	#8, r0
ffc00b1c:	ef 1a                         	mov.l	r1, r10
    R_BSP_VOLATILE_EVENACCESS const sci_iic_ch_rom_t * prom = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom;
ffc00b1e:	fb 62 f4 66 c0 ff             	mov.l	#0xffc066f4, r6
    R_BSP_InterruptWrite(prom->grp_tei_def, (bsp_int_cb_t) (FIT_NO_FUNC));
ffc00b24:	fb 22 00 00 00 10             	mov.l	#0x10000000, r2
    R_BSP_VOLATILE_EVENACCESS const sci_iic_ch_rom_t * prom = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom;
ffc00b2a:	b0 9f                         	movu.b	3[r1], r7
ffc00b2c:	fe 67 67                      	mov.l	[r7, r6], r7
ffc00b2f:	ec 77                         	mov.l	[r7], r7

ffc00b31 <.LVL68>:
    R_BSP_InterruptWrite(prom->grp_tei_def, (bsp_int_cb_t) (FIT_NO_FUNC));
ffc00b31:	ab 71                         	mov.l	48[r7], r1

ffc00b33 <.LVL69>:
ffc00b33:	05 f5 31 00                   	bsr.a	ffc03d28 <_Reset_Vector+0xffc03d2c>

ffc00b37 <.LVL70>:
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc00b37:	ef 03                         	mov.l	r0, r3
ffc00b39:	66 62                         	mov.l	#6, r2
ffc00b3b:	75 41 69                      	mov.l	#105, r1
ffc00b3e:	05 0a 32 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc00b42 <.LVL71>:
    icu_txi = (*prom->picu_txi);
ffc00b42:	aa 75                         	mov.l	32[r7], r5
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc00b44:	ef 03                         	mov.l	r0, r3
    icu_txi = (*prom->picu_txi);
ffc00b46:	cc 5e                         	mov.b	[r5], r14

ffc00b48 <.LVL72>:
    txi_en_mask = prom->txi_en_mask;
ffc00b48:	cd 75 24                      	mov.b	36[r7], r5

ffc00b4b <.LVL73>:
    (*prom->picu_txi) = icu_txi & (~txi_en_mask);
ffc00b4b:	aa 74                         	mov.l	32[r7], r4
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc00b4d:	66 52                         	mov.l	#5, r2
    (*prom->picu_txi) = icu_txi & (~txi_en_mask);
ffc00b4f:	7e 05                         	not	r5

ffc00b51 <.LVL74>:
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc00b51:	75 41 69                      	mov.l	#105, r1
    (*prom->picu_txi) = icu_txi & (~txi_en_mask);
ffc00b54:	53 e5                         	and	r14, r5
ffc00b56:	c3 45                         	mov.b	r5, [r4]
    icu_tei = (*prom->picu_tei);
ffc00b58:	aa f5                         	mov.l	40[r7], r5
ffc00b5a:	ec 5e                         	mov.l	[r5], r14

ffc00b5c <.LVL75>:
    tei_en_mask = prom->tei_en_mask;
ffc00b5c:	aa fd                         	mov.l	44[r7], r5

ffc00b5e <.LVL76>:
    (*prom->picu_tei) = icu_tei & (~tei_en_mask);
ffc00b5e:	aa f4                         	mov.l	40[r7], r4
ffc00b60:	7e 05                         	not	r5

ffc00b62 <.LVL77>:
ffc00b62:	53 e5                         	and	r14, r5

ffc00b64 <.LVL78>:
ffc00b64:	e3 45                         	mov.l	r5, [r4]
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc00b66:	05 e2 31 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc00b6a <.LVL79>:
    (*prom->pipr) = 0; /* Clears TXI interrupt source priority register. */
ffc00b6a:	a9 75                         	mov.l	16[r7], r5
ffc00b6c:	f8 54 00                      	mov.b	#0, [r5]
    if (*prom->pipr)
ffc00b6f:	a9 75                         	mov.l	16[r7], r5
ffc00b71:	58 55                         	movu.b	[r5], r5
ffc00b73:	61 05                         	cmp	#0, r5
ffc00b75:	20 03                         	beq.b	ffc00b78 <_Reset_Vector+0xffc00b7c>
        R_BSP_NOP();
ffc00b77:	03                            	nop
    R_BSP_InterruptControl(prom->grp_tei_def, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &ipl);
ffc00b78:	ab 71                         	mov.l	48[r7], r1
ffc00b7a:	71 03 04                      	add	#4, r0, r3
ffc00b7d:	66 42                         	mov.l	#4, r2
    ipl = 0; /* Clears TEI interrupt source priority register. */
ffc00b7f:	3e 01 00                      	mov.l	#0, 4[r0]
    R_BSP_InterruptControl(prom->grp_tei_def, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &ipl);
ffc00b82:	05 c6 31 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc00b86 <.LBB10>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00b86:	59 a7 03                      	movu.b	3[r10], r7

ffc00b89 <.LVL81>:
ffc00b89:	fe 67 67                      	mov.l	[r7, r6], r7
ffc00b8c:	ec 75                         	mov.l	[r7], r5

ffc00b8e <.LVL82>:
    if (SCI_IIC_IR_SET == (*prom->pir_txi))
ffc00b8e:	a9 5f                         	mov.l	20[r5], r7
ffc00b90:	58 77                         	movu.b	[r7], r7
ffc00b92:	61 17                         	cmp	#1, r7
ffc00b94:	14                            	beq.s	ffc00b98 <_Reset_Vector+0xffc00b9c>

ffc00b95 <.LBE10>:
} /* End of function r_sci_iic_int_disable() */
ffc00b95:	3f 6a 07                      	rtsd	#28, r6-r10

ffc00b98 <.LBB13>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00b98:	a8 5c                         	mov.l	4[r5], r4
        pregs->SCR.BYTE = SCI_IIC_SCR_INIT;
ffc00b9a:	3c 42 00                      	mov.b	#0, 2[r4]
        while (SCI_IIC_SCR_INIT != pregs->SCR.BYTE)
ffc00b9d:	fc 13 00                      	nop	; max	r0, r0
ffc00ba0:	b0 c7                         	movu.b	2[r4], r7
ffc00ba2:	61 07                         	cmp	#0, r7
ffc00ba4:	21 fc                         	bne.b	ffc00ba0 <_Reset_Vector+0xffc00ba4>
        (*prom->pir_txi) = SCI_IIC_IR_CLR;
ffc00ba6:	a9 5f                         	mov.l	20[r5], r7
ffc00ba8:	f8 74 00                      	mov.b	#0, [r7]

ffc00bab <.LVL84>:
        if (*prom->pir_txi)
ffc00bab:	a9 5f                         	mov.l	20[r5], r7
ffc00bad:	58 77                         	movu.b	[r7], r7
ffc00baf:	61 07                         	cmp	#0, r7
ffc00bb1:	20 03                         	beq.b	ffc00bb4 <_Reset_Vector+0xffc00bb8>
            R_BSP_NOP();
ffc00bb3:	03                            	nop
        r_sci_iic_init_io_register(p_sci_iic_info);
ffc00bb4:	ef a1                         	mov.l	r10, r1
ffc00bb6:	05 3a fd ff                   	bsr.a	ffc008f0 <_Reset_Vector+0xffc008f4>

ffc00bba <.LBE13>:
} /* End of function r_sci_iic_int_disable() */
ffc00bba:	3f 6a 07                      	rtsd	#28, r6-r10

ffc00bbd <.LFE9>:
ffc00bbd:	fc 13 00                      	nop	; max	r0, r0

ffc00bc0 <_r_sci_iic_mpc_setting>:
{
ffc00bc0:	6e 6c                         	pushm	r6-r12

ffc00bc2 <.LVL107>:
                                                           + (uint32_t)((port_gr * 8) + pin_num));
ffc00bc2:	5b 11                         	movu.b	r1, r1

ffc00bc4 <.LVL108>:
ffc00bc4:	5b 22                         	movu.b	r2, r2
ffc00bc6:	fd c3 17                      	shll	#3, r1, r7
ffc00bc9:	4b 27                         	add	r2, r7
    if ((*ppfs) != set_value)
ffc00bcb:	5b 3b                         	movu.b	r3, r11
                                                           + (uint32_t)((port_gr * 8) + pin_num));
ffc00bcd:	73 77 40 c1 08                	add	#0x8c140, r7, r7

ffc00bd2 <.LVL109>:
    if ((*ppfs) != set_value)
ffc00bd2:	58 7a                         	movu.b	[r7], r10
ffc00bd4:	47 ba                         	cmp	r11, r10
ffc00bd6:	1d                            	bne.s	ffc00bdb <_Reset_Vector+0xffc00bdf>

ffc00bd7 <.LVL110>:
ffc00bd7:	03                            	nop
} /* End of function r_sci_iic_mpc_setting() */
ffc00bd8:	3f 6c 07                      	rtsd	#28, r6-r12

ffc00bdb <.LVL111>:
ffc00bdb:	cf 3c                         	mov.b	r3, r12
    R_BSP_VOLATILE_EVENACCESS uint8_t * const ppmr = (uint8_t *)((uint32_t)SCI_IIC_PRV_PMR_BASE_REG + (uint32_t)port_gr);
ffc00bdd:	73 1a 60 c0 08                	add	#0x8c060, r1, r10
        (*ppmr) &= (~(1U << pin_num)); /* Uses as a GPIO (Input port). */
ffc00be2:	cc a4                         	mov.b	[r10], r4
ffc00be4:	66 16                         	mov.l	#1, r6
ffc00be6:	fd 62 26                      	shll	r2, r6
ffc00be9:	fc 3b 65                      	not	r6, r5
        R_BSP_RegisterProtectDisable(BSP_REG_PROTECT_MPC); /* Enables the PFS register writing. */
ffc00bec:	66 31                         	mov.l	#3, r1

ffc00bee <.LVL112>:
        (*ppmr) &= (~(1U << pin_num)); /* Uses as a GPIO (Input port). */
ffc00bee:	53 45                         	and	r4, r5
ffc00bf0:	c3 a5                         	mov.b	r5, [r10]
        R_BSP_RegisterProtectDisable(BSP_REG_PROTECT_MPC); /* Enables the PFS register writing. */
ffc00bf2:	05 36 30 00                   	bsr.a	ffc03c28 <_Reset_Vector+0xffc03c2c>

ffc00bf6 <.LVL113>:
        R_BSP_RegisterProtectEnable(BSP_REG_PROTECT_MPC); /* Disables the PFS register writing. */
ffc00bf6:	66 31                         	mov.l	#3, r1
        (*ppfs) = set_value; /* Pin function select to "SSCL/SSDA" or "Hi-Z" pin. */
ffc00bf8:	c3 7c                         	mov.b	r12, [r7]
        R_BSP_RegisterProtectEnable(BSP_REG_PROTECT_MPC); /* Disables the PFS register writing. */
ffc00bfa:	05 a6 2f 00                   	bsr.a	ffc03ba0 <_Reset_Vector+0xffc03ba4>

ffc00bfe <.LVL114>:
        if (SCI_IIC_MPC_SSCL_INIT != set_value)
ffc00bfe:	61 0b                         	cmp	#0, r11
ffc00c00:	10                            	beq.s	ffc00c08 <_Reset_Vector+0xffc00c0c>
            (*ppmr) |= (1U << pin_num); /* Uses as SCI_IIC (SSCL/SSDA). */
ffc00c01:	cc a5                         	mov.b	[r10], r5
ffc00c03:	57 56                         	or	r5, r6
ffc00c05:	c3 a6                         	mov.b	r6, [r10]
ffc00c07:	03                            	nop
        if (*ppmr)
ffc00c08:	58 a7                         	movu.b	[r10], r7

ffc00c0a <.LVL115>:
ffc00c0a:	61 07                         	cmp	#0, r7
ffc00c0c:	20 cc                         	beq.b	ffc00bd8 <_Reset_Vector+0xffc00bdc>
            R_BSP_NOP();
ffc00c0e:	03                            	nop
} /* End of function r_sci_iic_mpc_setting() */
ffc00c0f:	3f 6c 07                      	rtsd	#28, r6-r12

ffc00c12 <.LFE12>:
ffc00c12:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffc00c18 <_sci_iic_generate_start_cond>:
 * Arguments    : sci_iic_info_t * p_sci_iic_info    ; IIC Information
 * Return Value : SCI_IIC_SUCCESS                    ; Successful operation, communication state
 *              : SCI_IIC_ERR_BUS_BUSY               ; None reply error
 **********************************************************************************************************************/
static sci_iic_return_t sci_iic_generate_start_cond (sci_iic_info_t * p_sci_iic_info)
{
ffc00c18:	7e a7                         	push.l	r7
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
    R_BSP_VOLATILE_EVENACCESS uint8_t * const ppidr = SCI_IIC_PRV_PIDR_BASE_REG;
    R_BSP_VOLATILE_EVENACCESS const sci_iic_ch_rom_t * prom = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom;
ffc00c1a:	fb e2 f4 66 c0 ff             	mov.l	#0xffc066f4, r14
ffc00c20:	b0 9f                         	movu.b	3[r1], r7
ffc00c22:	fe 67 e2                      	mov.l	[r7, r14], r2
ffc00c25:	ec 24                         	mov.l	[r2], r4

ffc00c27 <.LVL2>:
    uint8_t sscl_port_pin;
    uint8_t ssda_port_gr;
    uint8_t ssda_port_pin;
    
    /* Check Bus busy(SSDA,SSCL pin level) */
    sscl_port_gr = prom->sscl_port_gr;
ffc00c27:	cd 45 39                      	mov.b	57[r4], r5

ffc00c2a <.LVL3>:
    sscl_port_pin = prom->sscl_port_pin;
ffc00c2a:	cd 4f 3a                      	mov.b	58[r4], r15

ffc00c2d <.LVL4>:
    ssda_port_gr = prom->ssda_port_gr;
    ssda_port_pin = prom->ssda_port_pin;
    if ((SCI_IIC_LOW == ((*(ppidr + sscl_port_gr)) & (1U << sscl_port_pin)))
ffc00c2d:	5b 55                         	movu.b	r5, r5
    ssda_port_gr = prom->ssda_port_gr;
ffc00c2f:	cd 43 3c                      	mov.b	60[r4], r3

ffc00c32 <.LVL5>:
    if ((SCI_IIC_LOW == ((*(ppidr + sscl_port_gr)) & (1U << sscl_port_pin)))
ffc00c32:	73 55 40 c0 08                	add	#0x8c040, r5, r5

ffc00c37 <.LVL6>:
    ssda_port_pin = prom->ssda_port_pin;
ffc00c37:	cd 47 3d                      	mov.b	61[r4], r7

ffc00c3a <.LVL7>:
    if ((SCI_IIC_LOW == ((*(ppidr + sscl_port_gr)) & (1U << sscl_port_pin)))
ffc00c3a:	cc 55                         	mov.b	[r5], r5

ffc00c3c <.LVL8>:
ffc00c3c:	5b f4                         	movu.b	r15, r4

ffc00c3e <.LVL9>:
ffc00c3e:	5b 55                         	movu.b	r5, r5
ffc00c40:	fd 60 45                      	shlr	r4, r5
ffc00c43:	7c 05                         	btst	#0, r5
ffc00c45:	20 38                         	beq.b	ffc00c7d <_Reset_Vector+0xffc00c81>
            || (SCI_IIC_LOW == ((*(ppidr + ssda_port_gr)) & (1U << ssda_port_pin))))
ffc00c47:	5b 33                         	movu.b	r3, r3
ffc00c49:	5b 77                         	movu.b	r7, r7

ffc00c4b <.LVL10>:
ffc00c4b:	73 33 40 c0 08                	add	#0x8c040, r3, r3

ffc00c50 <.LVL11>:
ffc00c50:	58 35                         	movu.b	[r3], r5
ffc00c52:	fd 60 75                      	shlr	r7, r5
ffc00c55:	7c 05                         	btst	#0, r5
ffc00c57:	20 26                         	beq.b	ffc00c7d <_Reset_Vector+0xffc00c81>

ffc00c59 <.LBB132>:
 * Return Value : None
 **********************************************************************************************************************/
static void sci_iic_set_internal_status (sci_iic_info_t * p_sci_iic_info, sci_iic_api_status_t new_status)
{
    /* Sets the previous status. */
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00c59:	e5 22 03 04                   	mov.l	12[r2], 16[r2]

ffc00c5d <.LBE132>:
    return ret;
ffc00c5d:	66 04                         	mov.l	#0, r4

ffc00c5f <.LBB135>:

    /* Sets the now status. */
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00c5f:	3e 23 02                      	mov.l	#2, 12[r2]

ffc00c62 <.LBB136>:
 * Arguments    : sci_iic_info_t * p_sci_iic_info     ;   IIC Information
 * Return Value : None
 **********************************************************************************************************************/
static void sci_iic_start_cond_generate (sci_iic_info_t * p_sci_iic_info)
{
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00c62:	b0 9f                         	movu.b	3[r1], r7

ffc00c64 <.LVL14>:
ffc00c64:	fe 67 e5                      	mov.l	[r7, r14], r5
ffc00c67:	ec 57                         	mov.l	[r5], r7
ffc00c69:	a8 7f                         	mov.l	4[r7], r7

ffc00c6b <.LVL15>:

    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STAREQ; /* mode set start mode.*/
ffc00c6b:	3c d4 01                      	mov.b	#1, 20[r5]

ffc00c6e <.LVL16>:

    /* SCR - Serial Control Register
     b5     TE - Transmit Enable - Serial transmission is enabled
     b4     RE - Transmit Enable - Serial reception is enabled */
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffc00c6e:	88 f5                         	mov.b	2[r7], r5
ffc00c70:	75 35 30                      	or	#48, r5
ffc00c73:	80 f5                         	mov.b	r5, 2[r7]
     b7:b6  IICSCLS - SSCL Output Select - Generate a start, restart, or stop condition.
     b5:b4  IICSDAS - SSDA Output Select - Generate a start, restart, or stop condition.
     b3     IICSTIF - Issuing of Start, Restart, or Stop Condition Completed Flag
     - There are no requests for generating conditions
     b0     IICSTAREQ - Start Condition Generation   - A start condition is not generated. */
    pregs->SIMR3.BYTE = SCI_IIC_ST_CON_GENERATED;
ffc00c75:	3c 7b 51                      	mov.b	#81, 11[r7]

ffc00c78 <.LVL17>:
} /* End of function sci_iic_generate_start_cond() */
ffc00c78:	ef 41                         	mov.l	r4, r1

ffc00c7a <.LVL18>:
ffc00c7a:	3f 77 01                      	rtsd	#4, r7-r7

ffc00c7d <.LVL19>:
        return SCI_IIC_ERR_BUS_BUSY;
ffc00c7d:	66 54                         	mov.l	#5, r4
} /* End of function sci_iic_generate_start_cond() */
ffc00c7f:	ef 41                         	mov.l	r4, r1

ffc00c81 <.LVL20>:
ffc00c81:	3f 77 01                      	rtsd	#4, r7-r7

ffc00c84 <.LFE19>:
ffc00c84:	00                            	brk
ffc00c85:	00                            	brk
	...

ffc00c88 <_sci_iic_after_gen_start_cond>:
{
ffc00c88:	ef 12                         	mov.l	r1, r2
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00c8a:	fb e2 f4 66 c0 ff             	mov.l	#0xffc066f4, r14
ffc00c90:	b0 9d                         	movu.b	3[r1], r5
ffc00c92:	fe 65 e4                      	mov.l	[r5, r14], r4
ffc00c95:	ec 45                         	mov.l	[r4], r5
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffc00c97:	a8 c3                         	mov.l	8[r4], r3
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00c99:	a8 5d                         	mov.l	4[r5], r5

ffc00c9b <.LVL22>:
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffc00c9b:	61 33                         	cmp	#3, r3
ffc00c9d:	20 50                         	beq.b	ffc00ced <_Reset_Vector+0xffc00cf1>
ffc00c9f:	61 43                         	cmp	#4, r3
ffc00ca1:	17                            	beq.s	ffc00ca8 <_Reset_Vector+0xffc00cac>
ffc00ca2:	61 23                         	cmp	#2, r3
ffc00ca4:	14                            	beq.s	ffc00ca8 <_Reset_Vector+0xffc00cac>
            ret = SCI_IIC_ERR_OTHER;
ffc00ca5:	66 61                         	mov.l	#6, r1

ffc00ca7 <.LVL23>:
} /* End of function sci_iic_after_gen_start_cond() */
ffc00ca7:	02                            	rts

ffc00ca8 <.LVL24>:
            switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status)
ffc00ca8:	a9 43                         	mov.l	16[r4], r3
ffc00caa:	61 13                         	cmp	#1, r3
ffc00cac:	20 6c                         	beq.b	ffc00d18 <_Reset_Vector+0xffc00d1c>
ffc00cae:	61 53                         	cmp	#5, r3
ffc00cb0:	21 f5                         	bne.b	ffc00ca5 <_Reset_Vector+0xffc00ca9>

ffc00cb2 <.LVL25>:
                    buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffc00cb2:	a9 a3                         	mov.l	24[r2], r3
ffc00cb4:	cc 33                         	mov.b	[r3], r3

ffc00cb6 <.LBB138>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00cb6:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffc00cba <.LBE138>:
                    buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffc00cba:	4b 33                         	add	r3, r3

ffc00cbc <.LBB142>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00cbc:	3e 43 04                      	mov.l	#4, 12[r4]

ffc00cbf <.LBE142>:
                    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffc00cbf:	f1 5b 0b                      	bclr	#3, 11[r5].b
                    buf_send_data |= SCI_IIC_R_CODE;
ffc00cc2:	78 03                         	bset	#0, r3

ffc00cc4 <.LBB143>:
                    pregs->SIMR3.BIT.IICSCLS = SCI_IIC_CLOCK_OUTPUT;
ffc00cc4:	8a dc                         	mov.b	11[r5], r4
ffc00cc6:	75 24 3f                      	and	#63, r4
ffc00cc9:	82 dc                         	mov.b	r4, 11[r5]
                    pregs->SIMR3.BIT.IICSDAS = SCI_IIC_CLOCK_OUTPUT;
ffc00ccb:	8a dc                         	mov.b	11[r5], r4
ffc00ccd:	75 24 cf                      	and	#-49, r4
ffc00cd0:	82 dc                         	mov.b	r4, 11[r5]
                    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffc00cd2:	8a dc                         	mov.b	11[r5], r4
ffc00cd4:	7c 34                         	btst	#3, r4
ffc00cd6:	21 fc                         	bne.b	ffc00cd2 <_Reset_Vector+0xffc00cd6>

ffc00cd8 <.LBB144>:
 *              : uint8_t * p_data                   ;   Transmitted data buffer pointer
 * Return Value : None
 **********************************************************************************************************************/
static void sci_iic_set_sending_data (sci_iic_info_t * p_sci_iic_info, uint8_t * p_data)
{
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00cd8:	b0 ad                         	movu.b	3[r2], r5

ffc00cda <.LVL30>:
ffc00cda:	fe 65 e5                      	mov.l	[r5, r14], r5
ffc00cdd:	ec 55                         	mov.l	[r5], r5
ffc00cdf:	a8 5d                         	mov.l	4[r5], r5

ffc00ce1 <.LVL31>:

    /* Sets the transmitting data. */
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffc00ce1:	80 db                         	mov.b	r3, 3[r5]

    /* dummy read */
    if (pregs->TDR)
ffc00ce3:	b0 dd                         	movu.b	3[r5], r5

ffc00ce5 <.LVL32>:
ffc00ce5:	61 05                         	cmp	#0, r5
ffc00ce7:	20 03                         	beq.b	ffc00cea <_Reset_Vector+0xffc00cee>
    {
        R_BSP_NOP();
ffc00ce9:	03                            	nop
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffc00cea:	66 01                         	mov.l	#0, r1
ffc00cec:	02                            	rts

ffc00ced <.LVL33>:
            buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffc00ced:	a9 93                         	mov.l	24[r1], r3
ffc00cef:	cc 33                         	mov.b	[r3], r3

ffc00cf1 <.LBB146>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00cf1:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffc00cf5 <.LBE146>:
            buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffc00cf5:	4b 33                         	add	r3, r3

ffc00cf7 <.LBB150>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00cf7:	3e 43 04                      	mov.l	#4, 12[r4]

ffc00cfa <.LBE150>:
            pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffc00cfa:	f1 5b 0b                      	bclr	#3, 11[r5].b
            buf_send_data |= SCI_IIC_R_CODE;
ffc00cfd:	78 03                         	bset	#0, r3

ffc00cff <.LBB151>:
            pregs->SIMR3.BIT.IICSCLS = SCI_IIC_CLOCK_OUTPUT;
ffc00cff:	8a dc                         	mov.b	11[r5], r4
ffc00d01:	75 24 3f                      	and	#63, r4
ffc00d04:	82 dc                         	mov.b	r4, 11[r5]
            pregs->SIMR3.BIT.IICSDAS = SCI_IIC_CLOCK_OUTPUT;
ffc00d06:	8a dc                         	mov.b	11[r5], r4
ffc00d08:	75 24 cf                      	and	#-49, r4
ffc00d0b:	82 dc                         	mov.b	r4, 11[r5]
            while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffc00d0d:	fc 13 00                      	nop	; max	r0, r0
ffc00d10:	8a dc                         	mov.b	11[r5], r4
ffc00d12:	7c 34                         	btst	#3, r4
ffc00d14:	21 fc                         	bne.b	ffc00d10 <_Reset_Vector+0xffc00d14>
ffc00d16:	2e c2                         	bra.b	ffc00cd8 <_Reset_Vector+0xffc00cdc>

ffc00d18 <.LVL37>:
                    if ((uint8_t *) FIT_NO_PTR == p_sci_iic_info->p_slv_adr) /* Pattern 4 of Master Write  */
ffc00d18:	a9 a3                         	mov.l	24[r2], r3
ffc00d1a:	a8 c9                         	mov.l	12[r4], r1

ffc00d1c <.LVL38>:
ffc00d1c:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc00d22:	20 26                         	beq.b	ffc00d48 <_Reset_Vector+0xffc00d4c>
                    buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffc00d24:	cc 33                         	mov.b	[r3], r3

ffc00d26 <.LBB152>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00d26:	a1 41                         	mov.l	r1, 16[r4]

ffc00d28 <.LBE152>:
                    buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffc00d28:	4b 33                         	add	r3, r3

ffc00d2a <.LBB155>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00d2a:	3e 43 03                      	mov.l	#3, 12[r4]

ffc00d2d <.LBE155>:
                    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffc00d2d:	f1 5b 0b                      	bclr	#3, 11[r5].b
                    pregs->SIMR3.BIT.IICSCLS = SCI_IIC_CLOCK_OUTPUT;
ffc00d30:	8a dc                         	mov.b	11[r5], r4
ffc00d32:	75 24 3f                      	and	#63, r4
ffc00d35:	82 dc                         	mov.b	r4, 11[r5]
                    pregs->SIMR3.BIT.IICSDAS = SCI_IIC_CLOCK_OUTPUT;
ffc00d37:	8a dc                         	mov.b	11[r5], r4
ffc00d39:	75 24 cf                      	and	#-49, r4
ffc00d3c:	82 dc                         	mov.b	r4, 11[r5]
                    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffc00d3e:	ef 00                         	nop	; mov.l	r0, r0
ffc00d40:	8a dc                         	mov.b	11[r5], r4
ffc00d42:	7c 34                         	btst	#3, r4
ffc00d44:	21 fc                         	bne.b	ffc00d40 <_Reset_Vector+0xffc00d44>
ffc00d46:	2e 92                         	bra.b	ffc00cd8 <_Reset_Vector+0xffc00cdc>

ffc00d48 <.LBB156>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00d48:	a1 41                         	mov.l	r1, 16[r4]

ffc00d4a <.LBE156>:
                        return ret;
ffc00d4a:	66 01                         	mov.l	#0, r1

ffc00d4c <.LBB159>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00d4c:	3e 43 07                      	mov.l	#7, 12[r4]

ffc00d4f <.LBB160>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00d4f:	b0 ad                         	movu.b	3[r2], r5

ffc00d51 <.LVL43>:
ffc00d51:	fe 65 e4                      	mov.l	[r5, r14], r4

ffc00d54 <.LVL44>:
ffc00d54:	ec 45                         	mov.l	[r4], r5
ffc00d56:	a8 5d                         	mov.l	4[r5], r5

ffc00d58 <.LVL45>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffc00d58:	3c c4 04                      	mov.b	#4, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffc00d5b:	88 d4                         	mov.b	2[r5], r4
ffc00d5d:	75 34 30                      	or	#48, r4
ffc00d60:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffc00d62:	3c 5b 54                      	mov.b	#84, 11[r5]

ffc00d65 <.LVL46>:
                        return ret;
ffc00d65:	02                            	rts

ffc00d66 <.LFE20>:
ffc00d66:	ef 00                         	nop	; mov.l	r0, r0

ffc00d68 <_sci_iic_after_send_slvadr>:
{
ffc00d68:	60 40                         	sub	#4, r0
ffc00d6a:	ef 15                         	mov.l	r1, r5
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00d6c:	fb 22 f4 66 c0 ff             	mov.l	#0xffc066f4, r2
ffc00d72:	b0 9c                         	movu.b	3[r1], r4
    volatile uint8_t uctmp = 0U;
ffc00d74:	f8 04 00                      	mov.b	#0, [r0]
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00d77:	fe 64 24                      	mov.l	[r4, r2], r4
ffc00d7a:	ec 41                         	mov.l	[r4], r1

ffc00d7c <.LVL49>:
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffc00d7c:	a8 c3                         	mov.l	8[r4], r3
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00d7e:	ed 1e 01                      	mov.l	4[r1], r14

ffc00d81 <.LVL50>:
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffc00d81:	61 33                         	cmp	#3, r3
ffc00d83:	3a 8d 00                      	beq.w	ffc00e10 <_Reset_Vector+0xffc00e14>
ffc00d86:	61 43                         	cmp	#4, r3
ffc00d88:	20 4d                         	beq.b	ffc00dd5 <_Reset_Vector+0xffc00dd9>
ffc00d8a:	61 23                         	cmp	#2, r3
ffc00d8c:	15                            	beq.s	ffc00d91 <_Reset_Vector+0xffc00d95>

ffc00d8d <.LVL51>:
            ret = SCI_IIC_ERR_OTHER;
ffc00d8d:	66 61                         	mov.l	#6, r1
} /* End of function sci_iic_after_send_slvadr() */
ffc00d8f:	67 01                         	rtsd	#4

ffc00d91 <.LVL52>:
            if (((uint8_t *) FIT_NO_PTR == p_sci_iic_info->p_data1st)
ffc00d91:	a9 5b                         	mov.l	20[r5], r3
ffc00d93:	a9 51                         	mov.l	16[r5], r1
ffc00d95:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc00d9b:	3a cc 00                      	beq.w	ffc00e67 <_Reset_Vector+0xffc00e6b>
                    && ((uint8_t *) FIT_NO_PTR != p_sci_iic_info->p_data2nd))
ffc00d9e:	74 01 00 00 00 10             	cmp	#0x10000000, r1
ffc00da4:	20 e9                         	beq.b	ffc00d8d <_Reset_Vector+0xffc00d91>

ffc00da6 <.LBB162>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00da6:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffc00daa <.LBE162>:
                if (0U != p_sci_iic_info->cnt1st)
ffc00daa:	a8 d9                         	mov.l	12[r5], r1

ffc00dac <.LBB165>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00dac:	3e 43 05                      	mov.l	#5, 12[r4]

ffc00daf <.LBE165>:
                if (0U != p_sci_iic_info->cnt1st)
ffc00daf:	61 01                         	cmp	#0, r1
ffc00db1:	20 dc                         	beq.b	ffc00d8d <_Reset_Vector+0xffc00d91>

ffc00db3 <.LBB166>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00db3:	b0 dc                         	movu.b	3[r5], r4
ffc00db5:	fe 64 24                      	mov.l	[r4, r2], r4
ffc00db8:	ec 44                         	mov.l	[r4], r4
ffc00dba:	a8 4c                         	mov.l	4[r4], r4

ffc00dbc <.LVL56>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffc00dbc:	c4 34 03                      	mov.b	[r3], 3[r4]
    if (pregs->TDR)
ffc00dbf:	b0 cc                         	movu.b	3[r4], r4

ffc00dc1 <.LVL57>:
ffc00dc1:	61 04                         	cmp	#0, r4
ffc00dc3:	16                            	beq.s	ffc00dc9 <_Reset_Vector+0xffc00dcd>
        R_BSP_NOP();
ffc00dc4:	03                            	nop
ffc00dc5:	a8 d9                         	mov.l	12[r5], r1
ffc00dc7:	a9 5b                         	mov.l	20[r5], r3

ffc00dc9 <.LVL58>:
                    p_sci_iic_info->cnt1st--;
ffc00dc9:	60 11                         	sub	#1, r1
                    p_sci_iic_info->p_data1st++;
ffc00dcb:	62 13                         	add	#1, r3
                    p_sci_iic_info->cnt1st--;
ffc00dcd:	a0 d9                         	mov.l	r1, 12[r5]
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffc00dcf:	66 01                         	mov.l	#0, r1
                    p_sci_iic_info->p_data1st++;
ffc00dd1:	a1 5b                         	mov.l	r3, 20[r5]
} /* End of function sci_iic_after_send_slvadr() */
ffc00dd3:	67 01                         	rtsd	#4

ffc00dd5 <.LVL59>:
            switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status)
ffc00dd5:	a8 cb                         	mov.l	12[r4], r3
ffc00dd7:	61 33                         	cmp	#3, r3
ffc00dd9:	20 65                         	beq.b	ffc00e3e <_Reset_Vector+0xffc00e42>
ffc00ddb:	61 43                         	cmp	#4, r3
ffc00ddd:	21 b0                         	bne.b	ffc00d8d <_Reset_Vector+0xffc00d91>
                    if (1U >= p_sci_iic_info->cnt2nd)
ffc00ddf:	a8 d4                         	mov.l	8[r5], r4
ffc00de1:	61 14                         	cmp	#1, r4
ffc00de3:	24 05                         	bgtu.b	ffc00de8 <_Reset_Vector+0xffc00dec>
ffc00de5:	38 bd 00                      	bra.w	ffc00ea2 <_Reset_Vector+0xffc00ea6>
                        pregs->SIMR2.BIT.IICACKT = SCI_IIC_ACK_TRANS;
ffc00de8:	f1 ed 0a                      	bclr	#5, 10[r14].b

ffc00deb <.LBB168>:
                    p_sci_iic_info->cnt2nd--;
ffc00deb:	60 14                         	sub	#1, r4
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffc00ded:	66 01                         	mov.l	#0, r1

ffc00def <.LBB171>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00def:	b0 db                         	movu.b	3[r5], r3
ffc00df1:	fe 63 23                      	mov.l	[r3, r2], r3
ffc00df4:	e5 33 03 04                   	mov.l	12[r3], 16[r3]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00df8:	3e 33 06                      	mov.l	#6, 12[r3]

ffc00dfb <.LBB172>:
 * Return Value : Returns received data.
 **********************************************************************************************************************/
static uint8_t sci_iic_get_receiving_data (sci_iic_info_t * p_sci_iic_info)
{
    uint8_t ret;
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00dfb:	b0 db                         	movu.b	3[r5], r3
ffc00dfd:	fe 63 23                      	mov.l	[r3, r2], r3
ffc00e00:	ec 33                         	mov.l	[r3], r3
ffc00e02:	a8 3b                         	mov.l	4[r3], r3

ffc00e04 <.LVL62>:

    ret = pregs->RDR;
ffc00e04:	89 3b                         	mov.b	5[r3], r3

ffc00e06 <.LVL63>:
                    p_sci_iic_info->cnt2nd--;
ffc00e06:	a0 d4                         	mov.l	r4, 8[r5]
                    uctmp = sci_iic_get_receiving_data(p_sci_iic_info);
ffc00e08:	c3 03                         	mov.b	r3, [r0]
                    pregs->TDR = 0xff;
ffc00e0a:	f9 e4 03 ff                   	mov.b	#255, 3[r14]
} /* End of function sci_iic_after_send_slvadr() */
ffc00e0e:	67 01                         	rtsd	#4

ffc00e10 <.LBB174>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00e10:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffc00e14 <.LBE174>:
            if (1U >= p_sci_iic_info->cnt2nd)
ffc00e14:	a8 d3                         	mov.l	8[r5], r3

ffc00e16 <.LBB177>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00e16:	3e 43 06                      	mov.l	#6, 12[r4]

ffc00e19 <.LBE177>:
            if (1U >= p_sci_iic_info->cnt2nd)
ffc00e19:	61 13                         	cmp	#1, r3
ffc00e1b:	25 1e                         	bleu.b	ffc00e39 <_Reset_Vector+0xffc00e3d>
                pregs->SIMR2.BIT.IICACKT = SCI_IIC_ACK_TRANS;
ffc00e1d:	f1 ed 0a                      	bclr	#5, 10[r14].b

ffc00e20 <.LBB178>:
            p_sci_iic_info->cnt2nd--;
ffc00e20:	60 13                         	sub	#1, r3
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffc00e22:	66 01                         	mov.l	#0, r1

ffc00e24 <.LBB181>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00e24:	b0 dc                         	movu.b	3[r5], r4
ffc00e26:	fe 64 24                      	mov.l	[r4, r2], r4
ffc00e29:	ec 44                         	mov.l	[r4], r4
ffc00e2b:	a8 4c                         	mov.l	4[r4], r4

ffc00e2d <.LVL67>:
    ret = pregs->RDR;
ffc00e2d:	89 4c                         	mov.b	5[r4], r4

ffc00e2f <.LBE181>:
            p_sci_iic_info->cnt2nd--;
ffc00e2f:	a0 d3                         	mov.l	r3, 8[r5]
            uctmp = sci_iic_get_receiving_data(p_sci_iic_info);
ffc00e31:	c3 04                         	mov.b	r4, [r0]
            pregs->TDR = 0xff;
ffc00e33:	f9 e4 03 ff                   	mov.b	#255, 3[r14]
} /* End of function sci_iic_after_send_slvadr() */
ffc00e37:	67 01                         	rtsd	#4

ffc00e39 <.LVL69>:
                pregs->SIMR2.BIT.IICACKT = SCI_IIC_NACK_TRANS;
ffc00e39:	f1 e5 0a                      	bset	#5, 10[r14].b
ffc00e3c:	2e e4                         	bra.b	ffc00e20 <_Reset_Vector+0xffc00e24>

ffc00e3e <.LBB182>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00e3e:	a1 43                         	mov.l	r3, 16[r4]

ffc00e40 <.LBE182>:
                    sci_iic_set_sending_data(p_sci_iic_info, p_sci_iic_info->p_data1st);
ffc00e40:	a9 5b                         	mov.l	20[r5], r3

ffc00e42 <.LBB185>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00e42:	3e 43 05                      	mov.l	#5, 12[r4]

ffc00e45 <.LBB186>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00e45:	b0 dc                         	movu.b	3[r5], r4

ffc00e47 <.LBB188>:
ffc00e47:	fe 64 24                      	mov.l	[r4, r2], r4
ffc00e4a:	ec 44                         	mov.l	[r4], r4
ffc00e4c:	a8 4c                         	mov.l	4[r4], r4

ffc00e4e <.LVL73>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffc00e4e:	c4 34 03                      	mov.b	[r3], 3[r4]
    if (pregs->TDR)
ffc00e51:	b0 cc                         	movu.b	3[r4], r4

ffc00e53 <.LVL74>:
ffc00e53:	61 04                         	cmp	#0, r4
ffc00e55:	14                            	beq.s	ffc00e59 <_Reset_Vector+0xffc00e5d>
        R_BSP_NOP();
ffc00e56:	03                            	nop
ffc00e57:	a9 5b                         	mov.l	20[r5], r3

ffc00e59 <.LBE188>:
                    p_sci_iic_info->cnt1st--;
ffc00e59:	a8 dc                         	mov.l	12[r5], r4
                    p_sci_iic_info->p_data1st++;
ffc00e5b:	62 13                         	add	#1, r3
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffc00e5d:	66 01                         	mov.l	#0, r1
                    p_sci_iic_info->p_data1st++;
ffc00e5f:	a1 5b                         	mov.l	r3, 20[r5]
                    p_sci_iic_info->cnt1st--;
ffc00e61:	60 14                         	sub	#1, r4
ffc00e63:	a0 dc                         	mov.l	r4, 12[r5]
} /* End of function sci_iic_after_send_slvadr() */
ffc00e65:	67 01                         	rtsd	#4

ffc00e67 <.LVL76>:
ffc00e67:	ed 4e 03                      	mov.l	12[r4], r14

ffc00e6a <.LVL77>:
                    && ((uint8_t *) FIT_NO_PTR == p_sci_iic_info->p_data2nd))
ffc00e6a:	74 01 00 00 00 10             	cmp	#0x10000000, r1
ffc00e70:	20 38                         	beq.b	ffc00ea8 <_Reset_Vector+0xffc00eac>

ffc00e72 <.LBB189>:
                if (0U != p_sci_iic_info->cnt2nd)
ffc00e72:	a8 d3                         	mov.l	8[r5], r3

ffc00e74 <.LBB192>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00e74:	e7 4e 04                      	mov.l	r14, 16[r4]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00e77:	3e 43 05                      	mov.l	#5, 12[r4]

ffc00e7a <.LBE192>:
                if (0U != p_sci_iic_info->cnt2nd)
ffc00e7a:	61 03                         	cmp	#0, r3
ffc00e7c:	3a 11 ff                      	beq.w	ffc00d8d <_Reset_Vector+0xffc00d91>

ffc00e7f <.LBB193>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00e7f:	b0 dc                         	movu.b	3[r5], r4

ffc00e81 <.LVL81>:
ffc00e81:	fe 64 24                      	mov.l	[r4, r2], r4
ffc00e84:	ec 44                         	mov.l	[r4], r4
ffc00e86:	a8 4c                         	mov.l	4[r4], r4

ffc00e88 <.LVL82>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffc00e88:	c4 14 03                      	mov.b	[r1], 3[r4]

ffc00e8b <.LVL83>:
    if (pregs->TDR)
ffc00e8b:	b0 cc                         	movu.b	3[r4], r4

ffc00e8d <.LVL84>:
ffc00e8d:	61 04                         	cmp	#0, r4
ffc00e8f:	16                            	beq.s	ffc00e95 <_Reset_Vector+0xffc00e99>
        R_BSP_NOP();
ffc00e90:	03                            	nop
ffc00e91:	a8 d3                         	mov.l	8[r5], r3
ffc00e93:	a9 51                         	mov.l	16[r5], r1
                    p_sci_iic_info->cnt2nd--;
ffc00e95:	60 13                         	sub	#1, r3
                    p_sci_iic_info->p_data2nd++;
ffc00e97:	71 14 01                      	add	#1, r1, r4
                    p_sci_iic_info->cnt2nd--;
ffc00e9a:	a0 d3                         	mov.l	r3, 8[r5]
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffc00e9c:	66 01                         	mov.l	#0, r1
                    p_sci_iic_info->p_data2nd++;
ffc00e9e:	a1 54                         	mov.l	r4, 16[r5]
} /* End of function sci_iic_after_send_slvadr() */
ffc00ea0:	67 01                         	rtsd	#4

ffc00ea2 <.LVL85>:
                        pregs->SIMR2.BIT.IICACKT = SCI_IIC_NACK_TRANS;
ffc00ea2:	f1 e5 0a                      	bset	#5, 10[r14].b
ffc00ea5:	38 46 ff                      	bra.w	ffc00deb <_Reset_Vector+0xffc00def>

ffc00ea8 <.LBB195>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00ea8:	e7 4e 04                      	mov.l	r14, 16[r4]

ffc00eab <.LBE195>:
                return ret;
ffc00eab:	66 01                         	mov.l	#0, r1

ffc00ead <.LBB198>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00ead:	3e 43 07                      	mov.l	#7, 12[r4]

ffc00eb0 <.LBB199>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00eb0:	b0 dd                         	movu.b	3[r5], r5

ffc00eb2 <.LVL88>:
ffc00eb2:	fe 65 24                      	mov.l	[r5, r2], r4

ffc00eb5 <.LVL89>:
ffc00eb5:	ec 45                         	mov.l	[r4], r5
ffc00eb7:	a8 5d                         	mov.l	4[r5], r5

ffc00eb9 <.LVL90>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffc00eb9:	3c c4 04                      	mov.b	#4, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffc00ebc:	88 d4                         	mov.b	2[r5], r4
ffc00ebe:	75 34 30                      	or	#48, r4
ffc00ec1:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffc00ec3:	3c 5b 54                      	mov.b	#84, 11[r5]

ffc00ec6 <.LVL91>:
} /* End of function sci_iic_after_send_slvadr() */
ffc00ec6:	67 01                         	rtsd	#4

ffc00ec8 <_sci_iic_write_data_sending>:
{
ffc00ec8:	ef 15                         	mov.l	r1, r5
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffc00eca:	fb 22 f4 66 c0 ff             	mov.l	#0xffc066f4, r2
ffc00ed0:	b0 9c                         	movu.b	3[r1], r4
ffc00ed2:	fe 64 24                      	mov.l	[r4, r2], r4
ffc00ed5:	a8 c3                         	mov.l	8[r4], r3
ffc00ed7:	61 23                         	cmp	#2, r3
ffc00ed9:	20 2d                         	beq.b	ffc00f06 <_Reset_Vector+0xffc00f0a>
ffc00edb:	61 43                         	cmp	#4, r3
ffc00edd:	21 26                         	bne.b	ffc00f03 <_Reset_Vector+0xffc00f07>
            if (0U != p_sci_iic_info->cnt1st)
ffc00edf:	a8 99                         	mov.l	12[r1], r1

ffc00ee1 <.LVL93>:
ffc00ee1:	61 01                         	cmp	#0, r1
ffc00ee3:	21 6e                         	bne.b	ffc00f51 <_Reset_Vector+0xffc00f55>

ffc00ee5 <.LBB201>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00ee5:	e5 44 03 04                   	mov.l	12[r4], 16[r4]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00ee9:	3e 43 02                      	mov.l	#2, 12[r4]

ffc00eec <.LBB203>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00eec:	b0 dd                         	movu.b	3[r5], r5

ffc00eee <.LVL96>:
ffc00eee:	fe 65 24                      	mov.l	[r5, r2], r4
ffc00ef1:	ec 45                         	mov.l	[r4], r5
ffc00ef3:	a8 5d                         	mov.l	4[r5], r5

ffc00ef5 <.LVL97>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_RSTAREQ; /* mode set restart mode. */
ffc00ef5:	3c c4 02                      	mov.b	#2, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffc00ef8:	88 d4                         	mov.b	2[r5], r4
ffc00efa:	75 34 30                      	or	#48, r4
ffc00efd:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_RST_CON_GENERATED;
ffc00eff:	3c 5b 52                      	mov.b	#82, 11[r5]
} /* End of function sci_iic_write_data_sending() */
ffc00f02:	02                            	rts

ffc00f03 <.LVL98>:
            ret = SCI_IIC_ERR_OTHER;
ffc00f03:	66 61                         	mov.l	#6, r1

ffc00f05 <.LVL99>:
ffc00f05:	02                            	rts

ffc00f06 <.LVL100>:
            if ((uint8_t *) FIT_NO_PTR != p_sci_iic_info->p_data1st)
ffc00f06:	a9 1b                         	mov.l	20[r1], r3
ffc00f08:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc00f0e:	17                            	beq.s	ffc00f15 <_Reset_Vector+0xffc00f19>
                if (0U != p_sci_iic_info->cnt1st) /* Pattern 1 of Master Write  */
ffc00f0f:	a8 99                         	mov.l	12[r1], r1

ffc00f11 <.LVL101>:
ffc00f11:	61 01                         	cmp	#0, r1
ffc00f13:	21 40                         	bne.b	ffc00f53 <_Reset_Vector+0xffc00f57>
            if ((uint8_t *) FIT_NO_PTR != p_sci_iic_info->p_data2nd)
ffc00f15:	a9 53                         	mov.l	16[r5], r3
ffc00f17:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc00f1d:	17                            	beq.s	ffc00f24 <_Reset_Vector+0xffc00f28>
                if (0U != p_sci_iic_info->cnt2nd) /* Pattern 2 of Master Write */
ffc00f1e:	a8 d1                         	mov.l	8[r5], r1
ffc00f20:	61 01                         	cmp	#0, r1
ffc00f22:	21 4d                         	bne.b	ffc00f6f <_Reset_Vector+0xffc00f73>

ffc00f24 <.LBB205>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00f24:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffc00f28 <.LBE205>:
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffc00f28:	66 01                         	mov.l	#0, r1

ffc00f2a <.LBB208>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00f2a:	3e 43 07                      	mov.l	#7, 12[r4]

ffc00f2d <.LBB209>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00f2d:	b0 dc                         	movu.b	3[r5], r4
ffc00f2f:	fe 64 24                      	mov.l	[r4, r2], r4
ffc00f32:	ec 44                         	mov.l	[r4], r4
ffc00f34:	a8 4c                         	mov.l	4[r4], r4

ffc00f36 <.LVL104>:
    pregs->SCR.BYTE = New_icier;
ffc00f36:	f9 44 02 b4                   	mov.b	#180, 2[r4]

ffc00f3a <.LBB211>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00f3a:	b0 dd                         	movu.b	3[r5], r5

ffc00f3c <.LVL106>:
ffc00f3c:	fe 65 24                      	mov.l	[r5, r2], r4
ffc00f3f:	ec 45                         	mov.l	[r4], r5
ffc00f41:	a8 5d                         	mov.l	4[r5], r5

ffc00f43 <.LVL107>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffc00f43:	3c c4 04                      	mov.b	#4, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffc00f46:	88 d4                         	mov.b	2[r5], r4
ffc00f48:	75 34 30                      	or	#48, r4
ffc00f4b:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffc00f4d:	3c 5b 54                      	mov.b	#84, 11[r5]
ffc00f50:	02                            	rts

ffc00f51 <.LVL108>:
                sci_iic_set_sending_data(p_sci_iic_info, p_sci_iic_info->p_data1st);
ffc00f51:	a9 5b                         	mov.l	20[r5], r3

ffc00f53 <.LBB213>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00f53:	ec 44                         	mov.l	[r4], r4

ffc00f55 <.LBB215>:
ffc00f55:	a8 4c                         	mov.l	4[r4], r4

ffc00f57 <.LVL110>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffc00f57:	c4 34 03                      	mov.b	[r3], 3[r4]
    if (pregs->TDR)
ffc00f5a:	b0 cc                         	movu.b	3[r4], r4

ffc00f5c <.LVL111>:
ffc00f5c:	61 04                         	cmp	#0, r4
ffc00f5e:	16                            	beq.s	ffc00f64 <_Reset_Vector+0xffc00f68>
        R_BSP_NOP();
ffc00f5f:	03                            	nop
ffc00f60:	a8 d9                         	mov.l	12[r5], r1
ffc00f62:	a9 5b                         	mov.l	20[r5], r3

ffc00f64 <.LBE215>:
                p_sci_iic_info->cnt1st--;
ffc00f64:	60 11                         	sub	#1, r1
                p_sci_iic_info->p_data1st++;
ffc00f66:	62 13                         	add	#1, r3
                p_sci_iic_info->cnt1st--;
ffc00f68:	a0 d9                         	mov.l	r1, 12[r5]
                return ret;
ffc00f6a:	66 01                         	mov.l	#0, r1
                p_sci_iic_info->p_data1st++;
ffc00f6c:	a1 5b                         	mov.l	r3, 20[r5]
                return ret;
ffc00f6e:	02                            	rts

ffc00f6f <.LBB216>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00f6f:	ec 44                         	mov.l	[r4], r4

ffc00f71 <.LBB218>:
ffc00f71:	a8 4c                         	mov.l	4[r4], r4

ffc00f73 <.LVL115>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffc00f73:	c4 34 03                      	mov.b	[r3], 3[r4]
    if (pregs->TDR)
ffc00f76:	b0 cc                         	movu.b	3[r4], r4

ffc00f78 <.LVL116>:
ffc00f78:	61 04                         	cmp	#0, r4
ffc00f7a:	16                            	beq.s	ffc00f80 <_Reset_Vector+0xffc00f84>
        R_BSP_NOP();
ffc00f7b:	03                            	nop
ffc00f7c:	a8 d1                         	mov.l	8[r5], r1
ffc00f7e:	a9 53                         	mov.l	16[r5], r3

ffc00f80 <.LBE218>:
                    p_sci_iic_info->cnt2nd--;
ffc00f80:	60 11                         	sub	#1, r1
                    p_sci_iic_info->p_data2nd++;
ffc00f82:	62 13                         	add	#1, r3
                    p_sci_iic_info->cnt2nd--;
ffc00f84:	a0 d1                         	mov.l	r1, 8[r5]
                    return ret;
ffc00f86:	66 01                         	mov.l	#0, r1
                    p_sci_iic_info->p_data2nd++;
ffc00f88:	a1 53                         	mov.l	r3, 16[r5]
                    return ret;
ffc00f8a:	02                            	rts

ffc00f8b <.LFE22>:
ffc00f8b:	77 10 01 00 00                	nop	; mul	#1, r0

ffc00f90 <_sci_iic_release>:
{
ffc00f90:	7e a7                         	push.l	r7
ffc00f92:	ef 15                         	mov.l	r1, r5

ffc00f94 <.LBB219>:
} /* End of function sci_iic_release() */
ffc00f94:	66 01                         	mov.l	#0, r1

ffc00f96 <.LBB222>:
    g_sci_iic_ChStatus[p_sci_iic_info->ch_no] = status;
ffc00f96:	b0 dc                         	movu.b	3[r5], r4
ffc00f98:	fb 32 60 06 00 00             	mov.l	#0x660, r3
ffc00f9e:	66 27                         	mov.l	#2, r7
ffc00fa0:	fe 04 37                      	mov.b	r7, [r4, r3]
    p_sci_iic_info->dev_sts = status;
ffc00fa3:	80 d7                         	mov.b	r7, 2[r5]

ffc00fa5 <.LBE222>:
} /* End of function sci_iic_release() */
ffc00fa5:	3f 77 01                      	rtsd	#4, r7-r7

ffc00fa8 <_sci_iic_nack>:
{
ffc00fa8:	7e a7                         	push.l	r7
ffc00faa:	60 40                         	sub	#4, r0
ffc00fac:	ef 15                         	mov.l	r1, r5

ffc00fae <.LBB223>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00fae:	fb 42 f4 66 c0 ff             	mov.l	#0xffc066f4, r4
ffc00fb4:	b0 9b                         	movu.b	3[r1], r3

ffc00fb6 <.LBE223>:
    volatile uint8_t uctmp = 0U;
ffc00fb6:	f8 04 00                      	mov.b	#0, [r0]

ffc00fb9 <.LBB226>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc00fb9:	fe 63 43                      	mov.l	[r3, r4], r3
ffc00fbc:	e5 33 03 04                   	mov.l	12[r3], 16[r3]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc00fc0:	3e 33 07                      	mov.l	#7, 12[r3]

ffc00fc3 <.LBB227>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00fc3:	b0 9b                         	movu.b	3[r1], r3
ffc00fc5:	fe 63 43                      	mov.l	[r3, r4], r3
ffc00fc8:	ec 33                         	mov.l	[r3], r3
ffc00fca:	a8 3b                         	mov.l	4[r3], r3

ffc00fcc <.LVL127>:
    pregs->SCR.BYTE = New_icier;
ffc00fcc:	f9 34 02 b4                   	mov.b	#180, 2[r3]

ffc00fd0 <.LBB229>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00fd0:	b0 9b                         	movu.b	3[r1], r3
ffc00fd2:	fe 63 41                      	mov.l	[r3, r4], r1

ffc00fd5 <.LVL129>:
ffc00fd5:	ec 12                         	mov.l	[r1], r2

ffc00fd7 <.LBE229>:
            || (SCI_IIC_MODE_SEND_RECEIVE == g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode))
ffc00fd7:	a8 93                         	mov.l	8[r1], r3

ffc00fd9 <.LBB233>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00fd9:	a8 2a                         	mov.l	4[r2], r2

ffc00fdb <.LVL130>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffc00fdb:	3c 94 04                      	mov.b	#4, 20[r1]

ffc00fde <.LBE233>:
            || (SCI_IIC_MODE_SEND_RECEIVE == g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode))
ffc00fde:	60 33                         	sub	#3, r3

ffc00fe0 <.LBB234>:
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffc00fe0:	88 a1                         	mov.b	2[r2], r1
ffc00fe2:	75 31 30                      	or	#48, r1
ffc00fe5:	80 a1                         	mov.b	r1, 2[r2]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffc00fe7:	3c 2b 54                      	mov.b	#84, 11[r2]

ffc00fea <.LBE234>:
    if ((SCI_IIC_MODE_RECEIVE == g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffc00fea:	61 13                         	cmp	#1, r3

ffc00fec <.LBB235>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00fec:	b0 db                         	movu.b	3[r5], r3

ffc00fee <.LBE235>:
    if ((SCI_IIC_MODE_RECEIVE == g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffc00fee:	24 0d                         	bgtu.b	ffc00ffb <_Reset_Vector+0xffc00fff>

ffc00ff0 <.LBB238>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc00ff0:	fe 63 44                      	mov.l	[r3, r4], r4
ffc00ff3:	ec 44                         	mov.l	[r4], r4
ffc00ff5:	a8 4c                         	mov.l	4[r4], r4

ffc00ff7 <.LVL133>:
    ret = pregs->RDR;
ffc00ff7:	89 4c                         	mov.b	5[r4], r4

ffc00ff9 <.LBE238>:
        uctmp = sci_iic_get_receiving_data(p_sci_iic_info);
ffc00ff9:	c3 04                         	mov.b	r4, [r0]

ffc00ffb <.LBB239>:
} /* End of function sci_iic_nack() */
ffc00ffb:	66 01                         	mov.l	#0, r1

ffc00ffd <.LBB242>:
    g_sci_iic_ChStatus[p_sci_iic_info->ch_no] = status;
ffc00ffd:	fb 42 60 06 00 00             	mov.l	#0x660, r4
ffc01003:	66 37                         	mov.l	#3, r7
ffc01005:	fe 03 47                      	mov.b	r7, [r3, r4]
    p_sci_iic_info->dev_sts = status;
ffc01008:	80 d7                         	mov.b	r7, 2[r5]

ffc0100a <.LBE242>:
} /* End of function sci_iic_nack() */
ffc0100a:	3f 77 02                      	rtsd	#8, r7-r7

ffc0100d <.LFE25>:
ffc0100d:	fc 13 00                      	nop	; max	r0, r0

ffc01010 <_sci_iic_init_driver>:
{
ffc01010:	7e a7                         	push.l	r7
ffc01012:	ef 17                         	mov.l	r1, r7
    r_sci_iic_init_io_register(p_sci_iic_info);
ffc01014:	05 dc f8 ff                   	bsr.a	ffc008f0 <_Reset_Vector+0xffc008f4>

ffc01018 <.LBB245>:
} /* End of function sci_iic_init_driver() */
ffc01018:	66 01                         	mov.l	#0, r1

ffc0101a <.LBB248>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc0101a:	b0 fc                         	movu.b	3[r7], r4
ffc0101c:	fb 52 f4 66 c0 ff             	mov.l	#0xffc066f4, r5
ffc01022:	fe 64 55                      	mov.l	[r4, r5], r5
ffc01025:	e5 55 03 04                   	mov.l	12[r5], 16[r5]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc01029:	3e 53 01                      	mov.l	#1, 12[r5]

ffc0102c <.LBE248>:
} /* End of function sci_iic_init_driver() */
ffc0102c:	3f 77 01                      	rtsd	#4, r7-r7

ffc0102f <.LFE18>:
	...

ffc01030 <_sci_iic_read_data_receiving>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc01030:	fb 52 f4 66 c0 ff             	mov.l	#0xffc066f4, r5
    if (1U >= p_sci_iic_info->cnt2nd)
ffc01036:	a8 93                         	mov.l	8[r1], r3
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc01038:	b0 9c                         	movu.b	3[r1], r4
ffc0103a:	a9 12                         	mov.l	16[r1], r2
ffc0103c:	fe 64 54                      	mov.l	[r4, r5], r4
ffc0103f:	ec 44                         	mov.l	[r4], r4
ffc01041:	a8 4c                         	mov.l	4[r4], r4

ffc01043 <.LVL141>:
    if (1U >= p_sci_iic_info->cnt2nd)
ffc01043:	61 13                         	cmp	#1, r3
ffc01045:	25 1b                         	bleu.b	ffc01060 <_Reset_Vector+0xffc01064>
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc01047:	ef 45                         	mov.l	r4, r5

ffc01049 <.LBB261>:
    ret = pregs->RDR;
ffc01049:	89 5d                         	mov.b	5[r5], r5

ffc0104b <.LVL143>:
        (*p_sci_iic_info->p_data2nd) = sci_iic_get_receiving_data(p_sci_iic_info);
ffc0104b:	c3 25                         	mov.b	r5, [r2]
        p_sci_iic_info->cnt2nd--; /* Decreases the receiving data counter.  */
ffc0104d:	a8 93                         	mov.l	8[r1], r3
        p_sci_iic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffc0104f:	a9 15                         	mov.l	16[r1], r5
        p_sci_iic_info->cnt2nd--; /* Decreases the receiving data counter.  */
ffc01051:	60 13                         	sub	#1, r3
        p_sci_iic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffc01053:	62 15                         	add	#1, r5
        p_sci_iic_info->cnt2nd--; /* Decreases the receiving data counter.  */
ffc01055:	a0 93                         	mov.l	r3, 8[r1]
        p_sci_iic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffc01057:	a1 15                         	mov.l	r5, 16[r1]
        pregs->TDR = 0xff;
ffc01059:	f9 44 03 ff                   	mov.b	#255, 3[r4]
} /* End of function sci_iic_read_data_receiving() */
ffc0105d:	66 01                         	mov.l	#0, r1

ffc0105f <.LVL144>:
ffc0105f:	02                            	rts

ffc01060 <.LVL145>:
        pregs->SIMR2.BIT.IICACKT = SCI_IIC_NACK_TRANS;
ffc01060:	f1 45 0a                      	bset	#5, 10[r4].b
    if (0U >= p_sci_iic_info->cnt2nd)
ffc01063:	61 03                         	cmp	#0, r3
ffc01065:	21 34                         	bne.b	ffc01099 <_Reset_Vector+0xffc0109d>

ffc01067 <.LBB263>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc01067:	b0 9c                         	movu.b	3[r1], r4

ffc01069 <.LVL147>:
ffc01069:	fe 64 54                      	mov.l	[r4, r5], r4
ffc0106c:	ec 44                         	mov.l	[r4], r4
ffc0106e:	a8 4c                         	mov.l	4[r4], r4

ffc01070 <.LVL148>:
    ret = pregs->RDR;
ffc01070:	89 4c                         	mov.b	5[r4], r4

ffc01072 <.LVL149>:
        (*p_sci_iic_info->p_data2nd) = sci_iic_get_receiving_data(p_sci_iic_info);
ffc01072:	c3 24                         	mov.b	r4, [r2]

ffc01074 <.LBB267>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc01074:	b0 9c                         	movu.b	3[r1], r4
ffc01076:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01079:	e5 44 03 04                   	mov.l	12[r4], 16[r4]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc0107d:	3e 43 07                      	mov.l	#7, 12[r4]

ffc01080 <.LBB269>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc01080:	b0 9c                         	movu.b	3[r1], r4
ffc01082:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01085:	ec 45                         	mov.l	[r4], r5
ffc01087:	a8 5d                         	mov.l	4[r5], r5

ffc01089 <.LVL152>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffc01089:	3c c4 04                      	mov.b	#4, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffc0108c:	88 d4                         	mov.b	2[r5], r4
ffc0108e:	75 34 30                      	or	#48, r4
ffc01091:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffc01093:	3c 5b 54                      	mov.b	#84, 11[r5]
} /* End of function sci_iic_read_data_receiving() */
ffc01096:	66 01                         	mov.l	#0, r1

ffc01098 <.LVL153>:
ffc01098:	02                            	rts

ffc01099 <.LVL154>:
ffc01099:	b0 9b                         	movu.b	3[r1], r3
ffc0109b:	fe 63 55                      	mov.l	[r3, r5], r5
ffc0109e:	ec 55                         	mov.l	[r5], r5
ffc010a0:	a8 5d                         	mov.l	4[r5], r5
ffc010a2:	2e a7                         	bra.b	ffc01049 <_Reset_Vector+0xffc0104d>

ffc010a4 <.LFE23>:
ffc010a4:	76 10 01 00                   	nop	; mul	#1, r0

ffc010a8 <_sci_iic_disable>:
{
ffc010a8:	6e 6b                         	pushm	r6-r11
ffc010aa:	ef 16                         	mov.l	r1, r6

ffc010ac <.LBB277>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc010ac:	fb b2 f4 66 c0 ff             	mov.l	#0xffc066f4, r11

ffc010b2 <.LBB280>:
#if SCI_IIC_CFG_PORT_SETTING_PROCESSING
    /* Disables SCI_IIC multi-function pin controller after setting SCL and SDA to Hi-z by Reset. */
    /* Includes I/O register read operation at the end of the following function. */
    sscl_port_gr = prom->sscl_port_gr;
    sscl_port_pin = prom->sscl_port_pin;
    r_sci_iic_mpc_setting(sscl_port_gr, sscl_port_pin, SCI_IIC_MPC_SSCL_INIT);
ffc010b2:	66 03                         	mov.l	#0, r3

ffc010b4 <.LBB283>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc010b4:	b0 9f                         	movu.b	3[r1], r7
ffc010b6:	fe 67 b7                      	mov.l	[r7, r11], r7
ffc010b9:	ec 77                         	mov.l	[r7], r7
ffc010bb:	a8 7f                         	mov.l	4[r7], r7

ffc010bd <.LVL157>:
    pregs->SCR.BYTE = New_icier;
ffc010bd:	3c 72 00                      	mov.b	#0, 2[r7]

ffc010c0 <.LBB284>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc010c0:	b0 9f                         	movu.b	3[r1], r7
ffc010c2:	fe 67 b7                      	mov.l	[r7, r11], r7
ffc010c5:	ec 7a                         	mov.l	[r7], r10
    sscl_port_gr = prom->sscl_port_gr;
ffc010c7:	cd a1 39                      	mov.b	57[r10], r1

ffc010ca <.LVL159>:
    sscl_port_pin = prom->sscl_port_pin;
ffc010ca:	cd a2 3a                      	mov.b	58[r10], r2
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc010cd:	ed a7 01                      	mov.l	4[r10], r7

ffc010d0 <.LVL160>:
    r_sci_iic_mpc_setting(sscl_port_gr, sscl_port_pin, SCI_IIC_MPC_SSCL_INIT);
ffc010d0:	05 f0 fa ff                   	bsr.a	ffc00bc0 <_Reset_Vector+0xffc00bc4>

ffc010d4 <.LVL161>:
    ssda_port_gr = prom->ssda_port_gr;
ffc010d4:	cd a1 3c                      	mov.b	60[r10], r1

ffc010d7 <.LVL162>:
    ssda_port_pin = prom->ssda_port_pin;
ffc010d7:	cd a2 3d                      	mov.b	61[r10], r2

ffc010da <.LVL163>:
    r_sci_iic_mpc_setting(ssda_port_gr, ssda_port_pin, SCI_IIC_MPC_SSDA_INIT);
ffc010da:	66 03                         	mov.l	#0, r3
ffc010dc:	05 e4 fa ff                   	bsr.a	ffc00bc0 <_Reset_Vector+0xffc00bc4>

ffc010e0 <.LVL164>:
#endif

    /* Resets SCI_IIC registers. */
    pregs->SCMR.BIT.SMIF = 0;
ffc010e0:	f1 78 06                      	bclr	#0, 6[r7].b
    pregs->SIMR1.BIT.IICM = 0;
ffc010e3:	f1 78 09                      	bclr	#0, 9[r7].b

    /* dummy read */
    if (pregs->SCMR.BYTE)
ffc010e6:	b1 f7                         	movu.b	6[r7], r7

ffc010e8 <.LVL165>:
ffc010e8:	61 07                         	cmp	#0, r7
ffc010ea:	20 03                         	beq.b	ffc010ed <_Reset_Vector+0xffc010f1>
    {
        R_BSP_NOP();
ffc010ec:	03                            	nop

ffc010ed <.LBE284>:
    r_sci_iic_int_disable(p_sci_iic_info);
ffc010ed:	ef 61                         	mov.l	r6, r1
ffc010ef:	05 29 fa ff                   	bsr.a	ffc00b18 <_Reset_Vector+0xffc00b1c>

ffc010f3 <.LBB285>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc010f3:	b0 ef                         	movu.b	3[r6], r7
ffc010f5:	fe 67 b7                      	mov.l	[r7, r11], r7
ffc010f8:	e5 77 03 04                   	mov.l	12[r7], 16[r7]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffc010fc:	3e 73 01                      	mov.l	#1, 12[r7]

ffc010ff <.LVL167>:
} /* End of function sci_iic_disable() */
ffc010ff:	3f 6b 06                      	rtsd	#24, r6-r11

ffc01102 <.LFE31>:
ffc01102:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffc01108 <_r_sci_iic_advance>:
{
ffc01108:	6e 6c                         	pushm	r6-r12
ffc0110a:	60 40                         	sub	#4, r0
    if (NULL == p_sci_iic_info)
ffc0110c:	61 01                         	cmp	#0, r1
ffc0110e:	20 7e                         	beq.b	ffc0118c <_Reset_Vector+0xffc01190>

ffc01110 <.LBB487>:
    switch (g_sci_iic_ChStatus[p_sci_iic_info->ch_no])
ffc01110:	fb 62 60 06 00 00             	mov.l	#0x660, r6

ffc01116 <.LBE489>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc01116:	b0 9f                         	movu.b	3[r1], r7

ffc01118 <.LBB495>:
    switch (g_sci_iic_ChStatus[p_sci_iic_info->ch_no])
ffc01118:	fe c7 65                      	movu.b	[r7, r6], r5
ffc0111b:	61 05                         	cmp	#0, r5
ffc0111d:	20 76                         	beq.b	ffc01193 <_Reset_Vector+0xffc01197>
ffc0111f:	61 45                         	cmp	#4, r5
ffc01121:	10                            	beq.s	ffc01129 <_Reset_Vector+0xffc0112d>

ffc01122 <.LVL338>:
            ret = SCI_IIC_ERR_OTHER;
ffc01122:	66 6a                         	mov.l	#6, r10

ffc01124 <.LBE487>:
} /* End of function r_sci_iic_advance() */
ffc01124:	ef a1                         	mov.l	r10, r1
ffc01126:	3f 6c 08                      	rtsd	#32, r6-r12

ffc01129 <.LBB496>:
            else if (SCI_IIC_COMMUNICATION == p_sci_iic_info->dev_sts)
ffc01129:	59 1a 02                      	movu.b	2[r1], r10
ffc0112c:	61 4a                         	cmp	#4, r10
ffc0112e:	21 f4                         	bne.b	ffc01122 <_Reset_Vector+0xffc01126>

ffc01130 <.LBE496>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc01130:	fb b2 f4 66 c0 ff             	mov.l	#0xffc066f4, r11
ffc01136:	fe 67 ba                      	mov.l	[r7, r11], r10

ffc01139 <.LBB497>:
    if (SCI_IIC_EV_INIT != g_sci_iic_handles[p_sci_iic_info->ch_no]->api_event)
ffc01139:	ed a5 01                      	mov.l	4[r10], r5
ffc0113c:	61 05                         	cmp	#0, r5
ffc0113e:	20 e4                         	beq.b	ffc01122 <_Reset_Vector+0xffc01126>

ffc01140 <.LBB498>:
    n_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffc01140:	ed a7 03                      	mov.l	12[r10], r7

ffc01143 <.LVL343>:
    if ((SCI_IIC_STS_MAX > n_status) && (SCI_IIC_EV_MAX > event))
ffc01143:	61 77                         	cmp	#7, r7
ffc01145:	24 dd                         	bgtu.b	ffc01122 <_Reset_Vector+0xffc01126>
ffc01147:	61 65                         	cmp	#6, r5
ffc01149:	24 d9                         	bgtu.b	ffc01122 <_Reset_Vector+0xffc01126>
        if (NULL != gc_sci_iic_mtx_tbl[n_status][event].proc)
ffc0114b:	63 77                         	mul	#7, r7

ffc0114d <.LVL344>:
ffc0114d:	4b 57                         	add	r5, r7
ffc0114f:	6c 37                         	shll	#3, r7
ffc01151:	70 77 70 67 c0 ff             	add	#0xffc06770, r7, r7
ffc01157:	a8 7d                         	mov.l	4[r7], r5

ffc01159 <.LVL345>:
ffc01159:	61 05                         	cmp	#0, r5
ffc0115b:	20 c7                         	beq.b	ffc01122 <_Reset_Vector+0xffc01126>
ffc0115d:	ef 17                         	mov.l	r1, r7

ffc0115f <.LBE498>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc0115f:	ec a4                         	mov.l	[r10], r4
ffc01161:	ed 4c 01                      	mov.l	4[r4], r12

ffc01164 <.LBB501>:
            g_sci_iic_handles[p_sci_iic_info->ch_no]->api_event = SCI_IIC_EV_INIT;
ffc01164:	f9 a6 01 00                   	mov.l	#0, 4[r10]

ffc01168 <.LVL347>:
            ret = (*pFunc)(p_sci_iic_info);
ffc01168:	7f 15                         	jsr	r5

ffc0116a <.LBE501>:
        if (SCI_IIC_SUCCESS == ret)
ffc0116a:	71 1a 00                      	add	#0, r1, r10
ffc0116d:	21 b5                         	bne.b	ffc01122 <_Reset_Vector+0xffc01126>
            switch (g_sci_iic_ChStatus[p_sci_iic_info->ch_no])
ffc0116f:	b0 fc                         	movu.b	3[r7], r4
ffc01171:	fe c4 65                      	movu.b	[r4, r6], r5
ffc01174:	61 35                         	cmp	#3, r5
ffc01176:	20 24                         	beq.b	ffc0119a <_Reset_Vector+0xffc0119e>
ffc01178:	61 45                         	cmp	#4, r5
ffc0117a:	20 aa                         	beq.b	ffc01124 <_Reset_Vector+0xffc01128>
ffc0117c:	61 25                         	cmp	#2, r5
ffc0117e:	3a 8b 00                      	beq.w	ffc01209 <_Reset_Vector+0xffc0120d>
                    if (NULL != g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc)
ffc01181:	fe 64 b7                      	mov.l	[r4, r11], r7

ffc01184 <.LVL349>:
ffc01184:	a9 f7                         	mov.l	24[r7], r7
ffc01186:	a8 7f                         	mov.l	4[r7], r7
ffc01188:	61 07                         	cmp	#0, r7
ffc0118a:	21 7a                         	bne.b	ffc01204 <_Reset_Vector+0xffc01208>

ffc0118c <.LBE524>:
        ret = SCI_IIC_ERR_INVALID_ARG;
ffc0118c:	66 3a                         	mov.l	#3, r10
} /* End of function r_sci_iic_advance() */
ffc0118e:	ef a1                         	mov.l	r10, r1
ffc01190:	3f 6c 08                      	rtsd	#32, r6-r12

ffc01193 <.LBB502>:
            ret = SCI_IIC_ERR_NO_INIT;
ffc01193:	66 4a                         	mov.l	#4, r10

ffc01195 <.LBE502>:
} /* End of function r_sci_iic_advance() */
ffc01195:	ef a1                         	mov.l	r10, r1

ffc01197 <.LVL352>:
ffc01197:	3f 6c 08                      	rtsd	#32, r6-r12

ffc0119a <.LBB503>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc0119a:	fe 64 b5                      	mov.l	[r4, r11], r5

ffc0119d <.LBE505>:
    cnt = SCI_IIC_STOP_COND_WAIT;
ffc0119d:	f8 09 e8 03                   	mov.w	#0x3e8, [r0]

ffc011a1 <.LBB511>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffc011a1:	ec 54                         	mov.l	[r5], r4
ffc011a3:	b5 55                         	movu.b	20[r5], r5
ffc011a5:	a8 4c                         	mov.l	4[r4], r4
ffc011a7:	61 45                         	cmp	#4, r5
ffc011a9:	3a a7 00                      	beq.w	ffc01250 <_Reset_Vector+0xffc01254>
ffc011ac:	76 10 01 00                   	nop	; mul	#1, r0

ffc011b0 <.LBB512>:
        cnt--;
ffc011b0:	dc 05                         	mov.w	[r0], r5
ffc011b2:	60 15                         	sub	#1, r5
ffc011b4:	d3 05                         	mov.w	r5, [r0]
    } while (0U != cnt);/* WAIT_LOOP */
ffc011b6:	5c 05                         	movu.w	[r0], r5
ffc011b8:	61 05                         	cmp	#0, r5
ffc011ba:	21 f6                         	bne.b	ffc011b0 <_Reset_Vector+0xffc011b4>
    if (0U == cnt)
ffc011bc:	5c 09                         	movu.w	[r0], r9
ffc011be:	61 09                         	cmp	#0, r9
ffc011c0:	fc db 91                      	scne.l	r9

ffc011c3 <.LBE503>:
                    sci_iic_disable(p_sci_iic_info);
ffc011c3:	ef 71                         	mov.l	r7, r1
ffc011c5:	05 e3 fe ff                   	bsr.a	ffc010a8 <_Reset_Vector+0xffc010ac>

ffc011c9 <.LVL356>:
                    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffc011c9:	f1 cb 0b                      	bclr	#3, 11[r12].b
                    pregs->SIMR3.BIT.IICSCLS = SCI_IIC_HI_Z_OUTPUT;
ffc011cc:	cd c5 0b                      	mov.b	11[r12], r5
ffc011cf:	75 35 c0                      	or	#-64, r5
ffc011d2:	c7 c5 0b                      	mov.b	r5, 11[r12]
                    pregs->SIMR3.BIT.IICSDAS = SCI_IIC_HI_Z_OUTPUT;
ffc011d5:	cd c5 0b                      	mov.b	11[r12], r5
ffc011d8:	75 35 30                      	or	#48, r5
ffc011db:	c7 c5 0b                      	mov.b	r5, 11[r12]
                    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffc011de:	ef 00                         	nop	; mov.l	r0, r0
ffc011e0:	cd c5 0b                      	mov.b	11[r12], r5
ffc011e3:	7c 35                         	btst	#3, r5
ffc011e5:	21 fb                         	bne.b	ffc011e0 <_Reset_Vector+0xffc011e4>
                    if (SCI_IIC_TRUE == boolret)
ffc011e7:	5b 99                         	movu.b	r9, r9
ffc011e9:	b0 fd                         	movu.b	3[r7], r5
ffc011eb:	61 09                         	cmp	#0, r9
ffc011ed:	21 0c                         	bne.b	ffc011f9 <_Reset_Vector+0xffc011fd>

ffc011ef <.LBB516>:
    g_sci_iic_ChStatus[p_sci_iic_info->ch_no] = status;
ffc011ef:	66 5a                         	mov.l	#5, r10
ffc011f1:	fe 05 6a                      	mov.b	r10, [r5, r6]

ffc011f4 <.LBE516>:
                        ret = SCI_IIC_ERR_BUS_BUSY;
ffc011f4:	66 5a                         	mov.l	#5, r10

ffc011f6 <.LBB519>:
    p_sci_iic_info->dev_sts = status;
ffc011f6:	3c 72 05                      	mov.b	#5, 2[r7]

ffc011f9 <.LBE519>:
                    if (NULL != g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc)
ffc011f9:	fe 65 b7                      	mov.l	[r5, r11], r7

ffc011fc <.LVL359>:
ffc011fc:	a9 f7                         	mov.l	24[r7], r7
ffc011fe:	a8 7f                         	mov.l	4[r7], r7
ffc01200:	61 07                         	cmp	#0, r7
ffc01202:	20 8a                         	beq.b	ffc0118c <_Reset_Vector+0xffc01190>

ffc01204 <.LVL360>:
                        g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc();
ffc01204:	7f 17                         	jsr	r7
                break;
ffc01206:	38 1e ff                      	bra.w	ffc01124 <_Reset_Vector+0xffc01128>

ffc01209 <.LVL362>:
                    sci_iic_disable(p_sci_iic_info);
ffc01209:	ef 71                         	mov.l	r7, r1
ffc0120b:	05 9d fe ff                   	bsr.a	ffc010a8 <_Reset_Vector+0xffc010ac>

ffc0120f <.LVL363>:
                    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffc0120f:	f1 cb 0b                      	bclr	#3, 11[r12].b
                    pregs->SIMR3.BIT.IICSCLS = SCI_IIC_HI_Z_OUTPUT;
ffc01212:	cd c5 0b                      	mov.b	11[r12], r5
ffc01215:	75 35 c0                      	or	#-64, r5
ffc01218:	c7 c5 0b                      	mov.b	r5, 11[r12]
                    pregs->SIMR3.BIT.IICSDAS = SCI_IIC_HI_Z_OUTPUT;
ffc0121b:	cd c5 0b                      	mov.b	11[r12], r5
ffc0121e:	75 35 30                      	or	#48, r5
ffc01221:	c7 c5 0b                      	mov.b	r5, 11[r12]
                    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffc01224:	76 10 01 00                   	nop	; mul	#1, r0
ffc01228:	cd c5 0b                      	mov.b	11[r12], r5
ffc0122b:	7c 35                         	btst	#3, r5
ffc0122d:	21 fb                         	bne.b	ffc01228 <_Reset_Vector+0xffc0122c>
                    if (NULL != g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc)
ffc0122f:	b0 ff                         	movu.b	3[r7], r7

ffc01231 <.LVL364>:
ffc01231:	fe 67 b7                      	mov.l	[r7, r11], r7
ffc01234:	a9 f7                         	mov.l	24[r7], r7
ffc01236:	a8 7f                         	mov.l	4[r7], r7
ffc01238:	61 07                         	cmp	#0, r7
ffc0123a:	3a 52 ff                      	beq.w	ffc0118c <_Reset_Vector+0xffc01190>
                        g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc();
ffc0123d:	7f 17                         	jsr	r7

ffc0123f <.LVL365>:
                break;
ffc0123f:	38 e5 fe                      	bra.w	ffc01124 <_Reset_Vector+0xffc01128>

ffc01242 <.LBB520>:
        cnt--;
ffc01242:	dc 05                         	mov.w	[r0], r5
ffc01244:	60 15                         	sub	#1, r5
ffc01246:	d3 05                         	mov.w	r5, [r0]
    } while (0U != cnt);/* WAIT_LOOP */
ffc01248:	5c 05                         	movu.w	[r0], r5
ffc0124a:	61 05                         	cmp	#0, r5
ffc0124c:	3a 70 ff                      	beq.w	ffc011bc <_Reset_Vector+0xffc011c0>

ffc0124f <.LVL367>:
ffc0124f:	03                            	nop

ffc01250 <.LBB513>:
    if ((SCI_IIC_STPREQ == g_sci_iic_handles[p_sci_iic_info->ch_no]->mode) && (1 == pregs->SIMR3.BIT.IICSTIF))
ffc01250:	8a cd                         	mov.b	11[r4], r5
ffc01252:	68 35                         	shlr	#3, r5
ffc01254:	64 15                         	and	#1, r5
ffc01256:	cf 59                         	mov.b	r5, r9
ffc01258:	20 ea                         	beq.b	ffc01242 <_Reset_Vector+0xffc01246>
ffc0125a:	38 69 ff                      	bra.w	ffc011c3 <_Reset_Vector+0xffc011c7>

ffc0125d <.LBE514>:
ffc0125d:	fc 13 00                      	nop	; max	r0, r0

ffc01260 <_r_sci_iic_txi_isr_processing>:
 * Arguments    : uint8_t ch_no    ; number of channel
 * Return Value : None
 **********************************************************************************************************************/
void r_sci_iic_txi_isr_processing (uint8_t ch_no)
{
    sci_regs_t pregs = g_sci_iic_handles[ch_no]->prom->regs;
ffc01260:	5b 11                         	movu.b	r1, r1
ffc01262:	fb 52 f4 66 c0 ff             	mov.l	#0xffc066f4, r5
ffc01268:	fe 61 55                      	mov.l	[r1, r5], r5
ffc0126b:	ec 54                         	mov.l	[r5], r4

    /* ---- Checks NACK reception. ---- */
    if ((((SCI_IIC_MODE_SEND == g_sci_iic_handles[ch_no]->api_mode)
ffc0126d:	a8 d3                         	mov.l	8[r5], r3
    sci_regs_t pregs = g_sci_iic_handles[ch_no]->prom->regs;
ffc0126f:	a8 4a                         	mov.l	4[r4], r2

ffc01271 <.LVL369>:
    if ((((SCI_IIC_MODE_SEND == g_sci_iic_handles[ch_no]->api_mode)
ffc01271:	61 23                         	cmp	#2, r3
ffc01273:	20 32                         	beq.b	ffc012a5 <_Reset_Vector+0xffc012a9>
            || (SCI_IIC_STS_SEND_SLVADR_R_WAIT == g_sci_iic_handles[ch_no]->api_n_status))
ffc01275:	a8 dc                         	mov.l	12[r5], r4
ffc01277:	61 44                         	cmp	#4, r4
ffc01279:	20 0e                         	beq.b	ffc01287 <_Reset_Vector+0xffc0128b>
            || ((SCI_IIC_MODE_SEND_RECEIVE == g_sci_iic_handles[ch_no]->api_mode)
ffc0127b:	61 43                         	cmp	#4, r3
ffc0127d:	20 17                         	beq.b	ffc01294 <_Reset_Vector+0xffc01298>
    }
    else
    {
        /* ---- Receive ACK reception ---- */
        /* Sets event. */
        switch (g_sci_iic_handles[ch_no]->api_n_status)
ffc0127f:	61 54                         	cmp	#5, r4
ffc01281:	21 1b                         	bne.b	ffc0129c <_Reset_Vector+0xffc012a0>
            break;

            case SCI_IIC_STS_SEND_DATA_WAIT :

                /* Sets interrupted data sending. */
                g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_SEND;
ffc01283:	3e 51 04                      	mov.l	#4, 4[r5]
            break;
        }

    }

} /* End of function r_sci_iic_txi_isr_processing() */
ffc01286:	02                            	rts
        if (0U != pregs->SISR.BIT.IICACKR)
ffc01287:	8b 24                         	mov.b	12[r2], r4
ffc01289:	7c 04                         	btst	#0, r4
ffc0128b:	20 2d                         	beq.b	ffc012b8 <_Reset_Vector+0xffc012bc>
ffc0128d:	fc 13 00                      	nop	; max	r0, r0
            g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_NACK;
ffc01290:	3e 51 06                      	mov.l	#6, 4[r5]
ffc01293:	02                            	rts
                    && (SCI_IIC_STS_SEND_SLVADR_W_WAIT == g_sci_iic_handles[ch_no]->api_n_status)))
ffc01294:	61 34                         	cmp	#3, r4
ffc01296:	20 f1                         	beq.b	ffc01287 <_Reset_Vector+0xffc0128b>
                    && (SCI_IIC_STS_SEND_DATA_WAIT == g_sci_iic_handles[ch_no]->api_n_status)))
ffc01298:	61 54                         	cmp	#5, r4
ffc0129a:	20 27                         	beq.b	ffc012c1 <_Reset_Vector+0xffc012c5>
        switch (g_sci_iic_handles[ch_no]->api_n_status)
ffc0129c:	61 64                         	cmp	#6, r4
ffc0129e:	20 1a                         	beq.b	ffc012b8 <_Reset_Vector+0xffc012bc>
ffc012a0:	61 34                         	cmp	#3, r4
ffc012a2:	20 16                         	beq.b	ffc012b8 <_Reset_Vector+0xffc012bc>
} /* End of function r_sci_iic_txi_isr_processing() */
ffc012a4:	02                            	rts
        if (0U != pregs->SISR.BIT.IICACKR)
ffc012a5:	8b 24                         	mov.b	12[r2], r4
ffc012a7:	7c 04                         	btst	#0, r4
ffc012a9:	21 e7                         	bne.b	ffc01290 <_Reset_Vector+0xffc01294>
            switch (g_sci_iic_handles[ch_no]->api_n_status)
ffc012ab:	a8 dc                         	mov.l	12[r5], r4
ffc012ad:	61 54                         	cmp	#5, r4
ffc012af:	20 d4                         	beq.b	ffc01283 <_Reset_Vector+0xffc01287>
ffc012b1:	24 0b                         	bgtu.b	ffc012bc <_Reset_Vector+0xffc012c0>
ffc012b3:	61 34                         	cmp	#3, r4
ffc012b5:	23 ef                         	bnc.b	ffc012a4 <_Reset_Vector+0xffc012a8>
ffc012b7:	03                            	nop
                g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_ADD;
ffc012b8:	3e 51 03                      	mov.l	#3, 4[r5]
            break;
ffc012bb:	02                            	rts
            switch (g_sci_iic_handles[ch_no]->api_n_status)
ffc012bc:	61 64                         	cmp	#6, r4
ffc012be:	20 fa                         	beq.b	ffc012b8 <_Reset_Vector+0xffc012bc>
} /* End of function r_sci_iic_txi_isr_processing() */
ffc012c0:	02                            	rts
        if (0U != pregs->SISR.BIT.IICACKR)
ffc012c1:	8b 24                         	mov.b	12[r2], r4
ffc012c3:	7c 04                         	btst	#0, r4
ffc012c5:	21 cb                         	bne.b	ffc01290 <_Reset_Vector+0xffc01294>
ffc012c7:	2e bc                         	bra.b	ffc01283 <_Reset_Vector+0xffc01287>

ffc012c9 <.LFE45>:
ffc012c9:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc012d0 <_r_sci_iic_tei_isr_processing>:
 * Arguments    : uint8_t ch_no    ; number of channel
 * Return Value : None
 **********************************************************************************************************************/
void r_sci_iic_tei_isr_processing (uint8_t ch_no)
{
    sci_regs_t pregs = g_sci_iic_handles[ch_no]->prom->regs;
ffc012d0:	5b 11                         	movu.b	r1, r1
ffc012d2:	fb 52 f4 66 c0 ff             	mov.l	#0xffc066f4, r5
ffc012d8:	fe 61 51                      	mov.l	[r1, r5], r1

ffc012db <.LVL371>:
ffc012db:	ec 13                         	mov.l	[r1], r3
ffc012dd:	a8 3c                         	mov.l	4[r3], r4

ffc012df <.LVL372>:

    /* Clear IR flag */
    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffc012df:	f1 4b 0b                      	bclr	#3, 11[r4].b

    /* WAIT_LOOP */
    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffc012e2:	8a cd                         	mov.b	11[r4], r5
ffc012e4:	7c 35                         	btst	#3, r5
ffc012e6:	21 fc                         	bne.b	ffc012e2 <_Reset_Vector+0xffc012e6>
    {
        /* nothing to do */
    }

    /* WAIT_LOOP */
    while (0 != ((*g_sci_iic_handles[ch_no]->prom->pir_tei) & (g_sci_iic_handles[ch_no]->prom->tei_ir_mask)))
ffc012e8:	a9 b2                         	mov.l	24[r3], r2
ffc012ea:	a9 bb                         	mov.l	28[r3], r3
ffc012ec:	ec 25                         	mov.l	[r2], r5
ffc012ee:	fc 33 35                      	tst	r3, r5
ffc012f1:	21 fb                         	bne.b	ffc012ec <_Reset_Vector+0xffc012f0>
    {
        /* nothing to do */
    }

    /* ---- Checks NACK reception. ---- */
    if (0U != pregs->SISR.BIT.IICACKR)
ffc012f3:	8b 45                         	mov.b	12[r4], r5
ffc012f5:	7c 05                         	btst	#0, r5
ffc012f7:	21 16                         	bne.b	ffc0130d <_Reset_Vector+0xffc01311>
    {
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_NACK;
    }

    /* ---- Checks start condition detection. ---- */
    if ((SCI_IIC_STAREQ == g_sci_iic_handles[ch_no]->mode) || (SCI_IIC_RSTAREQ == g_sci_iic_handles[ch_no]->mode))
ffc012f9:	8d 14                         	mov.b	20[r1], r4

ffc012fb <.LVL373>:
ffc012fb:	71 45 ff                      	add	#-1, r4, r5
ffc012fe:	5b 55                         	movu.b	r5, r5
ffc01300:	61 15                         	cmp	#1, r5
ffc01302:	25 19                         	bleu.b	ffc0131b <_Reset_Vector+0xffc0131f>
        /* Sets event flag. */
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_START;
    }

    /* ---- Checks stop condition detection. ---- */
    if (SCI_IIC_STPREQ == g_sci_iic_handles[ch_no]->mode)
ffc01304:	5b 44                         	movu.b	r4, r4
ffc01306:	61 44                         	cmp	#4, r4
ffc01308:	1c                            	bne.s	ffc0130c <_Reset_Vector+0xffc01310>
    {
        /* Sets event flag. */
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_STOP;
ffc01309:	3e 11 05                      	mov.l	#5, 4[r1]
    }
} /* End of function r_sci_iic_tei_isr_processing() */
ffc0130c:	02                            	rts

ffc0130d <.LVL374>:
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_NACK;
ffc0130d:	3e 11 06                      	mov.l	#6, 4[r1]
    if ((SCI_IIC_STAREQ == g_sci_iic_handles[ch_no]->mode) || (SCI_IIC_RSTAREQ == g_sci_iic_handles[ch_no]->mode))
ffc01310:	8d 14                         	mov.b	20[r1], r4

ffc01312 <.LVL375>:
ffc01312:	71 45 ff                      	add	#-1, r4, r5
ffc01315:	5b 55                         	movu.b	r5, r5
ffc01317:	61 15                         	cmp	#1, r5
ffc01319:	24 eb                         	bgtu.b	ffc01304 <_Reset_Vector+0xffc01308>
        g_sci_iic_handles[ch_no]->mode = 0;
ffc0131b:	3c 94 00                      	mov.b	#0, 20[r1]

ffc0131e <.LVL376>:
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_START;
ffc0131e:	3e 11 02                      	mov.l	#2, 4[r1]
    if (SCI_IIC_STPREQ == g_sci_iic_handles[ch_no]->mode)
ffc01321:	02                            	rts

ffc01322 <.LFE46>:
ffc01322:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffc01328 <_riic_mcu_check_ir_txi>:
    switch (channel)
ffc01328:	5b 11                         	movu.b	r1, r1
ffc0132a:	61 11                         	cmp	#1, r1
ffc0132c:	16                            	beq.s	ffc01332 <_Reset_Vector+0xffc01336>
    uint8_t ret = RIIC_IR_CLR;
ffc0132d:	66 01                         	mov.l	#0, r1

ffc0132f <.LVL30>:
} /* End of function riic_mcu_check_ir_txi() */
ffc0132f:	64 11                         	and	#1, r1

ffc01331 <.LVL31>:
ffc01331:	02                            	rts
            ret = RIIC_IR_TXI1;
ffc01332:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc01337:	cd 51 33                      	mov.b	51[r5], r1
ffc0133a:	64 11                         	and	#1, r1

ffc0133c <.LVL32>:
} /* End of function riic_mcu_check_ir_txi() */
ffc0133c:	64 11                         	and	#1, r1

ffc0133e <.LVL33>:
ffc0133e:	02                            	rts

ffc0133f <_riic_mcu_check_ir_rxi>:
    switch (channel)
ffc0133f:	5b 11                         	movu.b	r1, r1
ffc01341:	61 11                         	cmp	#1, r1
ffc01343:	16                            	beq.s	ffc01349 <_Reset_Vector+0xffc0134d>
    uint8_t ret = RIIC_IR_CLR;
ffc01344:	66 01                         	mov.l	#0, r1

ffc01346 <.LVL35>:
} /* End of function riic_mcu_check_ir_rxi() */
ffc01346:	64 11                         	and	#1, r1

ffc01348 <.LVL36>:
ffc01348:	02                            	rts
            ret = RIIC_IR_RXI1;
ffc01349:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0134e:	cd 51 32                      	mov.b	50[r5], r1
ffc01351:	64 11                         	and	#1, r1

ffc01353 <.LVL37>:
} /* End of function riic_mcu_check_ir_rxi() */
ffc01353:	64 11                         	and	#1, r1

ffc01355 <.LVL38>:
ffc01355:	02                            	rts

ffc01356 <_riic_mcu_clear_ir_txi>:
    switch (channel)
ffc01356:	5b 11                         	movu.b	r1, r1
ffc01358:	61 11                         	cmp	#1, r1
ffc0135a:	20 03                         	beq.b	ffc0135d <_Reset_Vector+0xffc01361>
} /* End of function riic_mcu_clear_ir_txi() */
ffc0135c:	02                            	rts
            RIIC_IR_TXI1 = RIIC_IR_CLR; /* Clears TXI interrupt request register. */
ffc0135d:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc01362:	f1 58 33                      	bclr	#0, 51[r5].b
            if (RIIC_IR_CLR == RIIC_IR_TXI1)
ffc01365:	cd 55 33                      	mov.b	51[r5], r5
} /* End of function riic_mcu_clear_ir_txi() */
ffc01368:	02                            	rts

ffc01369 <_riic_mcu_clear_ir_rxi>:
    switch (channel)
ffc01369:	5b 11                         	movu.b	r1, r1
ffc0136b:	61 11                         	cmp	#1, r1
ffc0136d:	20 03                         	beq.b	ffc01370 <_Reset_Vector+0xffc01374>
} /* End of function riic_mcu_clear_ir_rxi() */
ffc0136f:	02                            	rts
            RIIC_IR_RXI1 = RIIC_IR_CLR; /* Clears TXI interrupt request register. */
ffc01370:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc01375:	f1 58 32                      	bclr	#0, 50[r5].b
            if (RIIC_IR_CLR == RIIC_IR_RXI1)
ffc01378:	cd 55 32                      	mov.b	50[r5], r5
} /* End of function riic_mcu_clear_ir_rxi() */
ffc0137b:	02                            	rts

ffc0137c <_riic_mcu_int_icier_setting>:
{
ffc0137c:	60 40                         	sub	#4, r0
    switch (channel)
ffc0137e:	5b 11                         	movu.b	r1, r1
    volatile uint8_t uctmp = 0x00;
ffc01380:	f8 04 00                      	mov.b	#0, [r0]
    switch (channel)
ffc01383:	61 11                         	cmp	#1, r1
ffc01385:	13                            	beq.s	ffc01388 <_Reset_Vector+0xffc0138c>
} /* End of function riic_mcu_int_icier_setting() */
ffc01386:	67 01                         	rtsd	#4
            RIIC1.ICIER.BYTE = (New_icier | RIIC_ICIER_TMO);
ffc01388:	78 02                         	bset	#0, r2

ffc0138a <.LVL66>:
ffc0138a:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffc0138f:	81 da                         	mov.b	r2, 7[r5]
            uctmp = RIIC1.ICIER.BYTE; /* Reads ICIER. */
ffc01391:	89 dd                         	mov.b	7[r5], r5
ffc01393:	c3 05                         	mov.b	r5, [r0]
} /* End of function riic_mcu_int_icier_setting() */
ffc01395:	67 01                         	rtsd	#4

ffc01397 <.LFE16>:
	...

ffc01398 <_riic_mcu_int_enable>:
{
ffc01398:	7e a7                         	push.l	r7
ffc0139a:	60 c0                         	sub	#12, r0
ffc0139c:	cf 17                         	mov.b	r1, r7
    volatile uint8_t uctmp = 0x00;
ffc0139e:	3c 08 00                      	mov.b	#0, 8[r0]
    group_priority.ipl = 0x00000000;
ffc013a1:	3e 01 00                      	mov.l	#0, 4[r0]
    if (group_priority.ipl < RIIC_IPR_CH1_EEI_SET)
ffc013a4:	a8 0d                         	mov.l	4[r0], r5
ffc013a6:	61 25                         	cmp	#2, r5
ffc013a8:	24 05                         	bgtu.b	ffc013ad <_Reset_Vector+0xffc013b1>
        group_priority.ipl = (uint32_t) RIIC_IPR_CH1_EEI_SET;
ffc013aa:	3e 01 03                      	mov.l	#3, 4[r0]
    if (group_priority.ipl < RIIC_IPR_CH1_TEI_SET)
ffc013ad:	a8 0d                         	mov.l	4[r0], r5
ffc013af:	61 25                         	cmp	#2, r5
ffc013b1:	24 07                         	bgtu.b	ffc013b8 <_Reset_Vector+0xffc013bc>
        group_priority.ipl = (uint32_t) RIIC_IPR_CH1_TEI_SET;
ffc013b3:	3e 01 03                      	mov.l	#3, 4[r0]
ffc013b6:	ef 00                         	nop	; mov.l	r0, r0
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_ENABLE, (void *) &group_priority);
ffc013b8:	71 03 04                      	add	#4, r0, r3
ffc013bb:	66 32                         	mov.l	#3, r2
ffc013bd:	75 41 40                      	mov.l	#64, r1

ffc013c0 <.LVL68>:
ffc013c0:	05 88 29 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc013c4 <.LVL69>:
    switch (channel)
ffc013c4:	5b 77                         	movu.b	r7, r7

ffc013c6 <.LVL70>:
ffc013c6:	61 17                         	cmp	#1, r7
ffc013c8:	14                            	beq.s	ffc013cc <_Reset_Vector+0xffc013d0>
} /* End of function riic_mcu_int_enable() */
ffc013c9:	3f 77 04                      	rtsd	#16, r7-r7

ffc013cc <.LVL71>:
            RIIC_IER_EEI1_GPBL1 = RIIC_IER_ENABLE; /* Enables EEI1 groupBL1 interrupt request enable register. */
ffc013cc:	fb 7e 00 70 08                	mov.l	#0x87000, r7
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc013d1:	ef 03                         	mov.l	r0, r3
ffc013d3:	66 62                         	mov.l	#6, r2
ffc013d5:	75 41 69                      	mov.l	#105, r1
ffc013d8:	05 70 29 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc013dc <.LVL72>:
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc013dc:	ef 03                         	mov.l	r0, r3
ffc013de:	66 52                         	mov.l	#5, r2
ffc013e0:	75 41 69                      	mov.l	#105, r1
            RIIC_IER_EEI1_GPBL1 = RIIC_IER_ENABLE; /* Enables EEI1 groupBL1 interrupt request enable register. */
ffc013e3:	ee 75 9d 01                   	mov.l	1652[r7], r5
ffc013e7:	79 d5                         	bset	#29, r5
ffc013e9:	eb 75 9d 01                   	mov.l	r5, 1652[r7]
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc013ed:	05 5b 29 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc013f1 <.LVL73>:
            RIIC_IER_RXI1 = RIIC_IER_ENABLE; /* Enables RXI1 interrupt request enable register. */
ffc013f1:	f2 72 06 02                   	bset	#2, 518[r7].b
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc013f5:	ef 03                         	mov.l	r0, r3
            RIIC_IER_TXI1 = RIIC_IER_ENABLE; /* Enables TXI1 interrupt request enable register. */
ffc013f7:	f2 73 06 02                   	bset	#3, 518[r7].b
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc013fb:	66 62                         	mov.l	#6, r2
ffc013fd:	75 41 69                      	mov.l	#105, r1
ffc01400:	05 48 29 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc01404 <.LVL74>:
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc01404:	ef 03                         	mov.l	r0, r3
ffc01406:	66 52                         	mov.l	#5, r2
ffc01408:	75 41 69                      	mov.l	#105, r1
            RIIC_IER_TEI1_GPBL1 = RIIC_IER_ENABLE; /* Enables TEI1 groupBL1 interrupt request enable register. */
ffc0140b:	ee 75 9d 01                   	mov.l	1652[r7], r5
ffc0140f:	79 c5                         	bset	#28, r5
ffc01411:	eb 75 9d 01                   	mov.l	r5, 1652[r7]
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc01415:	05 33 29 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc01419 <.LVL75>:
            RIIC_IPR_RXI1 = RIIC_IPR_CH1_RXI_SET; /* Sets RXI1 interrupt source priority register. */
ffc01419:	fa 74 32 03 02                	mov.b	#2, 818[r7]
            RIIC_IPR_TXI1 = RIIC_IPR_CH1_TXI_SET; /* Sets TXI1 interrupt source priority register. */
ffc0141e:	fa 74 33 03 02                	mov.b	#2, 819[r7]
            uctmp = RIIC_IPR_TXI1; /* Reads IPR. */
ffc01423:	ce 77 33 03                   	mov.b	819[r7], r7
ffc01427:	82 07                         	mov.b	r7, 8[r0]
} /* End of function riic_mcu_int_enable() */
ffc01429:	3f 77 04                      	rtsd	#16, r7-r7

ffc0142c <.LFE17>:
ffc0142c:	76 10 01 00                   	nop	; mul	#1, r0

ffc01430 <_riic_mcu_int_disable>:
{
ffc01430:	7e a7                         	push.l	r7
ffc01432:	60 c0                         	sub	#12, r0
    switch (channel)
ffc01434:	5b 11                         	movu.b	r1, r1
    volatile uint8_t uctmp = 0x00;
ffc01436:	3c 08 00                      	mov.b	#0, 8[r0]
    switch (channel)
ffc01439:	61 11                         	cmp	#1, r1
ffc0143b:	20 14                         	beq.b	ffc0144f <_Reset_Vector+0xffc01453>
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &group_priority);
ffc0143d:	71 03 04                      	add	#4, r0, r3
ffc01440:	66 42                         	mov.l	#4, r2
ffc01442:	75 41 40                      	mov.l	#64, r1

ffc01445 <.LVL77>:
    group_priority.ipl = 0x00000000;
ffc01445:	3e 01 00                      	mov.l	#0, 4[r0]
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &group_priority);
ffc01448:	05 00 29 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0144c <.LVL78>:
} /* End of function riic_mcu_int_disable() */
ffc0144c:	3f 77 04                      	rtsd	#16, r7-r7
            RIIC_IER_EEI1_GPBL1 = RIIC_IER_DISABLE; /* Disables TEI1 groupBL1 interrupt request enable register. */
ffc0144f:	fb 7e 00 70 08                	mov.l	#0x87000, r7
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc01454:	ef 03                         	mov.l	r0, r3
ffc01456:	66 62                         	mov.l	#6, r2
ffc01458:	75 41 69                      	mov.l	#105, r1
ffc0145b:	05 ed 28 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0145f <.LVL79>:
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc0145f:	ef 03                         	mov.l	r0, r3
ffc01461:	66 52                         	mov.l	#5, r2
ffc01463:	75 41 69                      	mov.l	#105, r1
            RIIC_IER_EEI1_GPBL1 = RIIC_IER_DISABLE; /* Disables TEI1 groupBL1 interrupt request enable register. */
ffc01466:	ee 75 9d 01                   	mov.l	1652[r7], r5
ffc0146a:	7b d5                         	bclr	#29, r5
ffc0146c:	eb 75 9d 01                   	mov.l	r5, 1652[r7]
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc01470:	05 d8 28 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc01474 <.LVL80>:
            RIIC_IER_RXI1 = RIIC_IER_DISABLE; /* Disables RXI1 interrupt request enable register. */
ffc01474:	f2 7a 06 02                   	bclr	#2, 518[r7].b
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc01478:	ef 03                         	mov.l	r0, r3
            RIIC_IER_TXI1 = RIIC_IER_DISABLE; /* Disables TXI1 interrupt request enable register. */
ffc0147a:	f2 7b 06 02                   	bclr	#3, 518[r7].b
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc0147e:	66 62                         	mov.l	#6, r2
ffc01480:	75 41 69                      	mov.l	#105, r1
ffc01483:	05 c5 28 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc01487 <.LVL81>:
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc01487:	ef 03                         	mov.l	r0, r3
ffc01489:	66 52                         	mov.l	#5, r2
ffc0148b:	75 41 69                      	mov.l	#105, r1
            RIIC_IER_TEI1_GPBL1 = RIIC_IER_DISABLE; /* Disables TEI1 groupBL1 interrupt request enable register. */
ffc0148e:	ee 75 9d 01                   	mov.l	1652[r7], r5
ffc01492:	7b c5                         	bclr	#28, r5
ffc01494:	eb 75 9d 01                   	mov.l	r5, 1652[r7]
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc01498:	05 b0 28 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0149c <.LVL82>:
            RIIC_IPR_RXI1 = RIIC_IPR_CH1_RXI_INIT; /* Sets RXI1 interrupt source priority register. */
ffc0149c:	fa 74 32 03 00                	mov.b	#0, 818[r7]
            RIIC_IPR_TXI1 = RIIC_IPR_CH1_TXI_INIT; /* Sets TXI1 interrupt source priority register. */
ffc014a1:	fa 74 33 03 00                	mov.b	#0, 819[r7]
            uctmp = RIIC_IPR_TXI1; /* Reads IPR. */
ffc014a6:	ce 77 33 03                   	mov.b	819[r7], r7
ffc014aa:	82 07                         	mov.b	r7, 8[r0]
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &group_priority);
ffc014ac:	71 03 04                      	add	#4, r0, r3
ffc014af:	66 42                         	mov.l	#4, r2
ffc014b1:	75 41 40                      	mov.l	#64, r1
    group_priority.ipl = 0x00000000;
ffc014b4:	3e 01 00                      	mov.l	#0, 4[r0]
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &group_priority);
ffc014b7:	05 91 28 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc014bb <.LVL83>:
} /* End of function riic_mcu_int_disable() */
ffc014bb:	3f 77 04                      	rtsd	#16, r7-r7

ffc014be <_riic_mcu_check_freq>:
{
ffc014be:	75 b0 00                      	dpushm.d	dr0-dr0
ffc014c1:	75 a0 10                      	dpushm.l	dcmr-dcmr
} /* End of function riic_mcu_check_freq() */
ffc014c4:	f9 03 03 38 9c 8c 41          	dmov.d	#0x418c9c38, drh0
ffc014cb:	fd 75 81 00                   	dmov.l	drl0, r1
ffc014cf:	fd 75 82 02                   	dmov.l	drh0, r2
ffc014d3:	75 a8 10                      	dpopm.l	dcmr-dcmr
ffc014d6:	75 b8 00                      	dpopm.d	dr0-dr0
ffc014d9:	02                            	rts

ffc014da <_riic_time_out>:
 *              : riic_api_status_t new_status  ; New status
 * Return Value : None
 **********************************************************************************************************************/
static void riic_api_status_set (riic_info_t * p_riic_info, riic_api_status_t new_status)
{
    uint8_t ch_no = p_riic_info->ch_no;
ffc014da:	88 9d                         	mov.b	3[r1], r5

ffc014dc <.LBE320>:
} /* End of function riic_time_out() */
ffc014dc:	66 01                         	mov.l	#0, r1

ffc014de <.LBB323>:
    
    /* Sets the previous status. */
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc014de:	5b 55                         	movu.b	r5, r5
ffc014e0:	6c 45                         	shll	#4, r5

ffc014e2 <.LVL3>:
ffc014e2:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc014e8:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

    /* Sets the now status. */
    riic_api_info[ch_no].N_status = new_status;
ffc014ec:	3e 52 0a                      	mov.l	#10, 8[r5]

ffc014ef <.LBE323>:
} /* End of function riic_time_out() */
ffc014ef:	02                            	rts

ffc014f0 <_riic_enable_slave_transfer>:
{
ffc014f0:	6e 6b                         	pushm	r6-r11
ffc014f2:	60 40                         	sub	#4, r0
ffc014f4:	ef 15                         	mov.l	r1, r5

ffc014f6 <.LBB332>:
 * Arguments    : riic_info_t * p_riic_info      ; IIC Information
 * Return Value : None
 **********************************************************************************************************************/
static void riic_slv_addr_match_int_enable (riic_info_t * p_riic_info)
{
    volatile uint8_t uctmp = 0x00;
ffc014f6:	3c 02 00                      	mov.b	#0, 2[r0]

    /* Creates the register pointer for the specified RIIC channel. */
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffc014f9:	88 9e                         	mov.b	3[r1], r6
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffc014fb:	cd 1e 03                      	mov.b	3[r1], r14
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffc014fe:	cd 1f 03                      	mov.b	3[r1], r15
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffc01501:	88 99                         	mov.b	3[r1], r1

ffc01503 <.LVL18>:
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffc01503:	88 da                         	mov.b	3[r5], r2
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffc01505:	cd 5b 03                      	mov.b	3[r5], r11
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc01508:	88 dc                         	mov.b	3[r5], r4

ffc0150a <.LBB334>:
 * Arguments    : riic_info_t * p_riic_info      ; IIC Information
 * Return Value : None
 **********************************************************************************************************************/
static void riic_reset_set (riic_info_t * p_riic_info)
{
    volatile uint8_t uctmp = 0x00;
ffc0150a:	f8 04 00                      	mov.b	#0, [r0]

    /* Creates the register pointer for the specified RIIC channel. */
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc0150d:	88 db                         	mov.b	3[r5], r3

ffc0150f <.LBE334>:
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffc0150f:	fb a2 42 69 c0 ff             	mov.l	#0xffc06942, r10
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffc01515:	5b 66                         	movu.b	r6, r6
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffc01517:	5b ee                         	movu.b	r14, r14

ffc01519 <.LBB342>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc01519:	5b 33                         	movu.b	r3, r3

ffc0151b <.LBE342>:
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffc0151b:	5b ff                         	movu.b	r15, r15

ffc0151d <.LBB343>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc0151d:	6c 53                         	shll	#5, r3

ffc0151f <.LBE343>:
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffc0151f:	5b 11                         	movu.b	r1, r1

ffc01521 <.LBB344>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc01521:	73 33 00 83 08                	add	#0x88300, r3, r3

ffc01526 <.LBE344>:
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffc01526:	5b 22                         	movu.b	r2, r2

ffc01528 <.LBB345>:

    /* Resets RIIC registers. */
    (*piccr1_reg) |= RIIC_ICCR1_RIIC_RESET; /* Sets ICCR1.IICRST bit. */
ffc01528:	f0 36                         	bset	#6, [r3].b
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffc0152a:	cc 37                         	mov.b	[r3], r7

ffc0152c <.LBE345>:
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffc0152c:	5b b3                         	movu.b	r11, r3

ffc0152e <.LBB346>:
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffc0152e:	c3 07                         	mov.b	r7, [r0]

ffc01530 <.LBE346>:
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc01530:	5b 44                         	movu.b	r4, r4
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffc01532:	88 df                         	mov.b	3[r5], r7
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffc01534:	6c 56                         	shll	#5, r6
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffc01536:	6c 5e                         	shll	#5, r14
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffc01538:	6c 5f                         	shll	#5, r15
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffc0153a:	5b 77                         	movu.b	r7, r7
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffc0153c:	6c 51                         	shll	#5, r1
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffc0153e:	6c 52                         	shll	#5, r2
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffc01540:	fe c7 a7                      	movu.b	[r7, r10], r7
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffc01543:	6c 53                         	shll	#5, r3
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc01545:	6c 54                         	shll	#5, r4
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffc01547:	73 66 0a 83 08                	add	#0x8830a, r6, r6

ffc0154c <.LVL19>:
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffc0154c:	73 ee 0b 83 08                	add	#0x8830b, r14, r14

ffc01551 <.LVL20>:
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffc01551:	73 ff 0c 83 08                	add	#0x8830c, r15, r15

ffc01556 <.LVL21>:
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffc01556:	73 11 0d 83 08                	add	#0x8830d, r1, r1

ffc0155b <.LVL22>:
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffc0155b:	73 22 0e 83 08                	add	#0x8830e, r2, r2

ffc01560 <.LVL23>:
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffc01560:	73 33 0f 83 08                	add	#0x8830f, r3, r3

ffc01565 <.LVL24>:
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc01565:	73 44 06 83 08                	add	#0x88306, r4, r4

ffc0156a <.LBB347>:
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffc0156a:	61 17                         	cmp	#1, r7
        *psarl0_reg = g_riic_slv_ad0_val[p_riic_info->ch_no] << 1;
ffc0156c:	b0 df                         	movu.b	3[r5], r7
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffc0156e:	3a 13 01                      	beq.w	ffc01681 <_Reset_Vector+0xffc01685>
    else if (2U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffc01571:	fe c7 a7                      	movu.b	[r7, r10], r7
ffc01574:	61 27                         	cmp	#2, r7
ffc01576:	3a 88 00                      	beq.w	ffc015fe <_Reset_Vector+0xffc01602>
        (*picser_reg) &= RIIC_ICSER_SAR0E_CLR;
ffc01579:	f0 48                         	bclr	#0, [r4].b
ffc0157b:	77 10 01 00 00                	nop	; mul	#1, r0
    if (1U == g_riic_slv_ad1_format[p_riic_info->ch_no])
ffc01580:	cd 5e 03                      	mov.b	3[r5], r14

ffc01583 <.LVL26>:
ffc01583:	fb 72 3f 69 c0 ff             	mov.l	#0xffc0693f, r7
ffc01589:	5b ee                         	movu.b	r14, r14
ffc0158b:	fe ce 7a                      	movu.b	[r14, r7], r10
ffc0158e:	61 1a                         	cmp	#1, r10
ffc01590:	3a a0 00                      	beq.w	ffc01630 <_Reset_Vector+0xffc01634>
    else if (2U == g_riic_slv_ad1_format[p_riic_info->ch_no])
ffc01593:	59 5a 03                      	movu.b	3[r5], r10
ffc01596:	fe ca 77                      	movu.b	[r10, r7], r7
ffc01599:	61 27                         	cmp	#2, r7
ffc0159b:	3a 1c 01                      	beq.w	ffc016b7 <_Reset_Vector+0xffc016bb>
        (*picser_reg) &= RIIC_ICSER_SAR1E_CLR;
ffc0159e:	f0 49                         	bclr	#1, [r4].b
    if (1U == g_riic_slv_ad2_format[p_riic_info->ch_no])
ffc015a0:	88 d9                         	mov.b	3[r5], r1

ffc015a2 <.LVL27>:
ffc015a2:	fb 72 3c 69 c0 ff             	mov.l	#0xffc0693c, r7
ffc015a8:	5b 11                         	movu.b	r1, r1
ffc015aa:	fe c1 7a                      	movu.b	[r1, r7], r10
ffc015ad:	61 1a                         	cmp	#1, r10
ffc015af:	3a a9 00                      	beq.w	ffc01658 <_Reset_Vector+0xffc0165c>

ffc015b2 <.LVL28>:
    else if (2 == g_riic_slv_ad2_format[p_riic_info->ch_no])
ffc015b2:	59 5a 03                      	movu.b	3[r5], r10
ffc015b5:	fe ca 77                      	movu.b	[r10, r7], r7
ffc015b8:	61 27                         	cmp	#2, r7
ffc015ba:	3a dc 00                      	beq.w	ffc01696 <_Reset_Vector+0xffc0169a>
        (*picser_reg) &= RIIC_ICSER_SAR2E_CLR;
ffc015bd:	f0 4a                         	bclr	#2, [r4].b
ffc015bf:	03                            	nop
    if (1U == g_riic_gca_enable[p_riic_info->ch_no])
ffc015c0:	b0 db                         	movu.b	3[r5], r3

ffc015c2 <.LVL29>:
ffc015c2:	fb 72 39 69 c0 ff             	mov.l	#0xffc06939, r7
ffc015c8:	fe c3 77                      	movu.b	[r3, r7], r7
ffc015cb:	61 17                         	cmp	#1, r7
ffc015cd:	3a af 00                      	beq.w	ffc0167c <_Reset_Vector+0xffc01680>
        (*picser_reg) &= RIIC_ICSER_GCAE_CLR;
ffc015d0:	f0 4b                         	bclr	#3, [r4].b
    uctmp = *picser_reg; /* Reads ICSER. */
ffc015d2:	cc 47                         	mov.b	[r4], r7

ffc015d4 <.LBE332>:
} /* End of function riic_enable_slave_transfer() */
ffc015d4:	66 01                         	mov.l	#0, r1

ffc015d6 <.LBB352>:
    uctmp = *picser_reg; /* Reads ICSER. */
ffc015d6:	80 87                         	mov.b	r7, 2[r0]

ffc015d8 <.LBB348>:
    volatile uint8_t uctmp = 0x00;
ffc015d8:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc015db:	b0 dc                         	movu.b	3[r5], r4

ffc015dd <.LVL31>:
ffc015dd:	6c 54                         	shll	#5, r4
ffc015df:	73 44 00 83 08                	add	#0x88300, r4, r4

ffc015e4 <.LVL32>:
    (*piccr1_reg) &= RIIC_ICCR1_ENABLE; /* Clears ICCR1.IICRST bit. */
ffc015e4:	f0 4e                         	bclr	#6, [r4].b
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffc015e6:	cc 47                         	mov.b	[r4], r7
ffc015e8:	80 0f                         	mov.b	r7, 1[r0]

ffc015ea <.LBB353>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc015ea:	b0 dd                         	movu.b	3[r5], r5

ffc015ec <.LVL34>:
ffc015ec:	6c 45                         	shll	#4, r5
ffc015ee:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc015f4:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc015f8:	3e 52 02                      	mov.l	#2, 8[r5]

ffc015fb <.LVL35>:
} /* End of function riic_enable_slave_transfer() */
ffc015fb:	3f 6b 07                      	rtsd	#28, r6-r11

ffc015fe <.LBB355>:
        *psarl0_reg = (uint8_t) (g_riic_slv_ad0_val[p_riic_info->ch_no] & RIIC_SARL_MASK);
ffc015fe:	88 df                         	mov.b	3[r5], r7
ffc01600:	fb a2 52 69 c0 ff             	mov.l	#0xffc06952, r10
ffc01606:	5b 77                         	movu.b	r7, r7
ffc01608:	fe 57 a7                      	mov.w	[r7, r10], r7
ffc0160b:	c3 67                         	mov.b	r7, [r6]
        *psaru0_reg = (uint8_t) (((g_riic_slv_ad0_val[p_riic_info->ch_no] & RIIC_SARU_MASK) >> 7) |
ffc0160d:	b0 df                         	movu.b	3[r5], r7
ffc0160f:	fe d7 a7                      	movu.w	[r7, r10], r7
ffc01612:	6a 77                         	shar	#7, r7
ffc01614:	64 67                         	and	#6, r7
ffc01616:	78 07                         	bset	#0, r7
ffc01618:	c3 e7                         	mov.b	r7, [r14]
        (*picser_reg) |= RIIC_ICSER_SAR0E_SET;
ffc0161a:	f0 40                         	bset	#0, [r4].b
    if (1U == g_riic_slv_ad1_format[p_riic_info->ch_no])
ffc0161c:	cd 5e 03                      	mov.b	3[r5], r14

ffc0161f <.LVL37>:
ffc0161f:	fb 72 3f 69 c0 ff             	mov.l	#0xffc0693f, r7
ffc01625:	5b ee                         	movu.b	r14, r14
ffc01627:	fe ce 7a                      	movu.b	[r14, r7], r10
ffc0162a:	61 1a                         	cmp	#1, r10
ffc0162c:	3b 67 ff                      	bne.w	ffc01593 <_Reset_Vector+0xffc01597>
ffc0162f:	03                            	nop
        *psarl1_reg = (uint8_t) (g_riic_slv_ad1_val[p_riic_info->ch_no] << 1);
ffc01630:	b0 df                         	movu.b	3[r5], r7
ffc01632:	fb a2 4c 69 c0 ff             	mov.l	#0xffc0694c, r10
ffc01638:	fe 57 a6                      	mov.w	[r7, r10], r6

ffc0163b <.LVL38>:
ffc0163b:	6c 16                         	shll	#1, r6
ffc0163d:	c3 f6                         	mov.b	r6, [r15]
        *psaru1_reg = 0x00;
ffc0163f:	f8 14 00                      	mov.b	#0, [r1]
        (*picser_reg) |= RIIC_ICSER_SAR1E_SET;
ffc01642:	f0 41                         	bset	#1, [r4].b
    if (1U == g_riic_slv_ad2_format[p_riic_info->ch_no])
ffc01644:	88 d9                         	mov.b	3[r5], r1

ffc01646 <.LVL39>:
ffc01646:	fb 72 3c 69 c0 ff             	mov.l	#0xffc0693c, r7
ffc0164c:	5b 11                         	movu.b	r1, r1
ffc0164e:	fe c1 7a                      	movu.b	[r1, r7], r10
ffc01651:	61 1a                         	cmp	#1, r10
ffc01653:	3b 5f ff                      	bne.w	ffc015b2 <_Reset_Vector+0xffc015b6>
ffc01656:	ef 00                         	nop	; mov.l	r0, r0
        *psarl2_reg = (uint8_t) (g_riic_slv_ad2_val[p_riic_info->ch_no] << 1);
ffc01658:	b0 df                         	movu.b	3[r5], r7
ffc0165a:	fb a2 46 69 c0 ff             	mov.l	#0xffc06946, r10
ffc01660:	fe 57 a1                      	mov.w	[r7, r10], r1
ffc01663:	6c 11                         	shll	#1, r1
ffc01665:	c3 21                         	mov.b	r1, [r2]
        *psaru2_reg = 0x00;
ffc01667:	f8 34 00                      	mov.b	#0, [r3]
        (*picser_reg) |= RIIC_ICSER_SAR2E_SET;
ffc0166a:	f0 42                         	bset	#2, [r4].b
    if (1U == g_riic_gca_enable[p_riic_info->ch_no])
ffc0166c:	b0 db                         	movu.b	3[r5], r3

ffc0166e <.LVL40>:
ffc0166e:	fb 72 39 69 c0 ff             	mov.l	#0xffc06939, r7
ffc01674:	fe c3 77                      	movu.b	[r3, r7], r7
ffc01677:	61 17                         	cmp	#1, r7
ffc01679:	3b 57 ff                      	bne.w	ffc015d0 <_Reset_Vector+0xffc015d4>
        (*picser_reg) |= RIIC_ICSER_GCAE_SET;
ffc0167c:	f0 43                         	bset	#3, [r4].b
ffc0167e:	38 54 ff                      	bra.w	ffc015d2 <_Reset_Vector+0xffc015d6>

ffc01681 <.LVL41>:
        *psarl0_reg = g_riic_slv_ad0_val[p_riic_info->ch_no] << 1;
ffc01681:	fb a2 52 69 c0 ff             	mov.l	#0xffc06952, r10
ffc01687:	fe 57 ab                      	mov.w	[r7, r10], r11
ffc0168a:	6c 1b                         	shll	#1, r11
ffc0168c:	c3 6b                         	mov.b	r11, [r6]
        *psaru0_reg = 0x00;
ffc0168e:	f8 e4 00                      	mov.b	#0, [r14]
        (*picser_reg) |= RIIC_ICSER_SAR0E_SET;
ffc01691:	f0 40                         	bset	#0, [r4].b
ffc01693:	38 ed fe                      	bra.w	ffc01580 <_Reset_Vector+0xffc01584>

ffc01696 <.LVL42>:
        *psarl2_reg = (uint8_t) (g_riic_slv_ad2_val[p_riic_info->ch_no] & RIIC_SARL_MASK);
ffc01696:	88 df                         	mov.b	3[r5], r7
ffc01698:	fb a2 46 69 c0 ff             	mov.l	#0xffc06946, r10
ffc0169e:	5b 77                         	movu.b	r7, r7
ffc016a0:	fe 57 a7                      	mov.w	[r7, r10], r7
ffc016a3:	c3 27                         	mov.b	r7, [r2]
        *psaru2_reg = (uint8_t) (((g_riic_slv_ad2_val[p_riic_info->ch_no] & RIIC_SARU_MASK) >> 7) |
ffc016a5:	b0 df                         	movu.b	3[r5], r7
ffc016a7:	fe d7 a7                      	movu.w	[r7, r10], r7
ffc016aa:	6a 77                         	shar	#7, r7
ffc016ac:	64 67                         	and	#6, r7
ffc016ae:	78 07                         	bset	#0, r7
ffc016b0:	c3 37                         	mov.b	r7, [r3]
        (*picser_reg) |= RIIC_ICSER_SAR2E_SET;
ffc016b2:	f0 42                         	bset	#2, [r4].b
ffc016b4:	38 0c ff                      	bra.w	ffc015c0 <_Reset_Vector+0xffc015c4>

ffc016b7 <.LVL43>:
        *psarl1_reg = (uint8_t) (g_riic_slv_ad1_val[p_riic_info->ch_no] & RIIC_SARL_MASK);
ffc016b7:	88 df                         	mov.b	3[r5], r7
ffc016b9:	fb a2 4c 69 c0 ff             	mov.l	#0xffc0694c, r10
ffc016bf:	5b 77                         	movu.b	r7, r7
ffc016c1:	fe 57 a7                      	mov.w	[r7, r10], r7
ffc016c4:	c3 f7                         	mov.b	r7, [r15]
        *psaru1_reg = (uint8_t) (((g_riic_slv_ad1_val[p_riic_info->ch_no] & RIIC_SARU_MASK) >> 7) |
ffc016c6:	b0 df                         	movu.b	3[r5], r7
ffc016c8:	fe d7 a7                      	movu.w	[r7, r10], r7
ffc016cb:	6a 77                         	shar	#7, r7
ffc016cd:	64 67                         	and	#6, r7
ffc016cf:	78 07                         	bset	#0, r7
ffc016d1:	c3 17                         	mov.b	r7, [r1]
        (*picser_reg) |= RIIC_ICSER_SAR1E_SET;
ffc016d3:	f0 41                         	bset	#1, [r4].b
ffc016d5:	38 cb fe                      	bra.w	ffc015a0 <_Reset_Vector+0xffc015a4>

ffc016d8 <_riic_arbitration_lost>:
    if (((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc016d8:	b0 9d                         	movu.b	3[r1], r5
ffc016da:	6c 45                         	shll	#4, r5
ffc016dc:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc016e2:	ec 55                         	mov.l	[r5], r5
ffc016e4:	61 15                         	cmp	#1, r5
ffc016e6:	20 36                         	beq.b	ffc0171c <_Reset_Vector+0xffc01720>
            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc016e8:	b0 9d                         	movu.b	3[r1], r5
ffc016ea:	6c 45                         	shll	#4, r5
ffc016ec:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc016f2:	ec 55                         	mov.l	[r5], r5
ffc016f4:	61 25                         	cmp	#2, r5
ffc016f6:	20 26                         	beq.b	ffc0171c <_Reset_Vector+0xffc01720>
            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc016f8:	b0 9d                         	movu.b	3[r1], r5
ffc016fa:	6c 45                         	shll	#4, r5
ffc016fc:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01702:	ec 55                         	mov.l	[r5], r5
ffc01704:	61 35                         	cmp	#3, r5
ffc01706:	20 16                         	beq.b	ffc0171c <_Reset_Vector+0xffc01720>
    else if ((RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc01708:	b0 9d                         	movu.b	3[r1], r5
ffc0170a:	6c 45                         	shll	#4, r5
ffc0170c:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01712:	ec 55                         	mov.l	[r5], r5
ffc01714:	61 55                         	cmp	#5, r5
ffc01716:	13                            	beq.s	ffc01719 <_Reset_Vector+0xffc0171d>
            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc01717:	88 9d                         	mov.b	3[r1], r5
} /* End of function riic_arbitration_lost() */
ffc01719:	66 01                         	mov.l	#0, r1

ffc0171b <.LVL45>:
ffc0171b:	02                            	rts

ffc0171c <.LVL46>:
{
ffc0171c:	6e 7a                         	pushm	r7-r10
        if ((((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc0171e:	b0 9d                         	movu.b	3[r1], r5
ffc01720:	6c 45                         	shll	#4, r5
ffc01722:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01728:	a8 5d                         	mov.l	4[r5], r5
ffc0172a:	61 15                         	cmp	#1, r5
ffc0172c:	20 34                         	beq.b	ffc01760 <_Reset_Vector+0xffc01764>
                || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc0172e:	b0 9d                         	movu.b	3[r1], r5
ffc01730:	6c 45                         	shll	#4, r5
ffc01732:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01738:	a8 5d                         	mov.l	4[r5], r5
ffc0173a:	61 25                         	cmp	#2, r5
ffc0173c:	20 24                         	beq.b	ffc01760 <_Reset_Vector+0xffc01764>
                || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc0173e:	b0 9d                         	movu.b	3[r1], r5
ffc01740:	6c 45                         	shll	#4, r5
ffc01742:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01748:	a8 5d                         	mov.l	4[r5], r5
ffc0174a:	61 35                         	cmp	#3, r5
ffc0174c:	20 14                         	beq.b	ffc01760 <_Reset_Vector+0xffc01764>
                || (RIIC_MODE_NONE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc0174e:	b0 9d                         	movu.b	3[r1], r5
ffc01750:	6c 45                         	shll	#4, r5
ffc01752:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01758:	a8 5d                         	mov.l	4[r5], r5
ffc0175a:	61 05                         	cmp	#0, r5
ffc0175c:	21 24                         	bne.b	ffc01780 <_Reset_Vector+0xffc01784>
ffc0175e:	ef 00                         	nop	; mov.l	r0, r0

ffc01760 <.LBB356>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01760:	88 9d                         	mov.b	3[r1], r5

ffc01762 <.LBB359>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01762:	88 99                         	mov.b	3[r1], r1

ffc01764 <.LVL49>:
ffc01764:	66 82                         	mov.l	#8, r2

ffc01766 <.LBB362>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01766:	5b 55                         	movu.b	r5, r5
ffc01768:	6c 45                         	shll	#4, r5

ffc0176a <.LVL50>:
ffc0176a:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01770:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc01774:	3e 52 08                      	mov.l	#8, 8[r5]

ffc01777 <.LBB363>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01777:	05 05 fc ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc0177b <.LBE363>:
} /* End of function riic_arbitration_lost() */
ffc0177b:	66 01                         	mov.l	#0, r1
ffc0177d:	3f 7a 04                      	rtsd	#16, r7-r10

ffc01780 <.LVL53>:
        else if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01780:	b0 9d                         	movu.b	3[r1], r5
ffc01782:	6c 45                         	shll	#4, r5
ffc01784:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0178a:	a8 5b                         	mov.l	4[r5], r3
ffc0178c:	61 43                         	cmp	#4, r3
ffc0178e:	21 ed                         	bne.b	ffc0177b <_Reset_Vector+0xffc0177f>
            riic_api_mode_event_init(priic_info_s[p_riic_info->ch_no], RIIC_MODE_S_READY);
ffc01790:	88 9d                         	mov.b	3[r1], r5
ffc01792:	fb 42 98 04 00 00             	mov.l	#0x498, r4
ffc01798:	5b 55                         	movu.b	r5, r5
ffc0179a:	fe 65 47                      	mov.l	[r5, r4], r7

ffc0179d <.LBB364>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc0179d:	cd 7e 03                      	mov.b	3[r7], r14

ffc017a0 <.LBE364>:
            riic_api_status_set(priic_info_s[p_riic_info->ch_no], RIIC_STS_AL);
ffc017a0:	88 9d                         	mov.b	3[r1], r5

ffc017a2 <.LBB370>:
    riic_api_event[ch_no] = RIIC_EV_INIT;
ffc017a2:	5b ee                         	movu.b	r14, r14

ffc017a4 <.LBE370>:
            riic_api_status_set(priic_info_s[p_riic_info->ch_no], RIIC_STS_AL);
ffc017a4:	5b 55                         	movu.b	r5, r5

ffc017a6 <.LBB371>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc017a6:	fd c4 e2                      	shll	#4, r14, r2
ffc017a9:	70 22 5c 04 00 00             	add	#0x45c, r2, r2

ffc017af <.LBE371>:
            riic_api_status_set(priic_info_s[p_riic_info->ch_no], RIIC_STS_AL);
ffc017af:	fe 65 47                      	mov.l	[r5, r4], r7

ffc017b2 <.LBB372>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc017b2:	e4 22 01                      	mov.l	[r2], 4[r2]

ffc017b5 <.LBB373>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc017b5:	88 fd                         	mov.b	3[r7], r5

ffc017b7 <.LBE373>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc017b7:	cd 1f 03                      	mov.b	3[r1], r15

ffc017ba <.LBB379>:
    riic_api_event[ch_no] = RIIC_EV_INIT;
ffc017ba:	fb 72 8c 04 00 00             	mov.l	#0x48c, r7
ffc017c0:	66 0a                         	mov.l	#0, r10
ffc017c2:	fe 2e 7a                      	mov.l	r10, [r14, r7]
    riic_api_info[ch_no].N_Mode = new_mode;
ffc017c5:	e3 23                         	mov.l	r3, [r2]

ffc017c7 <.LBB380>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc017c7:	5b f3                         	movu.b	r15, r3

ffc017c9 <.LBB381>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc017c9:	5b 55                         	movu.b	r5, r5
ffc017cb:	6c 45                         	shll	#4, r5

ffc017cd <.LBE381>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc017cd:	fe 63 43                      	mov.l	[r3, r4], r3

ffc017d0 <.LBB382>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc017d0:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc017d6:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

ffc017da <.LBE382>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc017da:	a9 3b                         	mov.l	20[r3], r3

ffc017dc <.LBB383>:
    riic_api_info[ch_no].N_status = new_status;
ffc017dc:	3e 52 09                      	mov.l	#9, 8[r5]

ffc017df <.LBE383>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc017df:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc017e5:	20 24                         	beq.b	ffc01809 <_Reset_Vector+0xffc0180d>
                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc017e7:	b0 9d                         	movu.b	3[r1], r5
ffc017e9:	fe 65 47                      	mov.l	[r5, r4], r7
ffc017ec:	a9 77                         	mov.l	16[r7], r7
ffc017ee:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffc017f4:	20 15                         	beq.b	ffc01809 <_Reset_Vector+0xffc0180d>
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_RX_SP_NAK);
ffc017f6:	88 9f                         	mov.b	3[r1], r7

ffc017f8 <.LBB384>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc017f8:	fb 26 b8                      	mov.l	#-72, r2

ffc017fb <.LBE384>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_RX_SP_NAK);
ffc017fb:	5b 77                         	movu.b	r7, r7
ffc017fd:	fe 67 47                      	mov.l	[r7, r4], r7

ffc01800 <.LBB387>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01800:	88 f9                         	mov.b	3[r7], r1

ffc01802 <.LVL61>:
ffc01802:	05 7a fb ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01806 <.LVL62>:
ffc01806:	38 75 ff                      	bra.w	ffc0177b <_Reset_Vector+0xffc0177f>

ffc01809 <.LBE387>:
            else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01809:	b0 9d                         	movu.b	3[r1], r5
ffc0180b:	fe 65 47                      	mov.l	[r5, r4], r7
ffc0180e:	a9 7f                         	mov.l	20[r7], r7
ffc01810:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffc01816:	20 12                         	beq.b	ffc01828 <_Reset_Vector+0xffc0182c>
                    && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01818:	b0 9f                         	movu.b	3[r1], r7
ffc0181a:	fe 67 47                      	mov.l	[r7, r4], r7
ffc0181d:	a9 77                         	mov.l	16[r7], r7
ffc0181f:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffc01825:	20 36                         	beq.b	ffc0185b <_Reset_Vector+0xffc0185f>
ffc01827:	03                            	nop
            else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01828:	b0 9d                         	movu.b	3[r1], r5
ffc0182a:	fe 65 47                      	mov.l	[r5, r4], r7
ffc0182d:	a9 7f                         	mov.l	20[r7], r7
ffc0182f:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffc01835:	3b 46 ff                      	bne.w	ffc0177b <_Reset_Vector+0xffc0177f>
                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01838:	b0 9f                         	movu.b	3[r1], r7
ffc0183a:	fe 67 47                      	mov.l	[r7, r4], r7
ffc0183d:	a9 77                         	mov.l	16[r7], r7
ffc0183f:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffc01845:	3a 36 ff                      	beq.w	ffc0177b <_Reset_Vector+0xffc0177f>
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_SP);
ffc01848:	88 9f                         	mov.b	3[r1], r7

ffc0184a <.LBB388>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc0184a:	75 42 28                      	mov.l	#40, r2

ffc0184d <.LBE388>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_SP);
ffc0184d:	5b 77                         	movu.b	r7, r7
ffc0184f:	fe 67 47                      	mov.l	[r7, r4], r7

ffc01852 <.LBB391>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01852:	88 f9                         	mov.b	3[r7], r1

ffc01854 <.LVL65>:
ffc01854:	05 28 fb ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01858 <.LVL66>:
ffc01858:	38 23 ff                      	bra.w	ffc0177b <_Reset_Vector+0xffc0177f>

ffc0185b <.LBE391>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_SP_NAK);
ffc0185b:	88 9f                         	mov.b	3[r1], r7

ffc0185d <.LBB392>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc0185d:	fb 26 98                      	mov.l	#-104, r2

ffc01860 <.LBE392>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_SP_NAK);
ffc01860:	5b 77                         	movu.b	r7, r7
ffc01862:	fe 67 47                      	mov.l	[r7, r4], r7

ffc01865 <.LBB395>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01865:	88 f9                         	mov.b	3[r7], r1

ffc01867 <.LVL69>:
ffc01867:	05 15 fb ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc0186b <.LVL70>:
ffc0186b:	38 10 ff                      	bra.w	ffc0177b <_Reset_Vector+0xffc0177f>

ffc0186e <.LBE395>:
ffc0186e:	ef 00                         	nop	; mov.l	r0, r0

ffc01870 <_riic_advance>:
{
ffc01870:	6e 6b                         	pushm	r6-r11
ffc01872:	60 40                         	sub	#4, r0

ffc01874 <.LBB430>:
    switch (g_riic_ChStatus[p_riic_info->ch_no])
ffc01874:	fb a2 70 06 00 00             	mov.l	#0x670, r10

ffc0187a <.LBE430>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc0187a:	88 9e                         	mov.b	3[r1], r6

ffc0187c <.LVL72>:
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffc0187c:	cd 1b 03                      	mov.b	3[r1], r11

ffc0187f <.LBB437>:
    switch (g_riic_ChStatus[p_riic_info->ch_no])
ffc0187f:	b0 9f                         	movu.b	3[r1], r7
ffc01881:	fe c7 a5                      	movu.b	[r7, r10], r5
ffc01884:	61 45                         	cmp	#4, r5
ffc01886:	20 26                         	beq.b	ffc018ac <_Reset_Vector+0xffc018b0>
ffc01888:	25 13                         	bleu.b	ffc0189b <_Reset_Vector+0xffc0189f>
ffc0188a:	61 55                         	cmp	#5, r5
ffc0188c:	20 1c                         	beq.b	ffc018a8 <_Reset_Vector+0xffc018ac>
            ret = RIIC_ERR_OTHER;
ffc0188e:	61 65                         	cmp	#6, r5
ffc01890:	66 85                         	mov.l	#8, r5
ffc01892:	fd 74 e5 07                   	stz	#7, r5

ffc01896 <.LBE437>:
} /* End of function riic_advance() */
ffc01896:	ef 51                         	mov.l	r5, r1
ffc01898:	3f 6b 07                      	rtsd	#28, r6-r11

ffc0189b <.LBB438>:
            ret = RIIC_ERR_OTHER;
ffc0189b:	61 05                         	cmp	#0, r5
ffc0189d:	66 85                         	mov.l	#8, r5
ffc0189f:	fd 74 e5 04                   	stz	#4, r5

ffc018a3 <.LBE438>:
} /* End of function riic_advance() */
ffc018a3:	ef 51                         	mov.l	r5, r1

ffc018a5 <.LVL76>:
ffc018a5:	3f 6b 07                      	rtsd	#28, r6-r11

ffc018a8 <.LBB439>:
            ret = RIIC_ERR_AL;
ffc018a8:	66 65                         	mov.l	#6, r5
ffc018aa:	2e ec                         	bra.b	ffc01896 <_Reset_Vector+0xffc0189a>
            if ((((RIIC_NO_INIT == p_riic_info->dev_sts) || (RIIC_IDLE == p_riic_info->dev_sts))
ffc018ac:	b0 97                         	movu.b	2[r1], r7
ffc018ae:	61 07                         	cmp	#0, r7
ffc018b0:	3a 17 02                      	beq.w	ffc01ac7 <_Reset_Vector+0xffc01acb>
ffc018b3:	b0 97                         	movu.b	2[r1], r7
ffc018b5:	61 17                         	cmp	#1, r7
ffc018b7:	3a 10 02                      	beq.w	ffc01ac7 <_Reset_Vector+0xffc01acb>
                    || (RIIC_FINISH == p_riic_info->dev_sts)) || (RIIC_NACK == p_riic_info->dev_sts))
ffc018ba:	b0 97                         	movu.b	2[r1], r7
ffc018bc:	61 27                         	cmp	#2, r7
ffc018be:	3a 09 02                      	beq.w	ffc01ac7 <_Reset_Vector+0xffc01acb>
ffc018c1:	b0 97                         	movu.b	2[r1], r7
ffc018c3:	61 37                         	cmp	#3, r7
ffc018c5:	3a 02 02                      	beq.w	ffc01ac7 <_Reset_Vector+0xffc01acb>
            else if (RIIC_COMMUNICATION == p_riic_info->dev_sts)
ffc018c8:	b0 97                         	movu.b	2[r1], r7
ffc018ca:	61 47                         	cmp	#4, r7
ffc018cc:	20 15                         	beq.b	ffc018e1 <_Reset_Vector+0xffc018e5>
            else if (RIIC_TMO == p_riic_info->dev_sts)
ffc018ce:	b0 97                         	movu.b	2[r1], r7
ffc018d0:	61 67                         	cmp	#6, r7
ffc018d2:	3a e7 02                      	beq.w	ffc01bb9 <_Reset_Vector+0xffc01bbd>
            else if (RIIC_AL == p_riic_info->dev_sts)
ffc018d5:	b0 95                         	movu.b	2[r1], r5
                ret = RIIC_ERR_AL;
ffc018d7:	61 55                         	cmp	#5, r5
ffc018d9:	66 65                         	mov.l	#6, r5
ffc018db:	fd 74 f5 08                   	stnz	#8, r5
ffc018df:	2e b7                         	bra.b	ffc01896 <_Reset_Vector+0xffc0189a>

ffc018e1 <.LBE439>:
    if (RIIC_EV_INIT != riic_api_event[p_riic_info->ch_no])
ffc018e1:	88 9f                         	mov.b	3[r1], r7
ffc018e3:	fb 42 8c 04 00 00             	mov.l	#0x48c, r4
ffc018e9:	5b 77                         	movu.b	r7, r7
ffc018eb:	fe 67 47                      	mov.l	[r7, r4], r7
ffc018ee:	61 07                         	cmp	#0, r7
ffc018f0:	3a d7 01                      	beq.w	ffc01ac7 <_Reset_Vector+0xffc01acb>
ffc018f3:	ef 17                         	mov.l	r1, r7
        ret = riic_func_table(riic_api_event[p_riic_info->ch_no], p_riic_info);
ffc018f5:	88 9b                         	mov.b	3[r1], r3

ffc018f7 <.LBB440>:
    n_status = riic_api_info[p_riic_info->ch_no].N_status;
ffc018f7:	b0 9d                         	movu.b	3[r1], r5
ffc018f9:	6c 45                         	shll	#4, r5
ffc018fb:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01901:	a8 d5                         	mov.l	8[r5], r5

ffc01903 <.LVL80>:
    if ((RIIC_STS_MAX > n_status) && (RIIC_EV_MAX > event))
ffc01903:	61 a5                         	cmp	#10, r5
ffc01905:	25 05                         	bleu.b	ffc0190a <_Reset_Vector+0xffc0190e>
ffc01907:	38 b2 01                      	bra.w	ffc01ab9 <_Reset_Vector+0xffc01abd>

ffc0190a <.LBE440>:
        ret = riic_func_table(riic_api_event[p_riic_info->ch_no], p_riic_info);
ffc0190a:	5b 33                         	movu.b	r3, r3

ffc0190c <.LVL82>:
ffc0190c:	fe 63 43                      	mov.l	[r3, r4], r3

ffc0190f <.LBB444>:
    if ((RIIC_STS_MAX > n_status) && (RIIC_EV_MAX > event))
ffc0190f:	61 a3                         	cmp	#10, r3
ffc01911:	25 05                         	bleu.b	ffc01916 <_Reset_Vector+0xffc0191a>
ffc01913:	38 a6 01                      	bra.w	ffc01ab9 <_Reset_Vector+0xffc01abd>
        if (NULL != gc_riic_mtx_tbl[n_status][event].proc)
ffc01916:	63 b5                         	mul	#11, r5

ffc01918 <.LVL84>:
ffc01918:	4b 35                         	add	r3, r5
ffc0191a:	6c 35                         	shll	#3, r5
ffc0191c:	70 55 60 69 c0 ff             	add	#0xffc06960, r5, r5
ffc01922:	a8 5b                         	mov.l	4[r5], r3
ffc01924:	61 03                         	cmp	#0, r3
ffc01926:	3a 93 01                      	beq.w	ffc01ab9 <_Reset_Vector+0xffc01abd>

ffc01929 <.LVL85>:
            riic_api_event[p_riic_info->ch_no] = RIIC_EV_INIT;
ffc01929:	88 9d                         	mov.b	3[r1], r5
ffc0192b:	5b 55                         	movu.b	r5, r5
ffc0192d:	66 02                         	mov.l	#0, r2
ffc0192f:	fe 25 42                      	mov.l	r2, [r5, r4]
            ret = (*pFunc)(p_riic_info);
ffc01932:	7f 13                         	jsr	r3

ffc01934 <.LBE444>:
        switch (ret)
ffc01934:	71 15 00                      	add	#0, r1, r5
ffc01937:	3b 84 01                      	bne.w	ffc01abb <_Reset_Vector+0xffc01abf>
                if (RIIC_STS_TMO == riic_api_info[p_riic_info->ch_no].N_status)
ffc0193a:	b0 fc                         	movu.b	3[r7], r4
ffc0193c:	6c 44                         	shll	#4, r4
ffc0193e:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01944:	a8 c4                         	mov.l	8[r4], r4
ffc01946:	61 a4                         	cmp	#10, r4
                    if ((((((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc01948:	b0 fc                         	movu.b	3[r7], r4
                if (RIIC_STS_TMO == riic_api_info[p_riic_info->ch_no].N_status)
ffc0194a:	3a 82 01                      	beq.w	ffc01acc <_Reset_Vector+0xffc01ad0>
                else if (((RIIC_STS_SP_COND_WAIT != riic_api_info[p_riic_info->ch_no].N_status)
ffc0194d:	6c 44                         	shll	#4, r4
ffc0194f:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01955:	a8 c4                         	mov.l	8[r4], r4
ffc01957:	61 84                         	cmp	#8, r4
ffc01959:	3b 3d ff                      	bne.w	ffc01896 <_Reset_Vector+0xffc0189a>
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc0195c:	5b 64                         	movu.b	r6, r4
ffc0195e:	6c 54                         	shll	#5, r4
ffc01960:	73 44 09 83 08                	add	#0x88309, r4, r4
                        || (0x00 != ((*picsr2_reg) & RIIC_ICSR2_STOP))) || (0x00 != ((*picier_reg) & RIIC_ICIER_SP)))
ffc01965:	cc 43                         	mov.b	[r4], r3
ffc01967:	7c 33                         	btst	#3, r3
ffc01969:	3b 2d ff                      	bne.w	ffc01896 <_Reset_Vector+0xffc0189a>
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffc0196c:	5b b6                         	movu.b	r11, r6

ffc0196e <.LVL87>:
ffc0196e:	6c 56                         	shll	#5, r6
ffc01970:	73 66 07 83 08                	add	#0x88307, r6, r6
                        || (0x00 != ((*picsr2_reg) & RIIC_ICSR2_STOP))) || (0x00 != ((*picier_reg) & RIIC_ICIER_SP)))
ffc01975:	cc 63                         	mov.b	[r6], r3
ffc01977:	7c 33                         	btst	#3, r3
ffc01979:	3b 1d ff                      	bne.w	ffc01896 <_Reset_Vector+0xffc0189a>
                    if (RIIC_ICSR2_AL == ((*picsr2_reg) & RIIC_ICSR2_AL))
ffc0197c:	cc 43                         	mov.b	[r4], r3
ffc0197e:	7c 13                         	btst	#1, r3
ffc01980:	3a fa 02                      	beq.w	ffc01c7a <_Reset_Vector+0xffc01c7e>
                        if (((RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc01983:	b0 fc                         	movu.b	3[r7], r4
ffc01985:	6c 44                         	shll	#4, r4
ffc01987:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc0198d:	ec 44                         	mov.l	[r4], r4
ffc0198f:	61 44                         	cmp	#4, r4
ffc01991:	3a 4b 03                      	beq.w	ffc01cdc <_Reset_Vector+0xffc01ce0>
                                || (RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc01994:	b0 fc                         	movu.b	3[r7], r4
ffc01996:	6c 44                         	shll	#4, r4
ffc01998:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc0199e:	ec 44                         	mov.l	[r4], r4
ffc019a0:	61 54                         	cmp	#5, r4
ffc019a2:	3a 3a 03                      	beq.w	ffc01cdc <_Reset_Vector+0xffc01ce0>
                                || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc019a5:	b0 fc                         	movu.b	3[r7], r4
ffc019a7:	6c 44                         	shll	#4, r4
ffc019a9:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc019af:	ec 44                         	mov.l	[r4], r4
ffc019b1:	61 64                         	cmp	#6, r4
ffc019b3:	3a 29 03                      	beq.w	ffc01cdc <_Reset_Vector+0xffc01ce0>
ffc019b6:	ef 00                         	nop	; mov.l	r0, r0
                        riic_set_ch_status(priic_info_m[p_riic_info->ch_no], RIIC_AL);
ffc019b8:	b0 fc                         	movu.b	3[r7], r4
ffc019ba:	fb 32 a4 04 00 00             	mov.l	#0x4a4, r3
ffc019c0:	fe 64 33                      	mov.l	[r4, r3], r3

ffc019c3 <.LBB445>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc019c3:	b0 bc                         	movu.b	3[r3], r4
ffc019c5:	66 51                         	mov.l	#5, r1
ffc019c7:	fe 04 a1                      	mov.b	r1, [r4, r10]
    p_riic_info->dev_sts = status;
ffc019ca:	80 b1                         	mov.b	r1, 2[r3]

ffc019cc <.LVL89>:
                    if ((((((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc019cc:	59 7a 03                      	movu.b	3[r7], r10
ffc019cf:	6c 4a                         	shll	#4, r10
ffc019d1:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc019d7:	ec aa                         	mov.l	[r10], r10
ffc019d9:	61 1a                         	cmp	#1, r10
ffc019db:	3a e3 01                      	beq.w	ffc01bbe <_Reset_Vector+0xffc01bc2>
                            || (RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc019de:	59 7a 03                      	movu.b	3[r7], r10
ffc019e1:	6c 4a                         	shll	#4, r10
ffc019e3:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc019e9:	ed aa 01                      	mov.l	4[r10], r10
ffc019ec:	61 1a                         	cmp	#1, r10
ffc019ee:	3a d0 01                      	beq.w	ffc01bbe <_Reset_Vector+0xffc01bc2>
                            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc019f1:	59 7a 03                      	movu.b	3[r7], r10
ffc019f4:	6c 4a                         	shll	#4, r10
ffc019f6:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc019fc:	ec aa                         	mov.l	[r10], r10
ffc019fe:	61 2a                         	cmp	#2, r10
ffc01a00:	3a be 01                      	beq.w	ffc01bbe <_Reset_Vector+0xffc01bc2>
                            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc01a03:	59 7a 03                      	movu.b	3[r7], r10
ffc01a06:	6c 4a                         	shll	#4, r10
ffc01a08:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01a0e:	ed aa 01                      	mov.l	4[r10], r10
ffc01a11:	61 2a                         	cmp	#2, r10
ffc01a13:	3a ab 01                      	beq.w	ffc01bbe <_Reset_Vector+0xffc01bc2>
                            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc01a16:	59 7a 03                      	movu.b	3[r7], r10
ffc01a19:	6c 4a                         	shll	#4, r10
ffc01a1b:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01a21:	ec aa                         	mov.l	[r10], r10
ffc01a23:	61 3a                         	cmp	#3, r10
ffc01a25:	3a 99 01                      	beq.w	ffc01bbe <_Reset_Vector+0xffc01bc2>
                            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc01a28:	59 7a 03                      	movu.b	3[r7], r10
ffc01a2b:	6c 4a                         	shll	#4, r10
ffc01a2d:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01a33:	ed aa 01                      	mov.l	4[r10], r10
ffc01a36:	61 3a                         	cmp	#3, r10
ffc01a38:	3a 86 01                      	beq.w	ffc01bbe <_Reset_Vector+0xffc01bc2>
                    if ((RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc01a3b:	59 7a 03                      	movu.b	3[r7], r10
ffc01a3e:	6c 4a                         	shll	#4, r10
ffc01a40:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01a46:	ec aa                         	mov.l	[r10], r10
ffc01a48:	61 5a                         	cmp	#5, r10
ffc01a4a:	3a 0e 02                      	beq.w	ffc01c58 <_Reset_Vector+0xffc01c5c>
                            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc01a4d:	59 7a 03                      	movu.b	3[r7], r10
ffc01a50:	6c 4a                         	shll	#4, r10
ffc01a52:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01a58:	ec aa                         	mov.l	[r10], r10
ffc01a5a:	61 6a                         	cmp	#6, r10
ffc01a5c:	3a fc 01                      	beq.w	ffc01c58 <_Reset_Vector+0xffc01c5c>
ffc01a5f:	03                            	nop
                    if ((RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc01a60:	59 7a 03                      	movu.b	3[r7], r10
ffc01a63:	6c 4a                         	shll	#4, r10
ffc01a65:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01a6b:	ec aa                         	mov.l	[r10], r10
ffc01a6d:	61 4a                         	cmp	#4, r10
ffc01a6f:	3a 71 01                      	beq.w	ffc01be0 <_Reset_Vector+0xffc01be4>
                            || (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc01a72:	59 7a 03                      	movu.b	3[r7], r10
ffc01a75:	6c 4a                         	shll	#4, r10
ffc01a77:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01a7d:	ed aa 01                      	mov.l	4[r10], r10
ffc01a80:	61 4a                         	cmp	#4, r10
ffc01a82:	3a 5e 01                      	beq.w	ffc01be0 <_Reset_Vector+0xffc01be4>

ffc01a85 <.LBB447>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01a85:	cd 7a 03                      	mov.b	3[r7], r10

ffc01a88 <.LBB453>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01a88:	88 ff                         	mov.b	3[r7], r7

ffc01a8a <.LBB459>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01a8a:	5b aa                         	movu.b	r10, r10

ffc01a8c <.LBE459>:
                        *picier_reg = RIIC_ICIER_INIT;
ffc01a8c:	f8 64 00                      	mov.b	#0, [r6]

ffc01a8f <.LBB460>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01a8f:	5b 77                         	movu.b	r7, r7

ffc01a91 <.LBB461>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01a91:	6c 4a                         	shll	#4, r10

ffc01a93 <.LBB462>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01a93:	6c 47                         	shll	#4, r7

ffc01a95 <.LBB463>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01a95:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01a9b:	e4 aa 01                      	mov.l	[r10], 4[r10]

ffc01a9e <.LBB464>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01a9e:	70 77 5c 04 00 00             	add	#0x45c, r7, r7

ffc01aa4 <.LBB465>:
    riic_api_info[ch_no].N_Mode = new_mode;
ffc01aa4:	f8 a6 00                      	mov.l	#0, [r10]

ffc01aa7 <.LBB466>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01aa7:	e5 77 02 03                   	mov.l	8[r7], 12[r7]
    riic_api_info[ch_no].N_status = new_status;
ffc01aab:	3e 72 01                      	mov.l	#1, 8[r7]

ffc01aae <.LBE466>:
                        while (RIIC_ICIER_INIT != (*picier_reg))
ffc01aae:	ef 00                         	nop	; mov.l	r0, r0
ffc01ab0:	58 67                         	movu.b	[r6], r7
ffc01ab2:	61 07                         	cmp	#0, r7
ffc01ab4:	21 fc                         	bne.b	ffc01ab0 <_Reset_Vector+0xffc01ab4>
ffc01ab6:	38 e0 fd                      	bra.w	ffc01896 <_Reset_Vector+0xffc0189a>

ffc01ab9 <.LBB467>:
        ret = RIIC_ERR_OTHER;
ffc01ab9:	66 85                         	mov.l	#8, r5

ffc01abb <.LBB468>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc01abb:	b0 fc                         	movu.b	3[r7], r4
ffc01abd:	66 71                         	mov.l	#7, r1
ffc01abf:	fe 04 a1                      	mov.b	r1, [r4, r10]
    p_riic_info->dev_sts = status;
ffc01ac2:	80 f1                         	mov.b	r1, 2[r7]
ffc01ac4:	38 d2 fd                      	bra.w	ffc01896 <_Reset_Vector+0xffc0189a>

ffc01ac7 <.LBB470>:
                ret = RIIC_ERR_OTHER;
ffc01ac7:	66 85                         	mov.l	#8, r5
ffc01ac9:	38 cd fd                      	bra.w	ffc01896 <_Reset_Vector+0xffc0189a>

ffc01acc <.LBE470>:
                    if ((((((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc01acc:	6c 44                         	shll	#4, r4
ffc01ace:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01ad4:	ec 44                         	mov.l	[r4], r4
ffc01ad6:	61 14                         	cmp	#1, r4
ffc01ad8:	3a ae 00                      	beq.w	ffc01b86 <_Reset_Vector+0xffc01b8a>
                            || (RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc01adb:	b0 fc                         	movu.b	3[r7], r4
ffc01add:	6c 44                         	shll	#4, r4
ffc01adf:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01ae5:	a8 4c                         	mov.l	4[r4], r4
ffc01ae7:	61 14                         	cmp	#1, r4
ffc01ae9:	3a 9d 00                      	beq.w	ffc01b86 <_Reset_Vector+0xffc01b8a>
                            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc01aec:	b0 fc                         	movu.b	3[r7], r4
ffc01aee:	6c 44                         	shll	#4, r4
ffc01af0:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01af6:	ec 44                         	mov.l	[r4], r4
ffc01af8:	61 24                         	cmp	#2, r4
ffc01afa:	3a 8c 00                      	beq.w	ffc01b86 <_Reset_Vector+0xffc01b8a>
                            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc01afd:	b0 fc                         	movu.b	3[r7], r4
ffc01aff:	6c 44                         	shll	#4, r4
ffc01b01:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01b07:	a8 4c                         	mov.l	4[r4], r4
ffc01b09:	61 24                         	cmp	#2, r4
ffc01b0b:	20 7b                         	beq.b	ffc01b86 <_Reset_Vector+0xffc01b8a>
                            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc01b0d:	b0 fc                         	movu.b	3[r7], r4
ffc01b0f:	6c 44                         	shll	#4, r4
ffc01b11:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01b17:	ec 44                         	mov.l	[r4], r4
ffc01b19:	61 34                         	cmp	#3, r4
ffc01b1b:	20 6b                         	beq.b	ffc01b86 <_Reset_Vector+0xffc01b8a>
                            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffc01b1d:	b0 fc                         	movu.b	3[r7], r4
ffc01b1f:	6c 44                         	shll	#4, r4
ffc01b21:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01b27:	a8 4c                         	mov.l	4[r4], r4
ffc01b29:	61 34                         	cmp	#3, r4
ffc01b2b:	20 5b                         	beq.b	ffc01b86 <_Reset_Vector+0xffc01b8a>
ffc01b2d:	fc 13 00                      	nop	; max	r0, r0
                    if ((RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc01b30:	b0 fc                         	movu.b	3[r7], r4
ffc01b32:	6c 44                         	shll	#4, r4
ffc01b34:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01b3a:	ec 44                         	mov.l	[r4], r4
ffc01b3c:	61 54                         	cmp	#5, r4
ffc01b3e:	20 13                         	beq.b	ffc01b51 <_Reset_Vector+0xffc01b55>
                            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc01b40:	b0 fc                         	movu.b	3[r7], r4
ffc01b42:	6c 44                         	shll	#4, r4
ffc01b44:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc01b4a:	ec 44                         	mov.l	[r4], r4
ffc01b4c:	61 64                         	cmp	#6, r4
ffc01b4e:	3b 48 fd                      	bne.w	ffc01896 <_Reset_Vector+0xffc0189a>
                        riic_set_ch_status(priic_info_s[p_riic_info->ch_no], RIIC_TMO);
ffc01b51:	88 fc                         	mov.b	3[r7], r4
                        if (NULL != g_riic_callbackfunc_s[p_riic_info->ch_no])
ffc01b53:	fb 22 80 06 00 00             	mov.l	#0x680, r2
                        riic_set_ch_status(priic_info_s[p_riic_info->ch_no], RIIC_TMO);
ffc01b59:	5b 44                         	movu.b	r4, r4
ffc01b5b:	fb 32 98 04 00 00             	mov.l	#0x498, r3
ffc01b61:	fe 64 33                      	mov.l	[r4, r3], r3

ffc01b64 <.LBB471>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc01b64:	b0 bc                         	movu.b	3[r3], r4
ffc01b66:	66 61                         	mov.l	#6, r1
ffc01b68:	fe 04 a1                      	mov.b	r1, [r4, r10]
    p_riic_info->dev_sts = status;
ffc01b6b:	80 b1                         	mov.b	r1, 2[r3]

ffc01b6d <.LVL101>:
                        if (NULL != g_riic_callbackfunc_s[p_riic_info->ch_no])
ffc01b6d:	59 7a 03                      	movu.b	3[r7], r10
ffc01b70:	fe 6a 2a                      	mov.l	[r10, r2], r10
ffc01b73:	61 0a                         	cmp	#0, r10
ffc01b75:	3a 21 fd                      	beq.w	ffc01896 <_Reset_Vector+0xffc0189a>
                            g_riic_callbackfunc_s[p_riic_info->ch_no]();
ffc01b78:	b0 ff                         	movu.b	3[r7], r7

ffc01b7a <.LVL102>:
ffc01b7a:	fe 67 27                      	mov.l	[r7, r2], r7
ffc01b7d:	e3 05                         	mov.l	r5, [r0]
ffc01b7f:	7f 17                         	jsr	r7
ffc01b81:	ec 05                         	mov.l	[r0], r5
ffc01b83:	38 13 fd                      	bra.w	ffc01896 <_Reset_Vector+0xffc0189a>

ffc01b86 <.LVL104>:
                        riic_set_ch_status(priic_info_m[p_riic_info->ch_no], RIIC_TMO);
ffc01b86:	88 fc                         	mov.b	3[r7], r4
                        if (NULL != g_riic_callbackfunc_m[p_riic_info->ch_no])
ffc01b88:	fb 22 74 06 00 00             	mov.l	#0x674, r2
                        riic_set_ch_status(priic_info_m[p_riic_info->ch_no], RIIC_TMO);
ffc01b8e:	5b 44                         	movu.b	r4, r4
ffc01b90:	fb 32 a4 04 00 00             	mov.l	#0x4a4, r3
ffc01b96:	fe 64 33                      	mov.l	[r4, r3], r3

ffc01b99 <.LBB473>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc01b99:	b0 bc                         	movu.b	3[r3], r4
ffc01b9b:	66 61                         	mov.l	#6, r1
ffc01b9d:	fe 04 a1                      	mov.b	r1, [r4, r10]
    p_riic_info->dev_sts = status;
ffc01ba0:	80 b1                         	mov.b	r1, 2[r3]

ffc01ba2 <.LVL106>:
                        if (NULL != g_riic_callbackfunc_m[p_riic_info->ch_no])
ffc01ba2:	b0 fc                         	movu.b	3[r7], r4
ffc01ba4:	fe 64 24                      	mov.l	[r4, r2], r4
ffc01ba7:	61 04                         	cmp	#0, r4
ffc01ba9:	20 87                         	beq.b	ffc01b30 <_Reset_Vector+0xffc01b34>
                            g_riic_callbackfunc_m[p_riic_info->ch_no]();
ffc01bab:	b0 fc                         	movu.b	3[r7], r4
ffc01bad:	fe 64 24                      	mov.l	[r4, r2], r4
ffc01bb0:	e3 05                         	mov.l	r5, [r0]
ffc01bb2:	7f 14                         	jsr	r4
ffc01bb4:	ec 05                         	mov.l	[r0], r5
ffc01bb6:	38 7a ff                      	bra.w	ffc01b30 <_Reset_Vector+0xffc01b34>

ffc01bb9 <.LBB475>:
                ret = RIIC_ERR_TMO;
ffc01bb9:	66 75                         	mov.l	#7, r5
ffc01bbb:	38 db fc                      	bra.w	ffc01896 <_Reset_Vector+0xffc0189a>

ffc01bbe <.LBE475>:
                        if (NULL != g_riic_callbackfunc_m[p_riic_info->ch_no])
ffc01bbe:	cd 7a 03                      	mov.b	3[r7], r10
ffc01bc1:	fb 42 74 06 00 00             	mov.l	#0x674, r4
ffc01bc7:	5b aa                         	movu.b	r10, r10
ffc01bc9:	fe 6a 4a                      	mov.l	[r10, r4], r10
ffc01bcc:	61 0a                         	cmp	#0, r10
ffc01bce:	3a 6d fe                      	beq.w	ffc01a3b <_Reset_Vector+0xffc01a3f>
                            g_riic_callbackfunc_m[p_riic_info->ch_no]();
ffc01bd1:	59 7a 03                      	movu.b	3[r7], r10
ffc01bd4:	fe 6a 4a                      	mov.l	[r10, r4], r10
ffc01bd7:	e3 05                         	mov.l	r5, [r0]
ffc01bd9:	7f 1a                         	jsr	r10
ffc01bdb:	ec 05                         	mov.l	[r0], r5
ffc01bdd:	38 5e fe                      	bra.w	ffc01a3b <_Reset_Vector+0xffc01a3f>

ffc01be0 <.LBB476>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01be0:	88 fb                         	mov.b	3[r7], r3

ffc01be2 <.LBB483>:
ffc01be2:	88 fc                         	mov.b	3[r7], r4

ffc01be4 <.LBB491>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01be4:	cd 7a 03                      	mov.b	3[r7], r10

ffc01be7 <.LBE491>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01be7:	88 fa                         	mov.b	3[r7], r2

ffc01be9 <.LBB498>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01be9:	5b 33                         	movu.b	r3, r3

ffc01beb <.LBE498>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01beb:	fb 12 98 04 00 00             	mov.l	#0x498, r1
ffc01bf1:	5b 22                         	movu.b	r2, r2

ffc01bf3 <.LBB499>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01bf3:	6c 43                         	shll	#4, r3

ffc01bf5 <.LBB500>:
ffc01bf5:	5b 44                         	movu.b	r4, r4

ffc01bf7 <.LBB501>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01bf7:	5b aa                         	movu.b	r10, r10

ffc01bf9 <.LBB502>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01bf9:	70 33 5c 04 00 00             	add	#0x45c, r3, r3

ffc01bff <.LBE502>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01bff:	fe 62 12                      	mov.l	[r2, r1], r2

ffc01c02 <.LBB503>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01c02:	6c 44                         	shll	#4, r4

ffc01c04 <.LBB504>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01c04:	6c 4a                         	shll	#4, r10

ffc01c06 <.LBB505>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01c06:	e4 33 01                      	mov.l	[r3], 4[r3]

ffc01c09 <.LBB506>:
ffc01c09:	70 44 5c 04 00 00             	add	#0x45c, r4, r4

ffc01c0f <.LBB507>:
    riic_api_info[ch_no].N_Mode = new_mode;
ffc01c0f:	f8 36 00                      	mov.l	#0, [r3]

ffc01c12 <.LBB508>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01c12:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10

ffc01c18 <.LBE509>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01c18:	a9 2b                         	mov.l	20[r2], r3

ffc01c1a <.LBB510>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffc01c1a:	e4 44 01                      	mov.l	[r4], 4[r4]

ffc01c1d <.LBB511>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01c1d:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]

ffc01c21 <.LBB512>:
    riic_api_info[ch_no].N_Mode = new_mode;
ffc01c21:	f8 46 04                      	mov.l	#4, [r4]

ffc01c24 <.LBB513>:
    riic_api_info[ch_no].N_status = new_status;
ffc01c24:	f9 a6 02 02                   	mov.l	#2, 8[r10]

ffc01c28 <.LBE513>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01c28:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc01c2e:	20 5e                         	beq.b	ffc01c8c <_Reset_Vector+0xffc01c90>
                                && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01c30:	59 7a 03                      	movu.b	3[r7], r10
ffc01c33:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffc01c36:	ed aa 04                      	mov.l	16[r10], r10
ffc01c39:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01c3f:	20 4d                         	beq.b	ffc01c8c <_Reset_Vector+0xffc01c90>
                            riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_RX);
ffc01c41:	88 ff                         	mov.b	3[r7], r7

ffc01c43 <.LBB514>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01c43:	fb 26 a0                      	mov.l	#-96, r2
                            riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX);
ffc01c46:	5b 77                         	movu.b	r7, r7
ffc01c48:	fe 67 17                      	mov.l	[r7, r1], r7

ffc01c4b <.LBB516>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01c4b:	88 f9                         	mov.b	3[r7], r1
ffc01c4d:	e3 05                         	mov.l	r5, [r0]
ffc01c4f:	05 2d f7 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01c53 <.LVL119>:
ffc01c53:	ec 05                         	mov.l	[r0], r5
ffc01c55:	38 41 fc                      	bra.w	ffc01896 <_Reset_Vector+0xffc0189a>

ffc01c58 <.LBE516>:
                        if (NULL != g_riic_callbackfunc_s[p_riic_info->ch_no])
ffc01c58:	cd 7a 03                      	mov.b	3[r7], r10
ffc01c5b:	fb 42 80 06 00 00             	mov.l	#0x680, r4
ffc01c61:	5b aa                         	movu.b	r10, r10
ffc01c63:	fe 6a 4a                      	mov.l	[r10, r4], r10
ffc01c66:	61 0a                         	cmp	#0, r10
ffc01c68:	3a f8 fd                      	beq.w	ffc01a60 <_Reset_Vector+0xffc01a64>
                            g_riic_callbackfunc_s[p_riic_info->ch_no]();
ffc01c6b:	59 7a 03                      	movu.b	3[r7], r10
ffc01c6e:	fe 6a 4a                      	mov.l	[r10, r4], r10
ffc01c71:	e3 05                         	mov.l	r5, [r0]
ffc01c73:	7f 1a                         	jsr	r10
ffc01c75:	ec 05                         	mov.l	[r0], r5
ffc01c77:	38 e9 fd                      	bra.w	ffc01a60 <_Reset_Vector+0xffc01a64>
                    else if (RIIC_ICSR2_NACKF == ((*picsr2_reg) & RIIC_ICSR2_NACKF))
ffc01c7a:	cc 44                         	mov.b	[r4], r4
ffc01c7c:	7c 44                         	btst	#4, r4

ffc01c7e <.LBB519>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc01c7e:	b0 fc                         	movu.b	3[r7], r4

ffc01c80 <.LBE519>:
                    else if (RIIC_ICSR2_NACKF == ((*picsr2_reg) & RIIC_ICSR2_NACKF))
ffc01c80:	20 73                         	beq.b	ffc01cf3 <_Reset_Vector+0xffc01cf7>

ffc01c82 <.LBB522>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc01c82:	66 32                         	mov.l	#3, r2
ffc01c84:	fe 04 a2                      	mov.b	r2, [r4, r10]
    p_riic_info->dev_sts = status;
ffc01c87:	80 f2                         	mov.b	r2, 2[r7]
ffc01c89:	38 43 fd                      	bra.w	ffc019cc <_Reset_Vector+0xffc019d0>

ffc01c8c <.LBE522>:
                        else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01c8c:	59 7a 03                      	movu.b	3[r7], r10
ffc01c8f:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffc01c92:	ed aa 05                      	mov.l	20[r10], r10
ffc01c95:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01c9b:	20 15                         	beq.b	ffc01cb0 <_Reset_Vector+0xffc01cb4>
                                && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01c9d:	59 7a 03                      	movu.b	3[r7], r10
ffc01ca0:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffc01ca3:	ed aa 04                      	mov.l	16[r10], r10
ffc01ca6:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01cac:	20 51                         	beq.b	ffc01cfd <_Reset_Vector+0xffc01d01>
ffc01cae:	ef 00                         	nop	; mov.l	r0, r0
                        else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01cb0:	59 7a 03                      	movu.b	3[r7], r10
ffc01cb3:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffc01cb6:	ed aa 05                      	mov.l	20[r10], r10
ffc01cb9:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01cbf:	3b d7 fb                      	bne.w	ffc01896 <_Reset_Vector+0xffc0189a>
                                && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01cc2:	59 7a 03                      	movu.b	3[r7], r10
ffc01cc5:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffc01cc8:	ed aa 04                      	mov.l	16[r10], r10
ffc01ccb:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01cd1:	3a c5 fb                      	beq.w	ffc01896 <_Reset_Vector+0xffc0189a>
                            riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX);
ffc01cd4:	88 ff                         	mov.b	3[r7], r7

ffc01cd6 <.LBB523>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01cd6:	75 42 20                      	mov.l	#32, r2
ffc01cd9:	38 6d ff                      	bra.w	ffc01c46 <_Reset_Vector+0xffc01c4a>

ffc01cdc <.LVL125>:
                            riic_set_ch_status(priic_info_s[p_riic_info->ch_no], RIIC_FINISH);
ffc01cdc:	b0 fc                         	movu.b	3[r7], r4
ffc01cde:	fb 32 98 04 00 00             	mov.l	#0x498, r3
ffc01ce4:	fe 64 33                      	mov.l	[r4, r3], r3

ffc01ce7 <.LBB525>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc01ce7:	b0 bc                         	movu.b	3[r3], r4
ffc01ce9:	66 22                         	mov.l	#2, r2
ffc01ceb:	fe 04 a2                      	mov.b	r2, [r4, r10]
    p_riic_info->dev_sts = status;
ffc01cee:	80 b2                         	mov.b	r2, 2[r3]
ffc01cf0:	38 c8 fc                      	bra.w	ffc019b8 <_Reset_Vector+0xffc019bc>

ffc01cf3 <.LBB527>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc01cf3:	66 23                         	mov.l	#2, r3
ffc01cf5:	fe 04 a3                      	mov.b	r3, [r4, r10]
    p_riic_info->dev_sts = status;
ffc01cf8:	80 f3                         	mov.b	r3, 2[r7]
ffc01cfa:	38 d2 fc                      	bra.w	ffc019cc <_Reset_Vector+0xffc019d0>

ffc01cfd <.LVL128>:
                            riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX);
ffc01cfd:	88 ff                         	mov.b	3[r7], r7

ffc01cff <.LBB529>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01cff:	fb 26 80                      	mov.l	#-128, r2
ffc01d02:	38 44 ff                      	bra.w	ffc01c46 <_Reset_Vector+0xffc01c4a>

ffc01d05 <.LBE529>:
ffc01d05:	fc 13 00                      	nop	; max	r0, r0

ffc01d08 <_riic_after_gen_start_cond>:
{
ffc01d08:	6e 6a                         	pushm	r6-r10
ffc01d0a:	60 80                         	sub	#8, r0
ffc01d0c:	ef 17                         	mov.l	r1, r7
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc01d0e:	cd 1a 03                      	mov.b	3[r1], r10

ffc01d11 <.LVL132>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc01d11:	88 9d                         	mov.b	3[r1], r5
    switch (riic_api_info[p_riic_info->ch_no].N_Mode)
ffc01d13:	b0 9d                         	movu.b	3[r1], r5
ffc01d15:	6c 45                         	shll	#4, r5
ffc01d17:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01d1d:	ec 55                         	mov.l	[r5], r5
ffc01d1f:	61 25                         	cmp	#2, r5
ffc01d21:	20 6f                         	beq.b	ffc01d90 <_Reset_Vector+0xffc01d94>
ffc01d23:	61 35                         	cmp	#3, r5
ffc01d25:	11                            	beq.s	ffc01d2e <_Reset_Vector+0xffc01d32>
ffc01d26:	61 15                         	cmp	#1, r5
ffc01d28:	16                            	beq.s	ffc01d2e <_Reset_Vector+0xffc01d32>

ffc01d29 <.LVL134>:
            ret = RIIC_ERR_OTHER;
ffc01d29:	66 81                         	mov.l	#8, r1

ffc01d2b <.LVL135>:
} /* End of function riic_after_gen_start_cond() */
ffc01d2b:	3f 6a 07                      	rtsd	#28, r6-r10

ffc01d2e <.LVL136>:
            switch (riic_api_info[p_riic_info->ch_no].B_status)
ffc01d2e:	b0 fd                         	movu.b	3[r7], r5
ffc01d30:	6c 45                         	shll	#4, r5
ffc01d32:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01d38:	a8 dd                         	mov.l	12[r5], r5
ffc01d3a:	61 05                         	cmp	#0, r5
ffc01d3c:	20 ed                         	beq.b	ffc01d29 <_Reset_Vector+0xffc01d2d>
ffc01d3e:	61 25                         	cmp	#2, r5
ffc01d40:	24 05                         	bgtu.b	ffc01d45 <_Reset_Vector+0xffc01d49>
ffc01d42:	38 e0 00                      	bra.w	ffc01e22 <_Reset_Vector+0xffc01e26>
ffc01d45:	61 65                         	cmp	#6, r5
ffc01d47:	21 e2                         	bne.b	ffc01d29 <_Reset_Vector+0xffc01d2d>
                    buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01d49:	a9 f5                         	mov.l	24[r7], r5

ffc01d4b <.LBB572>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01d4b:	cd 7a 03                      	mov.b	3[r7], r10

ffc01d4e <.LBB576>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01d4e:	88 f9                         	mov.b	3[r7], r1

ffc01d50 <.LVL139>:
ffc01d50:	75 42 32                      	mov.l	#50, r2

ffc01d53 <.LBE576>:
                    buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01d53:	cc 55                         	mov.b	[r5], r5

ffc01d55 <.LBB579>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01d55:	5b aa                         	movu.b	r10, r10
ffc01d57:	6c 4a                         	shll	#4, r10
ffc01d59:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10

ffc01d5f <.LBE579>:
                    buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01d5f:	ff 26 55                      	add	r5, r5, r6
                    buf_send_data |= R_CODE;
ffc01d62:	78 06                         	bset	#0, r6

ffc01d64 <.LBB580>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01d64:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffc01d68:	f9 a6 02 05                   	mov.l	#5, 8[r10]

ffc01d6c <.LBB581>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01d6c:	05 10 f6 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01d70 <.LBB582>:
    volatile uint8_t uctmp = 0x00;
ffc01d70:	3c 06 00                      	mov.b	#0, 6[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc01d73:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc01d76:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc01d78:	5b a7                         	movu.b	r10, r7

ffc01d7a <.LVL144>:
ffc01d7a:	6c 57                         	shll	#5, r7
ffc01d7c:	73 77 12 83 08                	add	#0x88312, r7, r7

ffc01d81 <.LVL145>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc01d81:	05 d5 f5 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc01d85 <.LVL146>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc01d85:	c3 76                         	mov.b	r6, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc01d87:	cc 77                         	mov.b	[r7], r7

ffc01d89 <.LBE582>:
    riic_return_t ret = RIIC_SUCCESS;
ffc01d89:	66 01                         	mov.l	#0, r1

ffc01d8b <.LBB585>:
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc01d8b:	81 87                         	mov.b	r7, 6[r0]

ffc01d8d <.LBE585>:
} /* End of function riic_after_gen_start_cond() */
ffc01d8d:	3f 6a 07                      	rtsd	#28, r6-r10

ffc01d90 <.LVL148>:
            buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01d90:	ed 1a 06                      	mov.l	24[r1], r10

ffc01d93 <.LBB586>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01d93:	88 9d                         	mov.b	3[r1], r5

ffc01d95 <.LBE586>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01d95:	88 9c                         	mov.b	3[r1], r4
            buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01d97:	cc a3                         	mov.b	[r10], r3

ffc01d99 <.LBB594>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01d99:	5b 55                         	movu.b	r5, r5

ffc01d9b <.LBE594>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01d9b:	5b 44                         	movu.b	r4, r4

ffc01d9d <.LBB595>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01d9d:	6c 45                         	shll	#4, r5

ffc01d9f <.LBE595>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01d9f:	6c 44                         	shll	#4, r4

ffc01da1 <.LBB596>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01da1:	70 55 5c 04 00 00             	add	#0x45c, r5, r5

ffc01da7 <.LBE596>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01da7:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
            buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01dad:	ff 2a 33                      	add	r3, r3, r10

ffc01db0 <.LBB597>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01db0:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

ffc01db4 <.LBE597>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01db4:	a8 4c                         	mov.l	4[r4], r4

ffc01db6 <.LBB598>:
    riic_api_info[ch_no].N_status = new_status;
ffc01db6:	3e 52 05                      	mov.l	#5, 8[r5]

ffc01db9 <.LBE598>:
            buf_send_data |= R_CODE;
ffc01db9:	78 0a                         	bset	#0, r10

ffc01dbb <.LBB599>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01dbb:	61 44                         	cmp	#4, r4
ffc01dbd:	21 5a                         	bne.b	ffc01e17 <_Reset_Vector+0xffc01e1b>
                if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01dbf:	88 9c                         	mov.b	3[r1], r4
ffc01dc1:	fb 52 98 04 00 00             	mov.l	#0x498, r5
ffc01dc7:	5b 44                         	movu.b	r4, r4
ffc01dc9:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01dcc:	a9 4c                         	mov.l	20[r4], r4
ffc01dce:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc01dd4:	3a e7 00                      	beq.w	ffc01ebb <_Reset_Vector+0xffc01ebf>
                        && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01dd7:	b0 9c                         	movu.b	3[r1], r4
ffc01dd9:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01ddc:	a9 44                         	mov.l	16[r4], r4
ffc01dde:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc01de4:	3a d7 00                      	beq.w	ffc01ebb <_Reset_Vector+0xffc01ebf>
ffc01de7:	03                            	nop
                    riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_NAK_AL | RIIC_ICIER_TX);
ffc01de8:	88 fc                         	mov.b	3[r7], r4

ffc01dea <.LBB600>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01dea:	fb 26 b2                      	mov.l	#-78, r2

ffc01ded <.LBE600>:
                    riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_NAK_AL | RIIC_ICIER_TX);
ffc01ded:	5b 44                         	movu.b	r4, r4
ffc01def:	fe 64 55                      	mov.l	[r4, r5], r5

ffc01df2 <.LBB603>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01df2:	88 d9                         	mov.b	3[r5], r1

ffc01df4 <.LVL153>:
ffc01df4:	05 88 f5 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01df8 <.LBB604>:
    volatile uint8_t uctmp = 0x00;
ffc01df8:	3c 05 00                      	mov.b	#0, 5[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc01dfb:	88 fd                         	mov.b	3[r7], r5
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc01dfd:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc01dff:	5b 57                         	movu.b	r5, r7

ffc01e01 <.LVL155>:
ffc01e01:	6c 57                         	shll	#5, r7
ffc01e03:	73 77 12 83 08                	add	#0x88312, r7, r7

ffc01e08 <.LVL156>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc01e08:	05 4e f5 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc01e0c <.LVL157>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc01e0c:	c3 7a                         	mov.b	r10, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc01e0e:	cc 77                         	mov.b	[r7], r7

ffc01e10 <.LBE604>:
    riic_return_t ret = RIIC_SUCCESS;
ffc01e10:	66 01                         	mov.l	#0, r1

ffc01e12 <.LBB607>:
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc01e12:	81 0f                         	mov.b	r7, 5[r0]

ffc01e14 <.LBE607>:
} /* End of function riic_after_gen_start_cond() */
ffc01e14:	3f 6a 07                      	rtsd	#28, r6-r10

ffc01e17 <.LBB608>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01e17:	88 99                         	mov.b	3[r1], r1

ffc01e19 <.LVL160>:
ffc01e19:	75 42 32                      	mov.l	#50, r2
ffc01e1c:	05 60 f5 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01e20 <.LVL161>:
ffc01e20:	2e d8                         	bra.b	ffc01df8 <_Reset_Vector+0xffc01dfc>

ffc01e22 <.LVL162>:
                    if ((uint8_t *) FIT_NO_PTR == p_riic_info->p_slv_adr) /* Pattern 4 of Master Write */
ffc01e22:	a9 f5                         	mov.l	24[r7], r5
ffc01e24:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffc01e2a:	3a ee 00                      	beq.w	ffc01f18 <_Reset_Vector+0xffc01f1c>
                        buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01e2d:	a9 f4                         	mov.l	24[r7], r4

ffc01e2f <.LBB610>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01e2f:	cd 7a 03                      	mov.b	3[r7], r10

ffc01e32 <.LBE610>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01e32:	88 fd                         	mov.b	3[r7], r5
                        buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01e34:	cc 44                         	mov.b	[r4], r4

ffc01e36 <.LBB617>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01e36:	5b aa                         	movu.b	r10, r10

ffc01e38 <.LBE617>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01e38:	5b 55                         	movu.b	r5, r5

ffc01e3a <.LBB618>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01e3a:	6c 4a                         	shll	#4, r10

ffc01e3c <.LBE618>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01e3c:	6c 45                         	shll	#4, r5

ffc01e3e <.LBB619>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01e3e:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc01e44:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]

ffc01e48 <.LBE619>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01e48:	70 55 5c 04 00 00             	add	#0x45c, r5, r5

ffc01e4e <.LBB620>:
    riic_api_info[ch_no].N_status = new_status;
ffc01e4e:	f9 a6 02 04                   	mov.l	#4, 8[r10]

ffc01e52 <.LBE620>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01e52:	ed 5a 01                      	mov.l	4[r5], r10
                        buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffc01e55:	ff 26 44                      	add	r4, r4, r6

ffc01e58 <.LBB621>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01e58:	61 4a                         	cmp	#4, r10
ffc01e5a:	3b b3 00                      	bne.w	ffc01f0d <_Reset_Vector+0xffc01f11>
                            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01e5d:	cd 7a 03                      	mov.b	3[r7], r10
ffc01e60:	fb 52 98 04 00 00             	mov.l	#0x498, r5
ffc01e66:	5b aa                         	movu.b	r10, r10
ffc01e68:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffc01e6b:	ed aa 05                      	mov.l	20[r10], r10
ffc01e6e:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01e74:	3a 65 01                      	beq.w	ffc01fd9 <_Reset_Vector+0xffc01fdd>
                                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01e77:	59 7a 03                      	movu.b	3[r7], r10
ffc01e7a:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffc01e7d:	ed aa 04                      	mov.l	16[r10], r10
ffc01e80:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01e86:	3a 53 01                      	beq.w	ffc01fd9 <_Reset_Vector+0xffc01fdd>
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffc01e89:	cd 7a 03                      	mov.b	3[r7], r10

ffc01e8c <.LBB622>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01e8c:	fb 26 f2                      	mov.l	#-14, r2

ffc01e8f <.LBE622>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffc01e8f:	5b aa                         	movu.b	r10, r10
ffc01e91:	fe 6a 5a                      	mov.l	[r10, r5], r10

ffc01e94 <.LBB625>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01e94:	cd a1 03                      	mov.b	3[r10], r1

ffc01e97 <.LVL166>:
ffc01e97:	05 e5 f4 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01e9b <.LBB626>:
    volatile uint8_t uctmp = 0x00;
ffc01e9b:	3c 07 00                      	mov.b	#0, 7[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc01e9e:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc01ea1:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc01ea3:	5b a7                         	movu.b	r10, r7

ffc01ea5 <.LVL168>:
ffc01ea5:	6c 57                         	shll	#5, r7
ffc01ea7:	73 77 12 83 08                	add	#0x88312, r7, r7

ffc01eac <.LVL169>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc01eac:	05 aa f4 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc01eb0 <.LVL170>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc01eb0:	c3 76                         	mov.b	r6, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc01eb2:	cc 77                         	mov.b	[r7], r7

ffc01eb4 <.LBE626>:
    riic_return_t ret = RIIC_SUCCESS;
ffc01eb4:	66 01                         	mov.l	#0, r1

ffc01eb6 <.LBB629>:
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc01eb6:	81 8f                         	mov.b	r7, 7[r0]

ffc01eb8 <.LBE629>:
} /* End of function riic_after_gen_start_cond() */
ffc01eb8:	3f 6a 07                      	rtsd	#28, r6-r10

ffc01ebb <.LVL172>:
                else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01ebb:	b0 fc                         	movu.b	3[r7], r4
ffc01ebd:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01ec0:	a9 4c                         	mov.l	20[r4], r4
ffc01ec2:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc01ec8:	20 12                         	beq.b	ffc01eda <_Reset_Vector+0xffc01ede>
                        && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01eca:	b0 fc                         	movu.b	3[r7], r4
ffc01ecc:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01ecf:	a9 44                         	mov.l	16[r4], r4
ffc01ed1:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc01ed7:	3a 11 ff                      	beq.w	ffc01de8 <_Reset_Vector+0xffc01dec>
                else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01eda:	b0 fc                         	movu.b	3[r7], r4
ffc01edc:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01edf:	a9 4c                         	mov.l	20[r4], r4
ffc01ee1:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc01ee7:	3b 11 ff                      	bne.w	ffc01df8 <_Reset_Vector+0xffc01dfc>
                        && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01eea:	b0 fc                         	movu.b	3[r7], r4
ffc01eec:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01eef:	a9 44                         	mov.l	16[r4], r4
ffc01ef1:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc01ef7:	3a 01 ff                      	beq.w	ffc01df8 <_Reset_Vector+0xffc01dfc>
                    riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_NAK_AL | RIIC_ICIER_RX);
ffc01efa:	88 fc                         	mov.b	3[r7], r4

ffc01efc <.LBB630>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01efc:	75 42 32                      	mov.l	#50, r2

ffc01eff <.LBE630>:
                    riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_NAK_AL | RIIC_ICIER_RX);
ffc01eff:	5b 44                         	movu.b	r4, r4
ffc01f01:	fe 64 55                      	mov.l	[r4, r5], r5

ffc01f04 <.LBB633>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01f04:	88 d9                         	mov.b	3[r5], r1

ffc01f06 <.LVL174>:
ffc01f06:	05 76 f4 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01f0a <.LVL175>:
ffc01f0a:	38 ee fe                      	bra.w	ffc01df8 <_Reset_Vector+0xffc01dfc>

ffc01f0d <.LBB634>:
ffc01f0d:	88 f9                         	mov.b	3[r7], r1

ffc01f0f <.LVL177>:
ffc01f0f:	75 42 52                      	mov.l	#82, r2
ffc01f12:	05 6a f4 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01f16 <.LVL178>:
ffc01f16:	2e 85                         	bra.b	ffc01e9b <_Reset_Vector+0xffc01e9f>

ffc01f18 <.LBB636>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc01f18:	88 fd                         	mov.b	3[r7], r5

ffc01f1a <.LBE636>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01f1a:	88 fc                         	mov.b	3[r7], r4

ffc01f1c <.LBB642>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01f1c:	5b 55                         	movu.b	r5, r5

ffc01f1e <.LBE642>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01f1e:	5b 44                         	movu.b	r4, r4

ffc01f20 <.LBB643>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01f20:	6c 45                         	shll	#4, r5

ffc01f22 <.LBE643>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01f22:	6c 44                         	shll	#4, r4

ffc01f24 <.LBB644>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc01f24:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc01f2a:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

ffc01f2e <.LBE644>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01f2e:	70 44 5c 04 00 00             	add	#0x45c, r4, r4

ffc01f34 <.LBB645>:
    riic_api_info[ch_no].N_status = new_status;
ffc01f34:	3e 52 08                      	mov.l	#8, 8[r5]

ffc01f37 <.LBE645>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc01f37:	a8 4d                         	mov.l	4[r4], r5
ffc01f39:	61 45                         	cmp	#4, r5
ffc01f3b:	3b fa 00                      	bne.w	ffc02035 <_Reset_Vector+0xffc02039>
                            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01f3e:	88 fc                         	mov.b	3[r7], r4
ffc01f40:	fb 52 98 04 00 00             	mov.l	#0x498, r5
ffc01f46:	5b 44                         	movu.b	r4, r4
ffc01f48:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01f4b:	a9 4c                         	mov.l	20[r4], r4
ffc01f4d:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc01f53:	3a ee 00                      	beq.w	ffc02041 <_Reset_Vector+0xffc02045>
                                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01f56:	b0 fc                         	movu.b	3[r7], r4
ffc01f58:	fe 64 54                      	mov.l	[r4, r5], r4
ffc01f5b:	a9 44                         	mov.l	16[r4], r4
ffc01f5d:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc01f63:	3a de 00                      	beq.w	ffc02041 <_Reset_Vector+0xffc02045>
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffc01f66:	88 fc                         	mov.b	3[r7], r4

ffc01f68 <.LBB646>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01f68:	fb 26 ba                      	mov.l	#-70, r2

ffc01f6b <.LBE646>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffc01f6b:	5b 44                         	movu.b	r4, r4
ffc01f6d:	fe 64 55                      	mov.l	[r4, r5], r5

ffc01f70 <.LBB649>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc01f70:	88 d9                         	mov.b	3[r5], r1

ffc01f72 <.LVL184>:
ffc01f72:	05 0a f4 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc01f76 <.LVL185>:
ffc01f76:	ef 00                         	nop	; mov.l	r0, r0

ffc01f78 <.LBE649>:
                        for (cnt = RIIC_CFG_SCL_CHECK_COUNTER; (false == scl_low_chk) && (cnt > 0x00000000); cnt--)
ffc01f78:	f8 0a e8 03                   	mov.l	#0x3e8, [r0]
ffc01f7c:	ec 05                         	mov.l	[r0], r5
ffc01f7e:	61 05                         	cmp	#0, r5
ffc01f80:	3a a9 fd                      	beq.w	ffc01d29 <_Reset_Vector+0xffc01d2d>
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc01f83:	5b aa                         	movu.b	r10, r10
ffc01f85:	6c 5a                         	shll	#5, r10

ffc01f87 <.LVL186>:
ffc01f87:	73 aa 00 83 08                	add	#0x88300, r10, r10
ffc01f8c:	76 10 01 00                   	nop	; mul	#1, r0
                            if (RIIC_ICCR1_SCLI_SET != ((*piccr1_reg) & RIIC_ICCR1_SCLI)) /* SCL low ? */
ffc01f90:	cc a5                         	mov.b	[r10], r5
ffc01f92:	7c 15                         	btst	#1, r5
ffc01f94:	21 34                         	bne.b	ffc01fc8 <_Reset_Vector+0xffc01fcc>

ffc01f96 <.LVL187>:
                        for (cnt = RIIC_CFG_SCL_CHECK_COUNTER; (false == scl_low_chk) && (cnt > 0x00000000); cnt--)
ffc01f96:	ec 0a                         	mov.l	[r0], r10
ffc01f98:	60 1a                         	sub	#1, r10
ffc01f9a:	e3 0a                         	mov.l	r10, [r0]

ffc01f9c <.LBB650>:
    volatile uint8_t uctmp = 0x00;
ffc01f9c:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc01f9f:	cd 7a 03                      	mov.b	3[r7], r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc01fa2:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc01fa4:	5b a7                         	movu.b	r10, r7

ffc01fa6 <.LVL189>:
ffc01fa6:	6c 57                         	shll	#5, r7
ffc01fa8:	73 77 09 83 08                	add	#0x88309, r7, r7

ffc01fad <.LVL190>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc01fad:	cc 74                         	mov.b	[r7], r4
ffc01faf:	7c 34                         	btst	#3, r4
ffc01fb1:	13                            	beq.s	ffc01fb4 <_Reset_Vector+0xffc01fb8>
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffc01fb2:	f0 7b                         	bclr	#3, [r7].b
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc01fb4:	5b 57                         	movu.b	r5, r7

ffc01fb6 <.LVL191>:
ffc01fb6:	6c 57                         	shll	#5, r7
ffc01fb8:	73 77 01 83 08                	add	#0x88301, r7, r7

ffc01fbd <.LBE650>:
    riic_return_t ret = RIIC_SUCCESS;
ffc01fbd:	66 01                         	mov.l	#0, r1

ffc01fbf <.LBB653>:
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffc01fbf:	f0 73                         	bset	#3, [r7].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc01fc1:	cc 77                         	mov.b	[r7], r7
ffc01fc3:	81 07                         	mov.b	r7, 4[r0]

ffc01fc5 <.LBE653>:
} /* End of function riic_after_gen_start_cond() */
ffc01fc5:	3f 6a 07                      	rtsd	#28, r6-r10

ffc01fc8 <.LVL192>:
                        for (cnt = RIIC_CFG_SCL_CHECK_COUNTER; (false == scl_low_chk) && (cnt > 0x00000000); cnt--)
ffc01fc8:	ec 05                         	mov.l	[r0], r5
ffc01fca:	60 15                         	sub	#1, r5
ffc01fcc:	e3 05                         	mov.l	r5, [r0]
ffc01fce:	ec 05                         	mov.l	[r0], r5
ffc01fd0:	61 05                         	cmp	#0, r5
ffc01fd2:	21 be                         	bne.b	ffc01f90 <_Reset_Vector+0xffc01f94>
            ret = RIIC_ERR_OTHER;
ffc01fd4:	66 81                         	mov.l	#8, r1
ffc01fd6:	38 55 fd                      	bra.w	ffc01d2b <_Reset_Vector+0xffc01d2f>

ffc01fd9 <.LVL193>:
                            else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01fd9:	59 7a 03                      	movu.b	3[r7], r10
ffc01fdc:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffc01fdf:	ed aa 05                      	mov.l	20[r10], r10
ffc01fe2:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01fe8:	20 14                         	beq.b	ffc01ffc <_Reset_Vector+0xffc02000>
                                    && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc01fea:	59 7a 03                      	movu.b	3[r7], r10
ffc01fed:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffc01ff0:	ed aa 04                      	mov.l	16[r10], r10
ffc01ff3:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc01ff9:	3a 9a 00                      	beq.w	ffc02093 <_Reset_Vector+0xffc02097>
                            else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc01ffc:	59 7a 03                      	movu.b	3[r7], r10
ffc01fff:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffc02002:	ed aa 05                      	mov.l	20[r10], r10
ffc02005:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc0200b:	3b 90 fe                      	bne.w	ffc01e9b <_Reset_Vector+0xffc01e9f>
                                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc0200e:	59 7a 03                      	movu.b	3[r7], r10
ffc02011:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffc02014:	ed aa 04                      	mov.l	16[r10], r10
ffc02017:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc0201d:	3a 7e fe                      	beq.w	ffc01e9b <_Reset_Vector+0xffc01e9f>
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffc02020:	cd 7a 03                      	mov.b	3[r7], r10

ffc02023 <.LBB654>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02023:	75 42 72                      	mov.l	#114, r2

ffc02026 <.LBE654>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffc02026:	5b aa                         	movu.b	r10, r10
ffc02028:	fe 6a 5a                      	mov.l	[r10, r5], r10

ffc0202b <.LBB657>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc0202b:	cd a1 03                      	mov.b	3[r10], r1

ffc0202e <.LVL195>:
ffc0202e:	05 4e f3 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02032 <.LVL196>:
ffc02032:	38 69 fe                      	bra.w	ffc01e9b <_Reset_Vector+0xffc01e9f>

ffc02035 <.LBB658>:
ffc02035:	88 f9                         	mov.b	3[r7], r1

ffc02037 <.LVL198>:
ffc02037:	75 42 1a                      	mov.l	#26, r2
ffc0203a:	05 42 f3 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc0203e <.LVL199>:
ffc0203e:	38 3a ff                      	bra.w	ffc01f78 <_Reset_Vector+0xffc01f7c>

ffc02041 <.LVL200>:
                            else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc02041:	b0 fc                         	movu.b	3[r7], r4
ffc02043:	fe 64 54                      	mov.l	[r4, r5], r4
ffc02046:	a9 4c                         	mov.l	20[r4], r4
ffc02048:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc0204e:	20 12                         	beq.b	ffc02060 <_Reset_Vector+0xffc02064>
                                    && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc02050:	b0 fc                         	movu.b	3[r7], r4
ffc02052:	fe 64 54                      	mov.l	[r4, r5], r4
ffc02055:	a9 44                         	mov.l	16[r4], r4
ffc02057:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc0205d:	20 4b                         	beq.b	ffc020a8 <_Reset_Vector+0xffc020ac>
ffc0205f:	03                            	nop
                            else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc02060:	b0 fc                         	movu.b	3[r7], r4
ffc02062:	fe 64 54                      	mov.l	[r4, r5], r4
ffc02065:	a9 4c                         	mov.l	20[r4], r4
ffc02067:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc0206d:	3b 0b ff                      	bne.w	ffc01f78 <_Reset_Vector+0xffc01f7c>
                                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc02070:	b0 fc                         	movu.b	3[r7], r4
ffc02072:	fe 64 54                      	mov.l	[r4, r5], r4
ffc02075:	a9 44                         	mov.l	16[r4], r4
ffc02077:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc0207d:	3a fb fe                      	beq.w	ffc01f78 <_Reset_Vector+0xffc01f7c>
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffc02080:	88 fc                         	mov.b	3[r7], r4

ffc02082 <.LBB660>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02082:	75 42 3a                      	mov.l	#58, r2

ffc02085 <.LBE660>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffc02085:	5b 44                         	movu.b	r4, r4
ffc02087:	fe 64 55                      	mov.l	[r4, r5], r5

ffc0208a <.LBB663>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc0208a:	88 d9                         	mov.b	3[r5], r1

ffc0208c <.LVL202>:
ffc0208c:	05 f0 f2 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02090 <.LVL203>:
ffc02090:	38 e8 fe                      	bra.w	ffc01f78 <_Reset_Vector+0xffc01f7c>

ffc02093 <.LBE663>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffc02093:	cd 7a 03                      	mov.b	3[r7], r10

ffc02096 <.LBB664>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02096:	fb 26 d2                      	mov.l	#-46, r2

ffc02099 <.LBE664>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffc02099:	5b aa                         	movu.b	r10, r10
ffc0209b:	fe 6a 5a                      	mov.l	[r10, r5], r10

ffc0209e <.LBB667>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc0209e:	cd a1 03                      	mov.b	3[r10], r1

ffc020a1 <.LVL206>:
ffc020a1:	05 db f2 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc020a5 <.LVL207>:
ffc020a5:	38 f6 fd                      	bra.w	ffc01e9b <_Reset_Vector+0xffc01e9f>

ffc020a8 <.LBE667>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffc020a8:	88 fc                         	mov.b	3[r7], r4

ffc020aa <.LBB668>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc020aa:	fb 26 9a                      	mov.l	#-102, r2

ffc020ad <.LBE668>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffc020ad:	5b 44                         	movu.b	r4, r4
ffc020af:	fe 64 55                      	mov.l	[r4, r5], r5

ffc020b2 <.LBB671>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc020b2:	88 d9                         	mov.b	3[r5], r1

ffc020b4 <.LVL210>:
ffc020b4:	05 c8 f2 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc020b8 <.LVL211>:
ffc020b8:	38 c0 fe                      	bra.w	ffc01f78 <_Reset_Vector+0xffc01f7c>

ffc020bb <.LBE671>:
ffc020bb:	77 10 01 00 00                	nop	; mul	#1, r0

ffc020c0 <_riic_init_io_register>:
{
ffc020c0:	6e 6d                         	pushm	r6-r13
ffc020c2:	75 b0 04                      	dpushm.d	dr0-dr4
ffc020c5:	75 a0 10                      	dpushm.l	dcmr-dcmr
ffc020c8:	71 00 d4                      	add	#-44, r0, r0
ffc020cb:	ef 17                         	mov.l	r1, r7
    volatile uint8_t uctmp = 0x00;
ffc020cd:	f9 04 2b 00                   	mov.b	#0, 43[r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc020d1:	88 99                         	mov.b	3[r1], r1

ffc020d3 <.LVL213>:
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffc020d3:	cd 7e 03                      	mov.b	3[r7], r14
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffc020d6:	cd 78 03                      	mov.b	3[r7], r8
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffc020d9:	cd 79 03                      	mov.b	3[r7], r9
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffc020dc:	cd 7c 03                      	mov.b	3[r7], r12
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffc020df:	88 fb                         	mov.b	3[r7], r3
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffc020e1:	88 fc                         	mov.b	3[r7], r4
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc020e3:	88 fa                         	mov.b	3[r7], r2
    volatile uint8_t * const picmr2_reg = RIIC_ICMR2_ADR(p_riic_info->ch_no);
ffc020e5:	88 fe                         	mov.b	3[r7], r6
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc020e7:	cd 7b 03                      	mov.b	3[r7], r11
    volatile uint8_t * const picfer_reg = RIIC_ICFER_ADR(p_riic_info->ch_no);
ffc020ea:	cd 7a 03                      	mov.b	3[r7], r10

ffc020ed <.LBB678>:
 * Arguments    : riic_info_t * p_riic_info      ; IIC Information
 * Return Value : None
 **********************************************************************************************************************/
static void riic_all_reset (riic_info_t * p_riic_info)
{
    volatile uint8_t uctmp = 0x00;
ffc020ed:	f9 04 2a 00                   	mov.b	#0, 42[r0]

    /* Creates the register pointer for the specified RIIC channel. */
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc020f1:	88 fd                         	mov.b	3[r7], r5

ffc020f3 <.LBE678>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc020f3:	5b 11                         	movu.b	r1, r1
ffc020f5:	6c 51                         	shll	#5, r1
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffc020f7:	5b ee                         	movu.b	r14, r14

ffc020f9 <.LBB689>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc020f9:	5b 55                         	movu.b	r5, r5

ffc020fb <.LBE689>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc020fb:	73 11 00 83 08                	add	#0x88300, r1, r1

ffc02100 <.LBB690>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc02100:	6c 55                         	shll	#5, r5

ffc02102 <.LBE690>:
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffc02102:	6c 5e                         	shll	#5, r14

ffc02104 <.LBB691>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc02104:	73 55 00 83 08                	add	#0x88300, r5, r5

ffc02109 <.LBE691>:
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffc02109:	5b 88                         	movu.b	r8, r8

ffc0210b <.LBB692>:

    /* Resets RIIC registers. */
    (*piccr1_reg) &= RIIC_ICCR1_ICE_CLR; /* Clears ICCR1.ICE bit to 0. */
ffc0210b:	cc 5f                         	mov.b	[r5], r15

ffc0210d <.LBE692>:
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffc0210d:	73 ee 0a 83 08                	add	#0x8830a, r14, r14

ffc02112 <.LVL215>:
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffc02112:	6c 58                         	shll	#5, r8
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffc02114:	5b 99                         	movu.b	r9, r9

ffc02116 <.LBB693>:
    (*piccr1_reg) &= RIIC_ICCR1_ICE_CLR; /* Clears ICCR1.ICE bit to 0. */
ffc02116:	75 2f 7f                      	and	#127, r15

ffc02119 <.LBE693>:
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffc02119:	73 88 0b 83 08                	add	#0x8830b, r8, r8

ffc0211e <.LBB694>:
    (*piccr1_reg) &= RIIC_ICCR1_ICE_CLR; /* Clears ICCR1.ICE bit to 0. */
ffc0211e:	c3 5f                         	mov.b	r15, [r5]

ffc02120 <.LBE694>:
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffc02120:	6c 59                         	shll	#5, r9

ffc02122 <.LBB695>:
    (*piccr1_reg) |= RIIC_ICCR1_RIIC_RESET; /* Sets ICCR1.IICRST bit to 1. */
ffc02122:	f0 56                         	bset	#6, [r5].b

    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffc02124:	cc 55                         	mov.b	[r5], r5

ffc02126 <.LBE695>:
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffc02126:	5b cc                         	movu.b	r12, r12
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffc02128:	73 99 0c 83 08                	add	#0x8830c, r9, r9

ffc0212d <.LBB696>:
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffc0212d:	c7 05 2a                      	mov.b	r5, 42[r0]

ffc02130 <.LBE696>:
    (*piccr1_reg) |= RIIC_ICCR1_ICE_SET; /* Sets ICCR1.ICE bit to 1. */
ffc02130:	cc 15                         	mov.b	[r1], r5
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffc02132:	6c 5c                         	shll	#5, r12
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffc02134:	5b 33                         	movu.b	r3, r3
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffc02136:	73 cc 0d 83 08                	add	#0x8830d, r12, r12

ffc0213b <.LVL218>:
    (*piccr1_reg) |= RIIC_ICCR1_ICE_SET; /* Sets ICCR1.ICE bit to 1. */
ffc0213b:	75 35 80                      	or	#-128, r5
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffc0213e:	6c 53                         	shll	#5, r3
    (*piccr1_reg) |= RIIC_ICCR1_ICE_SET; /* Sets ICCR1.ICE bit to 1. */
ffc02140:	c3 15                         	mov.b	r5, [r1]
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffc02142:	5b 44                         	movu.b	r4, r4
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffc02144:	73 33 0e 83 08                	add	#0x8830e, r3, r3

ffc02149 <.LVL219>:
    *psarl0_reg = RIIC_SARL0_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffc02149:	f8 e4 00                      	mov.b	#0, [r14]
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffc0214c:	6c 54                         	shll	#5, r4
    *psaru0_reg = RIIC_SARU0_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffc0214e:	f8 84 00                      	mov.b	#0, [r8]
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc02151:	5b 25                         	movu.b	r2, r5
    *psarl1_reg = RIIC_SARL1_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffc02153:	f8 94 00                      	mov.b	#0, [r9]
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffc02156:	73 44 0f 83 08                	add	#0x8830f, r4, r4

ffc0215b <.LVL220>:
    *psaru1_reg = RIIC_SARU1_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffc0215b:	f8 c4 00                      	mov.b	#0, [r12]
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc0215e:	6c 55                         	shll	#5, r5
    *psarl2_reg = RIIC_SARL2_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffc02160:	f8 34 00                      	mov.b	#0, [r3]
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc02163:	73 55 06 83 08                	add	#0x88306, r5, r5

ffc02168 <.LVL221>:
    *psaru2_reg = RIIC_SARU2_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffc02168:	f8 44 00                      	mov.b	#0, [r4]
    *picser_reg = RIIC_ICSER_INIT; /* Sets ICSER register. */
ffc0216b:	f8 54 00                      	mov.b	#0, [r5]
    uctmp = *picser_reg; /* Reads ICSER. */
ffc0216e:	cc 55                         	mov.b	[r5], r5

ffc02170 <.LVL222>:
    volatile uint8_t * const picmr2_reg = RIIC_ICMR2_ADR(p_riic_info->ch_no);
ffc02170:	5b 66                         	movu.b	r6, r6
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02172:	5b bb                         	movu.b	r11, r11
    volatile uint8_t * const picfer_reg = RIIC_ICFER_ADR(p_riic_info->ch_no);
ffc02174:	5b aa                         	movu.b	r10, r10
    volatile uint8_t * const picmr2_reg = RIIC_ICMR2_ADR(p_riic_info->ch_no);
ffc02176:	6c 56                         	shll	#5, r6
    uctmp = *picser_reg; /* Reads ICSER. */
ffc02178:	c7 05 2b                      	mov.b	r5, 43[r0]

ffc0217b <.LBB697>:
    riic_bps_calc(p_riic_info, g_riic_bps[p_riic_info->ch_no]); /* Set BPS */
ffc0217b:	88 fd                         	mov.b	3[r7], r5

ffc0217d <.LBB699>:
 *              : RIIC_ERR_OTHER                 ; Other error
 **********************************************************************************************************************/
static riic_return_t riic_bps_calc (riic_info_t * p_riic_info, uint16_t kbps)
{
    volatile uint8_t uctmp;
    volatile uint8_t * const picmr1_reg = RIIC_ICMR1_ADR(p_riic_info->ch_no);
ffc0217d:	cd 7c 03                      	mov.b	3[r7], r12

ffc02180 <.LBE697>:
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02180:	6c 5b                         	shll	#5, r11
    volatile uint8_t * const picfer_reg = RIIC_ICFER_ADR(p_riic_info->ch_no);
ffc02182:	6c 5a                         	shll	#5, r10

ffc02184 <.LBB716>:
    riic_bps_calc(p_riic_info, g_riic_bps[p_riic_info->ch_no]); /* Set BPS */
ffc02184:	5b 55                         	movu.b	r5, r5

ffc02186 <.LBB706>:
    volatile uint8_t * const picbrl_reg = RIIC_ICBRL_ADR(p_riic_info->ch_no);
ffc02186:	cd 78 03                      	mov.b	3[r7], r8

ffc02189 <.LBE706>:
    volatile uint8_t * const picmr2_reg = RIIC_ICMR2_ADR(p_riic_info->ch_no);
ffc02189:	73 66 03 83 08                	add	#0x88303, r6, r6

ffc0218e <.LBB707>:

    const uint8_t d_cks[RIIC_MAX_DIV] =
    { 1, 2, 4, 8, 16, 32, 64, 128 }; /* divider array of RIIC clock  */
    double pclk_val;

    volatile double bps = (double) (kbps * 1000);
ffc0218e:	fb 42 58 69 c0 ff             	mov.l	#0xffc06958, r4

ffc02194 <.LVL226>:
ffc02194:	fe d5 4d                      	movu.w	[r5, r4], r13
    volatile uint8_t * const picbrh_reg = RIIC_ICBRH_ADR(p_riic_info->ch_no);
ffc02197:	cd 79 03                      	mov.b	3[r7], r9

ffc0219a <.LBE707>:
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc0219a:	73 bb 04 83 08                	add	#0x88304, r11, r11

ffc0219f <.LBB708>:
    volatile double bps = (double) (kbps * 1000);
ffc0219f:	fb 5a e8 03                   	mov.l	#0x3e8, r5
ffc021a3:	4f d5                         	mul	r13, r5

ffc021a5 <.LBE708>:
    volatile uint8_t * const picfer_reg = RIIC_ICFER_ADR(p_riic_info->ch_no);
ffc021a5:	73 aa 05 83 08                	add	#0x88305, r10, r10

ffc021aa <.LBB709>:
    volatile double bps = (double) (kbps * 1000);
ffc021aa:	fd 77 85 09                   	itod	r5, dr0
    const uint8_t d_cks[RIIC_MAX_DIV] =
ffc021ae:	f8 02 01 02 04 08             	mov.l	#0x8040201, [r0]
    volatile double bps = (double) (kbps * 1000);
ffc021b4:	fc 79 08 08 00                	dmov.d	dr0, 32[r0]
    const uint8_t d_cks[RIIC_MAX_DIV] =
ffc021b9:	f9 02 01 10 20 40 80          	mov.l	#0x80402010, 4[r0]

    double scl_up_time;
    double scl_down_time;
    volatile uint8_t cnt;

    pclk_val = riic_mcu_check_freq(); /* Store pclk frequency */
ffc021c0:	05 fe f2 ff                   	bsr.a	ffc014be <_Reset_Vector+0xffc014c2>

ffc021c4 <.LVL230>:
ffc021c4:	fd 77 81 30                   	dmov.l	r1, drl3
ffc021c8:	fd 77 82 32                   	dmov.l	r2, drh3

ffc021cc <.LVL231>:

    /* Set Rise up time and down time */
    if (kbps > RIIC_FAST_SPPED_MAX)
ffc021cc:	76 0d 90 01                   	cmp	#400, r13
ffc021d0:	24 7e                         	bgtu.b	ffc0224e <_Reset_Vector+0xffc02252>
    {
        /* When bps more than 400Kbps[Fast mode plus] */
        scl_up_time = scl1m_up_time;
        scl_down_time = scl1m_down_time;
    }
    else if (kbps > RIIC_STAD_SPPED_MAX)
ffc021d2:	75 5d 64                      	cmp	#100, r13
ffc021d5:	24 05                         	bgtu.b	ffc021da <_Reset_Vector+0xffc021de>
ffc021d7:	38 8a 02                      	bra.w	ffc02461 <_Reset_Vector+0xffc02465>

ffc021da <.LVL232>:
    }

    /* Calculation for ICBRH and ICBRL registers value */

    /* Calculation L width time */
    L_time = (1 / (2 * bps)); /* Harf period of frequency */
ffc021da:	fc c9 08 08 00                	dmov.d	32[r0], dr0
ffc021df:	f9 03 13 00 00 f0 3f          	dmov.d	#0x3ff00000, drh1
ffc021e6:	76 90 00 00                   	dadd	dr0, dr0, dr0
ffc021ea:	76 90 15 00                   	ddiv	dr0, dr1, dr0
ffc021ee:	fc 79 08 06 00                	dmov.d	dr0, 24[r0]
    }
    else if (kbps > RIIC_STAD_SPPED_MAX)
    {
        /* 100kbps over */
        /* Check L width */
        if (L_time < 1.3E-6)
ffc021f3:	f9 03 00 6b 4e b9 1d          	dmov.l	#0x1db94e6b, drl0
ffc021fa:	f9 03 02 75 cf b5 3e          	dmov.l	#0x3eb5cf75, drh0
    H_time = L_time;
ffc02201:	fc c9 08 06 20                	dmov.d	24[r0], dr2
ffc02206:	fc 79 08 04 20                	dmov.d	dr2, 16[r0]
        if (L_time < 1.3E-6)
ffc0220b:	fc c9 08 06 20                	dmov.d	24[r0], dr2
ffc02210:	76 90 08 62                   	dcmple	dr2, dr0
ffc02214:	75 90 1b                      	mvfdr
ffc02217:	3a dd 02                      	beq.w	ffc024f4 <_Reset_Vector+0xffc024f8>
        {
            /* Wnen L width less than 1.3us */
            /* Subtract Rise up and down time for SCL from H/L width */
            L_time = 1.3E-6;
ffc0221a:	fc 79 08 06 00                	dmov.d	dr0, 24[r0]
            bps_tmp = bps;
ffc0221f:	fc c9 08 08 00                	dmov.d	32[r0], dr0

ffc02224 <.LVL233>:
            H_time = (((1 / bps_tmp) - L_time) - scl_up_time) - scl_down_time;
ffc02224:	fc c9 08 06 20                	dmov.d	24[r0], dr2
ffc02229:	76 90 15 00                   	ddiv	dr0, dr1, dr0

ffc0222d <.LVL234>:
ffc0222d:	76 90 01 02                   	dsub	dr2, dr0, dr0
ffc02231:	f9 03 10 76 83 0d f4          	dmov.l	#0xf40d8376, drl1
ffc02238:	f9 03 12 f5 21 94 3e          	dmov.l	#0x3e9421f5, drh1
ffc0223f:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc02243:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc02247:	fc 79 08 04 00                	dmov.d	dr0, 16[r0]
ffc0224c:	2e 6c                         	bra.b	ffc022b8 <_Reset_Vector+0xffc022bc>

ffc0224e <.LVL235>:
    L_time = (1 / (2 * bps)); /* Harf period of frequency */
ffc0224e:	fc c9 08 08 00                	dmov.d	32[r0], dr0
ffc02253:	f9 03 13 00 00 f0 3f          	dmov.d	#0x3ff00000, drh1
ffc0225a:	76 90 00 00                   	dadd	dr0, dr0, dr0
ffc0225e:	76 90 15 00                   	ddiv	dr0, dr1, dr0
ffc02262:	fc 79 08 06 00                	dmov.d	dr0, 24[r0]
        if (L_time < 0.5E-6)
ffc02267:	f9 03 00 8d ed b5 a0          	dmov.l	#0xa0b5ed8d, drl0
ffc0226e:	f9 03 02 f7 c6 a0 3e          	dmov.l	#0x3ea0c6f7, drh0
    H_time = L_time;
ffc02275:	fc c9 08 06 20                	dmov.d	24[r0], dr2
ffc0227a:	fc 79 08 04 20                	dmov.d	dr2, 16[r0]
        if (L_time < 0.5E-6)
ffc0227f:	fc c9 08 06 20                	dmov.d	24[r0], dr2
ffc02284:	76 90 28 40                   	dcmplt	dr0, dr2
ffc02288:	75 90 1b                      	mvfdr
ffc0228b:	3a 34 02                      	beq.w	ffc024bf <_Reset_Vector+0xffc024c3>
            L_time -= scl_down_time;
ffc0228e:	fc c9 08 06 00                	dmov.d	24[r0], dr0
ffc02293:	f9 03 10 2b 69 a4 29          	dmov.l	#0x29a4692b, drl1
ffc0229a:	f9 03 12 2b 1b 80 3e          	dmov.l	#0x3e801b2b, drh1

ffc022a1 <.LVL236>:
        }
        else
        {
            /* Subtract Rise up and down time for SCL from H/L width */
            L_time -= scl_down_time;
ffc022a1:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc022a5:	fc 79 08 06 00                	dmov.d	dr0, 24[r0]
            H_time -= scl_up_time;
ffc022aa:	fc c9 08 04 00                	dmov.d	16[r0], dr0
ffc022af:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc022b3:	fc 79 08 04 00                	dmov.d	dr0, 16[r0]
    }

    /*************** Calculation ICBRL value ***********************/
    /* Calculating until calc_val is less than 32 */
    /* WAIT_LOOP */
    for (calc_val = 0xFF, cnt = 0; RIIC_ICBR_MAX < calc_val; cnt++)
ffc022b8:	f9 03 03 00 e0 6f 40          	dmov.d	#0x406fe000, drh0
ffc022bf:	fc 79 08 02 00                	dmov.d	dr0, 8[r0]
ffc022c4:	f9 03 03 00 00 40 40          	dmov.d	#0x40400000, drh0
ffc022cb:	f9 04 28 00                   	mov.b	#0, 40[r0]
ffc022cf:	fc c9 08 02 10                	dmov.d	8[r0], dr1
ffc022d4:	76 90 18 60                   	dcmple	dr0, dr1
ffc022d8:	75 90 1b                      	mvfdr
ffc022db:	20 77                         	beq.b	ffc02352 <_Reset_Vector+0xffc02356>
    {
        calc_val = L_time; /* Set L width time */
ffc022dd:	fc c9 08 06 10                	dmov.d	24[r0], dr1
ffc022e2:	fc 79 08 02 10                	dmov.d	dr1, 8[r0]

        /* Check the range of divider of CKS */
        if (cnt >= RIIC_MAX_DIV)
ffc022e7:	59 05 28                      	movu.b	40[r0], r5
ffc022ea:	61 75                         	cmp	#7, r5
ffc022ec:	25 05                         	bleu.b	ffc022f1 <_Reset_Vector+0xffc022f5>
ffc022ee:	38 35 01                      	bra.w	ffc02423 <_Reset_Vector+0xffc02427>
            return RIIC_ERR_OTHER;
        }

        calc_val_tmp = calc_val;
        calc_val = (calc_val_tmp / (d_cks[cnt] / pclk_val));/* Calculattion ICBRL value */
        calc_val = calc_val + 0.5; /* round off */
ffc022f1:	f9 03 43 00 00 e0 3f          	dmov.d	#0x3fe00000, drh4
    for (calc_val = 0xFF, cnt = 0; RIIC_ICBR_MAX < calc_val; cnt++)
ffc022f8:	76 90 0c 10                   	dmov.d	dr0, dr1
ffc022fc:	2e 16                         	bra.b	ffc02312 <_Reset_Vector+0xffc02316>

ffc022fe <.LVL237>:
        calc_val = L_time; /* Set L width time */
ffc022fe:	fc c9 08 06 00                	dmov.d	24[r0], dr0
ffc02303:	fc 79 08 02 00                	dmov.d	dr0, 8[r0]
        if (cnt >= RIIC_MAX_DIV)
ffc02308:	59 05 28                      	movu.b	40[r0], r5
ffc0230b:	61 75                         	cmp	#7, r5
ffc0230d:	25 05                         	bleu.b	ffc02312 <_Reset_Vector+0xffc02316>
ffc0230f:	38 14 01                      	bra.w	ffc02423 <_Reset_Vector+0xffc02427>

ffc02312 <.LVL238>:
        calc_val_tmp = calc_val;
ffc02312:	fc c9 08 02 20                	dmov.d	8[r0], dr2

ffc02317 <.LVL239>:
        calc_val = (calc_val_tmp / (d_cks[cnt] / pclk_val));/* Calculattion ICBRL value */
ffc02317:	59 05 28                      	movu.b	40[r0], r5
ffc0231a:	fe c5 05                      	movu.b	[r5, r0], r5
ffc0231d:	fd 77 85 09                   	itod	r5, dr0
ffc02321:	76 90 05 03                   	ddiv	dr3, dr0, dr0
ffc02325:	76 90 25 00                   	ddiv	dr0, dr2, dr0
ffc02329:	fc 79 08 02 00                	dmov.d	dr0, 8[r0]
        calc_val = calc_val + 0.5; /* round off */
ffc0232e:	fc c9 08 02 00                	dmov.d	8[r0], dr0
ffc02333:	76 90 40 00                   	dadd	dr0, dr4, dr0
ffc02337:	fc 79 08 02 00                	dmov.d	dr0, 8[r0]
    for (calc_val = 0xFF, cnt = 0; RIIC_ICBR_MAX < calc_val; cnt++)
ffc0233c:	cd 05 28                      	mov.b	40[r0], r5
ffc0233f:	62 15                         	add	#1, r5
ffc02341:	c7 05 28                      	mov.b	r5, 40[r0]
ffc02344:	fc c9 08 02 00                	dmov.d	8[r0], dr0
ffc02349:	76 90 18 40                   	dcmplt	dr0, dr1
ffc0234d:	75 90 1b                      	mvfdr
ffc02350:	20 ae                         	beq.b	ffc022fe <_Reset_Vector+0xffc02302>

ffc02352 <.LVL240>:
    volatile uint8_t * const picmr1_reg = RIIC_ICMR1_ADR(p_riic_info->ch_no);
ffc02352:	5b cc                         	movu.b	r12, r12
    volatile uint8_t * const picbrl_reg = RIIC_ICBRL_ADR(p_riic_info->ch_no);
ffc02354:	5b 88                         	movu.b	r8, r8
    volatile uint8_t * const picmr1_reg = RIIC_ICMR1_ADR(p_riic_info->ch_no);
ffc02356:	6c 5c                         	shll	#5, r12

ffc02358 <.LVL241>:
    volatile uint8_t * const picbrl_reg = RIIC_ICBRL_ADR(p_riic_info->ch_no);
ffc02358:	6c 58                         	shll	#5, r8

ffc0235a <.LVL242>:
    volatile uint8_t * const picmr1_reg = RIIC_ICMR1_ADR(p_riic_info->ch_no);
ffc0235a:	73 cc 02 83 08                	add	#0x88302, r12, r12
    volatile uint8_t * const picbrl_reg = RIIC_ICBRL_ADR(p_riic_info->ch_no);
ffc0235f:	73 88 10 83 08                	add	#0x88310, r8, r8
    }

     /* store ICMR1 value to avoid CKS bit. */
    uctmp = (uint8_t) ((uint8_t) (*picmr1_reg) & (((~BIT4) & (~BIT5)) & (~BIT6)));
ffc02364:	cc c5                         	mov.b	[r12], r5
    *picbrl_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRL register */

    /*************** Calculation ICBRH value ***********************/
    calc_val = H_time; /* Set H width */
    calc_val_tmp = calc_val;
    calc_val = (calc_val_tmp / (d_cks[cnt - 1] / pclk_val)); /* Calculattion ICBRH value */
ffc02366:	71 04 ff                      	add	#-1, r0, r4
    calc_val = (uint8_t) (calc_val + 0.5); /* round off */

    /* If the calculated value is less than 1, it rounded up to 1. */
    if (1 > calc_val)
ffc02369:	f9 03 23 00 00 f0 3f          	dmov.d	#0x3ff00000, drh2
    uctmp = (uint8_t) ((uint8_t) (*picmr1_reg) & (((~BIT4) & (~BIT5)) & (~BIT6)));
ffc02370:	75 25 8f                      	and	#-113, r5
ffc02373:	c7 05 29                      	mov.b	r5, 41[r0]
    uctmp_tmp = uctmp;
ffc02376:	cd 03 29                      	mov.b	41[r0], r3

ffc02379 <.LVL243>:
    *picmr1_reg = (uint8_t) ((uctmp_tmp) | ((cnt - 1) << 4)); /* Set ICMR1.CKS bits.*/
ffc02379:	59 05 28                      	movu.b	40[r0], r5
ffc0237c:	60 15                         	sub	#1, r5
ffc0237e:	6c 45                         	shll	#4, r5
ffc02380:	57 35                         	or	r3, r5
ffc02382:	c3 c5                         	mov.b	r5, [r12]
    *picbrl_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRL register */
ffc02384:	fc c9 08 02 00                	dmov.d	8[r0], dr0
ffc02389:	76 90 01 02                   	dsub	dr2, dr0, dr0
ffc0238d:	76 90 0d 19                   	dtou	dr0, dr1
ffc02391:	fd 75 85 10                   	dmov.l	drl1, r5
ffc02395:	75 35 e0                      	or	#-32, r5
ffc02398:	c3 85                         	mov.b	r5, [r8]
    calc_val = H_time; /* Set H width */
ffc0239a:	fc c9 08 04 00                	dmov.d	16[r0], dr0
ffc0239f:	fc 79 08 02 00                	dmov.d	dr0, 8[r0]
    calc_val_tmp = calc_val;
ffc023a4:	fc c9 08 02 10                	dmov.d	8[r0], dr1

ffc023a9 <.LVL244>:
    calc_val = (calc_val_tmp / (d_cks[cnt - 1] / pclk_val)); /* Calculattion ICBRH value */
ffc023a9:	59 05 28                      	movu.b	40[r0], r5
ffc023ac:	fe c5 41                      	movu.b	[r5, r4], r1

ffc023af <.LVL245>:
ffc023af:	fd 77 81 09                   	itod	r1, dr0
ffc023b3:	76 90 05 33                   	ddiv	dr3, dr0, dr3

ffc023b7 <.LVL246>:
ffc023b7:	76 90 15 33                   	ddiv	dr3, dr1, dr3
ffc023bb:	fc 79 08 02 30                	dmov.d	dr3, 8[r0]
    calc_val = (uint8_t) (calc_val + 0.5); /* round off */
ffc023c0:	fc c9 08 02 00                	dmov.d	8[r0], dr0
ffc023c5:	f9 03 13 00 00 e0 3f          	dmov.d	#0x3fe00000, drh1

ffc023cc <.LVL247>:
ffc023cc:	76 90 10 00                   	dadd	dr0, dr1, dr0
ffc023d0:	76 90 0d 19                   	dtou	dr0, dr1
ffc023d4:	fd 75 85 10                   	dmov.l	drl1, r5
ffc023d8:	5b 55                         	movu.b	r5, r5
ffc023da:	fd 77 85 0d                   	utod	r5, dr0
ffc023de:	fc 79 08 02 00                	dmov.d	dr0, 8[r0]
    if (1 > calc_val)
ffc023e3:	fc c9 08 02 00                	dmov.d	8[r0], dr0
ffc023e8:	76 90 28 60                   	dcmple	dr0, dr2
ffc023ec:	75 90 1b                      	mvfdr
ffc023ef:	11                            	beq.s	ffc023f8 <_Reset_Vector+0xffc023fc>
    {
        calc_val = 1;
ffc023f0:	fc 79 08 02 20                	dmov.d	dr2, 8[r0]
ffc023f5:	fc 13 00                      	nop	; max	r0, r0
    }

    *picbrh_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRH register */
ffc023f8:	fc c9 08 02 00                	dmov.d	8[r0], dr0
    volatile uint8_t * const picbrh_reg = RIIC_ICBRH_ADR(p_riic_info->ch_no);
ffc023fd:	5b 99                         	movu.b	r9, r9
    *picbrh_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRH register */
ffc023ff:	f9 03 13 00 00 f0 3f          	dmov.d	#0x3ff00000, drh1
ffc02406:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc0240a:	76 90 0d 19                   	dtou	dr0, dr1
ffc0240e:	fd 75 85 10                   	dmov.l	drl1, r5
    volatile uint8_t * const picbrh_reg = RIIC_ICBRH_ADR(p_riic_info->ch_no);
ffc02412:	6c 59                         	shll	#5, r9

ffc02414 <.LVL248>:
ffc02414:	73 99 11 83 08                	add	#0x88311, r9, r9
    *picbrh_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRH register */
ffc02419:	75 35 e0                      	or	#-32, r5
ffc0241c:	c3 95                         	mov.b	r5, [r9]

    uctmp = *picbrh_reg; /* dummy read */
ffc0241e:	cc 95                         	mov.b	[r9], r5
ffc02420:	c7 05 29                      	mov.b	r5, 41[r0]

ffc02423 <.LBE709>:
    *picmr2_reg = g_riic_icmr2_init[p_riic_info->ch_no];
ffc02423:	b0 fd                         	movu.b	3[r7], r5
ffc02425:	fb 42 36 69 c0 ff             	mov.l	#0xffc06936, r4
ffc0242b:	fe 45 45                      	mov.b	[r5, r4], r5
ffc0242e:	c3 65                         	mov.b	r5, [r6]
    *picmr3_reg = g_riic_icmr3_init[p_riic_info->ch_no];
ffc02430:	b0 fd                         	movu.b	3[r7], r5
ffc02432:	fb 42 33 69 c0 ff             	mov.l	#0xffc06933, r4
ffc02438:	fe 45 45                      	mov.b	[r5, r4], r5
ffc0243b:	c3 b5                         	mov.b	r5, [r11]
    riic_mcu_int_disable(p_riic_info->ch_no);
ffc0243d:	88 f9                         	mov.b	3[r7], r1
ffc0243f:	05 f1 ef ff                   	bsr.a	ffc01430 <_Reset_Vector+0xffc01434>

ffc02443 <.LVL250>:
    *picfer_reg = g_riic_icfer_init[p_riic_info->ch_no];
ffc02443:	b0 ff                         	movu.b	3[r7], r7

ffc02445 <.LVL251>:
ffc02445:	fb 52 30 69 c0 ff             	mov.l	#0xffc06930, r5
ffc0244b:	fe 47 57                      	mov.b	[r7, r5], r7
ffc0244e:	c3 a7                         	mov.b	r7, [r10]
    uctmp = *picfer_reg; /* Reads ICFER. */
ffc02450:	cc a7                         	mov.b	[r10], r7
ffc02452:	c7 07 2b                      	mov.b	r7, 43[r0]
} /* End of function riic_init_io_register() */
ffc02455:	71 00 2c                      	add	#44, r0, r0
ffc02458:	75 a8 10                      	dpopm.l	dcmr-dcmr
ffc0245b:	75 b8 04                      	dpopm.d	dr0-dr4
ffc0245e:	6f 6d                         	popm	r6-r13

ffc02460 <.LVL252>:
ffc02460:	02                            	rts

ffc02461 <.LBB710>:
    L_time = (1 / (2 * bps)); /* Harf period of frequency */
ffc02461:	fc c9 08 08 00                	dmov.d	32[r0], dr0
ffc02466:	76 90 00 00                   	dadd	dr0, dr0, dr0
ffc0246a:	f9 03 13 00 00 f0 3f          	dmov.d	#0x3ff00000, drh1
ffc02471:	76 90 15 00                   	ddiv	dr0, dr1, dr0
ffc02475:	fc 79 08 06 00                	dmov.d	dr0, 24[r0]
    H_time = L_time;
ffc0247a:	fc c9 08 06 00                	dmov.d	24[r0], dr0
ffc0247f:	fc 79 08 04 00                	dmov.d	dr0, 16[r0]
        L_time -= scl_down_time;
ffc02484:	fc c9 08 06 00                	dmov.d	24[r0], dr0
ffc02489:	f9 03 10 76 83 0d f4          	dmov.l	#0xf40d8376, drl1
ffc02490:	f9 03 12 f5 21 94 3e          	dmov.l	#0x3e9421f5, drh1
ffc02497:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc0249b:	fc 79 08 06 00                	dmov.d	dr0, 24[r0]
        H_time -= scl_up_time;
ffc024a0:	fc c9 08 04 00                	dmov.d	16[r0], dr0
ffc024a5:	f9 03 10 8d ed b5 a0          	dmov.l	#0xa0b5ed8d, drl1
ffc024ac:	f9 03 12 f7 c6 b0 3e          	dmov.l	#0x3eb0c6f7, drh1
ffc024b3:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc024b7:	fc 79 08 04 00                	dmov.d	dr0, 16[r0]
ffc024bc:	38 fc fd                      	bra.w	ffc022b8 <_Reset_Vector+0xffc022bc>

ffc024bf <.LVL254>:
            L_time = 0.5E-6;
ffc024bf:	fc 79 08 06 00                	dmov.d	dr0, 24[r0]
            bps_tmp = bps;
ffc024c4:	fc c9 08 08 00                	dmov.d	32[r0], dr0

ffc024c9 <.LVL255>:
            H_time = (((1 / bps_tmp) - L_time) - scl_up_time) - scl_down_time;
ffc024c9:	fc c9 08 06 20                	dmov.d	24[r0], dr2
ffc024ce:	76 90 15 00                   	ddiv	dr0, dr1, dr0

ffc024d2 <.LVL256>:
ffc024d2:	76 90 01 02                   	dsub	dr2, dr0, dr0
ffc024d6:	f9 03 10 2b 69 a4 29          	dmov.l	#0x29a4692b, drl1
ffc024dd:	f9 03 12 2b 1b 80 3e          	dmov.l	#0x3e801b2b, drh1
ffc024e4:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc024e8:	76 90 01 01                   	dsub	dr1, dr0, dr0
ffc024ec:	fc 79 08 04 00                	dmov.d	dr0, 16[r0]
ffc024f1:	38 c7 fd                      	bra.w	ffc022b8 <_Reset_Vector+0xffc022bc>

ffc024f4 <.LVL257>:
            L_time -= scl_down_time;
ffc024f4:	fc c9 08 06 00                	dmov.d	24[r0], dr0
ffc024f9:	f9 03 10 76 83 0d f4          	dmov.l	#0xf40d8376, drl1
ffc02500:	f9 03 12 f5 21 94 3e          	dmov.l	#0x3e9421f5, drh1
ffc02507:	38 9a fd                      	bra.w	ffc022a1 <_Reset_Vector+0xffc022a5>

ffc0250a <.LBE710>:
ffc0250a:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffc02510 <_riic_clear_ir_flag>:
{
ffc02510:	6e 6a                         	pushm	r6-r10
ffc02512:	60 40                         	sub	#4, r0

ffc02514 <.LVL259>:
ffc02514:	ef 16                         	mov.l	r1, r6
    volatile uint8_t uctmp = 0x00;
ffc02516:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc02519:	cd 1a 03                      	mov.b	3[r1], r10

ffc0251c <.LVL260>:
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffc0251c:	88 9f                         	mov.b	3[r1], r7

ffc0251e <.LVL261>:
    if ((RIIC_IR_SET == riic_mcu_check_ir_txi(p_riic_info->ch_no))
ffc0251e:	88 99                         	mov.b	3[r1], r1

ffc02520 <.LVL262>:
ffc02520:	05 08 ee ff                   	bsr.a	ffc01328 <_Reset_Vector+0xffc0132c>

ffc02524 <.LVL263>:
ffc02524:	61 11                         	cmp	#1, r1
ffc02526:	21 5c                         	bne.b	ffc02582 <_Reset_Vector+0xffc02586>
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc02528:	5b a5                         	movu.b	r10, r5
ffc0252a:	6c 55                         	shll	#5, r5
ffc0252c:	73 55 00 83 08                	add	#0x88300, r5, r5
        if (RIIC_ICCR1_ICE_SET == ((*piccr1_reg) & RIIC_ICCR1_ICE)) /* ICCR1.ICE = 1 */
ffc02531:	cc 54                         	mov.b	[r5], r4
ffc02533:	7c 74                         	btst	#7, r4
ffc02535:	21 2e                         	bne.b	ffc02563 <_Reset_Vector+0xffc02567>
    uint8_t internal_flag = 0x00; /* Determines whether reinitialization is necessary. */
ffc02537:	66 0a                         	mov.l	#0, r10

ffc02539 <.LVL264>:
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffc02539:	5b 74                         	movu.b	r7, r4
ffc0253b:	6c 54                         	shll	#5, r4
ffc0253d:	73 44 07 83 08                	add	#0x88307, r4, r4

ffc02542 <.LVL265>:
        *picier_reg = RIIC_ICIER_INIT;
ffc02542:	f8 44 00                      	mov.b	#0, [r4]
        while (RIIC_ICIER_INIT != (*picier_reg))
ffc02545:	fc 13 00                      	nop	; max	r0, r0
ffc02548:	58 45                         	movu.b	[r4], r5
ffc0254a:	61 05                         	cmp	#0, r5
ffc0254c:	21 fc                         	bne.b	ffc02548 <_Reset_Vector+0xffc0254c>
        riic_mcu_clear_ir_rxi(p_riic_info->ch_no); /* Clears RXI interrupt request register. */
ffc0254e:	88 e9                         	mov.b	3[r6], r1
ffc02550:	05 19 ee ff                   	bsr.a	ffc01369 <_Reset_Vector+0xffc0136d>

ffc02554 <.LVL266>:
        riic_mcu_clear_ir_txi(p_riic_info->ch_no); /* Clears TXI interrupt request register. */
ffc02554:	88 e9                         	mov.b	3[r6], r1
ffc02556:	05 00 ee ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc0255a <.LVL267>:
        if (0x01 == internal_flag)
ffc0255a:	5b a7                         	movu.b	r10, r7

ffc0255c <.LVL268>:
ffc0255c:	61 17                         	cmp	#1, r7
ffc0255e:	20 31                         	beq.b	ffc0258f <_Reset_Vector+0xffc02593>
} /* End of function riic_clear_ir_flag() */
ffc02560:	3f 6a 06                      	rtsd	#24, r6-r10

ffc02563 <.LVL269>:
            (*piccr1_reg) |= RIIC_ICCR1_RIIC_RESET;
ffc02563:	f0 56                         	bset	#6, [r5].b
            while (RIIC_ICCR1_RIIC_RESET != ((*piccr1_reg) & RIIC_ICCR1_RIIC_RESET))
ffc02565:	fc 13 00                      	nop	; max	r0, r0
ffc02568:	cc 54                         	mov.b	[r5], r4
ffc0256a:	7c 64                         	btst	#6, r4
ffc0256c:	20 fc                         	beq.b	ffc02568 <_Reset_Vector+0xffc0256c>
            (*piccr1_reg) &= RIIC_ICCR1_ICE_CLR;
ffc0256e:	cc 54                         	mov.b	[r5], r4
ffc02570:	75 24 7f                      	and	#127, r4
ffc02573:	c3 54                         	mov.b	r4, [r5]
            while (RIIC_ICCR1_NOT_DRIVEN != ((*piccr1_reg) & RIIC_ICCR1_ICE))
ffc02575:	fc 13 00                      	nop	; max	r0, r0
ffc02578:	cc 54                         	mov.b	[r5], r4
ffc0257a:	7c 74                         	btst	#7, r4
ffc0257c:	21 fc                         	bne.b	ffc02578 <_Reset_Vector+0xffc0257c>
            internal_flag = 0x01;
ffc0257e:	66 1a                         	mov.l	#1, r10

ffc02580 <.LVL270>:
ffc02580:	2e b9                         	bra.b	ffc02539 <_Reset_Vector+0xffc0253d>

ffc02582 <.LVL271>:
            || (RIIC_IR_SET == riic_mcu_check_ir_rxi(p_riic_info->ch_no)))
ffc02582:	88 e9                         	mov.b	3[r6], r1
ffc02584:	05 bb ed ff                   	bsr.a	ffc0133f <_Reset_Vector+0xffc01343>

ffc02588 <.LVL272>:
ffc02588:	61 11                         	cmp	#1, r1
ffc0258a:	20 9e                         	beq.b	ffc02528 <_Reset_Vector+0xffc0252c>
} /* End of function riic_clear_ir_flag() */
ffc0258c:	3f 6a 06                      	rtsd	#24, r6-r10

ffc0258f <.LVL273>:
            riic_init_io_register(p_riic_info);
ffc0258f:	ef 61                         	mov.l	r6, r1
} /* End of function riic_clear_ir_flag() */
ffc02591:	62 40                         	add	#4, r0
ffc02593:	6f 6a                         	popm	r6-r10

ffc02595 <.LVL274>:
            riic_init_io_register(p_riic_info);
ffc02595:	04 2b fb ff                   	bra.a	ffc020c0 <_Reset_Vector+0xffc020c4>

ffc02599 <.LFE60>:
ffc02599:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc025a0 <_riic_after_dtct_stop_cond>:
{
ffc025a0:	60 40                         	sub	#4, r0

ffc025a2 <.LVL277>:
ffc025a2:	ef 13                         	mov.l	r1, r3
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc025a4:	88 9a                         	mov.b	3[r1], r2

ffc025a6 <.LBB724>:
    volatile uint32_t cnt = 0x00000000;
ffc025a6:	f8 06 00                      	mov.l	#0, [r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc025a9:	88 9c                         	mov.b	3[r1], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc025ab:	88 9d                         	mov.b	3[r1], r5
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc025ad:	5b 44                         	movu.b	r4, r4
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffc025af:	f8 0a e8 03                   	mov.l	#0x3e8, [r0]
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc025b3:	5b 55                         	movu.b	r5, r5
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffc025b5:	ec 01                         	mov.l	[r0], r1

ffc025b7 <.LVL279>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc025b7:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc025b9:	6c 55                         	shll	#5, r5
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc025bb:	73 44 00 83 08                	add	#0x88300, r4, r4

ffc025c0 <.LVL280>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc025c0:	73 55 01 83 08                	add	#0x88301, r5, r5

ffc025c5 <.LVL281>:
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffc025c5:	61 01                         	cmp	#0, r1
ffc025c7:	20 1b                         	beq.b	ffc025e2 <_Reset_Vector+0xffc025e6>
        if ((RIIC_MSK_BBSY != ((*piccr2_reg) & RIIC_MSK_BBSY)) && /* ICCR2.BBSY = 0 */
ffc025c9:	cc 51                         	mov.b	[r5], r1
ffc025cb:	7c 71                         	btst	#7, r1
ffc025cd:	19                            	bne.s	ffc025d6 <_Reset_Vector+0xffc025da>
        (RIIC_MSK_SCLSDA == ((*piccr1_reg) & RIIC_MSK_SCLSDA))) /* ICCR1.SCLI = 1, ICCR1.SDAI = 1 */
ffc025ce:	cc 41                         	mov.b	[r4], r1
        if ((RIIC_MSK_BBSY != ((*piccr2_reg) & RIIC_MSK_BBSY)) && /* ICCR2.BBSY = 0 */
ffc025d0:	64 31                         	and	#3, r1
ffc025d2:	61 31                         	cmp	#3, r1
ffc025d4:	20 43                         	beq.b	ffc02617 <_Reset_Vector+0xffc0261b>
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffc025d6:	ec 01                         	mov.l	[r0], r1
ffc025d8:	60 11                         	sub	#1, r1
ffc025da:	e3 01                         	mov.l	r1, [r0]
ffc025dc:	ec 01                         	mov.l	[r0], r1
ffc025de:	61 01                         	cmp	#0, r1
ffc025e0:	21 e9                         	bne.b	ffc025c9 <_Reset_Vector+0xffc025cd>
        ret = RIIC_ERR_BUS_BUSY;
ffc025e2:	66 51                         	mov.l	#5, r1

ffc025e4 <.LVL282>:
    if ((RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc025e4:	b0 bd                         	movu.b	3[r3], r5
ffc025e6:	6c 45                         	shll	#4, r5
ffc025e8:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc025ee:	ec 55                         	mov.l	[r5], r5
ffc025f0:	61 55                         	cmp	#5, r5
ffc025f2:	20 13                         	beq.b	ffc02605 <_Reset_Vector+0xffc02609>
            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc025f4:	b0 bd                         	movu.b	3[r3], r5
ffc025f6:	6c 45                         	shll	#4, r5
ffc025f8:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc025fe:	ec 55                         	mov.l	[r5], r5
ffc02600:	61 65                         	cmp	#6, r5
ffc02602:	13                            	beq.s	ffc02605 <_Reset_Vector+0xffc02609>
} /* End of function riic_after_dtct_stop_cond() */
ffc02603:	67 01                         	rtsd	#4
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffc02605:	5b 22                         	movu.b	r2, r2
ffc02607:	6c 52                         	shll	#5, r2

ffc02609 <.LVL283>:
ffc02609:	73 22 06 83 08                	add	#0x88306, r2, r2
        (*picser_reg) &= RIIC_ICSER_SAR_DASABLE;
ffc0260e:	cc 25                         	mov.b	[r2], r5
ffc02610:	75 25 f8                      	and	#-8, r5
ffc02613:	c3 25                         	mov.b	r5, [r2]
} /* End of function riic_after_dtct_stop_cond() */
ffc02615:	67 01                         	rtsd	#4

ffc02617 <.LVL284>:
        if (RIIC_TMO == g_riic_ChStatus[p_riic_info->ch_no])
ffc02617:	88 bc                         	mov.b	3[r3], r4
        if (RIIC_AL == g_riic_ChStatus[p_riic_info->ch_no])
ffc02619:	88 bd                         	mov.b	3[r3], r5
        if (RIIC_TMO == g_riic_ChStatus[p_riic_info->ch_no])
ffc0261b:	fb e2 70 06 00 00             	mov.l	#0x670, r14
ffc02621:	5b 44                         	movu.b	r4, r4
        if (RIIC_AL == g_riic_ChStatus[p_riic_info->ch_no])
ffc02623:	5b 55                         	movu.b	r5, r5
        if (RIIC_TMO == g_riic_ChStatus[p_riic_info->ch_no])
ffc02625:	fe c4 e1                      	movu.b	[r4, r14], r1
        if (RIIC_AL == g_riic_ChStatus[p_riic_info->ch_no])
ffc02628:	fe c5 e5                      	movu.b	[r5, r14], r5
    riic_return_t ret = RIIC_SUCCESS;
ffc0262b:	61 61                         	cmp	#6, r1
ffc0262d:	66 01                         	mov.l	#0, r1
ffc0262f:	fd 74 e1 07                   	stz	#7, r1

ffc02633 <.LVL285>:
            ret = RIIC_ERR_AL;
ffc02633:	61 55                         	cmp	#5, r5
ffc02635:	fd 74 e1 06                   	stz	#6, r1

ffc02639 <.LVL286>:
ffc02639:	2e ab                         	bra.b	ffc025e4 <_Reset_Vector+0xffc025e8>

ffc0263b <.LFE29>:
ffc0263b:	77 10 01 00 00                	nop	; mul	#1, r0

ffc02640 <_riic_init_driver>:
{
ffc02640:	7e a7                         	push.l	r7
ffc02642:	60 40                         	sub	#4, r0
ffc02644:	ef 17                         	mov.l	r1, r7

ffc02646 <.LBB734>:
    riic_init_io_register(p_riic_info);
ffc02646:	05 7a fa ff                   	bsr.a	ffc020c0 <_Reset_Vector+0xffc020c4>

ffc0264a <.LVL289>:
    riic_clear_ir_flag(p_riic_info);
ffc0264a:	ef 71                         	mov.l	r7, r1
ffc0264c:	05 c4 fe ff                   	bsr.a	ffc02510 <_Reset_Vector+0xffc02514>

ffc02650 <.LBB736>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02650:	88 fd                         	mov.b	3[r7], r5

ffc02652 <.LBB739>:
    riic_clear_ir_flag(p_riic_info);
ffc02652:	ef 71                         	mov.l	r7, r1

ffc02654 <.LBB742>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02654:	5b 55                         	movu.b	r5, r5
ffc02656:	6c 45                         	shll	#4, r5

ffc02658 <.LVL292>:
ffc02658:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0265e:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc02662:	3e 52 01                      	mov.l	#1, 8[r5]

ffc02665 <.LBB743>:
    riic_clear_ir_flag(p_riic_info);
ffc02665:	05 ab fe ff                   	bsr.a	ffc02510 <_Reset_Vector+0xffc02514>

ffc02669 <.LVL294>:
    riic_mcu_int_enable(p_riic_info->ch_no);
ffc02669:	88 f9                         	mov.b	3[r7], r1
ffc0266b:	05 2d ed ff                   	bsr.a	ffc01398 <_Reset_Vector+0xffc0139c>

ffc0266f <.LBB744>:
} /* End of function riic_init_driver() */
ffc0266f:	66 01                         	mov.l	#0, r1

ffc02671 <.LBB747>:
    volatile uint8_t uctmp = 0x00;
ffc02671:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc02674:	b0 fd                         	movu.b	3[r7], r5
ffc02676:	6c 55                         	shll	#5, r5
ffc02678:	73 55 00 83 08                	add	#0x88300, r5, r5

ffc0267d <.LVL296>:
    (*piccr1_reg) &= RIIC_ICCR1_ENABLE; /* Clears ICCR1.IICRST bit. */
ffc0267d:	f0 5e                         	bclr	#6, [r5].b
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffc0267f:	cc 57                         	mov.b	[r5], r7

ffc02681 <.LVL297>:
ffc02681:	c3 07                         	mov.b	r7, [r0]

ffc02683 <.LBE747>:
} /* End of function riic_init_driver() */
ffc02683:	3f 77 02                      	rtsd	#8, r7-r7

ffc02686 <.LFE22>:
	...

ffc02688 <_riic_generate_start_cond>:
{
ffc02688:	7e a7                         	push.l	r7
ffc0268a:	60 80                         	sub	#8, r0
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffc0268c:	88 9a                         	mov.b	3[r1], r2

ffc0268e <.LVL300>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc0268e:	88 9d                         	mov.b	3[r1], r5

ffc02690 <.LBB764>:
    volatile uint32_t cnt = 0x00000000;
ffc02690:	f8 06 00                      	mov.l	#0, [r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc02693:	cd 1e 03                      	mov.b	3[r1], r14
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02696:	88 9b                         	mov.b	3[r1], r3
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc02698:	5b ee                         	movu.b	r14, r14
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffc0269a:	f8 0a e8 03                   	mov.l	#0x3e8, [r0]
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc0269e:	5b 33                         	movu.b	r3, r3
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffc026a0:	ec 07                         	mov.l	[r0], r7
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc026a2:	6c 5e                         	shll	#5, r14
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc026a4:	6c 53                         	shll	#5, r3
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffc026a6:	73 ee 00 83 08                	add	#0x88300, r14, r14

ffc026ab <.LVL302>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc026ab:	73 33 01 83 08                	add	#0x88301, r3, r3

ffc026b0 <.LVL303>:
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffc026b0:	61 07                         	cmp	#0, r7
ffc026b2:	20 1f                         	beq.b	ffc026d1 <_Reset_Vector+0xffc026d5>
ffc026b4:	76 10 01 00                   	nop	; mul	#1, r0
        if ((RIIC_MSK_BBSY != ((*piccr2_reg) & RIIC_MSK_BBSY)) && /* ICCR2.BBSY = 0 */
ffc026b8:	cc 34                         	mov.b	[r3], r4
ffc026ba:	7c 74                         	btst	#7, r4
ffc026bc:	19                            	bne.s	ffc026c5 <_Reset_Vector+0xffc026c9>
        (RIIC_MSK_SCLSDA == ((*piccr1_reg) & RIIC_MSK_SCLSDA))) /* ICCR1.SCLI = 1, ICCR1.SDAI = 1 */
ffc026bd:	cc e4                         	mov.b	[r14], r4
        if ((RIIC_MSK_BBSY != ((*piccr2_reg) & RIIC_MSK_BBSY)) && /* ICCR2.BBSY = 0 */
ffc026bf:	64 34                         	and	#3, r4
ffc026c1:	61 34                         	cmp	#3, r4
ffc026c3:	20 13                         	beq.b	ffc026d6 <_Reset_Vector+0xffc026da>
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffc026c5:	ec 04                         	mov.l	[r0], r4
ffc026c7:	60 14                         	sub	#1, r4
ffc026c9:	e3 04                         	mov.l	r4, [r0]
ffc026cb:	ec 04                         	mov.l	[r0], r4
ffc026cd:	61 04                         	cmp	#0, r4
ffc026cf:	21 e9                         	bne.b	ffc026b8 <_Reset_Vector+0xffc026bc>
        ret = RIIC_ERR_BUS_BUSY; /* Bus busy */
ffc026d1:	66 51                         	mov.l	#5, r1

ffc026d3 <.LVL304>:
} /* End of function riic_generate_start_cond() */
ffc026d3:	3f 77 03                      	rtsd	#12, r7-r7

ffc026d6 <.LVL305>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc026d6:	5b 54                         	movu.b	r5, r4
ffc026d8:	6c 54                         	shll	#5, r4
ffc026da:	73 44 09 83 08                	add	#0x88309, r4, r4

ffc026df <.LVL306>:
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffc026df:	f0 4b                         	bclr	#3, [r4].b

ffc026e1 <.LVL307>:
        while (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START) || ((*picsr2_reg) & RIIC_ICSR2_STOP)))
ffc026e1:	cc 45                         	mov.b	[r4], r5
ffc026e3:	7c 25                         	btst	#2, r5
ffc026e5:	21 fc                         	bne.b	ffc026e1 <_Reset_Vector+0xffc026e5>
ffc026e7:	cc 45                         	mov.b	[r4], r5
ffc026e9:	7c 35                         	btst	#3, r5
ffc026eb:	21 f6                         	bne.b	ffc026e1 <_Reset_Vector+0xffc026e5>
ffc026ed:	ef 17                         	mov.l	r1, r7
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffc026ef:	5b 24                         	movu.b	r2, r4

ffc026f1 <.LBB766>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc026f1:	88 9d                         	mov.b	3[r1], r5

ffc026f3 <.LBE766>:
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffc026f3:	6c 54                         	shll	#5, r4
ffc026f5:	73 44 07 83 08                	add	#0x88307, r4, r4

ffc026fa <.LBB772>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc026fa:	5b 55                         	movu.b	r5, r5

ffc026fc <.LBE772>:
        (*picier_reg) &= (~RIIC_ICIER_AL);
ffc026fc:	f0 49                         	bclr	#1, [r4].b
        uctmp = *picier_reg; /* Reads ICIER. */
ffc026fe:	cc 44                         	mov.b	[r4], r4

ffc02700 <.LBB773>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02700:	6c 45                         	shll	#4, r5

ffc02702 <.LVL309>:
ffc02702:	70 55 5c 04 00 00             	add	#0x45c, r5, r5

ffc02708 <.LBE773>:
        uctmp = *picier_reg; /* Reads ICIER. */
ffc02708:	81 0c                         	mov.b	r4, 5[r0]

ffc0270a <.LBB774>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc0270a:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

ffc0270e <.LBE774>:
        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc0270e:	88 9c                         	mov.b	3[r1], r4

ffc02710 <.LBB775>:
    riic_api_info[ch_no].N_status = new_status;
ffc02710:	3e 52 03                      	mov.l	#3, 8[r5]

ffc02713 <.LBE775>:
        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffc02713:	5b 45                         	movu.b	r4, r5
ffc02715:	6c 45                         	shll	#4, r5
ffc02717:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0271d:	a8 5d                         	mov.l	4[r5], r5
ffc0271f:	61 45                         	cmp	#4, r5
ffc02721:	21 3a                         	bne.b	ffc0275b <_Reset_Vector+0xffc0275f>
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc02723:	88 9c                         	mov.b	3[r1], r4
ffc02725:	fb 52 98 04 00 00             	mov.l	#0x498, r5
ffc0272b:	5b 44                         	movu.b	r4, r4
ffc0272d:	fe 64 54                      	mov.l	[r4, r5], r4
ffc02730:	a9 4c                         	mov.l	20[r4], r4
ffc02732:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc02738:	20 5b                         	beq.b	ffc02793 <_Reset_Vector+0xffc02797>
                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc0273a:	b0 9c                         	movu.b	3[r1], r4
ffc0273c:	fe 64 54                      	mov.l	[r4, r5], r4
ffc0273f:	a9 44                         	mov.l	16[r4], r4
ffc02741:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc02747:	20 4c                         	beq.b	ffc02793 <_Reset_Vector+0xffc02797>
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_TX_RX);
ffc02749:	88 9c                         	mov.b	3[r1], r4

ffc0274b <.LBB776>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc0274b:	fb 26 b6                      	mov.l	#-74, r2

ffc0274e <.LBE776>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_TX_RX);
ffc0274e:	5b 44                         	movu.b	r4, r4
ffc02750:	fe 64 55                      	mov.l	[r4, r5], r5

ffc02753 <.LBB779>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02753:	88 d9                         	mov.b	3[r5], r1

ffc02755 <.LVL313>:
ffc02755:	05 27 ec ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02759 <.LVL314>:
ffc02759:	2e 0f                         	bra.b	ffc02768 <_Reset_Vector+0xffc0276c>

ffc0275b <.LBB780>:
ffc0275b:	88 99                         	mov.b	3[r1], r1

ffc0275d <.LVL316>:
ffc0275d:	75 42 16                      	mov.l	#22, r2

ffc02760 <.LVL317>:
ffc02760:	05 1c ec ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02764 <.LVL318>:
ffc02764:	76 10 01 00                   	nop	; mul	#1, r0

ffc02768 <.LBB782>:
    volatile uint8_t uctmp = 0x00;
ffc02768:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc0276b:	88 fc                         	mov.b	3[r7], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc0276d:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc0276f:	5b 44                         	movu.b	r4, r4
ffc02771:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02773:	5b 55                         	movu.b	r5, r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02775:	73 44 09 83 08                	add	#0x88309, r4, r4

ffc0277a <.LVL319>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc0277a:	6c 55                         	shll	#5, r5
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START_SET) >> 2U))
ffc0277c:	cc 43                         	mov.b	[r4], r3
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc0277e:	73 55 01 83 08                	add	#0x88301, r5, r5

ffc02783 <.LVL320>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START_SET) >> 2U))
ffc02783:	7c 23                         	btst	#2, r3
ffc02785:	13                            	beq.s	ffc02788 <_Reset_Vector+0xffc0278c>
        (*picsr2_reg) &= RIIC_ICSR2_START_CLR;
ffc02786:	f0 4a                         	bclr	#2, [r4].b
    (*piccr2_reg) |= RIIC_ICCR2_ST; /* Sets ICCR2.ST bit. */
ffc02788:	f0 51                         	bset	#1, [r5].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc0278a:	cc 57                         	mov.b	[r5], r7

ffc0278c <.LBE782>:
        ret = RIIC_SUCCESS;
ffc0278c:	66 01                         	mov.l	#0, r1

ffc0278e <.LBB785>:
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc0278e:	81 07                         	mov.b	r7, 4[r0]

ffc02790 <.LBE785>:
} /* End of function riic_generate_start_cond() */
ffc02790:	3f 77 03                      	rtsd	#12, r7-r7

ffc02793 <.LVL323>:
            else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc02793:	b0 fc                         	movu.b	3[r7], r4
ffc02795:	fe 64 54                      	mov.l	[r4, r5], r4
ffc02798:	a9 4c                         	mov.l	20[r4], r4
ffc0279a:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc027a0:	20 11                         	beq.b	ffc027b1 <_Reset_Vector+0xffc027b5>
                    && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc027a2:	b0 fc                         	movu.b	3[r7], r4
ffc027a4:	fe 64 54                      	mov.l	[r4, r5], r4
ffc027a7:	a9 44                         	mov.l	16[r4], r4
ffc027a9:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc027af:	20 32                         	beq.b	ffc027e1 <_Reset_Vector+0xffc027e5>
            else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffc027b1:	b0 fc                         	movu.b	3[r7], r4
ffc027b3:	fe 64 54                      	mov.l	[r4, r5], r4
ffc027b6:	a9 4c                         	mov.l	20[r4], r4
ffc027b8:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc027be:	21 aa                         	bne.b	ffc02768 <_Reset_Vector+0xffc0276c>
                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffc027c0:	b0 fc                         	movu.b	3[r7], r4
ffc027c2:	fe 64 54                      	mov.l	[r4, r5], r4
ffc027c5:	a9 44                         	mov.l	16[r4], r4
ffc027c7:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffc027cd:	20 9b                         	beq.b	ffc02768 <_Reset_Vector+0xffc0276c>
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_RX);
ffc027cf:	88 fc                         	mov.b	3[r7], r4

ffc027d1 <.LBB786>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc027d1:	75 42 36                      	mov.l	#54, r2

ffc027d4 <.LBE786>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_RX);
ffc027d4:	5b 44                         	movu.b	r4, r4
ffc027d6:	fe 64 55                      	mov.l	[r4, r5], r5

ffc027d9 <.LBB789>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc027d9:	88 d9                         	mov.b	3[r5], r1

ffc027db <.LVL326>:
ffc027db:	05 a1 eb ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc027df <.LVL327>:
ffc027df:	2e 89                         	bra.b	ffc02768 <_Reset_Vector+0xffc0276c>

ffc027e1 <.LBE789>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_TX);
ffc027e1:	88 fc                         	mov.b	3[r7], r4

ffc027e3 <.LBB790>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc027e3:	fb 26 96                      	mov.l	#-106, r2

ffc027e6 <.LBE790>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_TX);
ffc027e6:	5b 44                         	movu.b	r4, r4
ffc027e8:	fe 64 55                      	mov.l	[r4, r5], r5

ffc027eb <.LBB793>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc027eb:	88 d9                         	mov.b	3[r5], r1

ffc027ed <.LVL331>:
ffc027ed:	05 8f eb ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc027f1 <.LVL332>:
ffc027f1:	38 77 ff                      	bra.w	ffc02768 <_Reset_Vector+0xffc0276c>

ffc027f4 <.LBE793>:
ffc027f4:	76 10 01 00                   	nop	; mul	#1, r0

ffc027f8 <_riic_nack>:
{
ffc027f8:	7e a7                         	push.l	r7
ffc027fa:	60 40                         	sub	#4, r0
ffc027fc:	ef 17                         	mov.l	r1, r7
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc027fe:	88 9c                         	mov.b	3[r1], r4
    volatile uint8_t uctmp = 0x00;
ffc02800:	3c 01 00                      	mov.b	#0, 1[r0]

ffc02803 <.LBB804>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02803:	88 9d                         	mov.b	3[r1], r5

ffc02805 <.LBE804>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02805:	5b 44                         	movu.b	r4, r4
ffc02807:	6c 54                         	shll	#5, r4

ffc02809 <.LBB809>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02809:	5b 55                         	movu.b	r5, r5

ffc0280b <.LBE809>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc0280b:	73 44 01 83 08                	add	#0x88301, r4, r4

ffc02810 <.LBB810>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02810:	6c 45                         	shll	#4, r5

ffc02812 <.LBE810>:
    if (RIIC_ICCR2_MST_SET == ((*piccr2_reg) & RIIC_ICCR2_MST))
ffc02812:	cc 44                         	mov.b	[r4], r4

ffc02814 <.LBB811>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02814:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0281a:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc0281e:	3e 52 08                      	mov.l	#8, 8[r5]

ffc02821 <.LBB812>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02821:	88 99                         	mov.b	3[r1], r1

ffc02823 <.LBE812>:
    if (RIIC_ICCR2_MST_SET == ((*piccr2_reg) & RIIC_ICCR2_MST))
ffc02823:	7c 64                         	btst	#6, r4
ffc02825:	3a 88 00                      	beq.w	ffc028ad <_Reset_Vector+0xffc028b1>

ffc02828 <.LBB815>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02828:	66 a2                         	mov.l	#10, r2
ffc0282a:	05 52 eb ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc0282e <.LBB816>:
    volatile uint8_t uctmp = 0x00;
ffc0282e:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02831:	88 fc                         	mov.b	3[r7], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02833:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02835:	5b 44                         	movu.b	r4, r4
ffc02837:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02839:	5b 55                         	movu.b	r5, r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc0283b:	73 44 09 83 08                	add	#0x88309, r4, r4

ffc02840 <.LVL341>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02840:	6c 55                         	shll	#5, r5
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc02842:	cc 43                         	mov.b	[r4], r3
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02844:	73 55 01 83 08                	add	#0x88301, r5, r5

ffc02849 <.LVL342>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc02849:	7c 33                         	btst	#3, r3
ffc0284b:	21 4c                         	bne.b	ffc02897 <_Reset_Vector+0xffc0289b>
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffc0284d:	f0 53                         	bset	#3, [r5].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc0284f:	cc 55                         	mov.b	[r5], r5

ffc02851 <.LVL343>:
ffc02851:	c3 05                         	mov.b	r5, [r0]

ffc02853 <.LBE816>:
    if ((((RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode)
ffc02853:	b0 fd                         	movu.b	3[r7], r5
ffc02855:	6c 45                         	shll	#4, r5
ffc02857:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0285d:	ec 55                         	mov.l	[r5], r5
ffc0285f:	61 25                         	cmp	#2, r5
ffc02861:	20 3a                         	beq.b	ffc0289b <_Reset_Vector+0xffc0289f>
            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc02863:	b0 fd                         	movu.b	3[r7], r5
ffc02865:	6c 45                         	shll	#4, r5
ffc02867:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0286d:	ec 55                         	mov.l	[r5], r5
ffc0286f:	61 35                         	cmp	#3, r5
ffc02871:	20 2a                         	beq.b	ffc0289b <_Reset_Vector+0xffc0289f>
            || (RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc02873:	b0 fd                         	movu.b	3[r7], r5
ffc02875:	6c 45                         	shll	#4, r5
ffc02877:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0287d:	ec 55                         	mov.l	[r5], r5
ffc0287f:	61 55                         	cmp	#5, r5
ffc02881:	20 1a                         	beq.b	ffc0289b <_Reset_Vector+0xffc0289f>
            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffc02883:	b0 fd                         	movu.b	3[r7], r5
ffc02885:	6c 45                         	shll	#4, r5
ffc02887:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0288d:	ec 55                         	mov.l	[r5], r5
ffc0288f:	61 65                         	cmp	#6, r5
ffc02891:	12                            	beq.s	ffc0289b <_Reset_Vector+0xffc0289f>
} /* End of function riic_nack() */
ffc02892:	66 01                         	mov.l	#0, r1
ffc02894:	3f 77 02                      	rtsd	#8, r7-r7

ffc02897 <.LBB819>:
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffc02897:	f0 4b                         	bclr	#3, [r4].b
ffc02899:	2e b4                         	bra.b	ffc0284d <_Reset_Vector+0xffc02851>

ffc0289b <.LBB820>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc0289b:	b0 ff                         	movu.b	3[r7], r7

ffc0289d <.LVL347>:
ffc0289d:	6c 57                         	shll	#5, r7
ffc0289f:	73 77 13 83 08                	add	#0x88313, r7, r7

ffc028a4 <.LVL348>:
    return *picdrr_reg;
ffc028a4:	cc 77                         	mov.b	[r7], r7

ffc028a6 <.LVL349>:
        uctmp = riic_get_receiving_data(p_riic_info);
ffc028a6:	80 0f                         	mov.b	r7, 1[r0]
} /* End of function riic_nack() */
ffc028a8:	66 01                         	mov.l	#0, r1
ffc028aa:	3f 77 02                      	rtsd	#8, r7-r7

ffc028ad <.LBB822>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc028ad:	66 82                         	mov.l	#8, r2
ffc028af:	05 cd ea ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc028b3 <.LVL351>:
ffc028b3:	2e a0                         	bra.b	ffc02853 <_Reset_Vector+0xffc02857>

ffc028b5 <.LFE32>:
ffc028b5:	fc 13 00                      	nop	; max	r0, r0

ffc028b8 <_riic_after_receive_slvadr>:
{
ffc028b8:	6e 6b                         	pushm	r6-r11
ffc028ba:	60 80                         	sub	#8, r0
ffc028bc:	ef 17                         	mov.l	r1, r7
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc028be:	88 9c                         	mov.b	3[r1], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc028c0:	cd 1a 03                      	mov.b	3[r1], r10
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc028c3:	5b 44                         	movu.b	r4, r4
    volatile uint8_t uctmp = 0x00;
ffc028c5:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc028c8:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc028ca:	5b aa                         	movu.b	r10, r10
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc028cc:	73 44 09 83 08                	add	#0x88309, r4, r4

ffc028d1 <.LVL353>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc028d1:	6c 5a                         	shll	#5, r10
    (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffc028d3:	f0 4b                         	bclr	#3, [r4].b
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc028d5:	73 aa 01 83 08                	add	#0x88301, r10, r10

ffc028da <.LVL354>:
    while (0x00 != ((*picsr2_reg) & RIIC_ICSR2_STOP))
ffc028da:	cc 45                         	mov.b	[r4], r5
ffc028dc:	7c 35                         	btst	#3, r5
ffc028de:	21 fc                         	bne.b	ffc028da <_Reset_Vector+0xffc028de>
    if (((uint8_t *) FIT_NO_PTR != p_riic_info->p_data1st) && ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data2nd))
ffc028e0:	a9 7d                         	mov.l	20[r7], r5
ffc028e2:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffc028e8:	20 6e                         	beq.b	ffc02956 <_Reset_Vector+0xffc0295a>
ffc028ea:	a9 75                         	mov.l	16[r7], r5
ffc028ec:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffc028f2:	20 64                         	beq.b	ffc02956 <_Reset_Vector+0xffc0295a>

ffc028f4 <.LBB844>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc028f4:	88 f9                         	mov.b	3[r7], r1

ffc028f6 <.LVL356>:
ffc028f6:	fb 26 b8                      	mov.l	#-72, r2
ffc028f9:	05 83 ea ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc028fd <.LVL357>:
ffc028fd:	fc 13 00                      	nop	; max	r0, r0
    if (0x00 == ((*piccr2_reg) & RIIC_ICCR2_TRS))
ffc02900:	cc a5                         	mov.b	[r10], r5

ffc02902 <.LBB846>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02902:	cd 7a 03                      	mov.b	3[r7], r10

ffc02905 <.LBE846>:
    if (0x00 == ((*piccr2_reg) & RIIC_ICCR2_TRS))
ffc02905:	7c 55                         	btst	#5, r5
ffc02907:	3b 83 00                      	bne.w	ffc0298a <_Reset_Vector+0xffc0298e>

ffc0290a <.LBB850>:
        if (0x00000002 >= p_riic_info->cnt2nd)
ffc0290a:	a8 f5                         	mov.l	8[r7], r5

ffc0290c <.LBB851>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc0290c:	5b aa                         	movu.b	r10, r10
ffc0290e:	6c 4a                         	shll	#4, r10

ffc02910 <.LVL360>:
ffc02910:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc02916:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffc0291a:	f9 a6 02 07                   	mov.l	#7, 8[r10]

ffc0291e <.LBE851>:
        if (0x00000002 >= p_riic_info->cnt2nd)
ffc0291e:	61 25                         	cmp	#2, r5
ffc02920:	24 16                         	bgtu.b	ffc02936 <_Reset_Vector+0xffc0293a>

ffc02922 <.LBB852>:
    volatile uint8_t uctmp = 0x00;
ffc02922:	3c 03 00                      	mov.b	#0, 3[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02925:	59 7a 03                      	movu.b	3[r7], r10
ffc02928:	6c 5a                         	shll	#5, r10
ffc0292a:	73 aa 04 83 08                	add	#0x88304, r10, r10

ffc0292f <.LVL363>:
    (*picmr3_reg) |= RIIC_ICMR3_WAIT_SET;
ffc0292f:	f0 a6                         	bset	#6, [r10].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffc02931:	cc aa                         	mov.b	[r10], r10

ffc02933 <.LVL364>:
ffc02933:	c7 0a 03                      	mov.b	r10, 3[r0]

ffc02936 <.LVL365>:
        if (0x00000001 >= p_riic_info->cnt2nd)
ffc02936:	ed 7a 02                      	mov.l	8[r7], r10
ffc02939:	61 1a                         	cmp	#1, r10
ffc0293b:	24 05                         	bgtu.b	ffc02940 <_Reset_Vector+0xffc02944>
ffc0293d:	38 d6 00                      	bra.w	ffc02a13 <_Reset_Vector+0xffc02a17>

ffc02940 <.LBB854>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc02940:	88 ff                         	mov.b	3[r7], r7

ffc02942 <.LBE854>:
    return RIIC_SUCCESS;
ffc02942:	66 06                         	mov.l	#0, r6

ffc02944 <.LBB857>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc02944:	5b 77                         	movu.b	r7, r7
ffc02946:	6c 57                         	shll	#5, r7
ffc02948:	73 77 13 83 08                	add	#0x88313, r7, r7

ffc0294d <.LVL368>:
    return *picdrr_reg;
ffc0294d:	cc 77                         	mov.b	[r7], r7

ffc0294f <.LBE857>:
        uctmp = riic_get_receiving_data(p_riic_info);
ffc0294f:	81 07                         	mov.b	r7, 4[r0]
} /* End of function riic_after_receive_slvadr() */
ffc02951:	ef 61                         	mov.l	r6, r1
ffc02953:	3f 6b 08                      	rtsd	#32, r6-r11

ffc02956 <.LVL370>:
    else if (((uint8_t *) FIT_NO_PTR != p_riic_info->p_data1st) && ((uint8_t *) FIT_NO_PTR == p_riic_info->p_data2nd))
ffc02956:	a9 7d                         	mov.l	20[r7], r5
ffc02958:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffc0295e:	20 0c                         	beq.b	ffc0296a <_Reset_Vector+0xffc0296e>
ffc02960:	a9 75                         	mov.l	16[r7], r5
ffc02962:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffc02968:	20 7e                         	beq.b	ffc029e6 <_Reset_Vector+0xffc029ea>
    else if (((uint8_t *) FIT_NO_PTR == p_riic_info->p_data1st) && ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data2nd))
ffc0296a:	a9 7d                         	mov.l	20[r7], r5
ffc0296c:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffc02972:	21 8e                         	bne.b	ffc02900 <_Reset_Vector+0xffc02904>
ffc02974:	a9 75                         	mov.l	16[r7], r5
ffc02976:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffc0297c:	20 84                         	beq.b	ffc02900 <_Reset_Vector+0xffc02904>

ffc0297e <.LBB858>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc0297e:	88 f9                         	mov.b	3[r7], r1

ffc02980 <.LVL372>:
ffc02980:	75 42 28                      	mov.l	#40, r2
ffc02983:	05 f9 e9 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02987 <.LVL373>:
ffc02987:	38 79 ff                      	bra.w	ffc02900 <_Reset_Vector+0xffc02904>

ffc0298a <.LBB860>:
        if (0x00000000 != p_riic_info->cnt1st)
ffc0298a:	a8 fe                         	mov.l	12[r7], r6

ffc0298c <.LBB863>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc0298c:	5b aa                         	movu.b	r10, r10
ffc0298e:	6c 4a                         	shll	#4, r10

ffc02990 <.LVL375>:
ffc02990:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc02996:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffc0299a:	f9 a6 02 06                   	mov.l	#6, 8[r10]

ffc0299e <.LBE863>:
        if (0x00000000 != p_riic_info->cnt1st)
ffc0299e:	61 06                         	cmp	#0, r6
ffc029a0:	20 52                         	beq.b	ffc029f2 <_Reset_Vector+0xffc029f6>
            if ((uint8_t *) FIT_NO_PTR == p_riic_info->p_data1st)
ffc029a2:	ed 7a 05                      	mov.l	20[r7], r10
ffc029a5:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc029ab:	3a 84 00                      	beq.w	ffc02a2f <_Reset_Vector+0xffc02a33>
            riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffc029ae:	ed 7b 05                      	mov.l	20[r7], r11

ffc029b1 <.LBB864>:
    volatile uint8_t uctmp = 0x00;
ffc029b1:	3c 02 00                      	mov.b	#0, 2[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc029b4:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc029b7:	88 f9                         	mov.b	3[r7], r1

ffc029b9 <.LBE864>:
    return RIIC_SUCCESS;
ffc029b9:	66 06                         	mov.l	#0, r6

ffc029bb <.LBB867>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc029bb:	5b aa                         	movu.b	r10, r10
ffc029bd:	6c 5a                         	shll	#5, r10
ffc029bf:	73 aa 12 83 08                	add	#0x88312, r10, r10

ffc029c4 <.LVL378>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc029c4:	05 92 e9 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc029c8 <.LVL379>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc029c8:	cc b5                         	mov.b	[r11], r5
ffc029ca:	c3 a5                         	mov.b	r5, [r10]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc029cc:	cc aa                         	mov.b	[r10], r10

ffc029ce <.LVL380>:
ffc029ce:	c7 0a 02                      	mov.b	r10, 2[r0]

ffc029d1 <.LBE867>:
            p_riic_info->cnt1st--;
ffc029d1:	ed 7a 03                      	mov.l	12[r7], r10
ffc029d4:	60 1a                         	sub	#1, r10
ffc029d6:	e7 7a 03                      	mov.l	r10, 12[r7]
            p_riic_info->p_data1st++;
ffc029d9:	ed 7a 05                      	mov.l	20[r7], r10
ffc029dc:	62 1a                         	add	#1, r10
ffc029de:	e7 7a 05                      	mov.l	r10, 20[r7]

ffc029e1 <.LVL382>:
} /* End of function riic_after_receive_slvadr() */
ffc029e1:	ef 61                         	mov.l	r6, r1
ffc029e3:	3f 6b 08                      	rtsd	#32, r6-r11

ffc029e6 <.LBB868>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc029e6:	88 f9                         	mov.b	3[r7], r1

ffc029e8 <.LVL384>:
ffc029e8:	fb 26 98                      	mov.l	#-104, r2
ffc029eb:	05 91 e9 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc029ef <.LVL385>:
ffc029ef:	38 11 ff                      	bra.w	ffc02900 <_Reset_Vector+0xffc02904>

ffc029f2 <.LBB870>:
    volatile uint8_t uctmp = 0x00;
ffc029f2:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc029f5:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc029f8:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc029fa:	5b a7                         	movu.b	r10, r7

ffc029fc <.LVL387>:
ffc029fc:	6c 57                         	shll	#5, r7
ffc029fe:	73 77 12 83 08                	add	#0x88312, r7, r7

ffc02a03 <.LVL388>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02a03:	05 53 e9 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02a07 <.LVL389>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02a07:	f8 74 ff                      	mov.b	#255, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02a0a:	cc 77                         	mov.b	[r7], r7

ffc02a0c <.LVL390>:
ffc02a0c:	80 0f                         	mov.b	r7, 1[r0]
} /* End of function riic_after_receive_slvadr() */
ffc02a0e:	ef 61                         	mov.l	r6, r1
ffc02a10:	3f 6b 08                      	rtsd	#32, r6-r11

ffc02a13 <.LBB872>:
    volatile uint8_t uctmp = 0x00;
ffc02a13:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02a16:	59 7a 03                      	movu.b	3[r7], r10
ffc02a19:	6c 5a                         	shll	#5, r10
ffc02a1b:	73 aa 04 83 08                	add	#0x88304, r10, r10

ffc02a20 <.LVL392>:
    (*picmr3_reg) |= RIIC_ICMR3_RDRFS_SET;
ffc02a20:	f0 a5                         	bset	#5, [r10].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled.                */
ffc02a22:	f0 a4                         	bset	#4, [r10].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET; /* A 1 is sent as the acknowledge bit (NACK transmission).  */
ffc02a24:	f0 a3                         	bset	#3, [r10].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled.               */
ffc02a26:	f0 ac                         	bclr	#4, [r10].b
    uctmp = *picmr3_reg; /* Reads ICMR3.                                             */
ffc02a28:	cc aa                         	mov.b	[r10], r10

ffc02a2a <.LVL393>:
ffc02a2a:	c3 0a                         	mov.b	r10, [r0]
ffc02a2c:	38 14 ff                      	bra.w	ffc02940 <_Reset_Vector+0xffc02944>

ffc02a2f <.LVL394>:
                return RIIC_ERR_OTHER;
ffc02a2f:	66 86                         	mov.l	#8, r6

ffc02a31 <.LVL395>:
ffc02a31:	2e b0                         	bra.b	ffc029e1 <_Reset_Vector+0xffc029e5>

ffc02a33 <.LFE26>:
ffc02a33:	77 10 01 00 00                	nop	; mul	#1, r0

ffc02a38 <_riic_read_data_receiving>:
{
ffc02a38:	7e a7                         	push.l	r7
ffc02a3a:	60 80                         	sub	#8, r0
    volatile uint8_t uctmp = 0x00;
ffc02a3c:	3c 04 00                      	mov.b	#0, 4[r0]
    if (0x00000003 >= p_riic_info->cnt2nd)
ffc02a3f:	a8 97                         	mov.l	8[r1], r7
ffc02a41:	61 37                         	cmp	#3, r7
ffc02a43:	24 15                         	bgtu.b	ffc02a58 <_Reset_Vector+0xffc02a5c>

ffc02a45 <.LBB892>:
    volatile uint8_t uctmp = 0x00;
ffc02a45:	3c 03 00                      	mov.b	#0, 3[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02a48:	b0 9d                         	movu.b	3[r1], r5
ffc02a4a:	6c 55                         	shll	#5, r5
ffc02a4c:	73 55 04 83 08                	add	#0x88304, r5, r5

ffc02a51 <.LVL398>:
    (*picmr3_reg) |= RIIC_ICMR3_WAIT_SET;
ffc02a51:	f0 56                         	bset	#6, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffc02a53:	cc 57                         	mov.b	[r5], r7
ffc02a55:	80 8f                         	mov.b	r7, 3[r0]

ffc02a57 <.LVL399>:
ffc02a57:	03                            	nop
    if (0x00000002 >= p_riic_info->cnt2nd)
ffc02a58:	a8 97                         	mov.l	8[r1], r7
ffc02a5a:	61 27                         	cmp	#2, r7
ffc02a5c:	24 05                         	bgtu.b	ffc02a61 <_Reset_Vector+0xffc02a65>
ffc02a5e:	38 ba 00                      	bra.w	ffc02b18 <_Reset_Vector+0xffc02b1c>
    if (0x00000001 >= p_riic_info->cnt2nd)
ffc02a61:	a8 97                         	mov.l	8[r1], r7
ffc02a63:	61 17                         	cmp	#1, r7
ffc02a65:	25 22                         	bleu.b	ffc02a87 <_Reset_Vector+0xffc02a8b>
        *p_riic_info->p_data2nd = riic_get_receiving_data(p_riic_info);
ffc02a67:	a9 17                         	mov.l	16[r1], r7

ffc02a69 <.LBB894>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc02a69:	b0 9d                         	movu.b	3[r1], r5
ffc02a6b:	6c 55                         	shll	#5, r5
ffc02a6d:	73 55 13 83 08                	add	#0x88313, r5, r5

ffc02a72 <.LVL401>:
    return *picdrr_reg;
ffc02a72:	cc 55                         	mov.b	[r5], r5

ffc02a74 <.LVL402>:
        *p_riic_info->p_data2nd = riic_get_receiving_data(p_riic_info);
ffc02a74:	c3 75                         	mov.b	r5, [r7]
        p_riic_info->cnt2nd--; /* Decreases the receiving data counter. */
ffc02a76:	a8 97                         	mov.l	8[r1], r7
ffc02a78:	60 17                         	sub	#1, r7
ffc02a7a:	a0 97                         	mov.l	r7, 8[r1]
        p_riic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffc02a7c:	a9 17                         	mov.l	16[r1], r7
ffc02a7e:	62 17                         	add	#1, r7
ffc02a80:	a1 17                         	mov.l	r7, 16[r1]
} /* End of function riic_read_data_receiving() */
ffc02a82:	66 01                         	mov.l	#0, r1

ffc02a84 <.LVL403>:
ffc02a84:	3f 77 03                      	rtsd	#12, r7-r7

ffc02a87 <.LVL404>:
ffc02a87:	ef 17                         	mov.l	r1, r7
        if (RIIC_MODE_S_RECEIVE != riic_api_info[p_riic_info->ch_no].N_Mode)
ffc02a89:	b0 9d                         	movu.b	3[r1], r5
ffc02a8b:	6c 45                         	shll	#4, r5
ffc02a8d:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02a93:	ec 55                         	mov.l	[r5], r5
ffc02a95:	61 65                         	cmp	#6, r5
ffc02a97:	20 43                         	beq.b	ffc02ada <_Reset_Vector+0xffc02ade>

ffc02a99 <.LBB896>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02a99:	88 9d                         	mov.b	3[r1], r5

ffc02a9b <.LBB899>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02a9b:	88 99                         	mov.b	3[r1], r1

ffc02a9d <.LVL407>:
ffc02a9d:	75 42 1a                      	mov.l	#26, r2

ffc02aa0 <.LBB902>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02aa0:	5b 55                         	movu.b	r5, r5
ffc02aa2:	6c 45                         	shll	#4, r5

ffc02aa4 <.LVL408>:
ffc02aa4:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02aaa:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc02aae:	3e 52 08                      	mov.l	#8, 8[r5]

ffc02ab1 <.LBB903>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02ab1:	05 cb e8 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02ab5 <.LBB904>:
    volatile uint8_t uctmp = 0x00;
ffc02ab5:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02ab8:	88 fc                         	mov.b	3[r7], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02aba:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02abc:	5b 44                         	movu.b	r4, r4
ffc02abe:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02ac0:	5b 55                         	movu.b	r5, r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02ac2:	73 44 09 83 08                	add	#0x88309, r4, r4

ffc02ac7 <.LVL411>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02ac7:	6c 55                         	shll	#5, r5
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc02ac9:	cc 43                         	mov.b	[r4], r3
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02acb:	73 55 01 83 08                	add	#0x88301, r5, r5

ffc02ad0 <.LVL412>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc02ad0:	7c 33                         	btst	#3, r3
ffc02ad2:	21 70                         	bne.b	ffc02b42 <_Reset_Vector+0xffc02b46>
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffc02ad4:	f0 53                         	bset	#3, [r5].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc02ad6:	cc 55                         	mov.b	[r5], r5

ffc02ad8 <.LVL413>:
ffc02ad8:	80 0d                         	mov.b	r5, 1[r0]

ffc02ada <.LBE904>:
        if (0x00000000 != p_riic_info->cnt2nd)
ffc02ada:	a8 f5                         	mov.l	8[r7], r5
ffc02adc:	61 05                         	cmp	#0, r5
ffc02ade:	20 55                         	beq.b	ffc02b33 <_Reset_Vector+0xffc02b37>
            *p_riic_info->p_data2nd = riic_get_receiving_data(p_riic_info);
ffc02ae0:	a9 74                         	mov.l	16[r7], r4

ffc02ae2 <.LBB907>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc02ae2:	b0 fd                         	movu.b	3[r7], r5
ffc02ae4:	6c 55                         	shll	#5, r5
ffc02ae6:	73 55 13 83 08                	add	#0x88313, r5, r5

ffc02aeb <.LVL416>:
    return *picdrr_reg;
ffc02aeb:	cc 55                         	mov.b	[r5], r5

ffc02aed <.LVL417>:
            *p_riic_info->p_data2nd = riic_get_receiving_data(p_riic_info);
ffc02aed:	c3 45                         	mov.b	r5, [r4]
            p_riic_info->cnt2nd--; /* Decreases the receiving data counter. */
ffc02aef:	a8 f5                         	mov.l	8[r7], r5
ffc02af1:	60 15                         	sub	#1, r5
ffc02af3:	a0 f5                         	mov.l	r5, 8[r7]
            p_riic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffc02af5:	a9 75                         	mov.l	16[r7], r5
ffc02af7:	62 15                         	add	#1, r5
ffc02af9:	a1 75                         	mov.l	r5, 16[r7]

ffc02afb <.LBB909>:
    volatile uint8_t uctmp = 0x00;
ffc02afb:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02afe:	b0 fd                         	movu.b	3[r7], r5
ffc02b00:	6c 55                         	shll	#5, r5
ffc02b02:	73 55 04 83 08                	add	#0x88304, r5, r5

ffc02b07 <.LVL419>:
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled. */
ffc02b07:	f0 54                         	bset	#4, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET;
ffc02b09:	f0 53                         	bset	#3, [r5].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled. */
ffc02b0b:	f0 5c                         	bclr	#4, [r5].b
    (*picmr3_reg) &= RIIC_ICMR3_WAIT_CLR;
ffc02b0d:	f0 5e                         	bclr	#6, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffc02b0f:	cc 57                         	mov.b	[r5], r7

ffc02b11 <.LVL420>:
ffc02b11:	c3 07                         	mov.b	r7, [r0]
} /* End of function riic_read_data_receiving() */
ffc02b13:	66 01                         	mov.l	#0, r1
ffc02b15:	3f 77 03                      	rtsd	#12, r7-r7

ffc02b18 <.LBB911>:
    volatile uint8_t uctmp = 0x00;
ffc02b18:	3c 02 00                      	mov.b	#0, 2[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02b1b:	b0 9d                         	movu.b	3[r1], r5
ffc02b1d:	6c 55                         	shll	#5, r5
ffc02b1f:	73 55 04 83 08                	add	#0x88304, r5, r5

ffc02b24 <.LVL422>:
    (*picmr3_reg) |= RIIC_ICMR3_RDRFS_SET;
ffc02b24:	f0 55                         	bset	#5, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled.                */
ffc02b26:	f0 54                         	bset	#4, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET; /* A 1 is sent as the acknowledge bit (NACK transmission).  */
ffc02b28:	f0 53                         	bset	#3, [r5].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled.               */
ffc02b2a:	f0 5c                         	bclr	#4, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3.                                             */
ffc02b2c:	cc 57                         	mov.b	[r5], r7
ffc02b2e:	80 87                         	mov.b	r7, 2[r0]
ffc02b30:	38 31 ff                      	bra.w	ffc02a61 <_Reset_Vector+0xffc02a65>

ffc02b33 <.LBB913>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc02b33:	b0 fd                         	movu.b	3[r7], r5
ffc02b35:	6c 55                         	shll	#5, r5
ffc02b37:	73 55 13 83 08                	add	#0x88313, r5, r5

ffc02b3c <.LVL424>:
    return *picdrr_reg;
ffc02b3c:	cc 55                         	mov.b	[r5], r5

ffc02b3e <.LVL425>:
            uctmp = riic_get_receiving_data(p_riic_info);
ffc02b3e:	81 05                         	mov.b	r5, 4[r0]
ffc02b40:	2e bb                         	bra.b	ffc02afb <_Reset_Vector+0xffc02aff>

ffc02b42 <.LBB915>:
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffc02b42:	f0 4b                         	bclr	#3, [r4].b
ffc02b44:	2e 90                         	bra.b	ffc02ad4 <_Reset_Vector+0xffc02ad8>

ffc02b46 <.LBE915>:
ffc02b46:	ef 00                         	nop	; mov.l	r0, r0

ffc02b48 <_riic_write_data_sending>:
{
ffc02b48:	6e 6b                         	pushm	r6-r11
ffc02b4a:	60 80                         	sub	#8, r0

ffc02b4c <.LVL428>:
ffc02b4c:	ef 17                         	mov.l	r1, r7
    switch (riic_api_info[p_riic_info->ch_no].N_Mode)
ffc02b4e:	b0 9d                         	movu.b	3[r1], r5
ffc02b50:	6c 45                         	shll	#4, r5
ffc02b52:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02b58:	ec 55                         	mov.l	[r5], r5
ffc02b5a:	61 35                         	cmp	#3, r5
ffc02b5c:	20 12                         	beq.b	ffc02b6e <_Reset_Vector+0xffc02b72>
ffc02b5e:	61 55                         	cmp	#5, r5
ffc02b60:	3a cd 00                      	beq.w	ffc02c2d <_Reset_Vector+0xffc02c31>
ffc02b63:	61 15                         	cmp	#1, r5
ffc02b65:	20 57                         	beq.b	ffc02bbc <_Reset_Vector+0xffc02bc0>
            ret = RIIC_ERR_OTHER;
ffc02b67:	66 8a                         	mov.l	#8, r10

ffc02b69 <.LVL429>:
} /* End of function riic_write_data_sending() */
ffc02b69:	ef a1                         	mov.l	r10, r1
ffc02b6b:	3f 6b 08                      	rtsd	#32, r6-r11

ffc02b6e <.LVL430>:
            if (0x00000000 != p_riic_info->cnt1st)
ffc02b6e:	ed 1a 03                      	mov.l	12[r1], r10
ffc02b71:	61 0a                         	cmp	#0, r10
ffc02b73:	3b f0 00                      	bne.w	ffc02c63 <_Reset_Vector+0xffc02c67>

ffc02b76 <.LBB940>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02b76:	88 9c                         	mov.b	3[r1], r4

ffc02b78 <.LBB943>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02b78:	88 99                         	mov.b	3[r1], r1

ffc02b7a <.LVL433>:
ffc02b7a:	75 42 16                      	mov.l	#22, r2

ffc02b7d <.LBB946>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02b7d:	5b 44                         	movu.b	r4, r4
ffc02b7f:	6c 44                         	shll	#4, r4

ffc02b81 <.LVL434>:
ffc02b81:	70 44 5c 04 00 00             	add	#0x45c, r4, r4
ffc02b87:	e5 44 02 03                   	mov.l	8[r4], 12[r4]
    riic_api_info[ch_no].N_status = new_status;
ffc02b8b:	a0 c5                         	mov.l	r5, 8[r4]

ffc02b8d <.LBB947>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02b8d:	05 ef e7 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02b91 <.LBB948>:
    volatile uint8_t uctmp = 0x00;
ffc02b91:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02b94:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02b96:	88 ff                         	mov.b	3[r7], r7

ffc02b98 <.LVL437>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02b98:	5b 55                         	movu.b	r5, r5
ffc02b9a:	6c 55                         	shll	#5, r5
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02b9c:	5b 77                         	movu.b	r7, r7
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02b9e:	73 55 09 83 08                	add	#0x88309, r5, r5

ffc02ba3 <.LVL438>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02ba3:	6c 57                         	shll	#5, r7
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START_SET) >> 2U))
ffc02ba5:	cc 54                         	mov.b	[r5], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02ba7:	73 77 01 83 08                	add	#0x88301, r7, r7

ffc02bac <.LVL439>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START_SET) >> 2U))
ffc02bac:	7c 24                         	btst	#2, r4
ffc02bae:	13                            	beq.s	ffc02bb1 <_Reset_Vector+0xffc02bb5>
        (*picsr2_reg) &= RIIC_ICSR2_START_CLR;
ffc02baf:	f0 5a                         	bclr	#2, [r5].b
    (*piccr2_reg) |= RIIC_ICCR2_RS; /* Sets ICCR2.RS bit. */
ffc02bb1:	f0 72                         	bset	#2, [r7].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc02bb3:	cc 77                         	mov.b	[r7], r7

ffc02bb5 <.LVL440>:
ffc02bb5:	c3 07                         	mov.b	r7, [r0]
} /* End of function riic_write_data_sending() */
ffc02bb7:	ef a1                         	mov.l	r10, r1
ffc02bb9:	3f 6b 08                      	rtsd	#32, r6-r11

ffc02bbc <.LVL441>:
            if ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data1st)
ffc02bbc:	ed 1a 05                      	mov.l	20[r1], r10
ffc02bbf:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02bc5:	11                            	beq.s	ffc02bce <_Reset_Vector+0xffc02bd2>
                if (0x00000000 != p_riic_info->cnt1st) /* Pattern 1 of Master Write */
ffc02bc6:	ed 1a 03                      	mov.l	12[r1], r10
ffc02bc9:	61 0a                         	cmp	#0, r10
ffc02bcb:	3b ea 00                      	bne.w	ffc02cb5 <_Reset_Vector+0xffc02cb9>
            if ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data2nd)
ffc02bce:	ed 7a 04                      	mov.l	16[r7], r10
ffc02bd1:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02bd7:	11                            	beq.s	ffc02be0 <_Reset_Vector+0xffc02be4>
                if (0x00000000 != p_riic_info->cnt2nd) /* Pattern 2 of Master Write */
ffc02bd8:	ed 7a 02                      	mov.l	8[r7], r10
ffc02bdb:	61 0a                         	cmp	#0, r10
ffc02bdd:	3b fb 00                      	bne.w	ffc02cd8 <_Reset_Vector+0xffc02cdc>

ffc02be0 <.LBB950>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02be0:	cd 7a 03                      	mov.b	3[r7], r10

ffc02be3 <.LBB953>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02be3:	88 f9                         	mov.b	3[r7], r1

ffc02be5 <.LVL444>:
ffc02be5:	75 42 1a                      	mov.l	#26, r2

ffc02be8 <.LBB956>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02be8:	5b aa                         	movu.b	r10, r10
ffc02bea:	6c 4a                         	shll	#4, r10

ffc02bec <.LVL445>:
ffc02bec:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc02bf2:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffc02bf6:	f9 a6 02 08                   	mov.l	#8, 8[r10]

ffc02bfa <.LBB957>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02bfa:	05 82 e7 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02bfe <.LBB958>:
    volatile uint8_t uctmp = 0x00;
ffc02bfe:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02c01:	cd 7a 03                      	mov.b	3[r7], r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02c04:	88 ff                         	mov.b	3[r7], r7

ffc02c06 <.LVL448>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02c06:	5b aa                         	movu.b	r10, r10
ffc02c08:	6c 5a                         	shll	#5, r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02c0a:	5b 77                         	movu.b	r7, r7
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02c0c:	73 aa 09 83 08                	add	#0x88309, r10, r10

ffc02c11 <.LVL449>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02c11:	6c 57                         	shll	#5, r7
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc02c13:	cc a5                         	mov.b	[r10], r5
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02c15:	73 77 01 83 08                	add	#0x88301, r7, r7

ffc02c1a <.LVL450>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc02c1a:	7c 35                         	btst	#3, r5
ffc02c1c:	14                            	beq.s	ffc02c20 <_Reset_Vector+0xffc02c24>
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffc02c1d:	f0 ab                         	bclr	#3, [r10].b
ffc02c1f:	03                            	nop
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffc02c20:	f0 73                         	bset	#3, [r7].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc02c22:	cc 77                         	mov.b	[r7], r7

ffc02c24 <.LBE958>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02c24:	66 0a                         	mov.l	#0, r10

ffc02c26 <.LBB961>:
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc02c26:	80 0f                         	mov.b	r7, 1[r0]

ffc02c28 <.LBE961>:
} /* End of function riic_write_data_sending() */
ffc02c28:	ef a1                         	mov.l	r10, r1
ffc02c2a:	3f 6b 08                      	rtsd	#32, r6-r11

ffc02c2d <.LVL453>:
            if ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data1st)
ffc02c2d:	ed 1a 05                      	mov.l	20[r1], r10
ffc02c30:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02c36:	3a d2 00                      	beq.w	ffc02d08 <_Reset_Vector+0xffc02d0c>
                if (0x00000000 != p_riic_info->cnt1st)
ffc02c39:	ed 1a 03                      	mov.l	12[r1], r10
ffc02c3c:	61 0a                         	cmp	#0, r10
ffc02c3e:	20 57                         	beq.b	ffc02c95 <_Reset_Vector+0xffc02c99>
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffc02c40:	ed 1b 05                      	mov.l	20[r1], r11

ffc02c43 <.LBB962>:
    volatile uint8_t uctmp = 0x00;
ffc02c43:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02c46:	88 9e                         	mov.b	3[r1], r6
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02c48:	88 99                         	mov.b	3[r1], r1

ffc02c4a <.LBE962>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02c4a:	66 0a                         	mov.l	#0, r10

ffc02c4c <.LBB965>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02c4c:	5b 66                         	movu.b	r6, r6
ffc02c4e:	6c 56                         	shll	#5, r6
ffc02c50:	73 66 12 83 08                	add	#0x88312, r6, r6

ffc02c55 <.LVL456>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02c55:	05 01 e7 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02c59 <.LVL457>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02c59:	cc b5                         	mov.b	[r11], r5
ffc02c5b:	c3 65                         	mov.b	r5, [r6]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02c5d:	cc 65                         	mov.b	[r6], r5
ffc02c5f:	81 05                         	mov.b	r5, 4[r0]

ffc02c61 <.LBE965>:
                    p_riic_info->cnt1st--;
ffc02c61:	2e 23                         	bra.b	ffc02c84 <_Reset_Vector+0xffc02c88>

ffc02c63 <.LVL459>:
                riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffc02c63:	ed 1b 05                      	mov.l	20[r1], r11

ffc02c66 <.LBB966>:
    volatile uint8_t uctmp = 0x00;
ffc02c66:	3c 05 00                      	mov.b	#0, 5[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02c69:	88 9e                         	mov.b	3[r1], r6
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02c6b:	88 99                         	mov.b	3[r1], r1

ffc02c6d <.LBE966>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02c6d:	66 0a                         	mov.l	#0, r10

ffc02c6f <.LBB969>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02c6f:	5b 66                         	movu.b	r6, r6
ffc02c71:	6c 56                         	shll	#5, r6
ffc02c73:	73 66 12 83 08                	add	#0x88312, r6, r6

ffc02c78 <.LVL462>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02c78:	05 de e6 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02c7c <.LVL463>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02c7c:	cc b5                         	mov.b	[r11], r5
ffc02c7e:	c3 65                         	mov.b	r5, [r6]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02c80:	cc 65                         	mov.b	[r6], r5
ffc02c82:	81 0d                         	mov.b	r5, 5[r0]

ffc02c84 <.LBE969>:
                p_riic_info->cnt1st--;
ffc02c84:	a8 fd                         	mov.l	12[r7], r5
ffc02c86:	60 15                         	sub	#1, r5
ffc02c88:	a0 fd                         	mov.l	r5, 12[r7]
                p_riic_info->p_data1st++;
ffc02c8a:	a9 7d                         	mov.l	20[r7], r5
ffc02c8c:	62 15                         	add	#1, r5
ffc02c8e:	a1 7d                         	mov.l	r5, 20[r7]
} /* End of function riic_write_data_sending() */
ffc02c90:	ef a1                         	mov.l	r10, r1
ffc02c92:	3f 6b 08                      	rtsd	#32, r6-r11

ffc02c95 <.LBB970>:
    volatile uint8_t uctmp = 0x00;
ffc02c95:	3c 03 00                      	mov.b	#0, 3[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02c98:	88 9d                         	mov.b	3[r1], r5
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02c9a:	88 99                         	mov.b	3[r1], r1

ffc02c9c <.LVL466>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02c9c:	5b 57                         	movu.b	r5, r7

ffc02c9e <.LVL467>:
ffc02c9e:	6c 57                         	shll	#5, r7
ffc02ca0:	73 77 12 83 08                	add	#0x88312, r7, r7

ffc02ca5 <.LVL468>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02ca5:	05 b1 e6 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02ca9 <.LVL469>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02ca9:	f8 74 ff                      	mov.b	#255, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02cac:	cc 77                         	mov.b	[r7], r7

ffc02cae <.LVL470>:
ffc02cae:	80 8f                         	mov.b	r7, 3[r0]
} /* End of function riic_write_data_sending() */
ffc02cb0:	ef a1                         	mov.l	r10, r1
ffc02cb2:	3f 6b 08                      	rtsd	#32, r6-r11

ffc02cb5 <.LVL471>:
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffc02cb5:	ed 1b 05                      	mov.l	20[r1], r11

ffc02cb8 <.LBB972>:
    volatile uint8_t uctmp = 0x00;
ffc02cb8:	3c 07 00                      	mov.b	#0, 7[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02cbb:	88 9e                         	mov.b	3[r1], r6
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02cbd:	88 99                         	mov.b	3[r1], r1

ffc02cbf <.LBE972>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02cbf:	66 0a                         	mov.l	#0, r10

ffc02cc1 <.LBB975>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02cc1:	5b 66                         	movu.b	r6, r6
ffc02cc3:	6c 56                         	shll	#5, r6
ffc02cc5:	73 66 12 83 08                	add	#0x88312, r6, r6

ffc02cca <.LVL474>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02cca:	05 8c e6 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02cce <.LVL475>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02cce:	cc b5                         	mov.b	[r11], r5
ffc02cd0:	c3 65                         	mov.b	r5, [r6]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02cd2:	cc 65                         	mov.b	[r6], r5
ffc02cd4:	81 8d                         	mov.b	r5, 7[r0]

ffc02cd6 <.LBE975>:
                    p_riic_info->cnt1st--;
ffc02cd6:	2e ae                         	bra.b	ffc02c84 <_Reset_Vector+0xffc02c88>

ffc02cd8 <.LVL477>:
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data2nd);
ffc02cd8:	ed 7b 04                      	mov.l	16[r7], r11

ffc02cdb <.LBB976>:
    volatile uint8_t uctmp = 0x00;
ffc02cdb:	3c 06 00                      	mov.b	#0, 6[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02cde:	88 fe                         	mov.b	3[r7], r6
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02ce0:	88 f9                         	mov.b	3[r7], r1

ffc02ce2 <.LBE976>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02ce2:	66 0a                         	mov.l	#0, r10

ffc02ce4 <.LBB979>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02ce4:	5b 66                         	movu.b	r6, r6
ffc02ce6:	6c 56                         	shll	#5, r6
ffc02ce8:	73 66 12 83 08                	add	#0x88312, r6, r6

ffc02ced <.LVL480>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02ced:	05 69 e6 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02cf1 <.LVL481>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02cf1:	cc b5                         	mov.b	[r11], r5
ffc02cf3:	c3 65                         	mov.b	r5, [r6]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02cf5:	cc 65                         	mov.b	[r6], r5
ffc02cf7:	81 85                         	mov.b	r5, 6[r0]

ffc02cf9 <.LBE979>:
                    p_riic_info->cnt2nd--;
ffc02cf9:	a8 f5                         	mov.l	8[r7], r5
ffc02cfb:	60 15                         	sub	#1, r5
ffc02cfd:	a0 f5                         	mov.l	r5, 8[r7]
                    p_riic_info->p_data2nd++;
ffc02cff:	a9 75                         	mov.l	16[r7], r5
ffc02d01:	62 15                         	add	#1, r5
ffc02d03:	a1 75                         	mov.l	r5, 16[r7]
                    break;
ffc02d05:	38 64 fe                      	bra.w	ffc02b69 <_Reset_Vector+0xffc02b6d>

ffc02d08 <.LBB980>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02d08:	66 0a                         	mov.l	#0, r10

ffc02d0a <.LBB983>:
    volatile uint8_t uctmp = 0x00;
ffc02d0a:	3c 02 00                      	mov.b	#0, 2[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02d0d:	88 9d                         	mov.b	3[r1], r5
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02d0f:	88 99                         	mov.b	3[r1], r1

ffc02d11 <.LVL484>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02d11:	5b 57                         	movu.b	r5, r7

ffc02d13 <.LVL485>:
ffc02d13:	6c 57                         	shll	#5, r7
ffc02d15:	73 77 12 83 08                	add	#0x88312, r7, r7

ffc02d1a <.LVL486>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02d1a:	05 3c e6 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02d1e <.LVL487>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02d1e:	f8 74 ff                      	mov.b	#255, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02d21:	cc 77                         	mov.b	[r7], r7

ffc02d23 <.LVL488>:
ffc02d23:	80 87                         	mov.b	r7, 2[r0]
ffc02d25:	38 44 fe                      	bra.w	ffc02b69 <_Reset_Vector+0xffc02b6d>

ffc02d28 <_riic_after_send_slvadr>:
{
ffc02d28:	6e 6a                         	pushm	r6-r10
ffc02d2a:	60 c0                         	sub	#12, r0

ffc02d2c <.LVL490>:
ffc02d2c:	ef 17                         	mov.l	r1, r7
    volatile uint8_t uctmp = 0x00;
ffc02d2e:	3c 08 00                      	mov.b	#0, 8[r0]
    switch (riic_api_info[p_riic_info->ch_no].N_Mode)
ffc02d31:	b0 9d                         	movu.b	3[r1], r5
ffc02d33:	6c 45                         	shll	#4, r5
ffc02d35:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02d3b:	ec 55                         	mov.l	[r5], r5
ffc02d3d:	61 25                         	cmp	#2, r5
ffc02d3f:	3a dd 00                      	beq.w	ffc02e1c <_Reset_Vector+0xffc02e20>
ffc02d42:	61 35                         	cmp	#3, r5
ffc02d44:	20 6a                         	beq.b	ffc02dae <_Reset_Vector+0xffc02db2>
ffc02d46:	61 15                         	cmp	#1, r5
ffc02d48:	16                            	beq.s	ffc02d4e <_Reset_Vector+0xffc02d52>

ffc02d49 <.LVL491>:
            ret = RIIC_ERR_OTHER;
ffc02d49:	66 81                         	mov.l	#8, r1

ffc02d4b <.LVL492>:
} /* End of function riic_after_send_slvadr() */
ffc02d4b:	3f 6a 08                      	rtsd	#32, r6-r10

ffc02d4e <.LVL493>:
            if (((uint8_t *) FIT_NO_PTR != (uint8_t *) p_riic_info->p_data1st)
ffc02d4e:	ed 1a 05                      	mov.l	20[r1], r10
ffc02d51:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02d57:	3a 6e 01                      	beq.w	ffc02ec5 <_Reset_Vector+0xffc02ec9>
                    && ((uint8_t *) FIT_NO_PTR != (uint8_t *) p_riic_info->p_data2nd))
ffc02d5a:	ed 1a 04                      	mov.l	16[r1], r10
ffc02d5d:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02d63:	3a 62 01                      	beq.w	ffc02ec5 <_Reset_Vector+0xffc02ec9>

ffc02d66 <.LBB1028>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02d66:	88 9d                         	mov.b	3[r1], r5

ffc02d68 <.LBB1031>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02d68:	88 99                         	mov.b	3[r1], r1

ffc02d6a <.LVL496>:
ffc02d6a:	75 42 52                      	mov.l	#82, r2

ffc02d6d <.LBB1034>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02d6d:	5b 55                         	movu.b	r5, r5
ffc02d6f:	6c 45                         	shll	#4, r5

ffc02d71 <.LVL497>:
ffc02d71:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02d77:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc02d7b:	3e 52 06                      	mov.l	#6, 8[r5]

ffc02d7e <.LBB1035>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02d7e:	05 fe e5 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02d82 <.LBE1035>:
                if (0x00000000 != p_riic_info->cnt1st)
ffc02d82:	ed 7a 03                      	mov.l	12[r7], r10
ffc02d85:	61 0a                         	cmp	#0, r10
ffc02d87:	20 c2                         	beq.b	ffc02d49 <_Reset_Vector+0xffc02d4d>
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffc02d89:	a9 7e                         	mov.l	20[r7], r6

ffc02d8b <.LBB1036>:
    volatile uint8_t uctmp = 0x00;
ffc02d8b:	3c 07 00                      	mov.b	#0, 7[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02d8e:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02d91:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02d93:	5b aa                         	movu.b	r10, r10
ffc02d95:	6c 5a                         	shll	#5, r10
ffc02d97:	73 aa 12 83 08                	add	#0x88312, r10, r10

ffc02d9c <.LVL501>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02d9c:	05 ba e5 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02da0 <.LVL502>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02da0:	cc 65                         	mov.b	[r6], r5

ffc02da2 <.LBE1036>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02da2:	66 01                         	mov.l	#0, r1

ffc02da4 <.LBB1039>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02da4:	c3 a5                         	mov.b	r5, [r10]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02da6:	cc aa                         	mov.b	[r10], r10

ffc02da8 <.LVL503>:
ffc02da8:	c7 0a 07                      	mov.b	r10, 7[r0]

ffc02dab <.LBE1039>:
                    p_riic_info->cnt1st--;
ffc02dab:	38 07 01                      	bra.w	ffc02eb2 <_Reset_Vector+0xffc02eb6>

ffc02dae <.LVL505>:
            switch (riic_api_info[p_riic_info->ch_no].N_status)
ffc02dae:	b0 9d                         	movu.b	3[r1], r5
ffc02db0:	6c 45                         	shll	#4, r5
ffc02db2:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02db8:	a8 d5                         	mov.l	8[r5], r5
ffc02dba:	61 45                         	cmp	#4, r5
ffc02dbc:	3a b8 00                      	beq.w	ffc02e74 <_Reset_Vector+0xffc02e78>
ffc02dbf:	61 55                         	cmp	#5, r5
ffc02dc1:	21 88                         	bne.b	ffc02d49 <_Reset_Vector+0xffc02d4d>

ffc02dc3 <.LBB1040>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02dc3:	88 9d                         	mov.b	3[r1], r5

ffc02dc5 <.LBB1043>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02dc5:	88 99                         	mov.b	3[r1], r1

ffc02dc7 <.LVL508>:
ffc02dc7:	75 42 32                      	mov.l	#50, r2

ffc02dca <.LBB1046>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02dca:	5b 55                         	movu.b	r5, r5
ffc02dcc:	6c 45                         	shll	#4, r5

ffc02dce <.LVL509>:
ffc02dce:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02dd4:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc02dd8:	3e 52 07                      	mov.l	#7, 8[r5]

ffc02ddb <.LBB1047>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02ddb:	05 a1 e5 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02ddf <.LBE1047>:
                    if (2U >= p_riic_info->cnt2nd)
ffc02ddf:	ed 7a 02                      	mov.l	8[r7], r10
ffc02de2:	61 2a                         	cmp	#2, r10
ffc02de4:	24 16                         	bgtu.b	ffc02dfa <_Reset_Vector+0xffc02dfe>

ffc02de6 <.LBB1048>:
    volatile uint8_t uctmp = 0x00;
ffc02de6:	3c 03 00                      	mov.b	#0, 3[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02de9:	59 7a 03                      	movu.b	3[r7], r10
ffc02dec:	6c 5a                         	shll	#5, r10
ffc02dee:	73 aa 04 83 08                	add	#0x88304, r10, r10

ffc02df3 <.LVL513>:
    (*picmr3_reg) |= RIIC_ICMR3_WAIT_SET;
ffc02df3:	f0 a6                         	bset	#6, [r10].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffc02df5:	cc aa                         	mov.b	[r10], r10

ffc02df7 <.LVL514>:
ffc02df7:	c7 0a 03                      	mov.b	r10, 3[r0]

ffc02dfa <.LVL515>:
                    if (0x00000001 >= p_riic_info->cnt2nd)
ffc02dfa:	ed 7a 02                      	mov.l	8[r7], r10
ffc02dfd:	61 1a                         	cmp	#1, r10
ffc02dff:	24 05                         	bgtu.b	ffc02e04 <_Reset_Vector+0xffc02e08>
ffc02e01:	38 32 01                      	bra.w	ffc02f33 <_Reset_Vector+0xffc02f37>
ffc02e04:	76 10 01 00                   	nop	; mul	#1, r0

ffc02e08 <.LBB1050>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc02e08:	88 ff                         	mov.b	3[r7], r7

ffc02e0a <.LBE1050>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02e0a:	66 01                         	mov.l	#0, r1

ffc02e0c <.LBB1053>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc02e0c:	5b 77                         	movu.b	r7, r7
ffc02e0e:	6c 57                         	shll	#5, r7
ffc02e10:	73 77 13 83 08                	add	#0x88313, r7, r7

ffc02e15 <.LVL518>:
    return *picdrr_reg;
ffc02e15:	cc 77                         	mov.b	[r7], r7

ffc02e17 <.LBE1053>:
                    uctmp = riic_get_receiving_data(p_riic_info);
ffc02e17:	82 07                         	mov.b	r7, 8[r0]
} /* End of function riic_after_send_slvadr() */
ffc02e19:	3f 6a 08                      	rtsd	#32, r6-r10

ffc02e1c <.LBB1054>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02e1c:	88 9d                         	mov.b	3[r1], r5

ffc02e1e <.LBB1057>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02e1e:	88 99                         	mov.b	3[r1], r1

ffc02e20 <.LVL522>:
ffc02e20:	75 42 32                      	mov.l	#50, r2

ffc02e23 <.LBB1060>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02e23:	5b 55                         	movu.b	r5, r5
ffc02e25:	6c 45                         	shll	#4, r5

ffc02e27 <.LVL523>:
ffc02e27:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02e2d:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc02e31:	3e 52 07                      	mov.l	#7, 8[r5]

ffc02e34 <.LBB1061>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02e34:	05 48 e5 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02e38 <.LBE1061>:
            if (2U >= p_riic_info->cnt2nd)
ffc02e38:	ed 7a 02                      	mov.l	8[r7], r10
ffc02e3b:	61 2a                         	cmp	#2, r10
ffc02e3d:	24 15                         	bgtu.b	ffc02e52 <_Reset_Vector+0xffc02e56>

ffc02e3f <.LBB1062>:
    volatile uint8_t uctmp = 0x00;
ffc02e3f:	3c 05 00                      	mov.b	#0, 5[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02e42:	b0 fd                         	movu.b	3[r7], r5
ffc02e44:	6c 55                         	shll	#5, r5
ffc02e46:	73 55 04 83 08                	add	#0x88304, r5, r5

ffc02e4b <.LVL527>:
    (*picmr3_reg) |= RIIC_ICMR3_WAIT_SET;
ffc02e4b:	f0 56                         	bset	#6, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffc02e4d:	cc 5a                         	mov.b	[r5], r10
ffc02e4f:	c7 0a 05                      	mov.b	r10, 5[r0]

ffc02e52 <.LVL528>:
            if (0x00000001 >= p_riic_info->cnt2nd)
ffc02e52:	ed 7a 02                      	mov.l	8[r7], r10
ffc02e55:	61 1a                         	cmp	#1, r10
ffc02e57:	24 b1                         	bgtu.b	ffc02e08 <_Reset_Vector+0xffc02e0c>

ffc02e59 <.LBB1064>:
    volatile uint8_t uctmp = 0x00;
ffc02e59:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02e5c:	b0 fd                         	movu.b	3[r7], r5
ffc02e5e:	6c 55                         	shll	#5, r5
ffc02e60:	73 55 04 83 08                	add	#0x88304, r5, r5

ffc02e65 <.LVL530>:
    (*picmr3_reg) |= RIIC_ICMR3_RDRFS_SET;
ffc02e65:	f0 55                         	bset	#5, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled.                */
ffc02e67:	f0 54                         	bset	#4, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET; /* A 1 is sent as the acknowledge bit (NACK transmission).  */
ffc02e69:	f0 53                         	bset	#3, [r5].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled.               */
ffc02e6b:	f0 5c                         	bclr	#4, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3.                                             */
ffc02e6d:	cc 5a                         	mov.b	[r5], r10
ffc02e6f:	c7 0a 01                      	mov.b	r10, 1[r0]

ffc02e72 <.LBB1066>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffc02e72:	2e 96                         	bra.b	ffc02e08 <_Reset_Vector+0xffc02e0c>

ffc02e74 <.LBB1068>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02e74:	88 9d                         	mov.b	3[r1], r5

ffc02e76 <.LBB1071>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02e76:	88 99                         	mov.b	3[r1], r1

ffc02e78 <.LVL534>:
ffc02e78:	75 42 52                      	mov.l	#82, r2

ffc02e7b <.LBB1074>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02e7b:	5b 55                         	movu.b	r5, r5
ffc02e7d:	6c 45                         	shll	#4, r5

ffc02e7f <.LVL535>:
ffc02e7f:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc02e85:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc02e89:	3e 52 06                      	mov.l	#6, 8[r5]

ffc02e8c <.LBB1075>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02e8c:	05 f0 e4 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02e90 <.LBE1075>:
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffc02e90:	a9 7e                         	mov.l	20[r7], r6

ffc02e92 <.LBB1076>:
    volatile uint8_t uctmp = 0x00;
ffc02e92:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02e95:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02e98:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02e9a:	5b aa                         	movu.b	r10, r10
ffc02e9c:	6c 5a                         	shll	#5, r10
ffc02e9e:	73 aa 12 83 08                	add	#0x88312, r10, r10

ffc02ea3 <.LVL539>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02ea3:	05 b3 e4 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02ea7 <.LVL540>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02ea7:	cc 65                         	mov.b	[r6], r5

ffc02ea9 <.LBE1076>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02ea9:	66 01                         	mov.l	#0, r1

ffc02eab <.LBB1079>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02eab:	c3 a5                         	mov.b	r5, [r10]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02ead:	cc aa                         	mov.b	[r10], r10

ffc02eaf <.LVL541>:
ffc02eaf:	c7 0a 04                      	mov.b	r10, 4[r0]

ffc02eb2 <.LBE1079>:
                    p_riic_info->cnt1st--;
ffc02eb2:	ed 7a 03                      	mov.l	12[r7], r10
ffc02eb5:	60 1a                         	sub	#1, r10
ffc02eb7:	e7 7a 03                      	mov.l	r10, 12[r7]
                    p_riic_info->p_data1st++;
ffc02eba:	ed 7a 05                      	mov.l	20[r7], r10
ffc02ebd:	62 1a                         	add	#1, r10
ffc02ebf:	e7 7a 05                      	mov.l	r10, 20[r7]
} /* End of function riic_after_send_slvadr() */
ffc02ec2:	3f 6a 08                      	rtsd	#32, r6-r10

ffc02ec5 <.LVL543>:
            else if (((uint8_t *) FIT_NO_PTR == p_riic_info->p_data1st)
ffc02ec5:	ed 7a 05                      	mov.l	20[r7], r10
ffc02ec8:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02ece:	3a 81 00                      	beq.w	ffc02f4f <_Reset_Vector+0xffc02f53>
            else if (((uint8_t *) FIT_NO_PTR == p_riic_info->p_data1st)
ffc02ed1:	ed 7a 05                      	mov.l	20[r7], r10
ffc02ed4:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02eda:	3b 6f fe                      	bne.w	ffc02d49 <_Reset_Vector+0xffc02d4d>
                    && ((uint8_t *) FIT_NO_PTR == p_riic_info->p_data2nd))
ffc02edd:	ed 7a 04                      	mov.l	16[r7], r10
ffc02ee0:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02ee6:	3b 63 fe                      	bne.w	ffc02d49 <_Reset_Vector+0xffc02d4d>

ffc02ee9 <.LBB1080>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02ee9:	cd 7a 03                      	mov.b	3[r7], r10

ffc02eec <.LBB1083>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02eec:	88 f9                         	mov.b	3[r7], r1

ffc02eee <.LVL546>:
ffc02eee:	75 42 1a                      	mov.l	#26, r2

ffc02ef1 <.LBB1086>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02ef1:	5b aa                         	movu.b	r10, r10
ffc02ef3:	6c 4a                         	shll	#4, r10

ffc02ef5 <.LVL547>:
ffc02ef5:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc02efb:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffc02eff:	f9 a6 02 08                   	mov.l	#8, 8[r10]

ffc02f03 <.LBB1087>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02f03:	05 79 e4 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02f07 <.LBB1088>:
    volatile uint8_t uctmp = 0x00;
ffc02f07:	3c 02 00                      	mov.b	#0, 2[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02f0a:	cd 7a 03                      	mov.b	3[r7], r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02f0d:	88 ff                         	mov.b	3[r7], r7

ffc02f0f <.LVL550>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02f0f:	5b aa                         	movu.b	r10, r10
ffc02f11:	6c 5a                         	shll	#5, r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02f13:	5b 77                         	movu.b	r7, r7
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffc02f15:	73 aa 09 83 08                	add	#0x88309, r10, r10

ffc02f1a <.LVL551>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02f1a:	6c 57                         	shll	#5, r7
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc02f1c:	cc a5                         	mov.b	[r10], r5
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffc02f1e:	73 77 01 83 08                	add	#0x88301, r7, r7

ffc02f23 <.LVL552>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffc02f23:	7c 35                         	btst	#3, r5
ffc02f25:	13                            	beq.s	ffc02f28 <_Reset_Vector+0xffc02f2c>
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffc02f26:	f0 ab                         	bclr	#3, [r10].b
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffc02f28:	f0 73                         	bset	#3, [r7].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc02f2a:	cc 77                         	mov.b	[r7], r7

ffc02f2c <.LBE1088>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02f2c:	66 01                         	mov.l	#0, r1

ffc02f2e <.LBB1091>:
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffc02f2e:	80 87                         	mov.b	r7, 2[r0]

ffc02f30 <.LBE1091>:
} /* End of function riic_after_send_slvadr() */
ffc02f30:	3f 6a 08                      	rtsd	#32, r6-r10

ffc02f33 <.LBB1092>:
    volatile uint8_t uctmp = 0x00;
ffc02f33:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffc02f36:	59 7a 03                      	movu.b	3[r7], r10
ffc02f39:	6c 5a                         	shll	#5, r10
ffc02f3b:	73 aa 04 83 08                	add	#0x88304, r10, r10

ffc02f40 <.LVL555>:
    (*picmr3_reg) |= RIIC_ICMR3_RDRFS_SET;
ffc02f40:	f0 a5                         	bset	#5, [r10].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled.                */
ffc02f42:	f0 a4                         	bset	#4, [r10].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET; /* A 1 is sent as the acknowledge bit (NACK transmission).  */
ffc02f44:	f0 a3                         	bset	#3, [r10].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled.               */
ffc02f46:	f0 ac                         	bclr	#4, [r10].b
    uctmp = *picmr3_reg; /* Reads ICMR3.                                             */
ffc02f48:	cc aa                         	mov.b	[r10], r10

ffc02f4a <.LVL556>:
ffc02f4a:	c3 0a                         	mov.b	r10, [r0]
ffc02f4c:	38 bc fe                      	bra.w	ffc02e08 <_Reset_Vector+0xffc02e0c>

ffc02f4f <.LVL557>:
                    && ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data2nd))
ffc02f4f:	ed 7a 04                      	mov.l	16[r7], r10
ffc02f52:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffc02f58:	3a 79 ff                      	beq.w	ffc02ed1 <_Reset_Vector+0xffc02ed5>

ffc02f5b <.LBB1094>:
    uint8_t ch_no = p_riic_info->ch_no;
ffc02f5b:	cd 7a 03                      	mov.b	3[r7], r10

ffc02f5e <.LBB1097>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02f5e:	88 f9                         	mov.b	3[r7], r1

ffc02f60 <.LVL560>:
ffc02f60:	75 42 52                      	mov.l	#82, r2

ffc02f63 <.LBB1100>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc02f63:	5b aa                         	movu.b	r10, r10
ffc02f65:	6c 4a                         	shll	#4, r10

ffc02f67 <.LVL561>:
ffc02f67:	70 aa 5c 04 00 00             	add	#0x45c, r10, r10
ffc02f6d:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffc02f71:	f9 a6 02 06                   	mov.l	#6, 8[r10]

ffc02f75 <.LBB1101>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffc02f75:	05 07 e4 ff                   	bsr.a	ffc0137c <_Reset_Vector+0xffc01380>

ffc02f79 <.LBE1101>:
                if (0x00000000 != p_riic_info->cnt2nd)
ffc02f79:	ed 7a 02                      	mov.l	8[r7], r10
ffc02f7c:	61 0a                         	cmp	#0, r10
ffc02f7e:	3a cb fd                      	beq.w	ffc02d49 <_Reset_Vector+0xffc02d4d>
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data2nd);
ffc02f81:	a9 76                         	mov.l	16[r7], r6

ffc02f83 <.LBB1102>:
    volatile uint8_t uctmp = 0x00;
ffc02f83:	3c 06 00                      	mov.b	#0, 6[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02f86:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02f89:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffc02f8b:	5b aa                         	movu.b	r10, r10
ffc02f8d:	6c 5a                         	shll	#5, r10
ffc02f8f:	73 aa 12 83 08                	add	#0x88312, r10, r10

ffc02f94 <.LVL565>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffc02f94:	05 c2 e3 ff                   	bsr.a	ffc01356 <_Reset_Vector+0xffc0135a>

ffc02f98 <.LVL566>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02f98:	cc 65                         	mov.b	[r6], r5

ffc02f9a <.LBE1102>:
    riic_return_t ret = RIIC_SUCCESS;
ffc02f9a:	66 01                         	mov.l	#0, r1

ffc02f9c <.LBB1105>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffc02f9c:	c3 a5                         	mov.b	r5, [r10]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffc02f9e:	cc aa                         	mov.b	[r10], r10

ffc02fa0 <.LVL567>:
ffc02fa0:	c7 0a 06                      	mov.b	r10, 6[r0]

ffc02fa3 <.LBE1105>:
                    p_riic_info->cnt2nd--;
ffc02fa3:	ed 7a 02                      	mov.l	8[r7], r10
ffc02fa6:	60 1a                         	sub	#1, r10
ffc02fa8:	e7 7a 02                      	mov.l	r10, 8[r7]
                    p_riic_info->p_data2nd++;
ffc02fab:	ed 7a 04                      	mov.l	16[r7], r10
ffc02fae:	62 1a                         	add	#1, r10
ffc02fb0:	e7 7a 04                      	mov.l	r10, 16[r7]
} /* End of function riic_after_send_slvadr() */
ffc02fb3:	3f 6a 08                      	rtsd	#32, r6-r10

ffc02fb6 <.LFE25>:
ffc02fb6:	ef 00                         	nop	; mov.l	r0, r0

ffc02fb8 <_riic1_eei_sub>:
 *                start condition detection, and stop condition detection.
 * Arguments    : None
 * Return Value : None
 **********************************************************************************************************************/
void riic1_eei_sub (void)
{
ffc02fb8:	7e a7                         	push.l	r7
    #ifdef TN_RXA012A
    riic_timeout_counter_clear(1);
    #endif

    /* Checks Time Out. */
    if ((0U != RIIC1.ICSR2.BIT.TMOF) && (0U != RIIC1.ICIER.BIT.TMOIE))
ffc02fba:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffc02fbf:	8a 5c                         	mov.b	9[r5], r4
ffc02fc1:	7c 04                         	btst	#0, r4
ffc02fc3:	20 1d                         	beq.b	ffc02fe0 <_Reset_Vector+0xffc02fe4>
ffc02fc5:	89 dc                         	mov.b	7[r5], r4
ffc02fc7:	7c 04                         	btst	#0, r4
ffc02fc9:	20 17                         	beq.b	ffc02fe0 <_Reset_Vector+0xffc02fe4>
    {
        /* all interrupt disable */
        RIIC1.ICIER.BIT.TMOIE = 0U;
ffc02fcb:	f1 58 07                      	bclr	#0, 7[r5].b
        /* WAIT_LOOP */
        while (0U != RIIC1.ICIER.BIT.TMOIE)
ffc02fce:	ef 00                         	nop	; mov.l	r0, r0
ffc02fd0:	89 dc                         	mov.b	7[r5], r4
ffc02fd2:	7c 04                         	btst	#0, r4
ffc02fd4:	21 fc                         	bne.b	ffc02fd0 <_Reset_Vector+0xffc02fd4>
        {
            /* Do Nothing */
        }
        riic_api_event[1] = RIIC_EV_INT_TMO;
ffc02fd6:	fb 72 8c 04 00 00             	mov.l	#0x48c, r7
ffc02fdc:	3e 71 0a                      	mov.l	#10, 4[r7]
ffc02fdf:	03                            	nop
    }

    /* Checks Arbitration Lost. */
    if ((0U != RIIC1.ICSR2.BIT.AL) && (0U != RIIC1.ICIER.BIT.ALIE))
ffc02fe0:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffc02fe5:	8a 5c                         	mov.b	9[r5], r4
ffc02fe7:	7c 14                         	btst	#1, r4
ffc02fe9:	10                            	beq.s	ffc02ff1 <_Reset_Vector+0xffc02ff5>
ffc02fea:	89 dc                         	mov.b	7[r5], r4
ffc02fec:	7c 14                         	btst	#1, r4
ffc02fee:	3b 04 01                      	bne.w	ffc030f2 <_Reset_Vector+0xffc030f6>
ffc02ff1:	fb 72 5c 04 00 00             	mov.l	#0x45c, r7
ffc02ff7:	03                            	nop
            riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
        }
    }

    /* Checks stop condition detection. */
    if ((0U != RIIC1.ICSR2.BIT.STOP) && (0U != RIIC1.ICIER.BIT.SPIE))
ffc02ff8:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffc02ffd:	8a 5c                         	mov.b	9[r5], r4
ffc02fff:	7c 34                         	btst	#3, r4
ffc03001:	10                            	beq.s	ffc03009 <_Reset_Vector+0xffc0300d>
ffc03002:	89 dd                         	mov.b	7[r5], r5
ffc03004:	7c 35                         	btst	#3, r5
ffc03006:	3b a1 00                      	bne.w	ffc030a7 <_Reset_Vector+0xffc030ab>
        /* Sets event flag. */
        riic_api_event[1] = RIIC_EV_INT_STOP;
    }

    /* Checks NACK reception. */
    if ((0U != RIIC1.ICSR2.BIT.NACKF) && (0U != RIIC1.ICIER.BIT.NAKIE))
ffc03009:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffc0300e:	8a 5c                         	mov.b	9[r5], r4
ffc03010:	7c 44                         	btst	#4, r4
ffc03012:	20 40                         	beq.b	ffc03052 <_Reset_Vector+0xffc03056>
ffc03014:	89 dc                         	mov.b	7[r5], r4
ffc03016:	7c 44                         	btst	#4, r4
ffc03018:	20 3a                         	beq.b	ffc03052 <_Reset_Vector+0xffc03056>
    {
        /* Prohibits NACK interrupt to generate stop condition. */
        RIIC1.ICIER.BIT.NAKIE = 0U;
ffc0301a:	f1 5c 07                      	bclr	#4, 7[r5].b

        /* Prohibits these interrupt. */
        /* After NACK interrupt, these interrupts will occur when they do not stop the following interrupts. */
        RIIC1.ICIER.BIT.TEIE = 0U;
ffc0301d:	f1 5e 07                      	bclr	#6, 7[r5].b
        RIIC1.ICIER.BIT.TIE = 0U;
ffc03020:	89 db                         	mov.b	7[r5], r3
        RIIC1.ICIER.BIT.RIE = 0U;
        /* WAIT_LOOP */
        while (((0U != RIIC1.ICIER.BIT.TEIE) || (0U != RIIC1.ICIER.BIT.TIE)) || (0U != RIIC1.ICIER.BIT.RIE) )
ffc03022:	ef 54                         	mov.l	r5, r4
        RIIC1.ICIER.BIT.TIE = 0U;
ffc03024:	7a 73                         	bclr	#7, r3
ffc03026:	81 db                         	mov.b	r3, 7[r5]
        RIIC1.ICIER.BIT.RIE = 0U;
ffc03028:	f1 5d 07                      	bclr	#5, 7[r5].b
        while (((0U != RIIC1.ICIER.BIT.TEIE) || (0U != RIIC1.ICIER.BIT.TIE)) || (0U != RIIC1.ICIER.BIT.RIE) )
ffc0302b:	77 10 01 00 00                	nop	; mul	#1, r0
ffc03030:	89 cd                         	mov.b	7[r4], r5
ffc03032:	7c 65                         	btst	#6, r5
ffc03034:	21 fc                         	bne.b	ffc03030 <_Reset_Vector+0xffc03034>
ffc03036:	89 cd                         	mov.b	7[r4], r5
ffc03038:	7c 75                         	btst	#7, r5
ffc0303a:	21 f6                         	bne.b	ffc03030 <_Reset_Vector+0xffc03034>
ffc0303c:	89 cd                         	mov.b	7[r4], r5
ffc0303e:	7c 55                         	btst	#5, r5
ffc03040:	21 f0                         	bne.b	ffc03030 <_Reset_Vector+0xffc03034>
        {
            /* Do Nothing */
        }

        if (0U == RIIC1.ICCR2.BIT.TRS)
ffc03042:	88 4d                         	mov.b	1[r4], r5
ffc03044:	7c 55                         	btst	#5, r5
ffc03046:	3a 12 01                      	beq.w	ffc03158 <_Reset_Vector+0xffc0315c>
        {
            riic_mcu_clear_ir_rxi(1);
        }

        /* Sets event flag. */
        riic_api_event[1] = RIIC_EV_INT_NACK;
ffc03049:	fb 52 8c 04 00 00             	mov.l	#0x48c, r5
ffc0304f:	3e 51 09                      	mov.l	#9, 4[r5]
    }

    /* Checks start condition detection. */
    if ((0U != RIIC1.ICSR2.BIT.START) && (0U != RIIC1.ICIER.BIT.STIE))
ffc03052:	fb 4e 20 83 08                	mov.l	#0x88320, r4
ffc03057:	8a 4d                         	mov.b	9[r4], r5
ffc03059:	7c 25                         	btst	#2, r5
ffc0305b:	17                            	beq.s	ffc03062 <_Reset_Vector+0xffc03066>
ffc0305c:	89 cd                         	mov.b	7[r4], r5
ffc0305e:	7c 25                         	btst	#2, r5
ffc03060:	21 27                         	bne.b	ffc03087 <_Reset_Vector+0xffc0308b>

        /* Sets event flag. */
        riic_api_event[1] = RIIC_EV_INT_START;
    }

    switch (riic_api_info[1].N_Mode)
ffc03062:	a9 77                         	mov.l	16[r7], r7
ffc03064:	61 07                         	cmp	#0, r7
ffc03066:	20 1e                         	beq.b	ffc03084 <_Reset_Vector+0xffc03088>
ffc03068:	61 37                         	cmp	#3, r7
ffc0306a:	24 05                         	bgtu.b	ffc0306f <_Reset_Vector+0xffc03073>
ffc0306c:	38 c0 00                      	bra.w	ffc0312c <_Reset_Vector+0xffc03130>
ffc0306f:	61 67                         	cmp	#6, r7
ffc03071:	24 13                         	bgtu.b	ffc03084 <_Reset_Vector+0xffc03088>
        case RIIC_MODE_S_READY :
        case RIIC_MODE_S_SEND :
        case RIIC_MODE_S_RECEIVE :

            /* Slave mode data */
            p_riic_info = priic_info_s[1];
ffc03073:	fb 72 98 04 00 00             	mov.l	#0x498, r7
ffc03079:	a8 79                         	mov.l	4[r7], r1

ffc0307b <.LBB1546>:
    if (NULL == p_riic_info)
ffc0307b:	61 01                         	cmp	#0, r1
ffc0307d:	17                            	beq.s	ffc03084 <_Reset_Vector+0xffc03088>

ffc0307e <.LBE1546>:
            return;
        break;
    }

    r_riic_advance(p_riic_info); /* Calls advance function */
} /* End of function riic1_eei_sub() */
ffc0307e:	7e b7                         	pop	r7

ffc03080 <.LBB1550>:
        ret = riic_advance(p_riic_info);
ffc03080:	04 f0 e7 ff                   	bra.a	ffc01870 <_Reset_Vector+0xffc01874>

ffc03084 <.LBE1550>:
} /* End of function riic1_eei_sub() */
ffc03084:	3f 77 01                      	rtsd	#4, r7-r7
        RIIC1.ICIER.BIT.STIE = 0U;
ffc03087:	f1 4a 07                      	bclr	#2, 7[r4].b
        RIIC1.ICSR2.BIT.START = 0U;
ffc0308a:	f1 4a 09                      	bclr	#2, 9[r4].b
        while ((0U != RIIC1.ICSR2.BIT.START) || (0U != RIIC1.ICIER.BIT.STIE))
ffc0308d:	fc 13 00                      	nop	; max	r0, r0
ffc03090:	8a 4d                         	mov.b	9[r4], r5
ffc03092:	7c 25                         	btst	#2, r5
ffc03094:	21 fc                         	bne.b	ffc03090 <_Reset_Vector+0xffc03094>
ffc03096:	89 cd                         	mov.b	7[r4], r5
ffc03098:	7c 25                         	btst	#2, r5
ffc0309a:	21 f6                         	bne.b	ffc03090 <_Reset_Vector+0xffc03094>
        riic_api_event[1] = RIIC_EV_INT_START;
ffc0309c:	fb 52 8c 04 00 00             	mov.l	#0x48c, r5
ffc030a2:	3e 51 03                      	mov.l	#3, 4[r5]
ffc030a5:	2e bd                         	bra.b	ffc03062 <_Reset_Vector+0xffc03066>
                || (RIIC_MODE_S_RECEIVE == riic_api_info[1].N_Mode))
ffc030a7:	a9 75                         	mov.l	16[r7], r5
ffc030a9:	60 45                         	sub	#4, r5
        if (((RIIC_MODE_S_READY == riic_api_info[1].N_Mode) || (RIIC_MODE_S_SEND == riic_api_info[1].N_Mode))
ffc030ab:	61 25                         	cmp	#2, r5
ffc030ad:	24 05                         	bgtu.b	ffc030b2 <_Reset_Vector+0xffc030b6>
ffc030af:	38 8d 00                      	bra.w	ffc0313c <_Reset_Vector+0xffc03140>
        RIIC1.ICIER.BIT.SPIE = 0U;
ffc030b2:	fb 4e 20 83 08                	mov.l	#0x88320, r4
ffc030b7:	f1 4b 07                      	bclr	#3, 7[r4].b
        RIIC1.ICMR3.BIT.RDRFS = 0U; /* Refer to the technical update. */
ffc030ba:	f1 4d 04                      	bclr	#5, 4[r4].b
        RIIC1.ICMR3.BIT.ACKWP = 1U; /* Refer to the technical update. */
ffc030bd:	f1 44 04                      	bset	#4, 4[r4].b
        RIIC1.ICMR3.BIT.ACKBT = 0U; /* Refer to the technical update. */
ffc030c0:	f1 4b 04                      	bclr	#3, 4[r4].b
        RIIC1.ICMR3.BIT.ACKWP = 0U; /* Refer to the technical update. */
ffc030c3:	f1 4c 04                      	bclr	#4, 4[r4].b
        while ((0U != RIIC1.ICMR3.BIT.RDRFS) || (0U != RIIC1.ICMR3.BIT.ACKBT))
ffc030c6:	ef 00                         	nop	; mov.l	r0, r0
ffc030c8:	89 45                         	mov.b	4[r4], r5
ffc030ca:	7c 55                         	btst	#5, r5
ffc030cc:	21 fc                         	bne.b	ffc030c8 <_Reset_Vector+0xffc030cc>
ffc030ce:	89 45                         	mov.b	4[r4], r5
ffc030d0:	7c 35                         	btst	#3, r5
ffc030d2:	21 f6                         	bne.b	ffc030c8 <_Reset_Vector+0xffc030cc>
        RIIC1.ICSR2.BIT.STOP = 0U;
ffc030d4:	f1 4b 09                      	bclr	#3, 9[r4].b
        while (0U != RIIC1.ICSR2.BIT.STOP)
ffc030d7:	fb 4e 20 83 08                	mov.l	#0x88320, r4
ffc030dc:	76 10 01 00                   	nop	; mul	#1, r0
ffc030e0:	8a 4d                         	mov.b	9[r4], r5
ffc030e2:	7c 35                         	btst	#3, r5
ffc030e4:	21 fc                         	bne.b	ffc030e0 <_Reset_Vector+0xffc030e4>
        riic_api_event[1] = RIIC_EV_INT_STOP;
ffc030e6:	fb 52 8c 04 00 00             	mov.l	#0x48c, r5
ffc030ec:	3e 51 07                      	mov.l	#7, 4[r5]
ffc030ef:	38 1a ff                      	bra.w	ffc03009 <_Reset_Vector+0xffc0300d>
        RIIC1.ICIER.BIT.ALIE = 0U;
ffc030f2:	f1 59 07                      	bclr	#1, 7[r5].b
        while (0U != RIIC1.ICIER.BIT.ALIE)
ffc030f5:	fc 13 00                      	nop	; max	r0, r0
ffc030f8:	89 dc                         	mov.b	7[r5], r4
ffc030fa:	7c 14                         	btst	#1, r4
ffc030fc:	21 fc                         	bne.b	ffc030f8 <_Reset_Vector+0xffc030fc>
        if (RIIC_MODE_S_READY == riic_api_info[1].B_Mode)
ffc030fe:	fb 72 5c 04 00 00             	mov.l	#0x45c, r7
ffc03104:	a9 7d                         	mov.l	20[r7], r5
        riic_api_event[1] = RIIC_EV_INT_AL;
ffc03106:	fb 42 8c 04 00 00             	mov.l	#0x48c, r4
ffc0310c:	3e 41 08                      	mov.l	#8, 4[r4]
        if (RIIC_MODE_S_READY == riic_api_info[1].B_Mode)
ffc0310f:	61 45                         	cmp	#4, r5
ffc03111:	3b e7 fe                      	bne.w	ffc02ff8 <_Reset_Vector+0xffc02ffc>
            riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
ffc03114:	fb 42 98 04 00 00             	mov.l	#0x498, r4
ffc0311a:	a8 4b                         	mov.l	4[r4], r3

ffc0311c <.LBB1551>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc0311c:	b0 bc                         	movu.b	3[r3], r4
ffc0311e:	fb 22 70 06 00 00             	mov.l	#0x670, r2
ffc03124:	fe 04 25                      	mov.b	r5, [r4, r2]
    p_riic_info->dev_sts = status;
ffc03127:	80 b5                         	mov.b	r5, 2[r3]
ffc03129:	38 cf fe                      	bra.w	ffc02ff8 <_Reset_Vector+0xffc02ffc>

ffc0312c <.LVL791>:
            p_riic_info = priic_info_m[1];
ffc0312c:	fb 72 a4 04 00 00             	mov.l	#0x4a4, r7
ffc03132:	a8 79                         	mov.l	4[r7], r1

ffc03134 <.LBB1553>:
    if (NULL == p_riic_info)
ffc03134:	61 01                         	cmp	#0, r1
ffc03136:	3b 48 ff                      	bne.w	ffc0307e <_Reset_Vector+0xffc03082>
ffc03139:	38 4b ff                      	bra.w	ffc03084 <_Reset_Vector+0xffc03088>

ffc0313c <.LBE1553>:
            riic_api_status_set(priic_info_s[1], RIIC_STS_SP_COND_WAIT);
ffc0313c:	fb 52 98 04 00 00             	mov.l	#0x498, r5
ffc03142:	a8 5d                         	mov.l	4[r5], r5

ffc03144 <.LBB1554>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc03144:	b0 dd                         	movu.b	3[r5], r5

ffc03146 <.LVL795>:
ffc03146:	6c 45                         	shll	#4, r5
ffc03148:	70 55 5c 04 00 00             	add	#0x45c, r5, r5
ffc0314e:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc03152:	3e 52 08                      	mov.l	#8, 8[r5]
ffc03155:	38 5d ff                      	bra.w	ffc030b2 <_Reset_Vector+0xffc030b6>

ffc03158 <.LVL796>:
            riic_mcu_clear_ir_rxi(1);
ffc03158:	66 11                         	mov.l	#1, r1
ffc0315a:	05 0f e2 ff                   	bsr.a	ffc01369 <_Reset_Vector+0xffc0136d>

ffc0315e <.LVL797>:
ffc0315e:	38 eb fe                      	bra.w	ffc03049 <_Reset_Vector+0xffc0304d>

ffc03161 <.LFE62>:
ffc03161:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc03168 <_riic1_txi_sub>:
    /* TXI processing is performed only when the following conditions are all met.                 */
    /*  - The address part of data has been received and the received address matches the RX's     */
    /*    own address.                                                                             */
    /*  - The RX device is in slave mode.                                                          */
    /*  - The RX device is in transmission mode (the R/W bit received is 'R' (slave transmission)) */
    tmp = RIIC1.ICCR2.BYTE;
ffc03168:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffc0316d:	88 5d                         	mov.b	1[r5], r5

ffc0316f <.LVL798>:
    if ((RIIC_ICCR2_MST_SET != (tmp & RIIC_ICCR2_MST)) && (RIIC_ICCR2_TRS_SET == (tmp & RIIC_ICCR2_TRS)))
ffc0316f:	75 25 60                      	and	#96, r5

ffc03172 <.LVL799>:
ffc03172:	75 55 20                      	cmp	#32, r5
ffc03175:	20 03                         	beq.b	ffc03178 <_Reset_Vector+0xffc0317c>
ffc03177:	02                            	rts
        /* Processing when the addresses match (slave send specified) */

        /* Determines whether the state is arbitration-lost detected.                           */
        /* When an arbitration-lost is detected, the riic_after_receive_slvadr function is not  */
        /* executed. Thus the internal status needs to be changed to "RIIC_STS_SEND_DATA_WAIT". */
        if (RIIC_STS_AL == riic_api_info[1].N_status)
ffc03178:	fb 42 5c 04 00 00             	mov.l	#0x45c, r4
ffc0317e:	a9 c5                         	mov.l	24[r4], r5
ffc03180:	fb 32 98 04 00 00             	mov.l	#0x498, r3
ffc03186:	a8 39                         	mov.l	4[r3], r1
ffc03188:	61 95                         	cmp	#9, r5
ffc0318a:	21 11                         	bne.b	ffc0319b <_Reset_Vector+0xffc0319f>

ffc0318c <.LBB1556>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc0318c:	b0 9d                         	movu.b	3[r1], r5
ffc0318e:	6c 45                         	shll	#4, r5
ffc03190:	4b 45                         	add	r4, r5
ffc03192:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc03196:	3e 52 06                      	mov.l	#6, 8[r5]
ffc03199:	a9 c5                         	mov.l	24[r4], r5

ffc0319b <.LVL801>:
        }

        /* Determines if the slave transmission is the first slave transmission.             */
        /* N_mode is updated from "RIIC_MODE_S_READY" to "RIIC_MODE_S_SEND" on the first TXI */
        /* interrupt after the slave transmission is determined.                             */
        if (RIIC_MODE_S_READY == riic_api_info[1].N_Mode)
ffc0319b:	a9 43                         	mov.l	16[r4], r3
ffc0319d:	61 43                         	cmp	#4, r3
ffc0319f:	1c                            	bne.s	ffc031a3 <_Reset_Vector+0xffc031a7>
        {
            /* Processing for the first slave transmission */
            /* Sets the internal mode. */
            riic_api_info[1].N_Mode = RIIC_MODE_S_SEND; /* Set slave transmission mode. */
ffc031a0:	3e 44 05                      	mov.l	#5, 16[r4]
        }

        /* Sets event. */
        switch (riic_api_info[1].N_status)
ffc031a3:	61 25                         	cmp	#2, r5
ffc031a5:	20 1e                         	beq.b	ffc031c3 <_Reset_Vector+0xffc031c7>
ffc031a7:	61 65                         	cmp	#6, r5
ffc031a9:	20 0b                         	beq.b	ffc031b4 <_Reset_Vector+0xffc031b8>

ffc031ab <.LBB1558>:
    if (NULL == p_riic_info)
ffc031ab:	61 01                         	cmp	#0, r1
ffc031ad:	20 ca                         	beq.b	ffc03177 <_Reset_Vector+0xffc0317b>
ffc031af:	03                            	nop

ffc031b0 <.LVL803>:
        ret = riic_advance(p_riic_info);
ffc031b0:	04 c0 e6 ff                   	bra.a	ffc01870 <_Reset_Vector+0xffc01874>

ffc031b4 <.LBE1558>:
            break;

            case RIIC_STS_SEND_DATA_WAIT :

                /* Sets interrupted data sending. */
                riic_api_event[1] = RIIC_EV_INT_SEND;
ffc031b4:	fb 52 8c 04 00 00             	mov.l	#0x48c, r5
ffc031ba:	3e 51 05                      	mov.l	#5, 4[r5]

ffc031bd <.LBB1563>:
    if (NULL == p_riic_info)
ffc031bd:	61 01                         	cmp	#0, r1
ffc031bf:	21 f1                         	bne.b	ffc031b0 <_Reset_Vector+0xffc031b4>
ffc031c1:	2e b6                         	bra.b	ffc03177 <_Reset_Vector+0xffc0317b>

ffc031c3 <.LBE1563>:
{
ffc031c3:	7e a7                         	push.l	r7

ffc031c5 <.LBB1564>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc031c5:	b0 9d                         	movu.b	3[r1], r5

ffc031c7 <.LBE1564>:
                riic_api_event[1] = RIIC_EV_INT_ADD;
ffc031c7:	fb 42 8c 04 00 00             	mov.l	#0x48c, r4
ffc031cd:	3e 41 04                      	mov.l	#4, 4[r4]

ffc031d0 <.LBB1567>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc031d0:	fb 42 70 06 00 00             	mov.l	#0x670, r4
ffc031d6:	66 47                         	mov.l	#4, r7
ffc031d8:	fe 05 47                      	mov.b	r7, [r5, r4]
    p_riic_info->dev_sts = status;
ffc031db:	80 97                         	mov.b	r7, 2[r1]

ffc031dd <.LBB1568>:
        }

        r_riic_advance(priic_info_s[1]); /* Calls advance function */

    }
} /* End of function riic1_txi_sub() */
ffc031dd:	7e b7                         	pop	r7

ffc031df <.LBB1569>:
        ret = riic_advance(p_riic_info);
ffc031df:	04 91 e6 ff                   	bra.a	ffc01870 <_Reset_Vector+0xffc01874>

ffc031e3 <.LBE1569>:
ffc031e3:	77 10 01 00 00                	nop	; mul	#1, r0

ffc031e8 <_riic1_rxi_sub>:

    #ifdef TN_RXA012A
    riic_timeout_counter_clear(1);
    #endif

    if (RIIC_STS_AL == riic_api_info[1].N_status)
ffc031e8:	fb 42 5c 04 00 00             	mov.l	#0x45c, r4
ffc031ee:	a9 c3                         	mov.l	24[r4], r3
ffc031f0:	61 93                         	cmp	#9, r3
ffc031f2:	21 19                         	bne.b	ffc0320b <_Reset_Vector+0xffc0320f>
    {
        /* Sets the internal status. */
        riic_api_status_set(priic_info_s[1], RIIC_STS_IDLE_EN_SLV);
ffc031f4:	fb 32 98 04 00 00             	mov.l	#0x498, r3
ffc031fa:	a8 3d                         	mov.l	4[r3], r5

ffc031fc <.LBB1570>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffc031fc:	b0 dd                         	movu.b	3[r5], r5

ffc031fe <.LVL811>:
ffc031fe:	6c 45                         	shll	#4, r5
ffc03200:	4b 45                         	add	r4, r5
ffc03202:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffc03206:	3e 52 02                      	mov.l	#2, 8[r5]
ffc03209:	a9 c3                         	mov.l	24[r4], r3

ffc0320b <.LVL812>:
    }

    if (RIIC_MODE_S_READY == riic_api_info[1].N_Mode)
ffc0320b:	a9 45                         	mov.l	16[r4], r5
ffc0320d:	61 45                         	cmp	#4, r5
ffc0320f:	20 72                         	beq.b	ffc03281 <_Reset_Vector+0xffc03285>
    {
        /* Sets the internal mode. */
        riic_api_info[1].N_Mode = RIIC_MODE_S_RECEIVE;
    }

    if ((RIIC_STS_IDLE_EN_SLV == riic_api_info[1].N_status))
ffc03211:	61 23                         	cmp	#2, r3
ffc03213:	20 26                         	beq.b	ffc03239 <_Reset_Vector+0xffc0323d>
    {
        /* Updates the channel status. */
        riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
    }

    switch (riic_api_info[1].N_Mode)
ffc03215:	61 25                         	cmp	#2, r5
ffc03217:	23 69                         	bnc.b	ffc03280 <_Reset_Vector+0xffc03284>
ffc03219:	61 35                         	cmp	#3, r5
ffc0321b:	24 61                         	bgtu.b	ffc0327c <_Reset_Vector+0xffc03280>
    {
        case RIIC_MODE_M_RECEIVE :
        case RIIC_MODE_M_SEND_RECEIVE :

            /* Master mode data */
            p_riic_info = priic_info_m[1];
ffc0321d:	fb 52 a4 04 00 00             	mov.l	#0x4a4, r5
ffc03223:	a8 59                         	mov.l	4[r5], r1

ffc03225 <.LVL813>:
        break;
ffc03225:	fc 13 00                      	nop	; max	r0, r0
            return;
        break;
    }

    /* Sets interrupted data receiving. */
    riic_api_event[1] = RIIC_EV_INT_RECEIVE;
ffc03228:	fb 52 8c 04 00 00             	mov.l	#0x48c, r5
ffc0322e:	3e 51 06                      	mov.l	#6, 4[r5]

ffc03231 <.LBB1572>:
    if (NULL == p_riic_info)
ffc03231:	61 01                         	cmp	#0, r1
ffc03233:	20 4d                         	beq.b	ffc03280 <_Reset_Vector+0xffc03284>
        ret = riic_advance(p_riic_info);
ffc03235:	04 3b e6 ff                   	bra.a	ffc01870 <_Reset_Vector+0xffc01874>

ffc03239 <.LBE1572>:
{
ffc03239:	7e a7                         	push.l	r7
        riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
ffc0323b:	fb 32 98 04 00 00             	mov.l	#0x498, r3
ffc03241:	a8 3b                         	mov.l	4[r3], r3

ffc03243 <.LBB1576>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc03243:	b0 bc                         	movu.b	3[r3], r4
ffc03245:	fb 22 70 06 00 00             	mov.l	#0x670, r2
ffc0324b:	66 47                         	mov.l	#4, r7
ffc0324d:	fe 04 27                      	mov.b	r7, [r4, r2]
    p_riic_info->dev_sts = status;
ffc03250:	80 b7                         	mov.b	r7, 2[r3]

ffc03252 <.LBE1576>:
    switch (riic_api_info[1].N_Mode)
ffc03252:	61 25                         	cmp	#2, r5
ffc03254:	23 25                         	bnc.b	ffc03279 <_Reset_Vector+0xffc0327d>
ffc03256:	61 35                         	cmp	#3, r5
ffc03258:	24 1d                         	bgtu.b	ffc03275 <_Reset_Vector+0xffc03279>
            p_riic_info = priic_info_m[1];
ffc0325a:	fb 52 a4 04 00 00             	mov.l	#0x4a4, r5
ffc03260:	a8 59                         	mov.l	4[r5], r1

ffc03262 <.LVL817>:
    riic_api_event[1] = RIIC_EV_INT_RECEIVE;
ffc03262:	fb 52 8c 04 00 00             	mov.l	#0x48c, r5
ffc03268:	3e 51 06                      	mov.l	#6, 4[r5]

ffc0326b <.LBB1579>:
    if (NULL == p_riic_info)
ffc0326b:	61 01                         	cmp	#0, r1
ffc0326d:	20 0c                         	beq.b	ffc03279 <_Reset_Vector+0xffc0327d>

ffc0326f <.LBE1579>:

    r_riic_advance(p_riic_info); /* Calls advance function */
} /* End of function riic1_rxi_sub() */
ffc0326f:	7e b7                         	pop	r7

ffc03271 <.LBB1580>:
        ret = riic_advance(p_riic_info);
ffc03271:	04 ff e5 ff                   	bra.a	ffc01870 <_Reset_Vector+0xffc01874>

ffc03275 <.LBE1580>:
    switch (riic_api_info[1].N_Mode)
ffc03275:	61 65                         	cmp	#6, r5
ffc03277:	20 38                         	beq.b	ffc032af <_Reset_Vector+0xffc032b3>

ffc03279 <.LVL820>:
} /* End of function riic1_rxi_sub() */
ffc03279:	3f 77 01                      	rtsd	#4, r7-r7

ffc0327c <.LVL821>:
    switch (riic_api_info[1].N_Mode)
ffc0327c:	61 65                         	cmp	#6, r5
ffc0327e:	20 26                         	beq.b	ffc032a4 <_Reset_Vector+0xffc032a8>
ffc03280:	02                            	rts
        riic_api_info[1].N_Mode = RIIC_MODE_S_RECEIVE;
ffc03281:	3e 44 06                      	mov.l	#6, 16[r4]
    if ((RIIC_STS_IDLE_EN_SLV == riic_api_info[1].N_status))
ffc03284:	61 23                         	cmp	#2, r3
        riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
ffc03286:	fb 32 98 04 00 00             	mov.l	#0x498, r3
    if ((RIIC_STS_IDLE_EN_SLV == riic_api_info[1].N_status))
ffc0328c:	15                            	beq.s	ffc03291 <_Reset_Vector+0xffc03295>
            p_riic_info = priic_info_s[1];
ffc0328d:	a8 39                         	mov.l	4[r3], r1

ffc0328f <.LVL822>:
        break;
ffc0328f:	2e 99                         	bra.b	ffc03228 <_Reset_Vector+0xffc0322c>

ffc03291 <.LVL823>:
        riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
ffc03291:	a8 3a                         	mov.l	4[r3], r2

ffc03293 <.LBB1581>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffc03293:	b0 ac                         	movu.b	3[r2], r4
ffc03295:	fb 12 70 06 00 00             	mov.l	#0x670, r1
ffc0329b:	fe 04 15                      	mov.b	r5, [r4, r1]
    p_riic_info->dev_sts = status;
ffc0329e:	80 a5                         	mov.b	r5, 2[r2]

ffc032a0 <.LBE1581>:
            p_riic_info = priic_info_s[1];
ffc032a0:	a8 39                         	mov.l	4[r3], r1

ffc032a2 <.LVL825>:
        break;
ffc032a2:	2e 86                         	bra.b	ffc03228 <_Reset_Vector+0xffc0322c>

ffc032a4 <.LVL826>:
ffc032a4:	fb 32 98 04 00 00             	mov.l	#0x498, r3
            p_riic_info = priic_info_s[1];
ffc032aa:	a8 39                         	mov.l	4[r3], r1

ffc032ac <.LVL827>:
        break;
ffc032ac:	38 7c ff                      	bra.w	ffc03228 <_Reset_Vector+0xffc0322c>

ffc032af <.LVL828>:
ffc032af:	fb 32 98 04 00 00             	mov.l	#0x498, r3

ffc032b5 <.LVL829>:
            p_riic_info = priic_info_s[1];
ffc032b5:	a8 39                         	mov.l	4[r3], r1

ffc032b7 <.LVL830>:
        break;
ffc032b7:	2e ab                         	bra.b	ffc03262 <_Reset_Vector+0xffc03266>

ffc032b9 <.LFE64>:
ffc032b9:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc032c0 <_riic1_tei_sub>:
    #ifdef TN_RXA012A
    riic_timeout_counter_clear(1);
    #endif

    /* Clears ICSR2.TEND. */
    RIIC1.ICSR2.BIT.TEND = 0U;
ffc032c0:	fb 4e 20 83 08                	mov.l	#0x88320, r4
ffc032c5:	f1 4e 09                      	bclr	#6, 9[r4].b
    /* WAIT_LOOP */
    while (0U != RIIC1.ICSR2.BIT.TEND)
ffc032c8:	8a 4d                         	mov.b	9[r4], r5
ffc032ca:	7c 65                         	btst	#6, r5
ffc032cc:	21 fc                         	bne.b	ffc032c8 <_Reset_Vector+0xffc032cc>
    {
        /* Do Nothing */
    }

    /* Sets event. */
    switch (riic_api_info[1].N_status)
ffc032ce:	fb 52 5c 04 00 00             	mov.l	#0x45c, r5
ffc032d4:	a9 d5                         	mov.l	24[r5], r5
ffc032d6:	61 45                         	cmp	#4, r5
ffc032d8:	23 18                         	bnc.b	ffc032f0 <_Reset_Vector+0xffc032f4>
ffc032da:	61 55                         	cmp	#5, r5
ffc032dc:	25 24                         	bleu.b	ffc03300 <_Reset_Vector+0xffc03304>
ffc032de:	61 65                         	cmp	#6, r5
ffc032e0:	21 10                         	bne.b	ffc032f0 <_Reset_Vector+0xffc032f4>
        break;

        case RIIC_STS_SEND_DATA_WAIT :

            /* Sets interrupted data sending. */
            riic_api_event[1] = RIIC_EV_INT_SEND;
ffc032e2:	fb 52 8c 04 00 00             	mov.l	#0x48c, r5
ffc032e8:	3e 51 05                      	mov.l	#5, 4[r5]

        break;
ffc032eb:	77 10 01 00 00                	nop	; mul	#1, r0
            /* Does nothing. */
        break;

    }

    r_riic_advance(priic_info_m[1]); /* Calls advance function */
ffc032f0:	fb 52 a4 04 00 00             	mov.l	#0x4a4, r5
ffc032f6:	a8 59                         	mov.l	4[r5], r1

ffc032f8 <.LBB1582>:
    if (NULL == p_riic_info)
ffc032f8:	61 01                         	cmp	#0, r1
ffc032fa:	20 1b                         	beq.b	ffc03315 <_Reset_Vector+0xffc03319>
        ret = riic_advance(p_riic_info);
ffc032fc:	04 74 e5 ff                   	bra.a	ffc01870 <_Reset_Vector+0xffc01874>

ffc03300 <.LBE1582>:
            riic_api_event[1] = RIIC_EV_INT_ADD;
ffc03300:	fb 52 8c 04 00 00             	mov.l	#0x48c, r5
ffc03306:	3e 51 04                      	mov.l	#4, 4[r5]
    r_riic_advance(priic_info_m[1]); /* Calls advance function */
ffc03309:	fb 52 a4 04 00 00             	mov.l	#0x4a4, r5
ffc0330f:	a8 59                         	mov.l	4[r5], r1

ffc03311 <.LBB1585>:
    if (NULL == p_riic_info)
ffc03311:	61 01                         	cmp	#0, r1
ffc03313:	21 e9                         	bne.b	ffc032fc <_Reset_Vector+0xffc03300>

ffc03315 <.LBE1585>:
} /* End of function riic1_tei_sub() */
ffc03315:	02                            	rts

ffc03316 <.LFE65>:
ffc03316:	ef 00                         	nop	; mov.l	r0, r0

ffc03318 <_get_iclk_freq_hz>:
*                frequency at which it is currently running.
* Arguments    : None
* Return Value : uint32_t - the iclk frequency in Hz
***********************************************************************************************************************/
uint32_t get_iclk_freq_hz(void)
{
ffc03318:	60 c0                         	sub	#12, r0
    uint32_t sys_clock_src_freq;
    uint32_t pll_multiplier;
    uint32_t pll_source_freq;
    uint32_t hoco_frequency[3] = {16000000, 18000000, 20000000};
ffc0331a:	f8 02 00 24 f4 00             	mov.l	#0xf42400, [r0]
ffc03320:	f9 02 01 80 a8 12 01          	mov.l	#0x112a880, 4[r0]

    /* Casting is valid because it matches the type to the retern value. */
    uint8_t  cksel = (uint8_t)SYSTEM.SCKCR3.BIT.CKSEL;
ffc03327:	fb 3e 00 00 08                	mov.l	#0x80000, r3
    uint32_t hoco_frequency[3] = {16000000, 18000000, 20000000};
ffc0332c:	f9 02 02 00 2d 31 01          	mov.l	#0x1312d00, 8[r0]
    uint8_t  cksel = (uint8_t)SYSTEM.SCKCR3.BIT.CKSEL;
ffc03333:	9c bd                         	mov.w	38[r3], r5
ffc03335:	68 85                         	shlr	#8, r5
ffc03337:	64 75                         	and	#7, r5

ffc03339 <.LVL0>:

    switch (cksel)
ffc03339:	5b 54                         	movu.b	r5, r4
ffc0333b:	61 14                         	cmp	#1, r4
ffc0333d:	20 4e                         	beq.b	ffc0338b <_Reset_Vector+0xffc0338f>
ffc0333f:	61 05                         	cmp	#0, r5
ffc03341:	20 35                         	beq.b	ffc03376 <_Reset_Vector+0xffc0337a>
ffc03343:	61 34                         	cmp	#3, r4
ffc03345:	20 1c                         	beq.b	ffc03361 <_Reset_Vector+0xffc03365>
ffc03347:	61 44                         	cmp	#4, r4
ffc03349:	20 5a                         	beq.b	ffc033a3 <_Reset_Vector+0xffc033a7>
            /* Set HOCO frequency. */
            sys_clock_src_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
            break;

        case BSP_PRV_CKSEL_MAIN_OSC:
            sys_clock_src_freq = BSP_CFG_XTAL_HZ;
ffc0334b:	fb 12 00 36 6e 01             	mov.l	#0x16e3600, r1

ffc03351 <.LVL1>:
            sys_clock_src_freq = BSP_CFG_XTAL_HZ;
            break;
    }

    /* Finally, divide the system clock source frequency by the currently set ICLK divider to get the ICLK frequency */
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffc03351:	fb 5e 00 00 08                	mov.l	#0x80000, r5

ffc03356 <.LVL2>:
ffc03356:	aa 55                         	mov.l	32[r5], r5
ffc03358:	69 85                         	shlr	#24, r5
ffc0335a:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffc0335c:	fd 60 51                      	shlr	r5, r1

ffc0335f <.LVL3>:
ffc0335f:	67 03                         	rtsd	#12

ffc03361 <.LVL4>:
            sys_clock_src_freq = BSP_SUB_CLOCK_HZ;
ffc03361:	fb 1e 00 80 00                	mov.l	#0x8000, r1

ffc03366 <.LVL5>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffc03366:	fb 5e 00 00 08                	mov.l	#0x80000, r5

ffc0336b <.LVL6>:
ffc0336b:	aa 55                         	mov.l	32[r5], r5
ffc0336d:	69 85                         	shlr	#24, r5
ffc0336f:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffc03371:	fd 60 51                      	shlr	r5, r1

ffc03374 <.LVL7>:
ffc03374:	67 03                         	rtsd	#12

ffc03376 <.LVL8>:
            sys_clock_src_freq = BSP_LOCO_HZ;
ffc03376:	fb 1e 80 a9 03                	mov.l	#0x3a980, r1

ffc0337b <.LVL9>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffc0337b:	fb 5e 00 00 08                	mov.l	#0x80000, r5

ffc03380 <.LVL10>:
ffc03380:	aa 55                         	mov.l	32[r5], r5
ffc03382:	69 85                         	shlr	#24, r5
ffc03384:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffc03386:	fd 60 51                      	shlr	r5, r1

ffc03389 <.LVL11>:
ffc03389:	67 03                         	rtsd	#12

ffc0338b <.LVL12>:
            sys_clock_src_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
ffc0338b:	cd 35 37                      	mov.b	55[r3], r5

ffc0338e <.LVL13>:
ffc0338e:	64 35                         	and	#3, r5
ffc03390:	fe 65 01                      	mov.l	[r5, r0], r1

ffc03393 <.LVL14>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffc03393:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffc03398:	aa 55                         	mov.l	32[r5], r5
ffc0339a:	69 85                         	shlr	#24, r5
ffc0339c:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffc0339e:	fd 60 51                      	shlr	r5, r1

ffc033a1 <.LVL15>:
ffc033a1:	67 03                         	rtsd	#12

ffc033a3 <.LVL16>:
            pll_multiplier = ((((uint32_t)(SYSTEM.PLLCR.BIT.STC + 1)) * BSP_PRV_NORMALIZE_X10) / 2);
ffc033a3:	9d 35                         	mov.w	40[r3], r5

ffc033a5 <.LVL17>:
            if (0x1 == SYSTEM.PLLCR.BIT.PLLSRCSEL)
ffc033a5:	9d 34                         	mov.w	40[r3], r4
            pll_multiplier = ((((uint32_t)(SYSTEM.PLLCR.BIT.STC + 1)) * BSP_PRV_NORMALIZE_X10) / 2);
ffc033a7:	fd 88 51                      	shlr	#8, r5, r1
ffc033aa:	75 21 3f                      	and	#63, r1
ffc033ad:	62 11                         	add	#1, r1
ffc033af:	63 a1                         	mul	#10, r1
ffc033b1:	fd 81 15                      	shlr	#1, r1, r5

ffc033b4 <.LVL18>:
            if (0x1 == SYSTEM.PLLCR.BIT.PLLSRCSEL)
ffc033b4:	7c 44                         	btst	#4, r4
ffc033b6:	21 2c                         	bne.b	ffc033e2 <_Reset_Vector+0xffc033e6>
            pll_source_freq = BSP_CFG_XTAL_HZ;
ffc033b8:	fb 12 00 36 6e 01             	mov.l	#0x16e3600, r1

ffc033be <.LVL19>:
ffc033be:	ef 00                         	nop	; mov.l	r0, r0
            sys_clock_src_freq = ((pll_source_freq / (((uint32_t)(SYSTEM.PLLCR.BIT.PLIDIV + 1)) * BSP_PRV_NORMALIZE_X10)) * pll_multiplier);
ffc033c0:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffc033c5:	9d 44                         	mov.w	40[r4], r4
ffc033c7:	64 34                         	and	#3, r4
ffc033c9:	62 14                         	add	#1, r4
ffc033cb:	63 a4                         	mul	#10, r4
ffc033cd:	fc 27 41                      	divu	r4, r1

ffc033d0 <.LVL20>:
ffc033d0:	4f 51                         	mul	r5, r1

ffc033d2 <.LVL21>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffc033d2:	fb 5e 00 00 08                	mov.l	#0x80000, r5

ffc033d7 <.LVL22>:
ffc033d7:	aa 55                         	mov.l	32[r5], r5
ffc033d9:	69 85                         	shlr	#24, r5
ffc033db:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffc033dd:	fd 60 51                      	shlr	r5, r1

ffc033e0 <.LVL23>:
ffc033e0:	67 03                         	rtsd	#12

ffc033e2 <.LVL24>:
                pll_source_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
ffc033e2:	cd 34 37                      	mov.b	55[r3], r4
ffc033e5:	64 34                         	and	#3, r4
ffc033e7:	fe 64 01                      	mov.l	[r4, r0], r1

ffc033ea <.LVL25>:
ffc033ea:	2e d6                         	bra.b	ffc033c0 <_Reset_Vector+0xffc033c4>

ffc033ec <.LFE3>:
ffc033ec:	76 10 01 00                   	nop	; mul	#1, r0

ffc033f0 <_mcu_clock_setup>:
* Return value : none
***********************************************************************************************************************/
void mcu_clock_setup(void)
{
    /* Switch to high-speed operation */
    operating_frequency_set();
ffc033f0:	fb 52 f0 66 c0 ff             	mov.l	#0xffc066f0, r5
ffc033f6:	ec 55                         	mov.l	[r5], r5
ffc033f8:	61 15                         	cmp	#1, r5
ffc033fa:	21 03                         	bne.b	ffc033fd <_Reset_Vector+0xffc03401>
ffc033fc:	02                            	rts
{
ffc033fd:	7e a7                         	push.l	r7
ffc033ff:	60 40                         	sub	#4, r0

ffc03401 <.LBB6>:
    /* Used for constructing value to write to SCKCR, SCKCR2, and SCKCR3 registers. */
    uint32_t tmp_clock = 0;
    uint32_t tmp_restore_clock = 0;

    /* Protect off. */
    SYSTEM.PRCR.WORD = 0xA50B;
ffc03401:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffc03406:	fa 59 ff 01 0b a5             	mov.w	#0xa50b, 1022[r5]

ffc0340c <.LBB8>:
    uint8_t tmp;
#endif
    volatile uint16_t tmp_packcr;

    /* Main clock will be not oscillate in software standby or deep software standby modes. */
    SYSTEM.MOFCR.BIT.MOFXIN = 0;
ffc0340c:	f2 58 93 c2                   	bclr	#0, 49811[r5].b

    /* Set the oscillation source of the main clock oscillator. */
    SYSTEM.MOFCR.BIT.MOSEL = BSP_CFG_MAIN_CLOCK_SOURCE;
ffc03410:	f2 5e 93 c2                   	bclr	#6, 49811[r5].b

#if BSP_CFG_HOCO_OSCILLATE_ENABLE == 1
    /* HOCO is chosen. Start it operating if it is not already operating. */
    if (1 == SYSTEM.HOCOCR.BIT.HCSTP)
ffc03414:	cd 54 36                      	mov.b	54[r5], r4
ffc03417:	64 14                         	and	#1, r4
ffc03419:	61 14                         	cmp	#1, r4
ffc0341b:	3a d9 01                      	beq.w	ffc035f4 <_Reset_Vector+0xffc035f8>
ffc0341e:	ef 00                         	nop	; mov.l	r0, r0
            R_BSP_NOP();
        }
    }

    /* WAIT_LOOP */
    while(0 == SYSTEM.OSCOVFSR.BIT.HCOVF)
ffc03420:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffc03425:	cd 54 3c                      	mov.b	60[r5], r4
ffc03428:	7c 34                         	btst	#3, r4
ffc0342a:	21 0e                         	bne.b	ffc03438 <_Reset_Vector+0xffc0343c>
    {
        /* The delay period needed is to make sure that the HOCO has stabilized.
           If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
        R_BSP_NOP();
ffc0342c:	03                            	nop
    while(0 == SYSTEM.OSCOVFSR.BIT.HCOVF)
ffc0342d:	cd 54 3c                      	mov.b	60[r5], r4
ffc03430:	7c 34                         	btst	#3, r4
ffc03432:	20 fa                         	beq.b	ffc0342c <_Reset_Vector+0xffc03430>
ffc03434:	76 10 01 00                   	nop	; mul	#1, r0
#endif /* BSP_CFG_MAIN_CLOCK_OSCILLATE_ENABLE == 1 */

    /* Sub-clock setting. */

    /* Cold start setting */
    if (0 == SYSTEM.RSTSR1.BIT.CWSF)
ffc03438:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffc0343d:	ce 75 91 c2                   	mov.b	49809[r7], r5
ffc03441:	7c 05                         	btst	#0, r5
ffc03443:	3b 85 01                      	bne.w	ffc035c8 <_Reset_Vector+0xffc035cc>
    {
        /* Stop the sub-clock oscillator */
        /* RCR4 - RTC Control Register 4
        b7:b1    Reserved - The write value should be 0.
        b0       RCKSEL   - Count Source Select - Sub-clock oscillator is selected. */
        RTC.RCR4.BIT.RCKSEL = 0;
ffc03446:	fb 4e 00 c4 08                	mov.l	#0x8c400, r4
ffc0344b:	f1 48 28                      	bclr	#0, 40[r4].b

        /* WAIT_LOOP */
        for (i = 0; i < 4; i++)
ffc0344e:	3c 03 00                      	mov.b	#0, 3[r0]
ffc03451:	b0 8f                         	movu.b	3[r0], r7
ffc03453:	61 37                         	cmp	#3, r7
ffc03455:	24 14                         	bgtu.b	ffc03469 <_Reset_Vector+0xffc0346d>
ffc03457:	03                            	nop
        {
            /* dummy read four times */
            dummy = RTC.RCR4.BYTE;
ffc03458:	cd 45 28                      	mov.b	40[r4], r5
ffc0345b:	80 85                         	mov.b	r5, 2[r0]
        for (i = 0; i < 4; i++)
ffc0345d:	88 8d                         	mov.b	3[r0], r5
ffc0345f:	62 15                         	add	#1, r5
ffc03461:	80 8d                         	mov.b	r5, 3[r0]
ffc03463:	b0 8d                         	movu.b	3[r0], r5
ffc03465:	61 35                         	cmp	#3, r5
ffc03467:	25 f1                         	bleu.b	ffc03458 <_Reset_Vector+0xffc0345c>
        }

        /* Confirm that the written */
        if (0 != RTC.RCR4.BIT.RCKSEL)
ffc03469:	fb 7e 00 c4 08                	mov.l	#0x8c400, r7
ffc0346e:	cd 75 28                      	mov.b	40[r7], r5
ffc03471:	7c 05                         	btst	#0, r5
ffc03473:	3b 7d 01                      	bne.w	ffc035f0 <_Reset_Vector+0xffc035f4>
ffc03476:	ef 00                         	nop	; mov.l	r0, r0

        /* RCR3 - RTC Control Register 3
        b7:b4    Reserved - The write value should be 0.
        b3:b1    RTCDV    - Sub-clock oscillator Drive Ability Control.
        b0       RTCEN    - Sub-clock oscillator is stopped. */
        RTC.RCR3.BIT.RTCEN = 0;
ffc03478:	fb 4e 00 c4 08                	mov.l	#0x8c400, r4
ffc0347d:	f1 48 26                      	bclr	#0, 38[r4].b

        /* WAIT_LOOP */
        for (i = 0; i < 4; i++)
ffc03480:	3c 03 00                      	mov.b	#0, 3[r0]
ffc03483:	b0 8f                         	movu.b	3[r0], r7
ffc03485:	61 37                         	cmp	#3, r7
ffc03487:	24 13                         	bgtu.b	ffc0349a <_Reset_Vector+0xffc0349e>
        {
            /* dummy read four times */
            dummy = RTC.RCR3.BYTE;
ffc03489:	cd 45 26                      	mov.b	38[r4], r5
ffc0348c:	80 85                         	mov.b	r5, 2[r0]
        for (i = 0; i < 4; i++)
ffc0348e:	88 8d                         	mov.b	3[r0], r5
ffc03490:	62 15                         	add	#1, r5
ffc03492:	80 8d                         	mov.b	r5, 3[r0]
ffc03494:	b0 8d                         	movu.b	3[r0], r5
ffc03496:	61 35                         	cmp	#3, r5
ffc03498:	25 f1                         	bleu.b	ffc03489 <_Reset_Vector+0xffc0348d>
        }

        /* Confirm that the written */
        if (0 != RTC.RCR3.BIT.RTCEN)
ffc0349a:	fb 7e 00 c4 08                	mov.l	#0x8c400, r7
ffc0349f:	cd 75 26                      	mov.b	38[r7], r5
ffc034a2:	7c 05                         	btst	#0, r5
ffc034a4:	14                            	beq.s	ffc034a8 <_Reset_Vector+0xffc034ac>
        {
            R_BSP_NOP();
ffc034a5:	03                            	nop
ffc034a6:	ef 00                         	nop	; mov.l	r0, r0

        /* SOSCCR - Sub-Clock Oscillator Control Register
        b7:b1    Reserved - The write value should be 0.
        b0       SOSTP    - Sub-clock oscillator Stop - Sub-clock oscillator is stopped.
        NOTE: Please refer Tool News(TN-RX*-A0257A) for details. */
        SYSTEM.SOSCCR.BYTE = 0x01;
ffc034a8:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffc034ad:	f9 74 33 01                   	mov.b	#1, 51[r7]

        /* Dummy read and compare. cf."5. I/O Registers", "(2) Notes on writing to I/O registers" in User's manual.
           This is done to ensure that the register has been written before the next register access. The RX has a 
           pipeline architecture so the next instruction could be executed before the previous write had finished.
         */
        if (0x01 != SYSTEM.SOSCCR.BYTE)
ffc034b1:	59 77 33                      	movu.b	51[r7], r7
ffc034b4:	61 17                         	cmp	#1, r7
ffc034b6:	20 03                         	beq.b	ffc034b9 <_Reset_Vector+0xffc034bd>
        {
            R_BSP_NOP();
ffc034b8:	03                            	nop
        }

        /* WAIT_LOOP */
        while (0 != SYSTEM.OSCOVFSR.BIT.SOOVF)
ffc034b9:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffc034be:	cd 45 3c                      	mov.b	60[r4], r5
ffc034c1:	7c 15                         	btst	#1, r5
ffc034c3:	20 0d                         	beq.b	ffc034d0 <_Reset_Vector+0xffc034d4>
        {
            /* The delay period needed is to make sure that the sub-clock has stopped. */
            R_BSP_NOP();
ffc034c5:	03                            	nop
        while (0 != SYSTEM.OSCOVFSR.BIT.SOOVF)
ffc034c6:	cd 45 3c                      	mov.b	60[r4], r5
ffc034c9:	7c 15                         	btst	#1, r5
ffc034cb:	21 fa                         	bne.b	ffc034c5 <_Reset_Vector+0xffc034c9>
ffc034cd:	fc 13 00                      	nop	; max	r0, r0
#endif
    }

#if (BSP_CFG_PHY_CLOCK_SOURCE == 1) || (BSP_CFG_USB_CLOCK_SOURCE == 3)
    /* initialize */
    tmp_packcr = SYSTEM.PACKCR.WORD;
ffc034d0:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffc034d5:	dd 57 22                      	mov.w	68[r5], r7
ffc034d8:	d3 07                         	mov.w	r7, [r0]

#if BSP_CFG_PHY_CLOCK_SOURCE == 1
    /* Set value of OUTCKSEL bit. */
    tmp_packcr |= 0x0010;
ffc034da:	dc 04                         	mov.w	[r0], r4
ffc034dc:	78 44                         	bset	#4, r4
ffc034de:	d3 04                         	mov.w	r4, [r0]
    /* Set value of UPLLSEL bit. */
    tmp_packcr |= 0x1000;
#endif

    /* Set value to PACLCR register. */
    SYSTEM.PACKCR.WORD = tmp_packcr;
ffc034e0:	dc 07                         	mov.w	[r0], r7
ffc034e2:	d7 57 22                      	mov.w	r7, 68[r5]
    #if BSP_CFG_PLL_SRC == 0
    /* Clear PLL clock source if PLL clock source is Main clock. */
    SYSTEM.PLLCR.BIT.PLLSRCSEL = 0;
    #else
    /* Set PLL clock source if PLL clock source is HOCO clock. */
    SYSTEM.PLLCR.BIT.PLLSRCSEL = 1;
ffc034e5:	9d 57                         	mov.w	40[r5], r7
ffc034e7:	78 47                         	bset	#4, r7
ffc034e9:	95 57                         	mov.w	r7, 40[r5]
#endif

#if BSP_PRV_PLL_CLK_OPERATING == 1

    /* Set PLL Input Divisor. */
    SYSTEM.PLLCR.BIT.PLIDIV = BSP_CFG_PLL_DIV - 1;
ffc034eb:	9d 54                         	mov.w	40[r5], r4
ffc034ed:	75 24 fc                      	and	#-4, r4
ffc034f0:	95 54                         	mov.w	r4, 40[r5]

    /* Set PLL Multiplier. */
    SYSTEM.PLLCR.BIT.STC = ((uint8_t)((float)BSP_CFG_PLL_MUL * 2.0)) - 1;
ffc034f2:	9d 54                         	mov.w	40[r5], r4
ffc034f4:	76 24 ff c0                   	and	#0xffffc0ff, r4
ffc034f8:	76 34 00 1d                   	or	#0x1d00, r4
ffc034fc:	95 54                         	mov.w	r4, 40[r5]

    /* Set the PLL to operating. */
    SYSTEM.PLLCR2.BYTE = 0x00;
ffc034fe:	f9 54 2a 00                   	mov.b	#0, 42[r5]

    /* WAIT_LOOP */
    while(0 == SYSTEM.OSCOVFSR.BIT.PLOVF)
ffc03502:	cd 54 3c                      	mov.b	60[r5], r4
ffc03505:	7c 24                         	btst	#2, r4
ffc03507:	19                            	bne.s	ffc03510 <_Reset_Vector+0xffc03514>
    {
        /* The delay period needed is to make sure that the PLL has stabilized.
           If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
        R_BSP_NOP();
ffc03508:	03                            	nop
    while(0 == SYSTEM.OSCOVFSR.BIT.PLOVF)
ffc03509:	cd 54 3c                      	mov.b	60[r5], r4
ffc0350c:	7c 24                         	btst	#2, r4
ffc0350e:	20 fa                         	beq.b	ffc03508 <_Reset_Vector+0xffc0350c>
    /* PLL is stopped after reset. */
#endif

#if BSP_PRV_PPLL_CLK_OPERATING == 1
    /* Set PPLL Input Divisor. */
    SYSTEM.PPLLCR.BIT.PPLIDIV = BSP_CFG_PPLL_DIV - 1;
ffc03510:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffc03515:	dd 54 24                      	mov.w	72[r5], r4
ffc03518:	75 24 fc                      	and	#-4, r4
ffc0351b:	78 04                         	bset	#0, r4
ffc0351d:	d7 54 24                      	mov.w	r4, 72[r5]

    /* Set PPLL Multiplier. */
    SYSTEM.PPLLCR.BIT.PPLSTC = ((uint8_t)((float)BSP_CFG_PPLL_MUL * 2.0)) - 1;
ffc03520:	dd 54 24                      	mov.w	72[r5], r4
ffc03523:	76 24 ff c0                   	and	#0xffffc0ff, r4
ffc03527:	76 34 00 31                   	or	#0x3100, r4
ffc0352b:	d7 54 24                      	mov.w	r4, 72[r5]

    /* Set the PPLL to operating. */
    SYSTEM.PPLLCR2.BYTE = 0x00;
ffc0352e:	f9 54 4a 00                   	mov.b	#0, 74[r5]

    /* WAIT_LOOP */
    while(0 == SYSTEM.OSCOVFSR.BIT.PPLOVF)
ffc03532:	cd 54 3c                      	mov.b	60[r5], r4
ffc03535:	7c 54                         	btst	#5, r4
ffc03537:	19                            	bne.s	ffc03540 <_Reset_Vector+0xffc03544>
    {
        /* The delay period needed is to make sure that the PPLL has stabilized.
           If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
        R_BSP_NOP();
ffc03538:	03                            	nop
    while(0 == SYSTEM.OSCOVFSR.BIT.PPLOVF)
ffc03539:	cd 54 3c                      	mov.b	60[r5], r4
ffc0353c:	7c 54                         	btst	#5, r4
ffc0353e:	20 fa                         	beq.b	ffc03538 <_Reset_Vector+0xffc0353c>
    }

    /* Set PPLCK Input Divisor. */
    SYSTEM.PPLLCR3.BIT.PPLCK = BSP_CFG_PPLCK_DIV - 1;
ffc03540:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffc03545:	cd 45 4b                      	mov.b	75[r4], r5
ffc03548:	75 25 f0                      	and	#-16, r5
ffc0354b:	65 35                         	or	#3, r5
ffc0354d:	c7 45 4b                      	mov.b	r5, 75[r4]

ffc03550 <.LBE8>:
    SYSTEM.SCKCR.LONG = tmp_clock;
ffc03550:	f9 42 08 22 12 c3 23          	mov.l	#0x23c31222, 32[r4]
    if(tmp_clock == SYSTEM.SCKCR.LONG)
ffc03557:	aa 47                         	mov.l	32[r4], r7
ffc03559:	74 07 22 12 c3 23             	cmp	#0x23c31222, r7
ffc0355f:	21 03                         	bne.b	ffc03562 <_Reset_Vector+0xffc03566>
        R_BSP_NOP();
ffc03561:	03                            	nop

ffc03562 <.LVL28>:
    SYSTEM.SCKCR2.WORD = (uint16_t)tmp_clock;
ffc03562:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffc03567:	3d f2 11                      	mov.w	#17, 36[r7]
    if((uint16_t)tmp_clock == SYSTEM.SCKCR2.WORD)
ffc0356a:	bc f5                         	movu.w	36[r7], r5
ffc0356c:	75 55 11                      	cmp	#17, r5
ffc0356f:	21 03                         	bne.b	ffc03572 <_Reset_Vector+0xffc03576>
        R_BSP_NOP();
ffc03571:	03                            	nop

ffc03572 <.LVL29>:
    SYSTEM.SCKCR3.WORD = (uint16_t)tmp_clock;
ffc03572:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffc03577:	f9 79 13 00 04                	mov.w	#0x400, 38[r7]
    if((uint16_t)tmp_clock == SYSTEM.SCKCR3.WORD)
ffc0357c:	bc fd                         	movu.w	38[r7], r5
ffc0357e:	76 05 00 04                   	cmp	#0x400, r5
ffc03582:	1e                            	bne.s	ffc03588 <_Reset_Vector+0xffc0358c>
        R_BSP_NOP();
ffc03583:	03                            	nop
ffc03584:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_SoftwareDelay((uint32_t)3, BSP_DELAY_MICROSECS);
ffc03588:	fb 2e 40 42 0f                	mov.l	#0xf4240, r2
ffc0358d:	66 31                         	mov.l	#3, r1
ffc0358f:	05 81 04 00                   	bsr.a	ffc03a10 <_Reset_Vector+0xffc03a14>

ffc03593 <.LVL30>:
        SYSTEM.SCKCR.LONG = tmp_restore_clock;
ffc03593:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffc03598:	f9 72 08 22 12 c2 21          	mov.l	#0x21c21222, 32[r7]
        if(tmp_restore_clock == SYSTEM.SCKCR.LONG)
ffc0359f:	aa 77                         	mov.l	32[r7], r7
ffc035a1:	74 07 22 12 c2 21             	cmp	#0x21c21222, r7
ffc035a7:	21 03                         	bne.b	ffc035aa <_Reset_Vector+0xffc035ae>
            R_BSP_NOP();
ffc035a9:	03                            	nop
    SYSTEM.LOCOCR.BYTE = 0x01;
ffc035aa:	fb 7e 00 00 08                	mov.l	#0x80000, r7
    R_BSP_SoftwareDelay((uint32_t)25, BSP_DELAY_MICROSECS);
ffc035af:	fb 2e 40 42 0f                	mov.l	#0xf4240, r2
ffc035b4:	75 41 19                      	mov.l	#25, r1
    SYSTEM.LOCOCR.BYTE = 0x01;
ffc035b7:	f9 74 34 01                   	mov.b	#1, 52[r7]
    R_BSP_SoftwareDelay((uint32_t)25, BSP_DELAY_MICROSECS);
ffc035bb:	05 55 04 00                   	bsr.a	ffc03a10 <_Reset_Vector+0xffc03a14>

ffc035bf <.LVL31>:
    SYSTEM.PRCR.WORD = 0xA500;
ffc035bf:	fa 79 ff 01 00 a5             	mov.w	#0xa500, 1022[r7]

ffc035c5 <.LBE6>:
} /* End of function mcu_clock_setup() */
ffc035c5:	3f 77 02                      	rtsd	#8, r7-r7

ffc035c8 <.LBB11>:
        SYSTEM.SOSCCR.BYTE = 0x01;
ffc035c8:	f9 74 33 01                   	mov.b	#1, 51[r7]
        if (0x01 != SYSTEM.SOSCCR.BYTE)
ffc035cc:	59 77 33                      	movu.b	51[r7], r7
ffc035cf:	61 17                         	cmp	#1, r7
ffc035d1:	20 07                         	beq.b	ffc035d8 <_Reset_Vector+0xffc035dc>
            R_BSP_NOP();
ffc035d3:	03                            	nop
ffc035d4:	76 10 01 00                   	nop	; mul	#1, r0
        while (0 != SYSTEM.OSCOVFSR.BIT.SOOVF)
ffc035d8:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffc035dd:	cd 45 3c                      	mov.b	60[r4], r5
ffc035e0:	7c 15                         	btst	#1, r5
ffc035e2:	3a ee fe                      	beq.w	ffc034d0 <_Reset_Vector+0xffc034d4>
            R_BSP_NOP();
ffc035e5:	03                            	nop
        while (0 != SYSTEM.OSCOVFSR.BIT.SOOVF)
ffc035e6:	cd 45 3c                      	mov.b	60[r4], r5
ffc035e9:	7c 15                         	btst	#1, r5
ffc035eb:	21 fa                         	bne.b	ffc035e5 <_Reset_Vector+0xffc035e9>
ffc035ed:	38 e3 fe                      	bra.w	ffc034d0 <_Reset_Vector+0xffc034d4>
            R_BSP_NOP();
ffc035f0:	03                            	nop
ffc035f1:	38 87 fe                      	bra.w	ffc03478 <_Reset_Vector+0xffc0347c>
        SYSTEM.HOCOPCR.BYTE = 0x00;
ffc035f4:	fa 54 94 c2 00                	mov.b	#0, 49812[r5]
        SYSTEM.HOCOCR.BYTE = 0x01;
ffc035f9:	c7 54 36                      	mov.b	r4, 54[r5]
        while(1 == SYSTEM.OSCOVFSR.BIT.HCOVF)
ffc035fc:	cd 54 3c                      	mov.b	60[r5], r4
ffc035ff:	7c 34                         	btst	#3, r4
ffc03601:	20 0a                         	beq.b	ffc0360b <_Reset_Vector+0xffc0360f>
            R_BSP_NOP();
ffc03603:	03                            	nop
        while(1 == SYSTEM.OSCOVFSR.BIT.HCOVF)
ffc03604:	cd 54 3c                      	mov.b	60[r5], r4
ffc03607:	7c 34                         	btst	#3, r4
ffc03609:	21 fa                         	bne.b	ffc03603 <_Reset_Vector+0xffc03607>
        SYSTEM.HOCOCR2.BYTE = 0x00;         //16MHz
ffc0360b:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffc03610:	f9 74 37 00                   	mov.b	#0, 55[r7]
        SYSTEM.HOCOCR.BYTE = 0x00;
ffc03614:	f9 74 36 00                   	mov.b	#0, 54[r7]
        if(0x00 == SYSTEM.HOCOCR.BYTE)
ffc03618:	59 77 36                      	movu.b	54[r7], r7
ffc0361b:	61 07                         	cmp	#0, r7
ffc0361d:	3b 03 fe                      	bne.w	ffc03420 <_Reset_Vector+0xffc03424>
            R_BSP_NOP();
ffc03620:	03                            	nop
ffc03621:	38 ff fd                      	bra.w	ffc03420 <_Reset_Vector+0xffc03424>

ffc03624 <.LBE11>:
ffc03624:	76 10 01 00                   	nop	; mul	#1, r0

ffc03628 <_bsp_non_existent_port_init>:
*                power.
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
void bsp_non_existent_port_init (void)
{
ffc03628:	6e 6d                         	pushm	r6-r13
ffc0362a:	60 40                         	sub	#4, r0
    /* OR in missing pin masks from above. */

    /* Set PORT0.PDR */
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
ffc0362c:	fb ae 00 c0 08                	mov.l	#0x8c000, r10

    /* Set PORT1.PDR */
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
ffc03631:	fb 7e 01 c0 08                	mov.l	#0x8c001, r7
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
ffc03636:	cc a4                         	mov.b	[r10], r4

    /* Set PORT2.PDR */
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
ffc03638:	fb 3e 02 c0 08                	mov.l	#0x8c002, r3

    /* Set PORT3.PDR */
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
ffc0363d:	fb de 03 c0 08                	mov.l	#0x8c003, r13

    /* Set PORT4.PDR */
    PORT4.PDR.BYTE |= BSP_PRV_PORT4_NE_PIN_MASK;
ffc03642:	fb 5e 04 c0 08                	mov.l	#0x8c004, r5
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
ffc03647:	75 34 5f                      	or	#95, r4

    /* Set PORT5.PDR */
    PORT5.PDR.BYTE |= BSP_PRV_PORT5_NE_PIN_MASK;
ffc0364a:	fb 8e 05 c0 08                	mov.l	#0x8c005, r8
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
ffc0364f:	c3 a4                         	mov.b	r4, [r10]

    /* Set PORT6.PDR */
    PORT6.PDR.BYTE |= BSP_PRV_PORT6_NE_PIN_MASK;
ffc03651:	fb 9e 06 c0 08                	mov.l	#0x8c006, r9
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
ffc03656:	cc 74                         	mov.b	[r7], r4

    /* Set PORT7.PDR */
    PORT7.PDR.BYTE |= BSP_PRV_PORT7_NE_PIN_MASK;
ffc03658:	fb ce 07 c0 08                	mov.l	#0x8c007, r12

    /* Set PORT8.PDR */
    PORT8.PDR.BYTE |= BSP_PRV_PORT8_NE_PIN_MASK;
ffc0365d:	fb be 08 c0 08                	mov.l	#0x8c008, r11

    /* Set PORT9.PDR */
    PORT9.PDR.BYTE |= BSP_PRV_PORT9_NE_PIN_MASK;
ffc03662:	fb 6e 09 c0 08                	mov.l	#0x8c009, r6
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
ffc03667:	65 34                         	or	#3, r4

    /* Set PORTA.PDR */
    PORTA.PDR.BYTE |= BSP_PRV_PORTA_NE_PIN_MASK;
ffc03669:	fb ae 0a c0 08                	mov.l	#0x8c00a, r10
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
ffc0366e:	c3 74                         	mov.b	r4, [r7]

    /* Set PORTB.PDR */
    PORTB.PDR.BYTE |= BSP_PRV_PORTB_NE_PIN_MASK;
ffc03670:	fb 7e 0b c0 08                	mov.l	#0x8c00b, r7
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
ffc03675:	cc 34                         	mov.b	[r3], r4

    /* Set PORTC.PDR */
    PORTC.PDR.BYTE |= BSP_PRV_PORTC_NE_PIN_MASK;
ffc03677:	fb fe 0c c0 08                	mov.l	#0x8c00c, r15

    /* Set PORTD.PDR */
    PORTD.PDR.BYTE |= BSP_PRV_PORTD_NE_PIN_MASK;
ffc0367c:	fb ee 0d c0 08                	mov.l	#0x8c00d, r14

    /* Set PORTE.PDR */
    PORTE.PDR.BYTE |= BSP_PRV_PORTE_NE_PIN_MASK;
ffc03681:	fb 1e 0e c0 08                	mov.l	#0x8c00e, r1
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
ffc03686:	c3 34                         	mov.b	r4, [r3]

    /* Set PORTF.PDR */
    PORTF.PDR.BYTE |= BSP_PRV_PORTF_NE_PIN_MASK;
ffc03688:	fb 2e 0f c0 08                	mov.l	#0x8c00f, r2
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
ffc0368d:	c0 d0                         	mov.b	[r13], [r0]

    /* Set PORTG.PDR */
    PORTG.PDR.BYTE |= BSP_PRV_PORTG_NE_PIN_MASK;
ffc0368f:	fb 3e 10 c0 08                	mov.l	#0x8c010, r3

    /* Set PORTH.PDR */
    PORTH.PDR.BYTE |= BSP_PRV_PORTH_NE_PIN_MASK;
ffc03694:	fb 4e 11 c0 08                	mov.l	#0x8c011, r4
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
ffc03699:	c0 0d                         	mov.b	[r0], [r13]

    /* Set PORTJ.PDR */
    PORTJ.PDR.BYTE |= BSP_PRV_PORTJ_NE_PIN_MASK;

    /* Set PORTK.PDR */
    PORTK.PDR.BYTE |= BSP_PRV_PORTK_NE_PIN_MASK;
ffc0369b:	fb de 13 c0 08                	mov.l	#0x8c013, r13
    PORT4.PDR.BYTE |= BSP_PRV_PORT4_NE_PIN_MASK;
ffc036a0:	c0 50                         	mov.b	[r5], [r0]
ffc036a2:	c0 05                         	mov.b	[r0], [r5]
    PORT5.PDR.BYTE |= BSP_PRV_PORT5_NE_PIN_MASK;
ffc036a4:	cc 85                         	mov.b	[r8], r5
ffc036a6:	75 35 c0                      	or	#-64, r5
ffc036a9:	c3 85                         	mov.b	r5, [r8]
    PORT6.PDR.BYTE |= BSP_PRV_PORT6_NE_PIN_MASK;
ffc036ab:	cc 95                         	mov.b	[r9], r5
ffc036ad:	f8 94 ff                      	mov.b	#255, [r9]
    PORT7.PDR.BYTE |= BSP_PRV_PORT7_NE_PIN_MASK;
ffc036b0:	cc c5                         	mov.b	[r12], r5
ffc036b2:	f8 c4 ff                      	mov.b	#255, [r12]
    PORT8.PDR.BYTE |= BSP_PRV_PORT8_NE_PIN_MASK;
ffc036b5:	cc b5                         	mov.b	[r11], r5
ffc036b7:	f8 b4 ff                      	mov.b	#255, [r11]
    PORT9.PDR.BYTE |= BSP_PRV_PORT9_NE_PIN_MASK;
ffc036ba:	cc 65                         	mov.b	[r6], r5
ffc036bc:	f8 64 ff                      	mov.b	#255, [r6]
    PORTA.PDR.BYTE |= BSP_PRV_PORTA_NE_PIN_MASK;
ffc036bf:	cc a5                         	mov.b	[r10], r5
ffc036c1:	c3 a5                         	mov.b	r5, [r10]
    PORTB.PDR.BYTE |= BSP_PRV_PORTB_NE_PIN_MASK;
ffc036c3:	cc 7a                         	mov.b	[r7], r10
ffc036c5:	c3 7a                         	mov.b	r10, [r7]
    PORTC.PDR.BYTE |= BSP_PRV_PORTC_NE_PIN_MASK;
ffc036c7:	cc f7                         	mov.b	[r15], r7
ffc036c9:	c3 f7                         	mov.b	r7, [r15]
    PORTD.PDR.BYTE |= BSP_PRV_PORTD_NE_PIN_MASK;
ffc036cb:	cc e7                         	mov.b	[r14], r7
ffc036cd:	c3 e7                         	mov.b	r7, [r14]
    PORTE.PDR.BYTE |= BSP_PRV_PORTE_NE_PIN_MASK;
ffc036cf:	cc 17                         	mov.b	[r1], r7
ffc036d1:	c3 17                         	mov.b	r7, [r1]
    PORTF.PDR.BYTE |= BSP_PRV_PORTF_NE_PIN_MASK;
ffc036d3:	cc 27                         	mov.b	[r2], r7
ffc036d5:	f8 24 ff                      	mov.b	#255, [r2]
    PORTG.PDR.BYTE |= BSP_PRV_PORTG_NE_PIN_MASK;
ffc036d8:	cc 37                         	mov.b	[r3], r7
ffc036da:	f8 34 ff                      	mov.b	#255, [r3]
    PORTH.PDR.BYTE |= BSP_PRV_PORTH_NE_PIN_MASK;
ffc036dd:	cc 47                         	mov.b	[r4], r7
ffc036df:	f8 44 ff                      	mov.b	#255, [r4]
    PORTJ.PDR.BYTE |= BSP_PRV_PORTJ_NE_PIN_MASK;
ffc036e2:	fb 7e 12 c0 08                	mov.l	#0x8c012, r7
ffc036e7:	cc 75                         	mov.b	[r7], r5
ffc036e9:	75 35 f7                      	or	#-9, r5
ffc036ec:	c3 75                         	mov.b	r5, [r7]
    PORTK.PDR.BYTE |= BSP_PRV_PORTK_NE_PIN_MASK;
ffc036ee:	cc d7                         	mov.b	[r13], r7
ffc036f0:	f8 d4 ff                      	mov.b	#255, [r13]

    /* Set PORTL.PDR */
    PORTL.PDR.BYTE |= BSP_PRV_PORTL_NE_PIN_MASK;
ffc036f3:	fb ae 14 c0 08                	mov.l	#0x8c014, r10
ffc036f8:	cc a7                         	mov.b	[r10], r7
ffc036fa:	f8 a4 ff                      	mov.b	#255, [r10]

    /* Set PORTM.PDR */
    PORTM.PDR.BYTE |= BSP_PRV_PORTM_NE_PIN_MASK;
ffc036fd:	fb ae 15 c0 08                	mov.l	#0x8c015, r10
ffc03702:	cc a7                         	mov.b	[r10], r7
ffc03704:	f8 a4 ff                      	mov.b	#255, [r10]

    /* Set PORTN.PDR */
    PORTN.PDR.BYTE |= BSP_PRV_PORTN_NE_PIN_MASK;
ffc03707:	fb ae 16 c0 08                	mov.l	#0x8c016, r10
ffc0370c:	cc a7                         	mov.b	[r10], r7
ffc0370e:	f8 a4 ff                      	mov.b	#255, [r10]

    /* Set PORTQ.PDR */
    PORTQ.PDR.BYTE |= BSP_PRV_PORTQ_NE_PIN_MASK;
ffc03711:	fb ae 17 c0 08                	mov.l	#0x8c017, r10
ffc03716:	cc a7                         	mov.b	[r10], r7
ffc03718:	f8 a4 ff                      	mov.b	#255, [r10]
} /* End of function bsp_non_existent_port_init() */
ffc0371b:	3f 6d 09                      	rtsd	#36, r6-r13

ffc0371e <.LFE3>:
	...

ffc03720 <_bsp_interrupt_enable_disable>:
#ifdef __FPU
    uint32_t      tmp_fpsw;
#endif
    bsp_int_err_t err = BSP_INT_SUCCESS;

    switch (vector)
ffc03720:	61 31                         	cmp	#3, r1
ffc03722:	20 4b                         	beq.b	ffc0376d <_Reset_Vector+0xffc03771>
ffc03724:	61 c1                         	cmp	#12, r1
ffc03726:	20 1a                         	beq.b	ffc03740 <_Reset_Vector+0xffc03744>
ffc03728:	61 21                         	cmp	#2, r1
ffc0372a:	14                            	beq.s	ffc0372e <_Reset_Vector+0xffc03732>

ffc0372b <.LVL79>:
                ICU.NMIER.BIT.NMIEN = 1;
            }
            else
            {
                /* NMI pin interrupts cannot be disabled after being enabled. */
                err = BSP_INT_ERR_UNSUPPORTED;
ffc0372b:	66 31                         	mov.l	#3, r1

ffc0372d <.LVL80>:
            err = BSP_INT_ERR_UNSUPPORTED;
            break;
    }

    return err;
} /* End of function bsp_interrupt_enable_disable() */
ffc0372d:	02                            	rts

ffc0372e <.LVL81>:
            if (true == enable)
ffc0372e:	5b 22                         	movu.b	r2, r2
ffc03730:	61 02                         	cmp	#0, r2
ffc03732:	20 f9                         	beq.b	ffc0372b <_Reset_Vector+0xffc0372f>
                ICU.NMIER.BIT.NMIEN = 1;
ffc03734:	fb 5e 00 70 08                	mov.l	#0x87000, r5
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc03739:	66 01                         	mov.l	#0, r1

ffc0373b <.LVL82>:
                ICU.NMIER.BIT.NMIEN = 1;
ffc0373b:	f2 50 81 05                   	bset	#0, 1409[r5].b
ffc0373f:	02                            	rts

ffc03740 <.LVL83>:
            if (true == enable)
ffc03740:	5b 22                         	movu.b	r2, r2
ffc03742:	61 02                         	cmp	#0, r2
ffc03744:	20 46                         	beq.b	ffc0378a <_Reset_Vector+0xffc0378e>
                IR(BSC,BUSERR) = 0;
ffc03746:	fb 5e 00 70 08                	mov.l	#0x87000, r5
                R_BSP_InterruptRequestEnable(VECT(BSC,BUSERR));
ffc0374b:	75 41 10                      	mov.l	#16, r1

ffc0374e <.LVL84>:
                IR(BSC,BUSERR) = 0;
ffc0374e:	f1 58 10                      	bclr	#0, 16[r5].b
                IPR(BSC,BUSERR) = 0x0F;
ffc03751:	ce 54 00 03                   	mov.b	768[r5], r4
ffc03755:	65 f4                         	or	#15, r4
ffc03757:	cb 54 00 03                   	mov.b	r4, 768[r5]
                R_BSP_InterruptRequestEnable(VECT(BSC,BUSERR));
ffc0375b:	05 88 05 00                   	bsr.a	ffc03ce3 <_Reset_Vector+0xffc03ce7>

ffc0375f <.LVL85>:
                BSC.BEREN.BIT.IGAEN = 1;
ffc0375f:	fb 5e 00 13 08                	mov.l	#0x81300, r5
ffc03764:	f1 50 04                      	bset	#0, 4[r5].b
                BSC.BEREN.BIT.TOEN = 1;
ffc03767:	f1 51 04                      	bset	#1, 4[r5].b
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc0376a:	66 01                         	mov.l	#0, r1
ffc0376c:	02                            	rts

ffc0376d <.LVL86>:
            tmp_fpsw = (uint32_t)R_BSP_GET_FPSW();
ffc0376d:	fd 6a 35                      	mvfc	fpsw, r5

ffc03770 <.LVL87>:
            if (true == enable)
ffc03770:	5b 22                         	movu.b	r2, r2
ffc03772:	61 02                         	cmp	#0, r2
ffc03774:	20 0c                         	beq.b	ffc03780 <_Reset_Vector+0xffc03784>
                R_BSP_SET_FPSW((tmp_fpsw | (uint32_t)BSP_PRV_FPU_EXCEPTIONS_ENABLE));
ffc03776:	76 35 00 7c                   	or	#0x7c00, r5

ffc0377a <.LVL88>:
ffc0377a:	fd 68 53                      	mvtc	r5, fpsw
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc0377d:	66 01                         	mov.l	#0, r1

ffc0377f <.LVL89>:
ffc0377f:	02                            	rts

ffc03780 <.LVL90>:
                R_BSP_SET_FPSW((tmp_fpsw & (uint32_t)~BSP_PRV_FPU_EXCEPTIONS_ENABLE));
ffc03780:	76 25 ff 83                   	and	#0xffff83ff, r5

ffc03784 <.LVL91>:
ffc03784:	fd 68 53                      	mvtc	r5, fpsw
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc03787:	66 01                         	mov.l	#0, r1

ffc03789 <.LVL92>:
ffc03789:	02                            	rts

ffc0378a <.LVL93>:
                R_BSP_InterruptRequestDisable(VECT(BSC,BUSERR));
ffc0378a:	75 41 10                      	mov.l	#16, r1

ffc0378d <.LVL94>:
ffc0378d:	05 66 05 00                   	bsr.a	ffc03cf3 <_Reset_Vector+0xffc03cf7>

ffc03791 <.LVL95>:
                BSC.BEREN.BIT.IGAEN = 0;
ffc03791:	fb 5e 00 13 08                	mov.l	#0x81300, r5
ffc03796:	f1 58 04                      	bclr	#0, 4[r5].b
                BSC.BEREN.BIT.TOEN = 0;
ffc03799:	f1 59 04                      	bclr	#1, 4[r5].b
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc0379c:	66 01                         	mov.l	#0, r1
ffc0379e:	02                            	rts

ffc0379f <.LFE10>:
ffc0379f:	03                            	nop

ffc037a0 <_bsp_mapped_interrupt_open>:
***********************************************************************************************************************/
void bsp_mapped_interrupt_open (void)
{
#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMT2_CMI2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMT2_CMI2) = BSP_PRV_INT_B_NUM_CMT2_CMI2;
ffc037a0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc037a5:	fa 54 80 07 01                	mov.b	#1, 1920[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMT3_CMI3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMT3_CMI3) = BSP_PRV_INT_B_NUM_CMT3_CMI3;
ffc037aa:	fa 54 81 07 02                	mov.b	#2, 1921[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_CMIA0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_CMIA0) = BSP_PRV_INT_B_NUM_TMR0_CMIA0;
ffc037af:	fa 54 92 07 03                	mov.b	#3, 1938[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_CMIB0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_CMIB0) = BSP_PRV_INT_B_NUM_TMR0_CMIB0;
ffc037b4:	fa 54 93 07 04                	mov.b	#4, 1939[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_OVI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_OVI0) = BSP_PRV_INT_B_NUM_TMR0_OVI0;
ffc037b9:	fa 54 94 07 05                	mov.b	#5, 1940[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_CMIA1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_CMIA1) = BSP_PRV_INT_B_NUM_TMR1_CMIA1;
ffc037be:	fa 54 95 07 06                	mov.b	#6, 1941[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_CMIB1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_CMIB1) = BSP_PRV_INT_B_NUM_TMR1_CMIB1;
ffc037c3:	fa 54 96 07 07                	mov.b	#7, 1942[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_OVI1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_OVI1) = BSP_PRV_INT_B_NUM_TMR1_OVI1;
ffc037c8:	fa 54 97 07 08                	mov.b	#8, 1943[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_CMIA2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_CMIA2) = BSP_PRV_INT_B_NUM_TMR2_CMIA2;
ffc037cd:	fa 54 98 07 09                	mov.b	#9, 1944[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_CMIB2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_CMIB2) = BSP_PRV_INT_B_NUM_TMR2_CMIB2;
ffc037d2:	fa 54 99 07 0a                	mov.b	#10, 1945[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_OVI2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_OVI2) = BSP_PRV_INT_B_NUM_TMR2_OVI2;
ffc037d7:	fa 54 9a 07 0b                	mov.b	#11, 1946[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_CMIA3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_CMIA3) = BSP_PRV_INT_B_NUM_TMR3_CMIA3;
ffc037dc:	fa 54 9b 07 0c                	mov.b	#12, 1947[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_CMIB3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_CMIB3) = BSP_PRV_INT_B_NUM_TMR3_CMIB3;
ffc037e1:	fa 54 9c 07 0d                	mov.b	#13, 1948[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_OVI3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_OVI3) = BSP_PRV_INT_B_NUM_TMR3_OVI3;
ffc037e6:	fa 54 9d 07 0e                	mov.b	#14, 1949[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0A) = BSP_PRV_INT_B_NUM_TPU0_TGI0A;
ffc037eb:	fa 54 82 07 0f                	mov.b	#15, 1922[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0B) = BSP_PRV_INT_B_NUM_TPU0_TGI0B;
ffc037f0:	fa 54 83 07 10                	mov.b	#16, 1923[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0C)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0C) = BSP_PRV_INT_B_NUM_TPU0_TGI0C;
ffc037f5:	fa 54 84 07 11                	mov.b	#17, 1924[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0D)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0D) = BSP_PRV_INT_B_NUM_TPU0_TGI0D;
ffc037fa:	fa 54 85 07 12                	mov.b	#18, 1925[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TCI0V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TCI0V) = BSP_PRV_INT_B_NUM_TPU0_TCI0V;
ffc037ff:	fa 54 86 07 13                	mov.b	#19, 1926[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TGI1A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TGI1A) = BSP_PRV_INT_B_NUM_TPU1_TGI1A;
ffc03804:	fa 54 90 07 14                	mov.b	#20, 1936[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TGI1B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TGI1B) = BSP_PRV_INT_B_NUM_TPU1_TGI1B;
ffc03809:	fa 54 87 07 15                	mov.b	#21, 1927[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TCI1V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TCI1V) = BSP_PRV_INT_B_NUM_TPU1_TCI1V;
ffc0380e:	fa 54 88 07 16                	mov.b	#22, 1928[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TCI1U)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TCI1U) = BSP_PRV_INT_B_NUM_TPU1_TCI1U;
ffc03813:	fa 54 89 07 17                	mov.b	#23, 1929[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TGI2A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TGI2A) = BSP_PRV_INT_B_NUM_TPU2_TGI2A;
ffc03818:	fa 54 8a 07 18                	mov.b	#24, 1930[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TGI2B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TGI2B) = BSP_PRV_INT_B_NUM_TPU2_TGI2B;
ffc0381d:	fa 54 8b 07 19                	mov.b	#25, 1931[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TCI2V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TCI2V) = BSP_PRV_INT_B_NUM_TPU2_TCI2V;
ffc03822:	fa 54 8c 07 1a                	mov.b	#26, 1932[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TCI2U)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TCI2U) = BSP_PRV_INT_B_NUM_TPU2_TCI2U;
ffc03827:	fa 54 8d 07 1b                	mov.b	#27, 1933[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3A) = BSP_PRV_INT_B_NUM_TPU3_TGI3A;
ffc0382c:	fa 54 8e 07 1c                	mov.b	#28, 1934[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3B) = BSP_PRV_INT_B_NUM_TPU3_TGI3B;
ffc03831:	fa 54 8f 07 1d                	mov.b	#29, 1935[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3C)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3C) = BSP_PRV_INT_B_NUM_TPU3_TGI3C;
ffc03836:	fa 54 91 07 1e                	mov.b	#30, 1937[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3D)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3D) = BSP_PRV_INT_B_NUM_TPU3_TGI3D;
ffc0383b:	fa 54 9e 07 1f                	mov.b	#31, 1950[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TCI3V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TCI3V) = BSP_PRV_INT_B_NUM_TPU3_TCI3V;
ffc03840:	fa 54 9f 07 20                	mov.b	#32, 1951[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TGI4A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TGI4A) = BSP_PRV_INT_B_NUM_TPU4_TGI4A;
ffc03845:	fa 54 a0 07 21                	mov.b	#33, 1952[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TGI4B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TGI4B) = BSP_PRV_INT_B_NUM_TPU4_TGI4B;
ffc0384a:	fa 54 a1 07 22                	mov.b	#34, 1953[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TCI4V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TCI4V) = BSP_PRV_INT_B_NUM_TPU4_TCI4V;
ffc0384f:	fa 54 a2 07 23                	mov.b	#35, 1954[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TCI4U)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TCI4U) = BSP_PRV_INT_B_NUM_TPU4_TCI4U;
ffc03854:	fa 54 a3 07 24                	mov.b	#36, 1955[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TGI5A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TGI5A) = BSP_PRV_INT_B_NUM_TPU5_TGI5A;
ffc03859:	fa 54 a4 07 25                	mov.b	#37, 1956[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TGI5B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TGI5B) = BSP_PRV_INT_B_NUM_TPU5_TGI5B;
ffc0385e:	fa 54 a5 07 26                	mov.b	#38, 1957[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TCI5V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TCI5V) = BSP_PRV_INT_B_NUM_TPU5_TCI5V;
ffc03863:	fa 54 a6 07 27                	mov.b	#39, 1958[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TCI5U)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TCI5U) = BSP_PRV_INT_B_NUM_TPU5_TCI5U;
ffc03868:	fa 54 a7 07 28                	mov.b	#40, 1959[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_IC0I0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_IC0I0) = BSP_PRV_INT_B_NUM_CMTW0_IC0I0;
ffc0386d:	fa 54 a8 07 29                	mov.b	#41, 1960[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_IC1I0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_IC1I0) = BSP_PRV_INT_B_NUM_CMTW0_IC1I0;
ffc03872:	fa 54 a9 07 2a                	mov.b	#42, 1961[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_OC0I0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_OC0I0) = BSP_PRV_INT_B_NUM_CMTW0_OC0I0;
ffc03877:	fa 54 aa 07 2b                	mov.b	#43, 1962[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_OC1I0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_OC1I0) = BSP_PRV_INT_B_NUM_CMTW0_OC1I0;
ffc0387c:	fa 54 ab 07 2c                	mov.b	#44, 1963[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_IC0I1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_IC0I1) = BSP_PRV_INT_B_NUM_CMTW1_IC0I1;
ffc03881:	fa 54 ac 07 2d                	mov.b	#45, 1964[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_IC1I1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_IC1I1) = BSP_PRV_INT_B_NUM_CMTW1_IC1I1;
ffc03886:	fa 54 ad 07 2e                	mov.b	#46, 1965[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_OC0I1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_OC0I1) = BSP_PRV_INT_B_NUM_CMTW1_OC0I1;
ffc0388b:	fa 54 ae 07 2f                	mov.b	#47, 1966[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_OC1I1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_OC1I1) = BSP_PRV_INT_B_NUM_CMTW1_OC1I1;
ffc03890:	fa 54 af 07 30                	mov.b	#48, 1967[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_RTC_CUP)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_RTC_CUP) = BSP_PRV_INT_B_NUM_RTC_CUP;
ffc03895:	fa 54 b0 07 31                	mov.b	#49, 1968[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_RXF0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_RXF0) = BSP_PRV_INT_B_NUM_CAN0_RXF0;
ffc0389a:	fa 54 b1 07 32                	mov.b	#50, 1969[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_TXF0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_TXF0) = BSP_PRV_INT_B_NUM_CAN0_TXF0;
ffc0389f:	fa 54 b2 07 33                	mov.b	#51, 1970[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_RXM0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_RXM0) = BSP_PRV_INT_B_NUM_CAN0_RXM0;
ffc038a4:	fa 54 b3 07 34                	mov.b	#52, 1971[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_TXM0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_TXM0) = BSP_PRV_INT_B_NUM_CAN0_TXM0;
ffc038a9:	fa 54 b4 07 35                	mov.b	#53, 1972[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_RXF1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_RXF1) = BSP_PRV_INT_B_NUM_CAN1_RXF1;
ffc038ae:	fa 54 b5 07 36                	mov.b	#54, 1973[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_TXF1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_TXF1) = BSP_PRV_INT_B_NUM_CAN1_TXF1;
ffc038b3:	fa 54 b6 07 37                	mov.b	#55, 1974[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_RXM1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_RXM1) = BSP_PRV_INT_B_NUM_CAN1_RXM1;
ffc038b8:	fa 54 b7 07 38                	mov.b	#56, 1975[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_TXM1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_TXM1) = BSP_PRV_INT_B_NUM_CAN1_TXM1;
ffc038bd:	fa 54 b8 07 39                	mov.b	#57, 1976[r5]
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN2_TXM2) = BSP_PRV_INT_B_NUM_CAN2_TXM2;
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_USB0_USBI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_USB0_USBI0) = BSP_PRV_INT_B_NUM_USB0_USBI0;
ffc038c2:	fa 54 b9 07 3e                	mov.b	#62, 1977[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12ADI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12ADI0) = BSP_PRV_INT_B_NUM_S12ADC0_S12ADI0;
ffc038c7:	fa 54 ba 07 40                	mov.b	#64, 1978[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12GBADI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12GBADI0) = BSP_PRV_INT_B_NUM_S12ADC0_S12GBADI0;
ffc038cc:	fa 54 bb 07 41                	mov.b	#65, 1979[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12GCADI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12GCADI0) = BSP_PRV_INT_B_NUM_S12ADC0_S12GCADI0;
ffc038d1:	fa 54 bc 07 42                	mov.b	#66, 1980[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12ADI1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12ADI1) = BSP_PRV_INT_B_NUM_S12ADC1_S12ADI1;
ffc038d6:	fa 54 bd 07 44                	mov.b	#68, 1981[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12GBADI1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12GBADI1) = BSP_PRV_INT_B_NUM_S12ADC1_S12GBADI1;
ffc038db:	fa 54 be 07 45                	mov.b	#69, 1982[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12GCADI1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12GCADI1) = BSP_PRV_INT_B_NUM_S12ADC1_S12GCADI1;
ffc038e0:	fa 54 bf 07 46                	mov.b	#70, 1983[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_ELC_ELSR18I)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_ELC_ELSR18I) = BSP_PRV_INT_B_NUM_ELC_ELSR18I;
ffc038e5:	fa 54 c0 07 4f                	mov.b	#79, 1984[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_ELC_ELSR19I)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_ELC_ELSR19I) = BSP_PRV_INT_B_NUM_ELC_ELSR19I;
ffc038ea:	fa 54 c1 07 50                	mov.b	#80, 1985[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_PROC_BUSY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_PROC_BUSY) = BSP_PRV_INT_B_NUM_TSIP_PROC_BUSY;
ffc038ef:	fa 54 c2 07 55                	mov.b	#85, 1986[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_ROMOK)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_ROMOK) = BSP_PRV_INT_B_NUM_TSIP_ROMOK;
ffc038f4:	fa 54 c3 07 56                	mov.b	#86, 1987[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_LONG_PLG)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_LONG_PLG) = BSP_PRV_INT_B_NUM_TSIP_LONG_PLG;
ffc038f9:	fa 54 c4 07 57                	mov.b	#87, 1988[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_TEST_BUSY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_TEST_BUSY) = BSP_PRV_INT_B_NUM_TSIP_TEST_BUSY;
ffc038fe:	fa 54 c5 07 58                	mov.b	#88, 1989[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY0) = BSP_PRV_INT_B_NUM_TSIP_WRRDY0;
ffc03903:	fa 54 c6 07 59                	mov.b	#89, 1990[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY1) = BSP_PRV_INT_B_NUM_TSIP_WRRDY1;
ffc03908:	fa 54 c7 07 5a                	mov.b	#90, 1991[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY4) = BSP_PRV_INT_B_NUM_TSIP_WRRDY4;
ffc0390d:	fa 54 c8 07 5b                	mov.b	#91, 1992[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_RDRDY0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_RDRDY0) = BSP_PRV_INT_B_NUM_TSIP_RDRDY0;
ffc03912:	fa 54 c9 07 5c                	mov.b	#92, 1993[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_RDRDY1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_RDRDY1) = BSP_PRV_INT_B_NUM_TSIP_RDRDY1;
ffc03917:	fa 54 ca 07 5d                	mov.b	#93, 1994[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_INTEGRATE_WRRDY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_INTEGRATE_WRRDY) = BSP_PRV_INT_B_NUM_TSIP_INTEGRATE_WRRDY;
ffc0391c:	fa 54 cb 07 5e                	mov.b	#94, 1995[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_INTEGRATE_RDRDY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_INTEGRATE_RDRDY) = BSP_PRV_INT_B_NUM_TSIP_INTEGRATE_RDRDY;
ffc03921:	fa 54 cc 07 5f                	mov.b	#95, 1996[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIA0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIA0) = BSP_PRV_INT_A_NUM_MTU0_TGIA0;
ffc03926:	fa 54 d1 09 01                	mov.b	#1, 2513[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIB0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIB0) = BSP_PRV_INT_A_NUM_MTU0_TGIB0;
ffc0392b:	fa 54 d2 09 02                	mov.b	#2, 2514[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIC0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIC0) = BSP_PRV_INT_A_NUM_MTU0_TGIC0;
ffc03930:	fa 54 d3 09 03                	mov.b	#3, 2515[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGID0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGID0) = BSP_PRV_INT_A_NUM_MTU0_TGID0;
ffc03935:	fa 54 d4 09 04                	mov.b	#4, 2516[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TCIV0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TCIV0) = BSP_PRV_INT_A_NUM_MTU0_TCIV0;
ffc0393a:	fa 54 d5 09 05                	mov.b	#5, 2517[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIE0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIE0) = BSP_PRV_INT_A_NUM_MTU0_TGIE0;
ffc0393f:	fa 54 d6 09 06                	mov.b	#6, 2518[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIF0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIF0) = BSP_PRV_INT_A_NUM_MTU0_TGIF0;
ffc03944:	fa 54 d7 09 07                	mov.b	#7, 2519[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIA1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIA1) = BSP_PRV_INT_A_NUM_MTU1_TGIA1;
ffc03949:	fa 54 d0 09 08                	mov.b	#8, 2512[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIB1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIB1) = BSP_PRV_INT_A_NUM_MTU1_TGIB1;
ffc0394e:	fa 54 d8 09 09                	mov.b	#9, 2520[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIV1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIV1) = BSP_PRV_INT_A_NUM_MTU1_TCIV1;
ffc03953:	fa 54 d9 09 0a                	mov.b	#10, 2521[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIU1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIU1) = BSP_PRV_INT_A_NUM_MTU1_TCIU1;
ffc03958:	fa 54 da 09 0b                	mov.b	#11, 2522[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIA2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIA2) = BSP_PRV_INT_A_NUM_MTU2_TGIA2;
ffc0395d:	fa 54 db 09 0c                	mov.b	#12, 2523[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIB2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIB2) = BSP_PRV_INT_A_NUM_MTU2_TGIB2;
ffc03962:	fa 54 dc 09 0d                	mov.b	#13, 2524[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIV2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIV2) = BSP_PRV_INT_A_NUM_MTU2_TCIV2;
ffc03967:	fa 54 dd 09 0e                	mov.b	#14, 2525[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIU2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIU2) = BSP_PRV_INT_A_NUM_MTU2_TCIU2;
ffc0396c:	fa 54 de 09 0f                	mov.b	#15, 2526[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIA3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIA3) = BSP_PRV_INT_A_NUM_MTU3_TGIA3;
ffc03971:	fa 54 df 09 10                	mov.b	#16, 2527[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIB3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIB3) = BSP_PRV_INT_A_NUM_MTU3_TGIB3;
ffc03976:	fa 54 e0 09 11                	mov.b	#17, 2528[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIC3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIC3) = BSP_PRV_INT_A_NUM_MTU3_TGIC3;
ffc0397b:	fa 54 e1 09 12                	mov.b	#18, 2529[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGID3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGID3) = BSP_PRV_INT_A_NUM_MTU3_TGID3;
ffc03980:	fa 54 e2 09 13                	mov.b	#19, 2530[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TCIV3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TCIV3) = BSP_PRV_INT_A_NUM_MTU3_TCIV3;
ffc03985:	fa 54 e3 09 14                	mov.b	#20, 2531[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIA4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIA4) = BSP_PRV_INT_A_NUM_MTU4_TGIA4;
ffc0398a:	fa 54 e4 09 15                	mov.b	#21, 2532[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIB4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIB4) = BSP_PRV_INT_A_NUM_MTU4_TGIB4;
ffc0398f:	fa 54 e5 09 16                	mov.b	#22, 2533[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIC4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIC4) = BSP_PRV_INT_A_NUM_MTU4_TGIC4;
ffc03994:	fa 54 e6 09 17                	mov.b	#23, 2534[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGID4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGID4) = BSP_PRV_INT_A_NUM_MTU4_TGID4;
ffc03999:	fa 54 e7 09 18                	mov.b	#24, 2535[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TCIV4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TCIV4) = BSP_PRV_INT_A_NUM_MTU4_TCIV4;
ffc0399e:	fa 54 e8 09 19                	mov.b	#25, 2536[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIU5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIU5) = BSP_PRV_INT_A_NUM_MTU5_TGIU5;
ffc039a3:	fa 54 e9 09 1b                	mov.b	#27, 2537[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIV5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIV5) = BSP_PRV_INT_A_NUM_MTU5_TGIV5;
ffc039a8:	fa 54 ea 09 1c                	mov.b	#28, 2538[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIW5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIW5) = BSP_PRV_INT_A_NUM_MTU5_TGIW5;
ffc039ad:	fa 54 eb 09 1d                	mov.b	#29, 2539[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIA6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIA6) = BSP_PRV_INT_A_NUM_MTU6_TGIA6;
ffc039b2:	fa 54 ec 09 1e                	mov.b	#30, 2540[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIB6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIB6) = BSP_PRV_INT_A_NUM_MTU6_TGIB6;
ffc039b7:	fa 54 ed 09 1f                	mov.b	#31, 2541[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIC6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIC6) = BSP_PRV_INT_A_NUM_MTU6_TGIC6;
ffc039bc:	fa 54 ee 09 20                	mov.b	#32, 2542[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGID6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGID6) = BSP_PRV_INT_A_NUM_MTU6_TGID6;
ffc039c1:	fa 54 ef 09 21                	mov.b	#33, 2543[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TCIV6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TCIV6) = BSP_PRV_INT_A_NUM_MTU6_TCIV6;
ffc039c6:	fa 54 f0 09 22                	mov.b	#34, 2544[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIA7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIA7) = BSP_PRV_INT_A_NUM_MTU7_TGIA7;
ffc039cb:	fa 54 f1 09 23                	mov.b	#35, 2545[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIB7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIB7) = BSP_PRV_INT_A_NUM_MTU7_TGIB7;
ffc039d0:	fa 54 f2 09 24                	mov.b	#36, 2546[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIC7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIC7) = BSP_PRV_INT_A_NUM_MTU7_TGIC7;
ffc039d5:	fa 54 f3 09 25                	mov.b	#37, 2547[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGID7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGID7) = BSP_PRV_INT_A_NUM_MTU7_TGID7;
ffc039da:	fa 54 f4 09 26                	mov.b	#38, 2548[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TCIV7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TCIV7) = BSP_PRV_INT_A_NUM_MTU7_TCIV7;
ffc039df:	fa 54 f5 09 27                	mov.b	#39, 2549[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIA8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIA8) = BSP_PRV_INT_A_NUM_MTU8_TGIA8;
ffc039e4:	fa 54 f6 09 29                	mov.b	#41, 2550[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIB8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIB8) = BSP_PRV_INT_A_NUM_MTU8_TGIB8;
ffc039e9:	fa 54 f7 09 2a                	mov.b	#42, 2551[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIC8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIC8) = BSP_PRV_INT_A_NUM_MTU8_TGIC8;
ffc039ee:	fa 54 f8 09 2b                	mov.b	#43, 2552[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGID8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGID8) = BSP_PRV_INT_A_NUM_MTU8_TGID8;
ffc039f3:	fa 54 f9 09 2c                	mov.b	#44, 2553[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TCIV8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TCIV8) = BSP_PRV_INT_A_NUM_MTU8_TCIV8;
ffc039f8:	fa 54 fa 09 2d                	mov.b	#45, 2554[r5]
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_GPTW3_GTCIU3) = BSP_PRV_INT_A_NUM_GPTW3_GTCIU3;
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_PMGI0_PMGI0I)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_PMGI0_PMGI0I) = BSP_PRV_INT_A_NUM_PMGI0_PMGI0I;
ffc039fd:	fa 54 fb 09 62                	mov.b	#98, 2555[r5]
#endif
} /* End of function bsp_mapped_interrupt_open() */
ffc03a02:	02                            	rts

ffc03a03 <_delay_wait>:
***********************************************************************************************************************/
R_BSP_PRAGMA_STATIC_INLINE_ASM(delay_wait)
void delay_wait (unsigned long loop_cnt)
{
    R_BSP_ASM_INTERNAL_USED(loop_cnt)
    R_BSP_ASM_BEGIN
ffc03a03:	2e 03                         	bra.b	ffc03a06 <_Reset_Vector+0xffc03a0a>
ffc03a05:	03                            	nop
ffc03a06:	03                            	nop
ffc03a07:	60 11                         	sub	#1, r1
ffc03a09:	21 fd                         	bne.b	ffc03a06 <_Reset_Vector+0xffc03a0a>
ffc03a0b:	02                            	rts

ffc03a0c <.LFE4>:
ffc03a0c:	00                            	brk
ffc03a0d:	00                            	brk
	...

ffc03a10 <_R_BSP_SoftwareDelay>:
 * The actual delay time is plus the overhead at a specified duration. The overhead changes under the influence of 
 * the compiler, operating frequency and ROM cache. When the operating frequency is low, or the specified duration in 
 * units of microsecond level, please note that the error becomes large.
 */
bool R_BSP_SoftwareDelay(uint32_t delay, bsp_delay_units_t units)
{
ffc03a10:	6e 7a                         	pushm	r7-r10
ffc03a12:	71 00 e4                      	add	#-28, r0, r0
ffc03a15:	ef 27                         	mov.l	r2, r7
ffc03a17:	ef 1a                         	mov.l	r1, r10
    volatile uint32_t loop_cnt;
    volatile uint64_t delay_cycles_64;
    volatile uint64_t loop_cnt_64;

#ifdef BSP_CFG_PARAM_CHECKING_ENABLE
    if ((BSP_DELAY_MICROSECS != units) && (BSP_DELAY_MILLISECS != units) && (BSP_DELAY_SECS != units))
ffc03a19:	77 02 40 42 0f                	cmp	#0xf4240, r2
ffc03a1e:	20 72                         	beq.b	ffc03a90 <_Reset_Vector+0xffc03a94>
ffc03a20:	76 02 e8 03                   	cmp	#0x3e8, r2
ffc03a24:	16                            	beq.s	ffc03a2a <_Reset_Vector+0xffc03a2e>
ffc03a25:	61 12                         	cmp	#1, r2
ffc03a27:	3b aa 00                      	bne.w	ffc03ad1 <_Reset_Vector+0xffc03ad5>

ffc03a2a <.LBB4>:
    return get_iclk_freq_hz();  // Get the MCU specific ICLK frequency
ffc03a2a:	05 ee f8 ff                   	bsr.a	ffc03318 <_Reset_Vector+0xffc0331c>

ffc03a2e <.LBE4>:
    {
        return(false);
    }
#endif

    iclk_rate = R_BSP_GetIClkFreqHz();  /* Get the current ICLK frequency */
ffc03a2e:	a1 81                         	mov.l	r1, 24[r0]
        }
    }
    else
    {
        /* Casting is valid because it matches the type to the right side or argument. */
        delay_cycles_64 = (((uint64_t)iclk_rate * (uint64_t)delay) / units);
ffc03a30:	ed 0e 06                      	mov.l	24[r0], r14
ffc03a33:	ef 73                         	mov.l	r7, r3
ffc03a35:	66 04                         	mov.l	#0, r4
ffc03a37:	fc 1f ae                      	emulu	r10, r14
ffc03a3a:	ef e1                         	mov.l	r14, r1
ffc03a3c:	ef f2                         	mov.l	r15, r2
ffc03a3e:	05 62 23 00                   	bsr.a	ffc05da0 <_Reset_Vector+0xffc05da4>
ffc03a42:	a0 81                         	mov.l	r1, 8[r0]
ffc03a44:	a0 8a                         	mov.l	r2, 12[r0]

        if (delay_cycles_64 > BSP_PRV_OVERHEAD_CYCLES_64)
ffc03a46:	ed 0a 02                      	mov.l	8[r0], r10

ffc03a49 <.LVL5>:
ffc03a49:	a8 8f                         	mov.l	12[r0], r7

ffc03a4b <.LVL6>:
ffc03a4b:	61 07                         	cmp	#0, r7
ffc03a4d:	3b 8b 00                      	bne.w	ffc03ad8 <_Reset_Vector+0xffc03adc>
ffc03a50:	61 2a                         	cmp	#2, r10
ffc03a52:	25 05                         	bleu.b	ffc03a57 <_Reset_Vector+0xffc03a5b>
ffc03a54:	38 84 00                      	bra.w	ffc03ad8 <_Reset_Vector+0xffc03adc>
        {
            delay_cycles_64 -= BSP_PRV_OVERHEAD_CYCLES_64;
        }
        else
        {
            delay_cycles = 0;
ffc03a57:	3e 05 00                      	mov.l	#0, 20[r0]
        }

        loop_cnt_64 = delay_cycles_64 / CPU_CYCLES_PER_LOOP;
ffc03a5a:	a8 81                         	mov.l	8[r0], r1
ffc03a5c:	a8 8a                         	mov.l	12[r0], r2
ffc03a5e:	66 33                         	mov.l	#3, r3
ffc03a60:	66 04                         	mov.l	#0, r4
ffc03a62:	05 3e 23 00                   	bsr.a	ffc05da0 <_Reset_Vector+0xffc05da4>
ffc03a66:	e3 01                         	mov.l	r1, [r0]
ffc03a68:	a0 0a                         	mov.l	r2, 4[r0]

        if ((loop_cnt_64 > 0xFFFFFFFFUL) || (0 == loop_cnt_64))
ffc03a6a:	ec 07                         	mov.l	[r0], r7
ffc03a6c:	a8 0f                         	mov.l	4[r0], r7
ffc03a6e:	61 07                         	cmp	#0, r7
ffc03a70:	21 61                         	bne.b	ffc03ad1 <_Reset_Vector+0xffc03ad5>
ffc03a72:	ec 07                         	mov.l	[r0], r7
ffc03a74:	06 95 07 01                   	or	4[r0].l, r7
ffc03a78:	61 07                         	cmp	#0, r7
ffc03a7a:	20 57                         	beq.b	ffc03ad1 <_Reset_Vector+0xffc03ad5>
             * also results in the minimum possible delay. */
            return(false);
        }

        /* Casting is valid because it matches the type to the right side or argument. */
        loop_cnt = (uint32_t)loop_cnt_64;
ffc03a7c:	ec 07                         	mov.l	[r0], r7
ffc03a7e:	ed 0a 01                      	mov.l	4[r0], r10
ffc03a81:	a1 07                         	mov.l	r7, 16[r0]
    }

    delay_wait(loop_cnt);
ffc03a83:	a9 01                         	mov.l	16[r0], r1
ffc03a85:	05 7e ff ff                   	bsr.a	ffc03a03 <_Reset_Vector+0xffc03a07>

ffc03a89 <.LVL8>:

    return(true);
ffc03a89:	66 11                         	mov.l	#1, r1
ffc03a8b:	5b 11                         	movu.b	r1, r1
} /* End of function R_BSP_SoftwareDelay() */
ffc03a8d:	3f 7a 0b                      	rtsd	#44, r7-r10

ffc03a90 <.LBB7>:
    return get_iclk_freq_hz();  // Get the MCU specific ICLK frequency
ffc03a90:	05 88 f8 ff                   	bsr.a	ffc03318 <_Reset_Vector+0xffc0331c>

ffc03a94 <.LBE7>:
    iclk_rate = R_BSP_GetIClkFreqHz();  /* Get the current ICLK frequency */
ffc03a94:	a1 81                         	mov.l	r1, 24[r0]
         (delay <= (0xFFFFFFFFUL / iclk_rate)) )  /* Ensure (iclk_rate * delay) will not exceed 32 bits */
ffc03a96:	a9 84                         	mov.l	24[r0], r4
ffc03a98:	fc 1f a4                      	emulu	r10, r4
ffc03a9b:	61 05                         	cmp	#0, r5
ffc03a9d:	21 93                         	bne.b	ffc03a30 <_Reset_Vector+0xffc03a34>
        delay_cycles = ((iclk_rate * delay) / units);
ffc03a9f:	ed 0e 06                      	mov.l	24[r0], r14
ffc03aa2:	4f ae                         	mul	r10, r14
ffc03aa4:	fb a2 83 de 1b 43             	mov.l	#0x431bde83, r10

ffc03aaa <.LVL11>:
ffc03aaa:	fc 1f ae                      	emulu	r10, r14
ffc03aad:	fd 92 f7                      	shlr	#18, r15, r7

ffc03ab0 <.LVL12>:
ffc03ab0:	a1 0f                         	mov.l	r7, 20[r0]
        if (delay_cycles > BSP_PRV_OVERHEAD_CYCLES)
ffc03ab2:	a9 0f                         	mov.l	20[r0], r7
ffc03ab4:	61 27                         	cmp	#2, r7
ffc03ab6:	24 35                         	bgtu.b	ffc03aeb <_Reset_Vector+0xffc03aef>
            delay_cycles = 0;
ffc03ab8:	3e 05 00                      	mov.l	#0, 20[r0]
        loop_cnt = delay_cycles / CPU_CYCLES_PER_LOOP;
ffc03abb:	a9 0c                         	mov.l	20[r0], r4
ffc03abd:	fb 72 ab aa aa aa             	mov.l	#0xaaaaaaab, r7
ffc03ac3:	fc 1f 74                      	emulu	r7, r4
ffc03ac6:	fd 81 57                      	shlr	#1, r5, r7
ffc03ac9:	a1 07                         	mov.l	r7, 16[r0]
        if (0 == loop_cnt)
ffc03acb:	a9 07                         	mov.l	16[r0], r7
ffc03acd:	61 07                         	cmp	#0, r7
ffc03acf:	21 b4                         	bne.b	ffc03a83 <_Reset_Vector+0xffc03a87>
        return(false);
ffc03ad1:	66 01                         	mov.l	#0, r1
ffc03ad3:	5b 11                         	movu.b	r1, r1
} /* End of function R_BSP_SoftwareDelay() */
ffc03ad5:	3f 7a 0b                      	rtsd	#44, r7-r10
            delay_cycles_64 -= BSP_PRV_OVERHEAD_CYCLES_64;
ffc03ad8:	ed 0a 02                      	mov.l	8[r0], r10
ffc03adb:	a8 8f                         	mov.l	12[r0], r7
ffc03add:	71 a5 fe                      	add	#-2, r10, r5
ffc03ae0:	fd 74 27 ff                   	adc	#-1, r7
ffc03ae4:	a0 85                         	mov.l	r5, 8[r0]
ffc03ae6:	a0 8f                         	mov.l	r7, 12[r0]
ffc03ae8:	38 72 ff                      	bra.w	ffc03a5a <_Reset_Vector+0xffc03a5e>
            delay_cycles -= BSP_PRV_OVERHEAD_CYCLES;
ffc03aeb:	a9 0f                         	mov.l	20[r0], r7
ffc03aed:	60 27                         	sub	#2, r7
ffc03aef:	a1 0f                         	mov.l	r7, 20[r0]
ffc03af1:	2e ca                         	bra.b	ffc03abb <_Reset_Vector+0xffc03abf>

ffc03af3 <.LFE6>:
ffc03af3:	77 10 01 00 00                	nop	; mul	#1, r0

ffc03af8 <_R_BSP_CpuInterruptLevelRead>:
{
    /* Use the compiler intrinsic function to read the CPU IPL. */
    uint32_t psw_value;

    /* Casting is valid because it matches the type to the right side or argument. */
    psw_value = (uint32_t)R_BSP_GET_PSW();
ffc03af8:	fd 6a 01                      	mvfc	psw, r1

ffc03afb <.LVL2>:
    psw_value = psw_value & 0x0f000000;
    psw_value = psw_value >> 24;
ffc03afb:	69 81                         	shlr	#24, r1

ffc03afd <.LVL3>:

    return psw_value;
} /* End of function R_BSP_CpuInterruptLevelRead() */
ffc03afd:	64 f1                         	and	#15, r1

ffc03aff <.LVL4>:
ffc03aff:	02                            	rts

ffc03b00 <_R_BSP_CpuInterruptLevelWrite>:
       The MVTIPL instruction needs to set an immediate value to src. */

    ret = false;

    /* Read current processor mode. */
    pmode = (R_BSP_GET_PSW() & 0x00100000);
ffc03b00:	fd 6a 05                      	mvfc	psw, r5

ffc03b03 <.LVL6>:

    /* Check current processor mode. */
    if (0 == pmode)
ffc03b03:	7d 45                         	btst	#20, r5
ffc03b05:	21 12                         	bne.b	ffc03b17 <_Reset_Vector+0xffc03b1b>

ffc03b07 <.LVL7>:
    {
        ret = true;

        /* Use the compiler intrinsic function to set the CPU IPL. */
        switch (level)
ffc03b07:	61 f1                         	cmp	#15, r1
ffc03b09:	24 0e                         	bgtu.b	ffc03b17 <_Reset_Vector+0xffc03b1b>
ffc03b0b:	6c 21                         	shll	#2, r1

ffc03b0d <.LVL8>:
ffc03b0d:	70 11 28 6d c0 ff             	add	#0xffc06d28, r1, r1
ffc03b13:	ec 15                         	mov.l	[r1], r5

ffc03b15 <.LVL9>:
ffc03b15:	7f 05                         	jmp	r5

ffc03b17 <.LVL10>:
                R_BSP_SET_IPL(15);
                break;
    #endif /* BSP_MCU_IPL_MAX */

            default:
                ret = false;
ffc03b17:	66 01                         	mov.l	#0, r1

ffc03b19 <.LVL11>:
                break;
        }
    }

    return ret;
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b19:	64 11                         	and	#1, r1

ffc03b1b <.LVL12>:
ffc03b1b:	02                            	rts

ffc03b1c <.L11>:
                R_BSP_SET_IPL(14);
ffc03b1c:	75 70 0e                      	mvtipl	#14
        ret = true;
ffc03b1f:	66 11                         	mov.l	#1, r1

ffc03b21 <.LVL14>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b21:	64 11                         	and	#1, r1

ffc03b23 <.LVL15>:
ffc03b23:	02                            	rts

ffc03b24 <.L9>:
                R_BSP_SET_IPL(15);
ffc03b24:	75 70 0f                      	mvtipl	#15
        ret = true;
ffc03b27:	66 11                         	mov.l	#1, r1

ffc03b29 <.LVL16>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b29:	64 11                         	and	#1, r1

ffc03b2b <.LVL17>:
ffc03b2b:	02                            	rts

ffc03b2c <.L25>:
                R_BSP_SET_IPL(0);
ffc03b2c:	75 70 00                      	mvtipl	#0
        ret = true;
ffc03b2f:	66 11                         	mov.l	#1, r1

ffc03b31 <.LVL18>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b31:	64 11                         	and	#1, r1

ffc03b33 <.LVL19>:
ffc03b33:	02                            	rts

ffc03b34 <.L24>:
                R_BSP_SET_IPL(1);
ffc03b34:	75 70 01                      	mvtipl	#1
        ret = true;
ffc03b37:	66 11                         	mov.l	#1, r1

ffc03b39 <.LVL20>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b39:	64 11                         	and	#1, r1

ffc03b3b <.LVL21>:
ffc03b3b:	02                            	rts

ffc03b3c <.L23>:
                R_BSP_SET_IPL(2);
ffc03b3c:	75 70 02                      	mvtipl	#2
        ret = true;
ffc03b3f:	66 11                         	mov.l	#1, r1

ffc03b41 <.LVL22>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b41:	64 11                         	and	#1, r1

ffc03b43 <.LVL23>:
ffc03b43:	02                            	rts

ffc03b44 <.L22>:
                R_BSP_SET_IPL(3);
ffc03b44:	75 70 03                      	mvtipl	#3
        ret = true;
ffc03b47:	66 11                         	mov.l	#1, r1

ffc03b49 <.LVL24>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b49:	64 11                         	and	#1, r1

ffc03b4b <.LVL25>:
ffc03b4b:	02                            	rts

ffc03b4c <.L21>:
                R_BSP_SET_IPL(4);
ffc03b4c:	75 70 04                      	mvtipl	#4
        ret = true;
ffc03b4f:	66 11                         	mov.l	#1, r1

ffc03b51 <.LVL26>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b51:	64 11                         	and	#1, r1

ffc03b53 <.LVL27>:
ffc03b53:	02                            	rts

ffc03b54 <.L20>:
                R_BSP_SET_IPL(5);
ffc03b54:	75 70 05                      	mvtipl	#5
        ret = true;
ffc03b57:	66 11                         	mov.l	#1, r1

ffc03b59 <.LVL28>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b59:	64 11                         	and	#1, r1

ffc03b5b <.LVL29>:
ffc03b5b:	02                            	rts

ffc03b5c <.L19>:
                R_BSP_SET_IPL(6);
ffc03b5c:	75 70 06                      	mvtipl	#6
        ret = true;
ffc03b5f:	66 11                         	mov.l	#1, r1

ffc03b61 <.LVL30>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b61:	64 11                         	and	#1, r1

ffc03b63 <.LVL31>:
ffc03b63:	02                            	rts

ffc03b64 <.L18>:
                R_BSP_SET_IPL(7);
ffc03b64:	75 70 07                      	mvtipl	#7
        ret = true;
ffc03b67:	66 11                         	mov.l	#1, r1

ffc03b69 <.LVL32>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b69:	64 11                         	and	#1, r1

ffc03b6b <.LVL33>:
ffc03b6b:	02                            	rts

ffc03b6c <.L17>:
                R_BSP_SET_IPL(8);
ffc03b6c:	75 70 08                      	mvtipl	#8
        ret = true;
ffc03b6f:	66 11                         	mov.l	#1, r1

ffc03b71 <.LVL34>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b71:	64 11                         	and	#1, r1

ffc03b73 <.LVL35>:
ffc03b73:	02                            	rts

ffc03b74 <.L16>:
                R_BSP_SET_IPL(9);
ffc03b74:	75 70 09                      	mvtipl	#9
        ret = true;
ffc03b77:	66 11                         	mov.l	#1, r1

ffc03b79 <.LVL36>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b79:	64 11                         	and	#1, r1

ffc03b7b <.LVL37>:
ffc03b7b:	02                            	rts

ffc03b7c <.L15>:
                R_BSP_SET_IPL(10);
ffc03b7c:	75 70 0a                      	mvtipl	#10
        ret = true;
ffc03b7f:	66 11                         	mov.l	#1, r1

ffc03b81 <.LVL38>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b81:	64 11                         	and	#1, r1

ffc03b83 <.LVL39>:
ffc03b83:	02                            	rts

ffc03b84 <.L14>:
                R_BSP_SET_IPL(11);
ffc03b84:	75 70 0b                      	mvtipl	#11
        ret = true;
ffc03b87:	66 11                         	mov.l	#1, r1

ffc03b89 <.LVL40>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b89:	64 11                         	and	#1, r1

ffc03b8b <.LVL41>:
ffc03b8b:	02                            	rts

ffc03b8c <.L13>:
                R_BSP_SET_IPL(12);
ffc03b8c:	75 70 0c                      	mvtipl	#12
        ret = true;
ffc03b8f:	66 11                         	mov.l	#1, r1

ffc03b91 <.LVL42>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b91:	64 11                         	and	#1, r1

ffc03b93 <.LVL43>:
ffc03b93:	02                            	rts

ffc03b94 <.L12>:
                R_BSP_SET_IPL(13);
ffc03b94:	75 70 0d                      	mvtipl	#13
        ret = true;
ffc03b97:	66 11                         	mov.l	#1, r1

ffc03b99 <.LVL44>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffc03b99:	64 11                         	and	#1, r1

ffc03b9b <.LVL45>:
ffc03b9b:	02                            	rts

ffc03b9c <.LFE6>:
ffc03b9c:	00                            	brk
ffc03b9d:	00                            	brk
	...

ffc03ba0 <_R_BSP_RegisterProtectEnable>:
 * The R_BSP_InterruptControl function used to secure atomicity in the critical section of the counter control with 
 * this function is valid only in supervisor mode. When this function is executed in user mode, the 
 * R_BSP_InterruptControl function is executed but atomicity is not to secure.
 */
void R_BSP_RegisterProtectEnable (bsp_reg_protect_t regs_to_protect)
{
ffc03ba0:	7e a7                         	push.l	r7
ffc03ba2:	60 40                         	sub	#4, r0
ffc03ba4:	ef 17                         	mov.l	r1, r7
    bsp_int_ctrl_t int_ctrl;

    /* Set IPL to the maximum value to disable all interrupts,
     * so the scheduler can not be scheduled in critical region.
     * Note: Please set this macro more than IPR for other FIT module interrupts. */
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc03ba6:	ef 03                         	mov.l	r0, r3
ffc03ba8:	66 62                         	mov.l	#6, r2
ffc03baa:	75 41 69                      	mov.l	#105, r1

ffc03bad <.LVL47>:
ffc03bad:	05 9b 01 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc03bb1 <.LVL48>:

    /* Is it safe to disable write access? */
    if (0 != s_protect_counters[regs_to_protect])
ffc03bb1:	fb 52 b0 04 00 00             	mov.l	#0x4b0, r5
ffc03bb7:	fe d7 54                      	movu.w	[r7, r5], r4
ffc03bba:	61 04                         	cmp	#0, r4
ffc03bbc:	20 0c                         	beq.b	ffc03bc8 <_Reset_Vector+0xffc03bcc>
    {
        /* Decrement the protect counter */
        s_protect_counters[regs_to_protect]--;
ffc03bbe:	fe 57 54                      	mov.w	[r7, r5], r4
ffc03bc1:	60 14                         	sub	#1, r4
ffc03bc3:	fe 17 54                      	mov.w	r4, [r7, r5]
ffc03bc6:	ef 00                         	nop	; mov.l	r0, r0
    }

    /* Is it safe to disable write access? */
    if (0 == s_protect_counters[regs_to_protect])
ffc03bc8:	fe d7 55                      	movu.w	[r7, r5], r5
ffc03bcb:	61 05                         	cmp	#0, r5
ffc03bcd:	21 24                         	bne.b	ffc03bf1 <_Reset_Vector+0xffc03bf5>
    {
        if (BSP_REG_PROTECT_MPC != regs_to_protect)
ffc03bcf:	61 37                         	cmp	#3, r7
ffc03bd1:	20 2e                         	beq.b	ffc03bff <_Reset_Vector+0xffc03c03>
               b3     PRC3  - Please check the user's manual.
               b2     PRC2  - Please check the user's manual.
               b1     PRC1  - Please check the user's manual.
               b0     PRC0  - Please check the user's manual.
            */
            SYSTEM.PRCR.WORD = (uint16_t)((SYSTEM.PRCR.WORD | BSP_PRV_PRCR_KEY) & (~s_prcr_masks[regs_to_protect]));
ffc03bd3:	fb 3e 00 00 08                	mov.l	#0x80000, r3
ffc03bd8:	de 34 ff 01                   	mov.w	1022[r3], r4
ffc03bdc:	fb 52 68 6d c0 ff             	mov.l	#0xffc06d68, r5
ffc03be2:	fe 57 55                      	mov.w	[r7, r5], r5
ffc03be5:	76 34 00 a5                   	or	#0xffffa500, r4
ffc03be9:	7e 05                         	not	r5
ffc03beb:	53 45                         	and	r4, r5
ffc03bed:	db 35 ff 01                   	mov.w	r5, 1022[r3]
            MPC.PWPR.BIT.B0WI = 1;
        }
    }

    /* Restore the IPL. */
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc03bf1:	ef 03                         	mov.l	r0, r3
ffc03bf3:	66 52                         	mov.l	#5, r2
ffc03bf5:	75 41 69                      	mov.l	#105, r1
ffc03bf8:	05 50 01 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc03bfc <.LVL49>:
#else /* BSP_MCU_REGISTER_WRITE_PROTECTION */
    /* No registers to protect. */
    /* This code is only used to remove compiler info messages about this parameter not being used. */
    INTERNAL_NOT_USED(regs_to_protect);
#endif /* BSP_MCU_REGISTER_WRITE_PROTECTION */
} /* End of function R_BSP_RegisterProtectEnable() */
ffc03bfc:	3f 77 02                      	rtsd	#8, r7-r7
            MPC.PWPR.BIT.B0WI = 0;
ffc03bff:	fb 7e 00 c1 08                	mov.l	#0x8c100, r7

ffc03c04 <.LVL51>:
ffc03c04:	8f fd                         	mov.b	31[r7], r5
ffc03c06:	7a 75                         	bclr	#7, r5
ffc03c08:	87 fd                         	mov.b	r5, 31[r7]
            MPC.PWPR.BIT.PFSWE = 0;
ffc03c0a:	f1 7e 1f                      	bclr	#6, 31[r7].b
            MPC.PWPR.BIT.B0WI = 1;
ffc03c0d:	8f fd                         	mov.b	31[r7], r5
ffc03c0f:	78 75                         	bset	#7, r5
ffc03c11:	87 fd                         	mov.b	r5, 31[r7]
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc03c13:	ef 03                         	mov.l	r0, r3
ffc03c15:	66 52                         	mov.l	#5, r2
ffc03c17:	75 41 69                      	mov.l	#105, r1
ffc03c1a:	05 2e 01 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc03c1e <.LVL52>:
} /* End of function R_BSP_RegisterProtectEnable() */
ffc03c1e:	3f 77 02                      	rtsd	#8, r7-r7

ffc03c21 <.LFE7>:
ffc03c21:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc03c28 <_R_BSP_RegisterProtectDisable>:
 * @note The R_BSP_InterruptControl function used to secure atomicity in the critical section of the counter control 
 * with this function is valid only in supervisor mode. When this function is executed in user mode, the 
 * R_BSP_InterruptControl function is executed but atomicity is not to secure.
 */
void R_BSP_RegisterProtectDisable (bsp_reg_protect_t regs_to_unprotect)
{
ffc03c28:	7e a7                         	push.l	r7
ffc03c2a:	60 40                         	sub	#4, r0
ffc03c2c:	ef 17                         	mov.l	r1, r7
    bsp_int_ctrl_t int_ctrl;

    /* Set IPL to the maximum value to disable all interrupts,
     * so the scheduler can not be scheduled in critical region.
     * Note: Please set this macro more than IPR for other FIT module interrupts. */
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffc03c2e:	ef 03                         	mov.l	r0, r3
ffc03c30:	66 62                         	mov.l	#6, r2
ffc03c32:	75 41 69                      	mov.l	#105, r1

ffc03c35 <.LVL54>:
ffc03c35:	05 13 01 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc03c39 <.LVL55>:

    /* If this is first entry then disable protection. */
    if (0 == s_protect_counters[regs_to_unprotect])
ffc03c39:	fb 52 b0 04 00 00             	mov.l	#0x4b0, r5
ffc03c3f:	fe d7 54                      	movu.w	[r7, r5], r4
ffc03c42:	61 04                         	cmp	#0, r4
ffc03c44:	21 22                         	bne.b	ffc03c66 <_Reset_Vector+0xffc03c6a>
    {
        if (BSP_REG_PROTECT_MPC != regs_to_unprotect)
ffc03c46:	61 37                         	cmp	#3, r7
ffc03c48:	20 34                         	beq.b	ffc03c7c <_Reset_Vector+0xffc03c80>
               b3     PRC3  - Please check the user's manual.
               b2     PRC2  - Please check the user's manual.
               b1     PRC1  - Please check the user's manual.
               b0     PRC0  - Please check the user's manual.
            */
            SYSTEM.PRCR.WORD = (uint16_t)((SYSTEM.PRCR.WORD | BSP_PRV_PRCR_KEY) | s_prcr_masks[regs_to_unprotect]);
ffc03c4a:	fb 3e 00 00 08                	mov.l	#0x80000, r3
ffc03c4f:	de 32 ff 01                   	mov.w	1022[r3], r2
ffc03c53:	fb 42 68 6d c0 ff             	mov.l	#0xffc06d68, r4
ffc03c59:	fe 57 44                      	mov.w	[r7, r4], r4
ffc03c5c:	57 24                         	or	r2, r4
ffc03c5e:	76 34 00 a5                   	or	#0xffffa500, r4
ffc03c62:	db 34 ff 01                   	mov.w	r4, 1022[r3]

    /* Increment the protect counter */
    s_protect_counters[regs_to_unprotect]++;

    /* Restore the IPL. */
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc03c66:	ef 03                         	mov.l	r0, r3
ffc03c68:	66 52                         	mov.l	#5, r2
ffc03c6a:	75 41 69                      	mov.l	#105, r1
    s_protect_counters[regs_to_unprotect]++;
ffc03c6d:	fe 57 54                      	mov.w	[r7, r5], r4
ffc03c70:	62 14                         	add	#1, r4
ffc03c72:	fe 17 54                      	mov.w	r4, [r7, r5]
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc03c75:	05 d3 00 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc03c79 <.LVL56>:
#else /* BSP_MCU_REGISTER_WRITE_PROTECTION */
    /* No registers to protect. */
    /* This code is only used to remove compiler info messages about this parameter not being used. */
    INTERNAL_NOT_USED(regs_to_unprotect);
#endif /* BSP_MCU_REGISTER_WRITE_PROTECTION */
} /* End of function R_BSP_RegisterProtectDisable() */
ffc03c79:	3f 77 02                      	rtsd	#8, r7-r7
            MPC.PWPR.BIT.B0WI = 0;
ffc03c7c:	fb 4e 00 c1 08                	mov.l	#0x8c100, r4
ffc03c81:	8f cb                         	mov.b	31[r4], r3
ffc03c83:	7a 73                         	bclr	#7, r3
ffc03c85:	87 cb                         	mov.b	r3, 31[r4]
            MPC.PWPR.BIT.PFSWE = 1;
ffc03c87:	f1 46 1f                      	bset	#6, 31[r4].b
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc03c8a:	ef 03                         	mov.l	r0, r3
ffc03c8c:	66 52                         	mov.l	#5, r2
ffc03c8e:	75 41 69                      	mov.l	#105, r1
    s_protect_counters[regs_to_unprotect]++;
ffc03c91:	fe 57 54                      	mov.w	[r7, r5], r4
ffc03c94:	62 14                         	add	#1, r4
ffc03c96:	fe 17 54                      	mov.w	r4, [r7, r5]
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffc03c99:	05 af 00 00                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc03c9d <.LVL58>:
} /* End of function R_BSP_RegisterProtectDisable() */
ffc03c9d:	3f 77 02                      	rtsd	#8, r7-r7

ffc03ca0 <_bsp_register_protect_open>:

    /* Initialize reference counters to 0. */
    /* WAIT_LOOP */
    for (i = 0; i < BSP_REG_PROTECT_TOTAL_ITEMS; i++)
    {
        s_protect_counters[i] = 0;
ffc03ca0:	fb 52 b0 04 00 00             	mov.l	#0x4b0, r5
ffc03ca6:	f8 55 00                      	mov.w	#0, [r5]

ffc03ca9 <.LVL61>:
ffc03ca9:	3d 51 00                      	mov.w	#0, 2[r5]

ffc03cac <.LVL62>:
ffc03cac:	3d 52 00                      	mov.w	#0, 4[r5]

ffc03caf <.LVL63>:
ffc03caf:	3d 53 00                      	mov.w	#0, 6[r5]

ffc03cb2 <.LVL64>:
    }
#else
    /* No registers to protect. */
#endif
} /* End of function bsp_register_protect_open() */
ffc03cb2:	02                            	rts

ffc03cb3 <_bsp_ram_initialize>:
{
    uint32_t i;

    /* Initialize g_bsp_Locks to 0. */
    /* WAIT_LOOP */
    for (i = 0; i < BSP_NUM_LOCKS; i++)
ffc03cb3:	fb 12 8c 06 00 00             	mov.l	#0x68c, r1
ffc03cb9:	fb 3a f4 01                   	mov.l	#500, r3
ffc03cbd:	66 02                         	mov.l	#0, r2
ffc03cbf:	7f 88                         	sstr.b
    {
        g_bsp_Locks[i].lock = 0;
    }
} /* End of function bsp_ram_initialize() */
ffc03cc1:	02                            	rts

ffc03cc2 <_R_BSP_InterruptControl.constprop.2>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc03cc2:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc03cc8:	fe 61 55                      	mov.l	[r1, r5], r5
ffc03ccb:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffc03cd2:	20 0e                         	beq.b	ffc03ce0 <_Reset_Vector+0xffc03ce4>
bsp_int_err_t R_BSP_InterruptControl (bsp_int_src_t vector, bsp_int_cmd_t cmd, void * pdata)
ffc03cd4:	60 40                         	sub	#4, r0
                cb_args.vector = vector;
ffc03cd6:	e3 01                         	mov.l	r1, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc03cd8:	ef 01                         	mov.l	r0, r1

ffc03cda <.LVL1>:
ffc03cda:	7f 15                         	jsr	r5

ffc03cdc <.LVL2>:
    err = BSP_INT_SUCCESS;
ffc03cdc:	66 01                         	mov.l	#0, r1
} /* End of function R_BSP_InterruptControl() */
ffc03cde:	67 01                         	rtsd	#4

ffc03ce0 <.LVL3>:
                err = BSP_INT_ERR_NO_REGISTERED_CALLBACK;
ffc03ce0:	66 11                         	mov.l	#1, r1

ffc03ce2 <.LVL4>:
} /* End of function R_BSP_InterruptControl() */
ffc03ce2:	02                            	rts

ffc03ce3 <_R_BSP_InterruptRequestEnable>:
    ier_reg_num = vector >> 3;
ffc03ce3:	fd 83 15                      	shlr	#3, r1, r5

ffc03ce6 <.LVL6>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03ce6:	66 72                         	mov.l	#7, r2
ffc03ce8:	53 12                         	and	r1, r2

ffc03cea <.LVL7>:
ffc03cea:	73 51 00 72 08                	add	#0x87200, r5, r1

ffc03cef <.LVL8>:
ffc03cef:	04 19 05 00                   	bra.a	ffc04208 <_Reset_Vector+0xffc0420c>

ffc03cf3 <_R_BSP_InterruptRequestDisable>:
    ier_reg_num = vector >> 3;
ffc03cf3:	fd 83 15                      	shlr	#3, r1, r5

ffc03cf6 <.LVL11>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03cf6:	66 72                         	mov.l	#7, r2
ffc03cf8:	53 12                         	and	r1, r2

ffc03cfa <.LVL12>:
ffc03cfa:	73 51 00 72 08                	add	#0x87200, r5, r1

ffc03cff <.LVL13>:
ffc03cff:	04 0d 05 00                   	bra.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03d03 <.LFE4>:
ffc03d03:	00                            	brk
ffc03d04:	00                            	brk
ffc03d05:	00                            	brk
	...

ffc03d08 <_bsp_interrupt_open>:
{
ffc03d08:	7e a7                         	push.l	r7

ffc03d0a <.LVL15>:
    for (i = 0; i < BSP_INT_SRC_TOTAL_ITEMS; i++)
ffc03d0a:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5

ffc03d10 <.LVL16>:
        g_bsp_vectors[i] = FIT_NO_FUNC;
ffc03d10:	fb 72 00 00 00 10             	mov.l	#0x10000000, r7
ffc03d16:	fd 22 57                      	mov.l	r7, [r5+]
    for (i = 0; i < BSP_INT_SRC_TOTAL_ITEMS; i++)
ffc03d19:	74 05 60 06 00 00             	cmp	#0x660, r5
ffc03d1f:	21 f1                         	bne.b	ffc03d10 <_Reset_Vector+0xffc03d14>
} /* End of function bsp_interrupt_open() */
ffc03d21:	7e b7                         	pop	r7
    bsp_mapped_interrupt_open();
ffc03d23:	04 7d fa ff                   	bra.a	ffc037a0 <_Reset_Vector+0xffc037a4>

ffc03d27 <.LFE5>:
ffc03d27:	03                            	nop

ffc03d28 <_R_BSP_InterruptWrite>:
        g_bsp_vectors[vector] = FIT_NO_FUNC;
ffc03d28:	fd 70 c2 ff ff ff ef          	tst	#0xefffffff, r2
ffc03d2f:	fd 70 e2 00 00 00 10          	stz	#0x10000000, r2

ffc03d36 <.LVL19>:
ffc03d36:	fb 52 b8 04 00 00             	mov.l	#0x4b8, r5
ffc03d3c:	fe 21 52                      	mov.l	r2, [r1, r5]
} /* End of function R_BSP_InterruptWrite() */
ffc03d3f:	66 01                         	mov.l	#0, r1

ffc03d41 <.LVL20>:
ffc03d41:	02                            	rts

ffc03d42 <.LFE6>:
ffc03d42:	00                            	brk
ffc03d43:	00                            	brk
ffc03d44:	00                            	brk
ffc03d45:	00                            	brk
	...

ffc03d48 <_R_BSP_InterruptControl>:
{
ffc03d48:	6e 7a                         	pushm	r7-r10
ffc03d4a:	60 80                         	sub	#8, r0

ffc03d4c <.LVL26>:
ffc03d4c:	ef 17                         	mov.l	r1, r7
    switch (cmd)
ffc03d4e:	61 32                         	cmp	#3, r2
ffc03d50:	3a 82 00                      	beq.w	ffc03dd2 <_Reset_Vector+0xffc03dd6>
ffc03d53:	ef 25                         	mov.l	r2, r5
ffc03d55:	24 24                         	bgtu.b	ffc03d79 <_Reset_Vector+0xffc03d7d>
ffc03d57:	61 12                         	cmp	#1, r2
ffc03d59:	20 61                         	beq.b	ffc03dba <_Reset_Vector+0xffc03dbe>
ffc03d5b:	24 6a                         	bgtu.b	ffc03dc5 <_Reset_Vector+0xffc03dc9>
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffc03d5d:	fb a2 b8 04 00 00             	mov.l	#0x4b8, r10
ffc03d63:	fe 61 aa                      	mov.l	[r1, r10], r10
ffc03d66:	fd 70 ca ff ff ff ef          	tst	#0xefffffff, r10
ffc03d6d:	20 49                         	beq.b	ffc03db6 <_Reset_Vector+0xffc03dba>
                cb_args.vector = vector;
ffc03d6f:	e3 01                         	mov.l	r1, [r0]
                g_bsp_vectors[vector](&cb_args);
ffc03d71:	ef 01                         	mov.l	r0, r1

ffc03d73 <.LVL27>:
    err = BSP_INT_SUCCESS;
ffc03d73:	ef 27                         	mov.l	r2, r7

ffc03d75 <.LVL28>:
                g_bsp_vectors[vector](&cb_args);
ffc03d75:	7f 1a                         	jsr	r10

ffc03d77 <.LVL29>:
ffc03d77:	2e 3a                         	bra.b	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03d79 <.LVL30>:
    switch (cmd)
ffc03d79:	61 52                         	cmp	#5, r2
ffc03d7b:	3a c6 00                      	beq.w	ffc03e41 <_Reset_Vector+0xffc03e45>
ffc03d7e:	22 05                         	bc.b	ffc03d83 <_Reset_Vector+0xffc03d87>
ffc03d80:	38 ee 00                      	bra.w	ffc03e6e <_Reset_Vector+0xffc03e72>
ffc03d83:	61 62                         	cmp	#6, r2
ffc03d85:	21 2a                         	bne.b	ffc03daf <_Reset_Vector+0xffc03db3>

ffc03d87 <.LBB198>:
    if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
ffc03d87:	61 03                         	cmp	#0, r3
ffc03d89:	20 26                         	beq.b	ffc03daf <_Reset_Vector+0xffc03db3>
ffc03d8b:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc03d91:	20 1e                         	beq.b	ffc03daf <_Reset_Vector+0xffc03db3>
        pmode = (R_BSP_GET_PSW() & 0x00100000);
ffc03d93:	fd 6a 07                      	mvfc	psw, r7

ffc03d96 <.LVL32>:
        if (0 == pmode)
ffc03d96:	7d 47                         	btst	#20, r7
ffc03d98:	3b 15 01                      	bne.w	ffc03ead <_Reset_Vector+0xffc03eb1>

ffc03d9b <.LBB200>:
                pdata->ipl = R_BSP_CpuInterruptLevelRead();
ffc03d9b:	a0 0b                         	mov.l	r3, 4[r0]
ffc03d9d:	05 5b fd ff                   	bsr.a	ffc03af8 <_Reset_Vector+0xffc03afc>

ffc03da1 <.LVL34>:
ffc03da1:	a8 0b                         	mov.l	4[r0], r3
ffc03da3:	e3 31                         	mov.l	r1, [r3]

ffc03da5 <.LVL35>:
            if (pdata->ipl < BSP_CFG_FIT_IPL_MAX)
ffc03da5:	61 a1                         	cmp	#10, r1
ffc03da7:	24 05                         	bgtu.b	ffc03dac <_Reset_Vector+0xffc03db0>
ffc03da9:	38 2f 01                      	bra.w	ffc03ed8 <_Reset_Vector+0xffc03edc>

ffc03dac <.LBB208>:
                    err = BSP_INT_ERR_INVALID_IPL;
ffc03dac:	66 57                         	mov.l	#5, r7
ffc03dae:	0b                            	bra.s	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03daf <.LBE208>:
                 err = BSP_INT_ERR_INVALID_ARG;
ffc03daf:	66 27                         	mov.l	#2, r7

ffc03db1 <.LVL38>:
} /* End of function R_BSP_InterruptControl() */
ffc03db1:	ef 71                         	mov.l	r7, r1
ffc03db3:	3f 7a 06                      	rtsd	#24, r7-r10

ffc03db6 <.LVL39>:
                err = BSP_INT_ERR_NO_REGISTERED_CALLBACK;
ffc03db6:	66 17                         	mov.l	#1, r7
ffc03db8:	2e f9                         	bra.b	ffc03db1 <_Reset_Vector+0xffc03db5>
            err = bsp_interrupt_enable_disable(vector, true);
ffc03dba:	05 66 f9 ff                   	bsr.a	ffc03720 <_Reset_Vector+0xffc03724>

ffc03dbe <.LVL40>:
ffc03dbe:	ef 17                         	mov.l	r1, r7

ffc03dc0 <.LVL41>:
} /* End of function R_BSP_InterruptControl() */
ffc03dc0:	ef 71                         	mov.l	r7, r1
ffc03dc2:	3f 7a 06                      	rtsd	#24, r7-r10

ffc03dc5 <.LVL42>:
            err = bsp_interrupt_enable_disable(vector, false);
ffc03dc5:	66 02                         	mov.l	#0, r2

ffc03dc7 <.LVL43>:
ffc03dc7:	05 59 f9 ff                   	bsr.a	ffc03720 <_Reset_Vector+0xffc03724>

ffc03dcb <.LVL44>:
ffc03dcb:	ef 17                         	mov.l	r1, r7

ffc03dcd <.LVL45>:
} /* End of function R_BSP_InterruptControl() */
ffc03dcd:	ef 71                         	mov.l	r7, r1
ffc03dcf:	3f 7a 06                      	rtsd	#24, r7-r10

ffc03dd2 <.LVL46>:
            if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
ffc03dd2:	61 03                         	cmp	#0, r3
ffc03dd4:	20 db                         	beq.b	ffc03daf <_Reset_Vector+0xffc03db3>
ffc03dd6:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc03ddc:	20 d3                         	beq.b	ffc03daf <_Reset_Vector+0xffc03db3>
                err = bsp_gr_int_enable_disable(vector, true, ((bsp_int_ctrl_t *)pdata)->ipl);
ffc03dde:	ec 3a                         	mov.l	[r3], r10

ffc03de0 <.LBB219>:
    if ((true == enable) && ((BSP_MCU_IPL_MIN == ipl) || (ipl > BSP_MCU_IPL_MAX)))
ffc03de0:	71 a5 ff                      	add	#-1, r10, r5
ffc03de3:	61 e5                         	cmp	#14, r5
ffc03de5:	24 ca                         	bgtu.b	ffc03daf <_Reset_Vector+0xffc03db3>
    if ((vector > BSP_INT_SRC_GR_INT_IE0_TOP) && (vector < BSP_INT_SRC_GR_INT_BE0_TOP))
ffc03de7:	75 51 14                      	cmp	#20, r1
ffc03dea:	3a f2 00                      	beq.w	ffc03edc <_Reset_Vector+0xffc03ee0>

ffc03ded <.LBB221>:
    else if ((vector > BSP_INT_SRC_GR_INT_BE0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL0_TOP))
ffc03ded:	71 15 ea                      	add	#-22, r1, r5
ffc03df0:	61 25                         	cmp	#2, r5
ffc03df2:	25 05                         	bleu.b	ffc03df7 <_Reset_Vector+0xffc03dfb>
ffc03df4:	38 8b 01                      	bra.w	ffc03f7f <_Reset_Vector+0xffc03f83>

ffc03df7 <.LBB223>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03df7:	66 22                         	mov.l	#2, r2

ffc03df9 <.LVL50>:
ffc03df9:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc03dfe <.LVL51>:
ffc03dfe:	05 0e 04 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03e02 <.LVL52>:
            IR(ICU, GROUPBE0)  = 0;
ffc03e02:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffc03e07 <.LVL53>:
ffc03e07:	f1 78 6a                      	bclr	#0, 106[r7].b
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
ffc03e0a:	ce 75 6a 03                   	mov.b	874[r7], r5
ffc03e0e:	64 f5                         	and	#15, r5
ffc03e10:	47 5a                         	cmp	r5, r10
ffc03e12:	24 05                         	bgtu.b	ffc03e17 <_Reset_Vector+0xffc03e1b>
ffc03e14:	38 5a 02                      	bra.w	ffc0406e <_Reset_Vector+0xffc04072>
ffc03e17:	66 f5                         	mov.l	#15, r5
ffc03e19:	53 a5                         	and	r10, r5
ffc03e1b:	fb 4e 00 70 08                	mov.l	#0x87000, r4
ffc03e20:	66 fa                         	mov.l	#15, r10

ffc03e22 <.LVL54>:
ffc03e22:	53 5a                         	and	r5, r10

ffc03e24 <.LBB225>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03e24:	66 22                         	mov.l	#2, r2

ffc03e26 <.LBE225>:
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
ffc03e26:	ce 45 6a 03                   	mov.b	874[r4], r5

ffc03e2a <.LBB229>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03e2a:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc03e2f <.LBE229>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc03e2f:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
ffc03e31:	75 25 f0                      	and	#-16, r5
ffc03e34:	57 a5                         	or	r10, r5
ffc03e36:	cb 45 6a 03                   	mov.b	r5, 874[r4]

ffc03e3a <.LBB230>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03e3a:	05 ce 03 00                   	bsr.a	ffc04208 <_Reset_Vector+0xffc0420c>

ffc03e3e <.LVL56>:
ffc03e3e:	38 73 ff                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03e41 <.LBB292>:
    if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
ffc03e41:	61 03                         	cmp	#0, r3
ffc03e43:	3a 6c ff                      	beq.w	ffc03daf <_Reset_Vector+0xffc03db3>
ffc03e46:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffc03e4c:	3a 63 ff                      	beq.w	ffc03daf <_Reset_Vector+0xffc03db3>
        pmode = (R_BSP_GET_PSW() & 0x00100000);
ffc03e4f:	fd 6a 07                      	mvfc	psw, r7

ffc03e52 <.LVL58>:
        if (0 == pmode)
ffc03e52:	7d 47                         	btst	#20, r7
ffc03e54:	21 59                         	bne.b	ffc03ead <_Reset_Vector+0xffc03eb1>

ffc03e56 <.LBB214>:
                ipl_value = pdata->ipl;
ffc03e56:	ec 31                         	mov.l	[r3], r1

ffc03e58 <.LVL60>:
            if (pdata->ipl < BSP_CFG_FIT_IPL_MAX)
ffc03e58:	61 a1                         	cmp	#10, r1
ffc03e5a:	25 05                         	bleu.b	ffc03e5f <_Reset_Vector+0xffc03e63>
ffc03e5c:	38 50 ff                      	bra.w	ffc03dac <_Reset_Vector+0xffc03db0>

ffc03e5f <.LVL61>:
ffc03e5f:	03                            	nop

ffc03e60 <.LBB204>:
                ret = R_BSP_CpuInterruptLevelWrite(ipl_value);
ffc03e60:	05 a0 fc ff                   	bsr.a	ffc03b00 <_Reset_Vector+0xffc03b04>

ffc03e64 <.LVL62>:
                if (false == ret)
ffc03e64:	61 01                         	cmp	#0, r1
ffc03e66:	3a 46 ff                      	beq.w	ffc03dac <_Reset_Vector+0xffc03db0>

ffc03e69 <.LBB215>:
            err = BSP_INT_SUCCESS;
ffc03e69:	66 07                         	mov.l	#0, r7
ffc03e6b:	38 46 ff                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03e6e <.LBB295>:
    if ((vector > BSP_INT_SRC_GR_INT_IE0_TOP) && (vector < BSP_INT_SRC_GR_INT_BE0_TOP))
ffc03e6e:	75 51 14                      	cmp	#20, r1
ffc03e71:	3a ba 00                      	beq.w	ffc03f2b <_Reset_Vector+0xffc03f2f>

ffc03e74 <.LBB297>:
    else if ((vector > BSP_INT_SRC_GR_INT_BE0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL0_TOP))
ffc03e74:	71 1a ea                      	add	#-22, r1, r10
ffc03e77:	61 2a                         	cmp	#2, r10
ffc03e79:	25 39                         	bleu.b	ffc03eb2 <_Reset_Vector+0xffc03eb6>
    else if ((vector > BSP_INT_SRC_GR_INT_BL0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL1_TOP))
ffc03e7b:	71 1a e6                      	add	#-26, r1, r10
ffc03e7e:	75 5a 1a                      	cmp	#26, r10
ffc03e81:	25 05                         	bleu.b	ffc03e86 <_Reset_Vector+0xffc03e8a>
ffc03e83:	38 ce 00                      	bra.w	ffc03f51 <_Reset_Vector+0xffc03f55>
            if (0 == ICU.GENBL0.LONG)
ffc03e86:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffc03e8b:	ee a7 9c 01                   	mov.l	1648[r10], r7
ffc03e8f:	61 07                         	cmp	#0, r7
ffc03e91:	3b 95 00                      	bne.w	ffc03f26 <_Reset_Vector+0xffc03f2a>

ffc03e94 <.LBB299>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03e94:	66 62                         	mov.l	#6, r2

ffc03e96 <.LVL66>:
ffc03e96:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc03e9b <.LVL67>:
ffc03e9b:	05 71 03 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03e9f <.LVL68>:
                IPR(ICU, GROUPBL0) = 0;
ffc03e9f:	ce a5 6e 03                   	mov.b	878[r10], r5
ffc03ea3:	75 25 f0                      	and	#-16, r5
ffc03ea6:	cb a5 6e 03                   	mov.b	r5, 878[r10]
ffc03eaa:	38 07 ff                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03ead <.LBB328>:
            err = BSP_INT_ERR_UNSUPPORTED;
ffc03ead:	66 37                         	mov.l	#3, r7
ffc03eaf:	38 02 ff                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03eb2 <.LBB316>:
            if (0 == ICU.GENBE0.LONG)
ffc03eb2:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffc03eb7:	ee a7 90 01                   	mov.l	1600[r10], r7
ffc03ebb:	61 07                         	cmp	#0, r7
ffc03ebd:	21 69                         	bne.b	ffc03f26 <_Reset_Vector+0xffc03f2a>

ffc03ebf <.LBB301>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03ebf:	66 22                         	mov.l	#2, r2

ffc03ec1 <.LVL72>:
ffc03ec1:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc03ec6 <.LVL73>:
ffc03ec6:	05 46 03 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03eca <.LVL74>:
                IPR(ICU, GROUPBE0) = 0;
ffc03eca:	ce a5 6a 03                   	mov.b	874[r10], r5
ffc03ece:	75 25 f0                      	and	#-16, r5
ffc03ed1:	cb a5 6a 03                   	mov.b	r5, 874[r10]
ffc03ed5:	38 dc fe                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03ed8 <.LBB205>:
                ret = R_BSP_CpuInterruptLevelWrite(ipl_value);
ffc03ed8:	66 b1                         	mov.l	#11, r1
ffc03eda:	2e 86                         	bra.b	ffc03e60 <_Reset_Vector+0xffc03e64>

ffc03edc <.LBB275>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03edc:	66 12                         	mov.l	#1, r2

ffc03ede <.LVL77>:
ffc03ede:	fb 1e 02 72 08                	mov.l	#0x87202, r1

ffc03ee3 <.LVL78>:
ffc03ee3:	05 29 03 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03ee7 <.LVL79>:
            IR(ICU, GROUPIE0)  = 0;
ffc03ee7:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffc03eec <.LVL80>:
ffc03eec:	f1 78 11                      	bclr	#0, 17[r7].b
            IPR(ICU, GROUPIE0) = (uint8_t)((ipl > IPR(ICU, GROUPIE0)) ? ipl : IPR(ICU, GROUPIE0));
ffc03eef:	ce 75 00 03                   	mov.b	768[r7], r5
ffc03ef3:	64 f5                         	and	#15, r5
ffc03ef5:	47 5a                         	cmp	r5, r10
ffc03ef7:	24 05                         	bgtu.b	ffc03efc <_Reset_Vector+0xffc03f00>
ffc03ef9:	38 13 01                      	bra.w	ffc0400c <_Reset_Vector+0xffc04010>
ffc03efc:	66 f5                         	mov.l	#15, r5
ffc03efe:	53 a5                         	and	r10, r5
ffc03f00:	fb 4e 00 70 08                	mov.l	#0x87000, r4
ffc03f05:	66 fa                         	mov.l	#15, r10

ffc03f07 <.LVL81>:
ffc03f07:	53 5a                         	and	r5, r10

ffc03f09 <.LBB277>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03f09:	66 12                         	mov.l	#1, r2

ffc03f0b <.LBE277>:
            IPR(ICU, GROUPIE0) = (uint8_t)((ipl > IPR(ICU, GROUPIE0)) ? ipl : IPR(ICU, GROUPIE0));
ffc03f0b:	ce 45 00 03                   	mov.b	768[r4], r5

ffc03f0f <.LBB281>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03f0f:	fb 1e 02 72 08                	mov.l	#0x87202, r1

ffc03f14 <.LBE281>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc03f14:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPIE0) = (uint8_t)((ipl > IPR(ICU, GROUPIE0)) ? ipl : IPR(ICU, GROUPIE0));
ffc03f16:	75 25 f0                      	and	#-16, r5
ffc03f19:	57 a5                         	or	r10, r5
ffc03f1b:	cb 45 00 03                   	mov.b	r5, 768[r4]

ffc03f1f <.LBB282>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03f1f:	05 e9 02 00                   	bsr.a	ffc04208 <_Reset_Vector+0xffc0420c>

ffc03f23 <.LVL83>:
ffc03f23:	38 8e fe                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03f26 <.LBB332>:
                err = BSP_INT_ERR_GROUP_STILL_ENABLED;
ffc03f26:	ef 57                         	mov.l	r5, r7
ffc03f28:	38 89 fe                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>
            if (0 == ICU.GENIE0.LONG)
ffc03f2b:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffc03f30:	ee a7 6d 01                   	mov.l	1460[r10], r7
ffc03f34:	61 07                         	cmp	#0, r7
ffc03f36:	21 f0                         	bne.b	ffc03f26 <_Reset_Vector+0xffc03f2a>

ffc03f38 <.LBB317>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03f38:	66 12                         	mov.l	#1, r2

ffc03f3a <.LVL86>:
ffc03f3a:	fb 1e 02 72 08                	mov.l	#0x87202, r1

ffc03f3f <.LVL87>:
ffc03f3f:	05 cd 02 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03f43 <.LVL88>:
                IPR(ICU, GROUPIE0) = 0;
ffc03f43:	ce a5 00 03                   	mov.b	768[r10], r5
ffc03f47:	75 25 f0                      	and	#-16, r5
ffc03f4a:	cb a5 00 03                   	mov.b	r5, 768[r10]
ffc03f4e:	38 63 fe                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03f51 <.LBB319>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL1_TOP) && (vector < BSP_INT_SRC_GR_INT_BL2_TOP))
ffc03f51:	71 1a ca                      	add	#-54, r1, r10
ffc03f54:	75 5a 15                      	cmp	#21, r10
ffc03f57:	24 7f                         	bgtu.b	ffc03fd6 <_Reset_Vector+0xffc03fda>
            if (0 == ICU.GENBL1.LONG)
ffc03f59:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffc03f5e:	ee a7 9d 01                   	mov.l	1652[r10], r7
ffc03f62:	61 07                         	cmp	#0, r7
ffc03f64:	21 c2                         	bne.b	ffc03f26 <_Reset_Vector+0xffc03f2a>

ffc03f66 <.LBB303>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03f66:	66 72                         	mov.l	#7, r2

ffc03f68 <.LVL91>:
ffc03f68:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc03f6d <.LVL92>:
ffc03f6d:	05 9f 02 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03f71 <.LVL93>:
                IPR(ICU, GROUPBL1) = 0;
ffc03f71:	ce a5 6f 03                   	mov.b	879[r10], r5
ffc03f75:	75 25 f0                      	and	#-16, r5
ffc03f78:	cb a5 6f 03                   	mov.b	r5, 879[r10]
ffc03f7c:	38 35 fe                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03f7f <.LBB283>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL1_TOP))
ffc03f7f:	71 15 e6                      	add	#-26, r1, r5
ffc03f82:	75 55 1a                      	cmp	#26, r5
ffc03f85:	25 05                         	bleu.b	ffc03f8a <_Reset_Vector+0xffc03f8e>
ffc03f87:	38 8e 00                      	bra.w	ffc04015 <_Reset_Vector+0xffc04019>

ffc03f8a <.LBB231>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03f8a:	66 62                         	mov.l	#6, r2

ffc03f8c <.LVL96>:
ffc03f8c:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc03f91 <.LVL97>:
ffc03f91:	05 7b 02 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03f95 <.LVL98>:
            IR(ICU, GROUPBL0)  = 0;
ffc03f95:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffc03f9a <.LVL99>:
ffc03f9a:	f1 78 6e                      	bclr	#0, 110[r7].b
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
ffc03f9d:	ce 75 6e 03                   	mov.b	878[r7], r5
ffc03fa1:	64 f5                         	and	#15, r5
ffc03fa3:	47 5a                         	cmp	r5, r10
ffc03fa5:	24 05                         	bgtu.b	ffc03faa <_Reset_Vector+0xffc03fae>
ffc03fa7:	38 01 01                      	bra.w	ffc040a8 <_Reset_Vector+0xffc040ac>
ffc03faa:	66 f4                         	mov.l	#15, r4
ffc03fac:	53 a4                         	and	r10, r4
ffc03fae:	ef 00                         	nop	; mov.l	r0, r0
ffc03fb0:	fb 3e 00 70 08                	mov.l	#0x87000, r3
ffc03fb5:	64 f4                         	and	#15, r4

ffc03fb7 <.LBB233>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03fb7:	66 62                         	mov.l	#6, r2

ffc03fb9 <.LBE233>:
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
ffc03fb9:	ce 35 6e 03                   	mov.b	878[r3], r5

ffc03fbd <.LBB237>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03fbd:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc03fc2 <.LBE237>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc03fc2:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
ffc03fc4:	fb a6 f0                      	mov.l	#-16, r10

ffc03fc7 <.LVL100>:
ffc03fc7:	53 5a                         	and	r5, r10
ffc03fc9:	57 4a                         	or	r4, r10
ffc03fcb:	cb 3a 6e 03                   	mov.b	r10, 878[r3]

ffc03fcf <.LBB238>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc03fcf:	05 39 02 00                   	bsr.a	ffc04208 <_Reset_Vector+0xffc0420c>

ffc03fd3 <.LVL102>:
ffc03fd3:	38 de fd                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc03fd6 <.LBB320>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL2_TOP) && (vector < BSP_INT_SRC_GR_INT_AL0_TOP))
ffc03fd6:	71 1a b3                      	add	#-77, r1, r10
ffc03fd9:	61 3a                         	cmp	#3, r10
ffc03fdb:	25 05                         	bleu.b	ffc03fe0 <_Reset_Vector+0xffc03fe4>
ffc03fdd:	38 9a 00                      	bra.w	ffc04077 <_Reset_Vector+0xffc0407b>
            if (0 == ICU.GENBL2.LONG)
ffc03fe0:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc03fe5:	ee 77 9e 01                   	mov.l	1656[r7], r7
ffc03fe9:	61 07                         	cmp	#0, r7
ffc03feb:	3b 3b ff                      	bne.w	ffc03f26 <_Reset_Vector+0xffc03f2a>

ffc03fee <.LBB305>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc03fee:	66 32                         	mov.l	#3, r2

ffc03ff0 <.LVL105>:
ffc03ff0:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc03ff5 <.LVL106>:
ffc03ff5:	05 17 02 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc03ff9 <.LVL107>:
                IPR(ICU, GROUPBL2) = 0;
ffc03ff9:	fb ae 00 70 08                	mov.l	#0x87000, r10

ffc03ffe <.LVL108>:
ffc03ffe:	ce a5 6b 03                   	mov.b	875[r10], r5
ffc04002:	75 25 f0                      	and	#-16, r5
ffc04005:	cb a5 6b 03                   	mov.b	r5, 875[r10]
ffc04009:	38 a8 fd                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc0400c <.LBB335>:
            IPR(ICU, GROUPIE0) = (uint8_t)((ipl > IPR(ICU, GROUPIE0)) ? ipl : IPR(ICU, GROUPIE0));
ffc0400c:	ce 75 00 03                   	mov.b	768[r7], r5
ffc04010:	64 f5                         	and	#15, r5
ffc04012:	38 ee fe                      	bra.w	ffc03f00 <_Reset_Vector+0xffc03f04>

ffc04015 <.LBB284>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL1_TOP) && (vector < BSP_INT_SRC_GR_INT_BL2_TOP))
ffc04015:	71 15 ca                      	add	#-54, r1, r5
ffc04018:	75 55 15                      	cmp	#21, r5
ffc0401b:	25 05                         	bleu.b	ffc04020 <_Reset_Vector+0xffc04024>
ffc0401d:	38 94 00                      	bra.w	ffc040b1 <_Reset_Vector+0xffc040b5>

ffc04020 <.LBB239>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc04020:	66 72                         	mov.l	#7, r2

ffc04022 <.LVL112>:
ffc04022:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc04027 <.LVL113>:
ffc04027:	05 e5 01 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc0402b <.LVL114>:
            IR(ICU, GROUPBL1)  = 0;
ffc0402b:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffc04030 <.LVL115>:
ffc04030:	f1 78 6f                      	bclr	#0, 111[r7].b
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
ffc04033:	ce 75 6f 03                   	mov.b	879[r7], r5
ffc04037:	64 f5                         	and	#15, r5
ffc04039:	47 5a                         	cmp	r5, r10
ffc0403b:	24 05                         	bgtu.b	ffc04040 <_Reset_Vector+0xffc04044>
ffc0403d:	38 fa 00                      	bra.w	ffc04137 <_Reset_Vector+0xffc0413b>
ffc04040:	66 f4                         	mov.l	#15, r4
ffc04042:	53 a4                         	and	r10, r4
ffc04044:	76 10 01 00                   	nop	; mul	#1, r0
ffc04048:	fb 3e 00 70 08                	mov.l	#0x87000, r3
ffc0404d:	64 f4                         	and	#15, r4

ffc0404f <.LBB241>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc0404f:	66 72                         	mov.l	#7, r2

ffc04051 <.LBE241>:
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
ffc04051:	ce 35 6f 03                   	mov.b	879[r3], r5

ffc04055 <.LBB245>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc04055:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc0405a <.LBE245>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc0405a:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
ffc0405c:	fb a6 f0                      	mov.l	#-16, r10

ffc0405f <.LVL116>:
ffc0405f:	53 5a                         	and	r5, r10
ffc04061:	57 4a                         	or	r4, r10
ffc04063:	cb 3a 6f 03                   	mov.b	r10, 879[r3]

ffc04067 <.LBB246>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc04067:	05 a1 01 00                   	bsr.a	ffc04208 <_Reset_Vector+0xffc0420c>

ffc0406b <.LVL118>:
ffc0406b:	38 46 fd                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc0406e <.LBE246>:
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
ffc0406e:	ce 75 6a 03                   	mov.b	874[r7], r5
ffc04072:	64 f5                         	and	#15, r5
ffc04074:	38 a7 fd                      	bra.w	ffc03e1b <_Reset_Vector+0xffc03e1f>

ffc04077 <.LBB321>:
    else if ((vector > BSP_INT_SRC_GR_INT_AL0_TOP) && (vector < BSP_INT_SRC_GR_INT_AL1_TOP))
ffc04077:	71 1a ae                      	add	#-82, r1, r10
ffc0407a:	61 fa                         	cmp	#15, r10
ffc0407c:	25 05                         	bleu.b	ffc04081 <_Reset_Vector+0xffc04085>
ffc0407e:	38 88 00                      	bra.w	ffc04106 <_Reset_Vector+0xffc0410a>
            if (0 == ICU.GENAL0.LONG)
ffc04081:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffc04086:	ee a7 1c 02                   	mov.l	2160[r10], r7
ffc0408a:	61 07                         	cmp	#0, r7
ffc0408c:	3b 9a fe                      	bne.w	ffc03f26 <_Reset_Vector+0xffc03f2a>

ffc0408f <.LBB307>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc0408f:	66 02                         	mov.l	#0, r2

ffc04091 <.LVL122>:
ffc04091:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffc04096 <.LVL123>:
ffc04096:	05 76 01 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc0409a <.LVL124>:
                IPR(ICU, GROUPAL0) = 0;
ffc0409a:	ce a5 70 03                   	mov.b	880[r10], r5
ffc0409e:	75 25 f0                      	and	#-16, r5
ffc040a1:	cb a5 70 03                   	mov.b	r5, 880[r10]
ffc040a5:	38 0c fd                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc040a8 <.LBB285>:
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
ffc040a8:	ce 74 6e 03                   	mov.b	878[r7], r4
ffc040ac:	64 f4                         	and	#15, r4
ffc040ae:	38 02 ff                      	bra.w	ffc03fb0 <_Reset_Vector+0xffc03fb4>

ffc040b1 <.LVL126>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL2_TOP) && (vector < BSP_INT_SRC_GR_INT_AL0_TOP))
ffc040b1:	71 15 b3                      	add	#-77, r1, r5
ffc040b4:	61 35                         	cmp	#3, r5
ffc040b6:	25 05                         	bleu.b	ffc040bb <_Reset_Vector+0xffc040bf>
ffc040b8:	38 88 00                      	bra.w	ffc04140 <_Reset_Vector+0xffc04144>

ffc040bb <.LBB247>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc040bb:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc040c0 <.LVL128>:
ffc040c0:	05 4c 01 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc040c4 <.LVL129>:
            IR(ICU, GROUPBL2)  = 0;
ffc040c4:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffc040c9 <.LVL130>:
ffc040c9:	f1 78 6b                      	bclr	#0, 107[r7].b
            IPR(ICU, GROUPBL2) = (uint8_t)((ipl > IPR(ICU, GROUPBL2)) ? ipl : IPR(ICU, GROUPBL2));
ffc040cc:	ce 75 6b 03                   	mov.b	875[r7], r5
ffc040d0:	64 f5                         	and	#15, r5
ffc040d2:	47 5a                         	cmp	r5, r10
ffc040d4:	24 05                         	bgtu.b	ffc040d9 <_Reset_Vector+0xffc040dd>
ffc040d6:	38 bb 00                      	bra.w	ffc04191 <_Reset_Vector+0xffc04195>
ffc040d9:	66 f4                         	mov.l	#15, r4
ffc040db:	53 a4                         	and	r10, r4
ffc040dd:	fc 13 00                      	nop	; max	r0, r0
ffc040e0:	fb 3e 00 70 08                	mov.l	#0x87000, r3
ffc040e5:	64 f4                         	and	#15, r4

ffc040e7 <.LBB249>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc040e7:	66 32                         	mov.l	#3, r2

ffc040e9 <.LBE249>:
            IPR(ICU, GROUPBL2) = (uint8_t)((ipl > IPR(ICU, GROUPBL2)) ? ipl : IPR(ICU, GROUPBL2));
ffc040e9:	ce 35 6b 03                   	mov.b	875[r3], r5

ffc040ed <.LBB253>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc040ed:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffc040f2 <.LBE253>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc040f2:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBL2) = (uint8_t)((ipl > IPR(ICU, GROUPBL2)) ? ipl : IPR(ICU, GROUPBL2));
ffc040f4:	fb a6 f0                      	mov.l	#-16, r10

ffc040f7 <.LVL131>:
ffc040f7:	53 5a                         	and	r5, r10
ffc040f9:	57 4a                         	or	r4, r10
ffc040fb:	cb 3a 6b 03                   	mov.b	r10, 875[r3]

ffc040ff <.LBB254>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc040ff:	05 09 01 00                   	bsr.a	ffc04208 <_Reset_Vector+0xffc0420c>

ffc04103 <.LVL133>:
ffc04103:	38 ae fc                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc04106 <.LBB322>:
    else if ((vector > BSP_INT_SRC_GR_INT_AL1_TOP) && (vector < BSP_INT_SRC_GR_INT_END))
ffc04106:	71 77 9d                      	add	#-99, r7, r7
ffc04109:	61 47                         	cmp	#4, r7
ffc0410b:	25 05                         	bleu.b	ffc04110 <_Reset_Vector+0xffc04114>
ffc0410d:	38 a2 fc                      	bra.w	ffc03daf <_Reset_Vector+0xffc03db3>
            if (0 == ICU.GENAL1.LONG)
ffc04110:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffc04115:	ee a7 1d 02                   	mov.l	2164[r10], r7
ffc04119:	61 07                         	cmp	#0, r7
ffc0411b:	3b 0b fe                      	bne.w	ffc03f26 <_Reset_Vector+0xffc03f2a>

ffc0411e <.LBB309>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc0411e:	66 12                         	mov.l	#1, r2

ffc04120 <.LVL136>:
ffc04120:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffc04125 <.LVL137>:
ffc04125:	05 e7 00 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc04129 <.LVL138>:
                IPR(ICU, GROUPAL1) = 0;
ffc04129:	ce a5 71 03                   	mov.b	881[r10], r5
ffc0412d:	75 25 f0                      	and	#-16, r5
ffc04130:	cb a5 71 03                   	mov.b	r5, 881[r10]
ffc04134:	38 7d fc                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc04137 <.LBB286>:
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
ffc04137:	ce 74 6f 03                   	mov.b	879[r7], r4
ffc0413b:	64 f4                         	and	#15, r4
ffc0413d:	38 0b ff                      	bra.w	ffc04048 <_Reset_Vector+0xffc0404c>

ffc04140 <.LVL140>:
    else if ((vector > BSP_INT_SRC_GR_INT_AL0_TOP) && (vector < BSP_INT_SRC_GR_INT_AL1_TOP))
ffc04140:	71 15 ae                      	add	#-82, r1, r5
ffc04143:	61 f5                         	cmp	#15, r5
ffc04145:	24 5a                         	bgtu.b	ffc0419f <_Reset_Vector+0xffc041a3>

ffc04147 <.LBB255>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc04147:	66 02                         	mov.l	#0, r2

ffc04149 <.LVL142>:
ffc04149:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffc0414e <.LVL143>:
ffc0414e:	05 be 00 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc04152 <.LVL144>:
            IR(ICU, GROUPAL0)  = 0;
ffc04152:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffc04157 <.LVL145>:
ffc04157:	f1 78 70                      	bclr	#0, 112[r7].b
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
ffc0415a:	ce 75 70 03                   	mov.b	880[r7], r5
ffc0415e:	64 f5                         	and	#15, r5
ffc04160:	47 5a                         	cmp	r5, r10
ffc04162:	24 05                         	bgtu.b	ffc04167 <_Reset_Vector+0xffc0416b>
ffc04164:	38 8c 00                      	bra.w	ffc041f0 <_Reset_Vector+0xffc041f4>
ffc04167:	66 f5                         	mov.l	#15, r5
ffc04169:	53 a5                         	and	r10, r5
ffc0416b:	fb 4e 00 70 08                	mov.l	#0x87000, r4
ffc04170:	66 fa                         	mov.l	#15, r10

ffc04172 <.LVL146>:
ffc04172:	53 5a                         	and	r5, r10

ffc04174 <.LBB257>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc04174:	66 02                         	mov.l	#0, r2

ffc04176 <.LBE257>:
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
ffc04176:	ce 45 70 03                   	mov.b	880[r4], r5

ffc0417a <.LBB261>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc0417a:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffc0417f <.LBE261>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc0417f:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
ffc04181:	75 25 f0                      	and	#-16, r5
ffc04184:	57 5a                         	or	r5, r10
ffc04186:	cb 4a 70 03                   	mov.b	r10, 880[r4]

ffc0418a <.LBB262>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc0418a:	05 7e 00 00                   	bsr.a	ffc04208 <_Reset_Vector+0xffc0420c>

ffc0418e <.LVL148>:
ffc0418e:	38 23 fc                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc04191 <.LBE262>:
            IPR(ICU, GROUPBL2) = (uint8_t)((ipl > IPR(ICU, GROUPBL2)) ? ipl : IPR(ICU, GROUPBL2));
ffc04191:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffc04196:	ce 74 6b 03                   	mov.b	875[r7], r4
ffc0419a:	64 f4                         	and	#15, r4
ffc0419c:	38 44 ff                      	bra.w	ffc040e0 <_Reset_Vector+0xffc040e4>

ffc0419f <.LVL150>:
    else if ((vector > BSP_INT_SRC_GR_INT_AL1_TOP) && (vector < BSP_INT_SRC_GR_INT_END))
ffc0419f:	71 77 9d                      	add	#-99, r7, r7
ffc041a2:	61 47                         	cmp	#4, r7
ffc041a4:	25 05                         	bleu.b	ffc041a9 <_Reset_Vector+0xffc041ad>
ffc041a6:	38 09 fc                      	bra.w	ffc03daf <_Reset_Vector+0xffc03db3>

ffc041a9 <.LBB263>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffc041a9:	66 12                         	mov.l	#1, r2

ffc041ab <.LVL152>:
ffc041ab:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffc041b0 <.LVL153>:
ffc041b0:	05 5c 00 00                   	bsr.a	ffc0420c <_Reset_Vector+0xffc04210>

ffc041b4 <.LVL154>:
            IR(ICU, GROUPAL1)  = 0;
ffc041b4:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffc041b9 <.LVL155>:
ffc041b9:	f1 78 71                      	bclr	#0, 113[r7].b
            IPR(ICU, GROUPAL1) = (uint8_t)((ipl > IPR(ICU, GROUPAL1)) ? ipl : IPR(ICU, GROUPAL1));
ffc041bc:	ce 75 71 03                   	mov.b	881[r7], r5
ffc041c0:	64 f5                         	and	#15, r5
ffc041c2:	47 5a                         	cmp	r5, r10
ffc041c4:	25 35                         	bleu.b	ffc041f9 <_Reset_Vector+0xffc041fd>
ffc041c6:	66 f5                         	mov.l	#15, r5
ffc041c8:	53 a5                         	and	r10, r5
ffc041ca:	fb 4e 00 70 08                	mov.l	#0x87000, r4
ffc041cf:	66 fa                         	mov.l	#15, r10

ffc041d1 <.LVL156>:
ffc041d1:	53 5a                         	and	r5, r10

ffc041d3 <.LBB265>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc041d3:	66 12                         	mov.l	#1, r2

ffc041d5 <.LBE265>:
            IPR(ICU, GROUPAL1) = (uint8_t)((ipl > IPR(ICU, GROUPAL1)) ? ipl : IPR(ICU, GROUPAL1));
ffc041d5:	ce 45 71 03                   	mov.b	881[r4], r5

ffc041d9 <.LBB269>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc041d9:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffc041de <.LBE269>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffc041de:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPAL1) = (uint8_t)((ipl > IPR(ICU, GROUPAL1)) ? ipl : IPR(ICU, GROUPAL1));
ffc041e0:	75 25 f0                      	and	#-16, r5
ffc041e3:	57 5a                         	or	r5, r10
ffc041e5:	cb 4a 71 03                   	mov.b	r10, 881[r4]

ffc041e9 <.LBB270>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffc041e9:	05 1f 00 00                   	bsr.a	ffc04208 <_Reset_Vector+0xffc0420c>

ffc041ed <.LVL158>:
ffc041ed:	38 c4 fb                      	bra.w	ffc03db1 <_Reset_Vector+0xffc03db5>

ffc041f0 <.LBE270>:
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
ffc041f0:	ce 75 70 03                   	mov.b	880[r7], r5
ffc041f4:	64 f5                         	and	#15, r5
ffc041f6:	38 75 ff                      	bra.w	ffc0416b <_Reset_Vector+0xffc0416f>
            IPR(ICU, GROUPAL1) = (uint8_t)((ipl > IPR(ICU, GROUPAL1)) ? ipl : IPR(ICU, GROUPAL1));
ffc041f9:	ce 75 71 03                   	mov.b	881[r7], r5
ffc041fd:	64 f5                         	and	#15, r5
ffc041ff:	2e cb                         	bra.b	ffc041ca <_Reset_Vector+0xffc041ce>

ffc04201 <.LBE286>:
ffc04201:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc04208 <_R_BSP_BitSet>:
void R_BSP_BitSet(uint8_t *data, uint32_t bit)
{
    R_BSP_ASM_INTERNAL_USED(data)
    R_BSP_ASM_INTERNAL_USED(bit)

    R_BSP_ASM_BEGIN
ffc04208:	fc 60 12                      	bset	r2, [r1].b
ffc0420b:	02                            	rts

ffc0420c <_R_BSP_BitClear>:
void R_BSP_BitClear(uint8_t *data, uint32_t bit)
{
    R_BSP_ASM_INTERNAL_USED(data)
    R_BSP_ASM_INTERNAL_USED(bit)

    R_BSP_ASM_BEGIN
ffc0420c:	fc 64 12                      	bclr	r2, [r1].b
ffc0420f:	02                            	rts

ffc04210 <_R_BSP_SetDPSW>:
R_BSP_PRAGMA_INLINE_ASM(R_BSP_SetDPSW)
void R_BSP_SetDPSW(uint32_t data)
{
    R_BSP_ASM_INTERNAL_USED(data)

    R_BSP_ASM_BEGIN
ffc04210:	fd 77 81 04                   	mvtdc	r1, dpsw
ffc04214:	02                            	rts

ffc04215 <_PowerON_Reset_PC_Prg>:
#endif

#if defined(__CCRX__) || defined(__GNUC__)

    /* Initialize the Interrupt Table Register */
    R_BSP_SET_INTB(R_BSP_SECTOP_INTVECTTBL);
ffc04215:	fd 73 0c f0 62 c0 ff          	mvtc	#0xffc062f0, intb

#ifdef BSP_MCU_EXCEPTION_TABLE
    /* Initialize the Exception Table Register */
    R_BSP_SET_EXTB(R_BSP_SECTOP_EXCEPTVECTTBL);
ffc0421c:	fd 73 0d 80 ff ff ff          	mvtc	#-128, extb
#endif

#ifdef BSP_MCU_FLOATING_POINT
#ifdef __FPU
    /* Initialize the Floating-Point Status Word Register. */
    R_BSP_SET_FPSW(BSP_PRV_FPSW_INIT | BSP_PRV_FPU_ROUND | BSP_PRV_FPU_DENOM);
ffc04223:	fd 77 03 00                   	mvtc	#0, fpsw
#endif

#ifdef BSP_MCU_DOUBLE_PRECISION_FLOATING_POINT
#ifdef __DPFPU
    /* Initialize the Double-Precision Floating-Point Status Word Register. */
    R_BSP_SET_DPSW(BSP_PRV_DPSW_INIT | BSP_PRV_FPU_ROUND | BSP_PRV_FPU_DENOM);
ffc04227:	66 01                         	mov.l	#0, r1
ffc04229:	05 e7 ff ff                   	bsr.a	ffc04210 <_Reset_Vector+0xffc04214>

ffc0422d <.LVL0>:
#ifdef BSP_MCU_VBATT_INITIALIZE
    vbatt_voltage_stability_wait();
#endif

    /* Switch to high-speed operation */ 
    mcu_clock_setup();
ffc0422d:	05 c3 f1 ff                   	bsr.a	ffc033f0 <_Reset_Vector+0xffc033f4>

ffc04231 <.LVL1>:
#if BSP_CFG_USER_WARM_START_CALLBACK_PRE_INITC_ENABLED == 1
    BSP_CFG_USER_WARM_START_PRE_C_FUNCTION();
#endif

    /* Initialize C runtime environment */
    _INITSCT();
ffc04231:	05 e1 bd ff                   	bsr.a	ffc00012 <_Reset_Vector+0xffc00016>

ffc04235 <.LVL2>:
    /* Initialize C++ global class object */
    _CALL_INIT();
#endif

    /* Initialize RAM */
    bsp_ram_initialize();
ffc04235:	05 7e fa ff                   	bsr.a	ffc03cb3 <_Reset_Vector+0xffc03cb7>

ffc04239 <.LVL3>:
    init_iolib();
#endif /* defined(__CCRX__) */
#endif

    /* Initialize MCU interrupt callbacks. */
    bsp_interrupt_open();
ffc04239:	05 cf fa ff                   	bsr.a	ffc03d08 <_Reset_Vector+0xffc03d0c>

ffc0423d <.LVL4>:

    /* Initialize register protection functionality. */
    bsp_register_protect_open();
ffc0423d:	05 63 fa ff                   	bsr.a	ffc03ca0 <_Reset_Vector+0xffc03ca4>

ffc04241 <.LVL5>:

    /* Configure the MCU and board hardware */
    hardware_setup();
ffc04241:	05 1f 00 00                   	bsr.a	ffc04260 <_Reset_Vector+0xffc04264>

ffc04245 <.LVL6>:

    /* Enable interrupt and select the I stack or the U stack */
    R_BSP_SET_PSW(BSP_PRV_PSW_INIT);
ffc04245:	fd 7f 00 00 00 03             	mvtc	#0x30000, psw
    #endif
#endif /* BSP_CFG_RUN_IN_USER_MODE */
#endif /* BSP_CFG_RTOS_USED */

    /* Enable the bus error interrupt to catch accesses to illegal/reserved areas of memory */
    R_BSP_InterruptControl(BSP_INT_SRC_BUS_ERROR, BSP_INT_CMD_INTERRUPT_ENABLE, FIT_NO_PTR);
ffc0424b:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04251:	66 12                         	mov.l	#1, r2
ffc04253:	66 c1                         	mov.l	#12, r1
ffc04255:	05 f3 fa ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04259 <.LVL7>:

#if (BSP_CFG_RTOS_USED == 0) || (BSP_CFG_RTOS_USED == 5)    /* Non-OS or Azure RTOS */
    /* Call the main program function (should not return) */
    R_BSP_MAIN_FUNCTION();
ffc04259:	05 7f 04 00                   	bsr.a	ffc046d8 <_Reset_Vector+0xffc046dc>

ffc0425d <.LVL8>:
    /* Infinite loop is intended here. */
    /* WAIT_LOOP */
    while(1)
    {
        /* Infinite loop. Put a breakpoint here if you want to catch an exit of main(). */
        R_BSP_NOP();
ffc0425d:	03                            	nop
ffc0425e:	2e ff                         	bra.b	ffc0425d <_Reset_Vector+0xffc04261>

ffc04260 <_hardware_setup>:
{
/* When using the user startup program, disable the following code. */
#if BSP_CFG_STARTUP_DISABLE == 0
#if BSP_CFG_ROM_CACHE_ENABLE == 1
    /* Initialize ROM cache function */
    rom_cache_function_set();
ffc04260:	fb 52 f0 66 c0 ff             	mov.l	#0xffc066f0, r5
ffc04266:	ec 55                         	mov.l	[r5], r5
ffc04268:	61 15                         	cmp	#1, r5
ffc0426a:	20 0d                         	beq.b	ffc04277 <_Reset_Vector+0xffc0427b>

ffc0426c <.LBB14>:
#if BSP_CFG_NONCACHEABLE_AREA1_ENABLE == 1
    rom_cache_noncacheable_area1_set();
#endif /* BSP_CFG_NONCACHEABLE_AREA1_ENABLE == 1 */

    /* Invalidates the contents of the ROM cache. */
    FLASH.ROMCIV.WORD = 0x0001;
ffc0426c:	fb 5e 00 10 08                	mov.l	#0x81000, r5
ffc04271:	3d 52 01                      	mov.w	#1, 4[r5]

    /* Enables the ROM cache. */
    FLASH.ROMCE.WORD = 0x0001;
ffc04274:	f8 55 01                      	mov.w	#1, [r5]

ffc04277 <.LBB16>:
* Return value : none
***********************************************************************************************************************/
static void output_ports_configure(void)
{
    /* Add code here to setup additional output ports */
    R_BSP_NOP();
ffc04277:	03                            	nop

ffc04278 <.LBB18>:
* Return value : none
***********************************************************************************************************************/
static void interrupts_configure(void)
{
    /* Add code here to setup additional interrupts */
    R_BSP_NOP();
ffc04278:	03                            	nop

ffc04279 <.LBB20>:
static void peripheral_modules_enable(void)
{
    /* Add code here to enable peripherals used by the application */
#if BSP_CFG_CONFIGURATOR_SELECT == 1
    /* Smart Configurator initialization function */
    R_Systeminit();
ffc04279:	05 68 00 00                   	bsr.a	ffc042e1 <_Reset_Vector+0xffc042e5>

ffc0427d <.LVL0>:
    bsp_non_existent_port_init();
ffc0427d:	05 ab f3 ff                   	bsr.a	ffc03628 <_Reset_Vector+0xffc0362c>

ffc04281 <.LBB22>:
static void bsp_adc_initial_configure(void)
{
    uint32_t tmp_mstp;

    /* Protect off. */
    SYSTEM.PRCR.WORD = 0xA502;
ffc04281:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffc04286:	fa 49 ff 01 02 a5             	mov.w	#0xa502, 1022[r4]

    /* Store the value of the MSTPCR. */
    tmp_mstp = MSTP(S12AD1);
ffc0428c:	a9 45                         	mov.l	16[r4], r5

    /* Release from the module-stop state */
    MSTP(S12AD1) = 0;
ffc0428e:	a9 43                         	mov.l	16[r4], r3
    tmp_mstp = MSTP(S12AD1);
ffc04290:	69 05                         	shlr	#16, r5
    MSTP(S12AD1) = 0;
ffc04292:	7b 03                         	bclr	#16, r3
    tmp_mstp = MSTP(S12AD1);
ffc04294:	64 15                         	and	#1, r5

ffc04296 <.LVL2>:
    MSTP(S12AD1) = 0;
ffc04296:	a1 43                         	mov.l	r3, 16[r4]

    if(0 != MSTP(S12AD1))
ffc04298:	a9 44                         	mov.l	16[r4], r4
ffc0429a:	7d 04                         	btst	#16, r4
ffc0429c:	14                            	beq.s	ffc042a0 <_Reset_Vector+0xffc042a4>
    {
        R_BSP_NOP();
ffc0429d:	03                            	nop
ffc0429e:	ef 00                         	nop	; mov.l	r0, r0
    }

    /* Writing to the A/D conversion time setting register is enabled. */
    S12AD1.ADSAMPR.BYTE = 0x03;
ffc042a0:	fb 3e 00 91 08                	mov.l	#0x89100, r3

    /* Writing to the A/D conversion time setting register is disabled. */
    S12AD1.ADSAMPR.BYTE = 0x02;

    /* Restore the value of the MSTPCR. */
    MSTP(S12AD1) = tmp_mstp;
ffc042a5:	fb 4e 00 00 08                	mov.l	#0x80000, r4

ffc042aa <.LBB25>:
static void bsp_bsc_initial_configure(void)
{
    st_bsp_bsc_t bsp_bsc;

    /* Setting priority when bus right request contention occurs. */
    bsp_bsc.ebmapcr.u_long     = BSC.EBMAPCR.LONG;
ffc042aa:	fb 2e 00 58 0c                	mov.l	#0xc5800, r2

ffc042af <.LBB28>:
    S12AD1.ADSAMPR.BYTE = 0x03;
ffc042af:	f9 34 63 03                   	mov.b	#3, 99[r3]
    S12AD1.ADSAM.WORD = 0x0020;
ffc042b3:	f9 35 37 20                   	mov.w	#32, 110[r3]
    S12AD1.ADSAMPR.BYTE = 0x02;
ffc042b7:	f9 34 63 02                   	mov.b	#2, 99[r3]
    MSTP(S12AD1) = tmp_mstp;
ffc042bb:	a9 43                         	mov.l	16[r4], r3
ffc042bd:	7c 05                         	btst	#0, r5
ffc042bf:	fd f0 13                      	bmne	#16, r3
ffc042c2:	a1 43                         	mov.l	r3, 16[r4]
    SYSTEM.PRCR.WORD = 0xA500;
ffc042c4:	fa 49 ff 01 00 a5             	mov.w	#0xa500, 1022[r4]

ffc042ca <.LBB29>:
    bsp_bsc.ebmapcr.u_long     = BSC.EBMAPCR.LONG;
ffc042ca:	ec 25                         	mov.l	[r2], r5

ffc042cc <.LVL3>:
    bsp_bsc.ebmapcr.bit.pr1sel = BSP_CFG_EBMAPCR_1ST_PRIORITY;
ffc042cc:	77 25 88 88 f8                	and	#0xfff88888, r5
ffc042d1:	77 35 30 21 04                	or	#0x42130, r5
    bsp_bsc.ebmapcr.bit.pr3sel = BSP_CFG_EBMAPCR_3RD_PRIORITY;
    bsp_bsc.ebmapcr.bit.pr4sel = BSP_CFG_EBMAPCR_4TH_PRIORITY;
    bsp_bsc.ebmapcr.bit.pr5sel = BSP_CFG_EBMAPCR_5TH_PRIORITY;

    /* Set to EBMAPCR register */
    BSC.EBMAPCR.LONG = bsp_bsc.ebmapcr.u_long;
ffc042d6:	e3 25                         	mov.l	r5, [r2]

ffc042d8 <.LBE29>:
} /* End of function hardware_setup() */
ffc042d8:	02                            	rts

ffc042d9 <.LFE3>:
ffc042d9:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc042e0 <_r_undefined_exception>:

void r_undefined_exception(void)
{
    /* Start user code for r_undefined_exception. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffc042e0:	02                            	rts

ffc042e1 <_R_Systeminit>:
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void R_Systeminit(void)
{
ffc042e1:	6e 7a                         	pushm	r7-r10
    /* Enable writing to registers related to operating modes, LPC, CGC and software reset */
    SYSTEM.PRCR.WORD = 0xA50BU;
ffc042e3:	fb ae 00 00 08                	mov.l	#0x80000, r10

    /* Enable writing to MPC pin function control registers */
    MPC.PWPR.BIT.B0WI = 0U;
ffc042e8:	fb 7e 00 c1 08                	mov.l	#0x8c100, r7
    SYSTEM.PRCR.WORD = 0xA50BU;
ffc042ed:	fa a9 ff 01 0b a5             	mov.w	#0xa50b, 1022[r10]
    MPC.PWPR.BIT.B0WI = 0U;
ffc042f3:	8f fd                         	mov.b	31[r7], r5
ffc042f5:	7a 75                         	bclr	#7, r5
ffc042f7:	87 fd                         	mov.b	r5, 31[r7]
    MPC.PWPR.BIT.PFSWE = 1U;
ffc042f9:	f1 76 1f                      	bset	#6, 31[r7].b

    /* Write 0 to the target bits in the POECR2 registers */
    POE3.POECR2.WORD = 0x0000U;
ffc042fc:	fb 5e c0 c4 08                	mov.l	#0x8c4c0, r5
ffc04301:	3d 56 00                      	mov.w	#0, 12[r5]

    /* Initialize clocks settings */
    R_CGC_Create();
ffc04304:	05 59 00 00                   	bsr.a	ffc0435d <_Reset_Vector+0xffc04361>

ffc04308 <.LVL0>:

    /* Set peripheral settings */
    R_Config_SCI0_Create();
ffc04308:	05 96 00 00                   	bsr.a	ffc0439e <_Reset_Vector+0xffc043a2>

ffc0430c <.LVL1>:
    R_Config_RIIC0_Create();
ffc0430c:	05 19 01 00                   	bsr.a	ffc04425 <_Reset_Vector+0xffc04429>

ffc04310 <.LVL2>:
    R_Config_MTU3_MTU4_Create();
ffc04310:	05 99 01 00                   	bsr.a	ffc044a9 <_Reset_Vector+0xffc044ad>

ffc04314 <.LVL3>:

    /* Set interrupt settings */
    R_Interrupt_Create();
ffc04314:	05 4e 00 00                   	bsr.a	ffc04362 <_Reset_Vector+0xffc04366>

ffc04318 <.LVL4>:

    /* Register undefined interrupt */
    R_BSP_InterruptWrite(BSP_INT_SRC_UNDEFINED_INTERRUPT,(bsp_int_cb_t)r_undefined_exception);
ffc04318:	fb 22 e0 42 c0 ff             	mov.l	#0xffc042e0, r2
ffc0431e:	66 b1                         	mov.l	#11, r1
ffc04320:	05 08 fa ff                   	bsr.a	ffc03d28 <_Reset_Vector+0xffc03d2c>

ffc04324 <.LVL5>:

    /* Register group BL0 interrupt TEI0 (SCI0) */
    R_BSP_InterruptWrite(BSP_INT_SRC_BL0_SCI0_TEI0,(bsp_int_cb_t)r_Config_SCI0_transmitend_interrupt);
ffc04324:	fb 22 f8 06 c0 ff             	mov.l	#0xffc006f8, r2
ffc0432a:	75 41 1a                      	mov.l	#26, r1
ffc0432d:	05 fb f9 ff                   	bsr.a	ffc03d28 <_Reset_Vector+0xffc03d2c>

ffc04331 <.LVL6>:

    /* Register group BL1 interrupt TEI0 (RIIC0) */
    R_BSP_InterruptWrite(BSP_INT_SRC_BL1_RIIC0_TEI0,(bsp_int_cb_t)r_Config_RIIC0_transmitend_interrupt);
ffc04331:	fb 22 48 07 c0 ff             	mov.l	#0xffc00748, r2
ffc04337:	75 41 40                      	mov.l	#64, r1
ffc0433a:	05 ee f9 ff                   	bsr.a	ffc03d28 <_Reset_Vector+0xffc03d2c>

ffc0433e <.LVL7>:

    /* Register group BL1 interrupt EEI0 (RIIC0) */
    R_BSP_InterruptWrite(BSP_INT_SRC_BL1_RIIC0_EEI0,(bsp_int_cb_t)r_Config_RIIC0_error_interrupt);
ffc0433e:	fb 22 88 07 c0 ff             	mov.l	#0xffc00788, r2
ffc04344:	75 41 41                      	mov.l	#65, r1
ffc04347:	05 e1 f9 ff                   	bsr.a	ffc03d28 <_Reset_Vector+0xffc03d2c>

ffc0434b <.LVL8>:

    /* Disable writing to MPC pin function control registers */
    MPC.PWPR.BIT.PFSWE = 0U;
ffc0434b:	f1 7e 1f                      	bclr	#6, 31[r7].b
    MPC.PWPR.BIT.B0WI = 1U;
ffc0434e:	8f fd                         	mov.b	31[r7], r5
ffc04350:	78 75                         	bset	#7, r5
ffc04352:	87 fd                         	mov.b	r5, 31[r7]

    /* Enable protection */
    SYSTEM.PRCR.WORD = 0xA500U;
ffc04354:	fa a9 ff 01 00 a5             	mov.w	#0xa500, 1022[r10]
}
ffc0435a:	3f 7a 04                      	rtsd	#16, r7-r10

ffc0435d <_R_CGC_Create>:
* Return Value : None
***********************************************************************************************************************/

void R_CGC_Create(void)
{
    R_CGC_Create_UserInit();
ffc0435d:	04 04 00 00                   	bra.a	ffc04361 <_Reset_Vector+0xffc04365>

ffc04361 <_R_CGC_Create_UserInit>:

void R_CGC_Create_UserInit(void)
{
    /* Start user code for user init. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffc04361:	02                            	rts

ffc04362 <_R_Interrupt_Create>:
***********************************************************************************************************************/

void R_Interrupt_Create(void)
{
    /* Disable group BL0 interrupt*/
    IEN(ICU,GROUPBL0) = 0U;
ffc04362:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04367:	f2 5e 0d 02                   	bclr	#6, 525[r5].b
    
    /* Disable group BL1 interrupt*/
    IEN(ICU,GROUPBL1) = 0U;
ffc0436b:	ce 54 0d 02                   	mov.b	525[r5], r4
ffc0436f:	7a 74                         	bclr	#7, r4
ffc04371:	cb 54 0d 02                   	mov.b	r4, 525[r5]
    

    /* Set group BL0 interrupt priority level */
    IPR(ICU,GROUPBL0) = _02_ICU_PRIORITY_LEVEL2;
ffc04375:	ce 54 6e 03                   	mov.b	878[r5], r4
ffc04379:	75 24 f0                      	and	#-16, r4
ffc0437c:	78 14                         	bset	#1, r4
ffc0437e:	cb 54 6e 03                   	mov.b	r4, 878[r5]

    /* Set group BL1 interrupt priority level */
    IPR(ICU,GROUPBL1) = _03_ICU_PRIORITY_LEVEL3;
ffc04382:	ce 54 6f 03                   	mov.b	879[r5], r4
ffc04386:	75 24 f0                      	and	#-16, r4
ffc04389:	65 34                         	or	#3, r4
ffc0438b:	cb 54 6f 03                   	mov.b	r4, 879[r5]

    /* Enable group BL0 interrupt */
    IEN(ICU,GROUPBL0) = 1U;
ffc0438f:	f2 56 0d 02                   	bset	#6, 525[r5].b

    /* Enable group BL1 interrupt */
    IEN(ICU,GROUPBL1) = 1U;
ffc04393:	ce 54 0d 02                   	mov.b	525[r5], r4
ffc04397:	78 74                         	bset	#7, r4
ffc04399:	cb 54 0d 02                   	mov.b	r4, 525[r5]
}
ffc0439d:	02                            	rts

ffc0439e <_R_Config_SCI0_Create>:
***********************************************************************************************************************/

void R_Config_SCI0_Create(void)
{
    /* Cancel SCI stop state */
    MSTP(SCI0) = 0U;
ffc0439e:	fb 3e 00 00 08                	mov.l	#0x80000, r3

    /* Set interrupt priority */
    IPR(SCI0, RXI0) = _02_SCI_PRIORITY_LEVEL2;
ffc043a3:	fb 2e 00 70 08                	mov.l	#0x87000, r2
    MSTP(SCI0) = 0U;
ffc043a8:	ed 3e 05                      	mov.l	20[r3], r14
    IPR(SCI0, TXI0) = _02_SCI_PRIORITY_LEVEL2;

    /* Clear the control register */
    SCI0.SCR.BYTE = 0x00U;
ffc043ab:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
    SCI0.SPMR.BYTE = _00_SCI_CLOCK_NOT_INVERTED | _00_SCI_CLOCK_NOT_DELAYED;
    SCI0.SCR.BYTE = _10_SCI_RECEIVE_ENABLE | _20_SCI_TRANSMIT_ENABLE | _40_SCI_RXI_ERI_ENABLE | _80_SCI_TXI_ENABLE | 
                    _04_SCI_TEI_INTERRUPT_ENABLE;

    /* Set SSCL0 pin */
    MPC.P33PFS.BYTE = 0x0BU;
ffc043b0:	fb 1e 00 c1 08                	mov.l	#0x8c100, r1
    PORT3.ODR0.BYTE |= 0x40U;
ffc043b5:	fb 4e 03 c0 08                	mov.l	#0x8c003, r4
    MSTP(SCI0) = 0U;
ffc043ba:	7b fe                         	bclr	#31, r14
ffc043bc:	e7 3e 05                      	mov.l	r14, 20[r3]
    IPR(SCI0, RXI0) = _02_SCI_PRIORITY_LEVEL2;
ffc043bf:	ce 23 3a 03                   	mov.b	826[r2], r3
ffc043c3:	75 23 f0                      	and	#-16, r3
ffc043c6:	78 13                         	bset	#1, r3
ffc043c8:	cb 23 3a 03                   	mov.b	r3, 826[r2]
    IPR(SCI0, TXI0) = _02_SCI_PRIORITY_LEVEL2;
ffc043cc:	ce 23 3b 03                   	mov.b	827[r2], r3
ffc043d0:	75 23 f0                      	and	#-16, r3
ffc043d3:	78 13                         	bset	#1, r3
ffc043d5:	cb 23 3b 03                   	mov.b	r3, 827[r2]
    SCI0.SCR.BYTE = 0x00U;
ffc043d9:	3c 52 00                      	mov.b	#0, 2[r5]
    SCI0.SIMR3.BYTE = _C0_SCI_SSCL_HIGH_IMPEDANCE | _30_SCI_SSDA_HIGH_IMPEDANCE;
ffc043dc:	f9 54 0b f0                   	mov.b	#240, 11[r5]
    SCI0.SMR.BYTE = _00_SCI_CLOCK_PCLK | _00_SCI_ASYNCHRONOUS_OR_I2C_MODE;
ffc043e0:	f8 54 00                      	mov.b	#0, [r5]
    SCI0.SCMR.BIT.SMIF = 0U;
ffc043e3:	f1 58 06                      	bclr	#0, 6[r5].b
    SCI0.SCMR.BIT.SINV = 0U;
ffc043e6:	f1 5a 06                      	bclr	#2, 6[r5].b
    SCI0.SCMR.BIT.SDIR = 1U;
ffc043e9:	f1 53 06                      	bset	#3, 6[r5].b
    SCI0.BRR = 0x12U;
ffc043ec:	3c 51 12                      	mov.b	#18, 1[r5]
    SCI0.SEMR.BYTE = _00_SCI_NOISE_FILTER_DISABLE | _00_SCI_BIT_MODULATION_DISABLE;
ffc043ef:	3c 57 00                      	mov.b	#0, 7[r5]
    SCI0.SIMR1.BYTE |= (_01_SCI_IIC_MODE | _00_SCI_NONE);
ffc043f2:	f1 50 09                      	bset	#0, 9[r5].b
    SCI0.SIMR2.BYTE |= (_00_SCI_ACK_NACK_INTERRUPTS | _02_SCI_SYNCHRONIZATION | _20_SCI_NACK_TRANSMISSION);
ffc043f5:	8a d3                         	mov.b	10[r5], r3
ffc043f7:	75 33 22                      	or	#34, r3
ffc043fa:	82 d3                         	mov.b	r3, 10[r5]
    SCI0.SPMR.BYTE = _00_SCI_CLOCK_NOT_INVERTED | _00_SCI_CLOCK_NOT_DELAYED;
ffc043fc:	3c 5d 00                      	mov.b	#0, 13[r5]
    SCI0.SCR.BYTE = _10_SCI_RECEIVE_ENABLE | _20_SCI_TRANSMIT_ENABLE | _40_SCI_RXI_ERI_ENABLE | _80_SCI_TXI_ENABLE | 
ffc043ff:	f9 54 02 f4                   	mov.b	#244, 2[r5]
    MPC.P33PFS.BYTE = 0x0BU;
ffc04403:	f9 14 5b 0b                   	mov.b	#11, 91[r1]
    PORT3.ODR0.BYTE |= 0x40U;
ffc04407:	f1 46 83                      	bset	#6, 131[r4].b
    PORT3.PMR.BYTE |= 0x08U;
ffc0440a:	f1 43 60                      	bset	#3, 96[r4].b

    /* Set SSDA0 pin */
    MPC.P32PFS.BYTE = 0x0BU;
ffc0440d:	f9 14 5a 0b                   	mov.b	#11, 90[r1]
    PORT3.ODR0.BYTE |= 0x10U;
ffc04411:	f1 44 83                      	bset	#4, 131[r4].b
    PORT3.PMR.BYTE |= 0x04U;
ffc04414:	f1 42 60                      	bset	#2, 96[r4].b

    R_Config_SCI0_Create_UserInit();
ffc04417:	04 0d 00 00                   	bra.a	ffc04424 <_Reset_Vector+0xffc04428>

ffc0441b <_R_Config_SCI0_IIC_StopCondition>:
* Return Value : None
***********************************************************************************************************************/

void R_Config_SCI0_IIC_StopCondition(void)
{
    SCI0.SIMR3.BYTE = _04_SCI_STOP_CONDITION_ON | _10_SCI_SSDA_START_RESTART_STOP_CONDITION | 
ffc0441b:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffc04420:	3c 5b 54                      	mov.b	#84, 11[r5]
                      _40_SCI_SSCL_START_RESTART_STOP_CONDITION;
}
ffc04423:	02                            	rts

ffc04424 <_R_Config_SCI0_Create_UserInit>:
}
ffc04424:	02                            	rts

ffc04425 <_R_Config_RIIC0_Create>:
***********************************************************************************************************************/

void R_Config_RIIC0_Create(void)
{
    /* Cancel RIIC stop state */
    MSTP(RIIC0) = 0U;
ffc04425:	fb 2e 00 00 08                	mov.l	#0x80000, r2
    RIIC0.ICCR1.BIT.ICE = 0U;
ffc0442a:	fb 5e 00 83 08                	mov.l	#0x88300, r5
    MSTP(RIIC0) = 0U;
ffc0442f:	ed 2e 05                      	mov.l	20[r2], r14

    /* Cancel internal reset */
    RIIC0.ICCR1.BIT.IICRST = 0U;

    /* Set interrupt priority */
    IPR(RIIC0, RXI0) = _02_IIC_PRIORITY_LEVEL2;
ffc04432:	fb 3e 00 70 08                	mov.l	#0x87000, r3
    IPR(RIIC0, TXI0) = _02_IIC_PRIORITY_LEVEL2;

    /* Set SCL0 pin */
    MPC.P12PFS.BYTE = 0x0FU;
ffc04437:	fb 1e 00 c1 08                	mov.l	#0x8c100, r1
    PORT1.PMR.BYTE |= 0x04U;
ffc0443c:	fb 4e 01 c0 08                	mov.l	#0x8c001, r4
    MSTP(RIIC0) = 0U;
ffc04441:	7b 5e                         	bclr	#21, r14
ffc04443:	e7 2e 05                      	mov.l	r14, 20[r2]
    RIIC0.ICCR1.BIT.ICE = 0U;
ffc04446:	cc 52                         	mov.b	[r5], r2
ffc04448:	7a 72                         	bclr	#7, r2
ffc0444a:	c3 52                         	mov.b	r2, [r5]
    RIIC0.ICCR1.BIT.IICRST = 1U;
ffc0444c:	f0 56                         	bset	#6, [r5].b
    RIIC0.ICCR1.BIT.ICE = 1U;
ffc0444e:	cc 52                         	mov.b	[r5], r2
ffc04450:	78 72                         	bset	#7, r2
ffc04452:	c3 52                         	mov.b	r2, [r5]
    RIIC0.ICMR1.BYTE |= _70_IIC_PCLK_DIV_128;
ffc04454:	88 d2                         	mov.b	2[r5], r2
ffc04456:	75 32 70                      	or	#112, r2
ffc04459:	80 d2                         	mov.b	r2, 2[r5]
    RIIC0.ICBRL.BYTE = _F6_IIC0_SCL_LOW_LEVEL_PERIOD;
ffc0445b:	f9 54 10 f6                   	mov.b	#246, 16[r5]
    RIIC0.ICBRH.BYTE = _F6_IIC0_SCL_HIGH_LEVEL_PERIOD;
ffc0445f:	f9 54 11 f6                   	mov.b	#246, 17[r5]
    RIIC0.ICMR2.BYTE = 0x00U;
ffc04463:	3c 53 00                      	mov.b	#0, 3[r5]
    RIIC0.ICMR3.BIT.NF = _00_IIC_NOISE_FILTER_1;
ffc04466:	89 52                         	mov.b	4[r5], r2
ffc04468:	75 22 fc                      	and	#-4, r2
ffc0446b:	81 52                         	mov.b	r2, 4[r5]
    RIIC0.ICMR3.BIT.SMBS = 0U;
ffc0446d:	89 52                         	mov.b	4[r5], r2
ffc0446f:	7a 72                         	bclr	#7, r2
ffc04471:	81 52                         	mov.b	r2, 4[r5]
    RIIC0.ICFER.BYTE = _00_IIC_TIMEOUT_FUNCTION_DISABLE | _02_IIC_MASTER_ARBITRATION_ENABLE | 
ffc04473:	3c 55 72                      	mov.b	#114, 5[r5]
    RIIC0.ICIER.BYTE = _02_IIC_ARBITRATION_LOST_INTERRUPT_ENABLE | _04_IIC_START_CONDITION_INTERRUPT_ENABLE | 
ffc04476:	f9 54 07 fe                   	mov.b	#254, 7[r5]
    RIIC0.ICCR1.BIT.IICRST = 0U;
ffc0447a:	f0 5e                         	bclr	#6, [r5].b
    IPR(RIIC0, RXI0) = _02_IIC_PRIORITY_LEVEL2;
ffc0447c:	ce 35 34 03                   	mov.b	820[r3], r5
ffc04480:	75 25 f0                      	and	#-16, r5
ffc04483:	78 15                         	bset	#1, r5
ffc04485:	cb 35 34 03                   	mov.b	r5, 820[r3]
    IPR(RIIC0, TXI0) = _02_IIC_PRIORITY_LEVEL2;
ffc04489:	ce 35 35 03                   	mov.b	821[r3], r5
ffc0448d:	75 25 f0                      	and	#-16, r5
ffc04490:	78 15                         	bset	#1, r5
ffc04492:	cb 35 35 03                   	mov.b	r5, 821[r3]
    MPC.P12PFS.BYTE = 0x0FU;
ffc04496:	f9 14 4a 0f                   	mov.b	#15, 74[r1]
    PORT1.PMR.BYTE |= 0x04U;
ffc0449a:	f1 42 60                      	bset	#2, 96[r4].b

    /* Set SDA0 pin */
    MPC.P13PFS.BYTE = 0x0FU;
ffc0449d:	f9 14 4b 0f                   	mov.b	#15, 75[r1]
    PORT1.PMR.BYTE |= 0x08U;
ffc044a1:	f1 43 60                      	bset	#3, 96[r4].b

    R_Config_RIIC0_Create_UserInit();
ffc044a4:	04 04 00 00                   	bra.a	ffc044a8 <_Reset_Vector+0xffc044ac>

ffc044a8 <_R_Config_RIIC0_Create_UserInit>:
}
ffc044a8:	02                            	rts

ffc044a9 <_R_Config_MTU3_MTU4_Create>:
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void R_Config_MTU3_MTU4_Create(void)
{
ffc044a9:	7e a7                         	push.l	r7
    /* Release MTU channel 3 from stop state */
    MSTP(MTU3) = 0U;
ffc044ab:	fb ee 00 00 08                	mov.l	#0x80000, r14

    /* Enable read/write to MTU3, MTU4 registers */
    MTU.TRWERA.BIT.RWE = 1U;
ffc044b0:	fb 5e 0a 12 0c                	mov.l	#0xc120a, r5
    MSTP(MTU3) = 0U;
ffc044b5:	ed ef 04                      	mov.l	16[r14], r15
    /* Stop MTU channel 3 counter */
    MTU.TSTRA.BIT.CST3 = 0U;
    MTU.TSTRA.BIT.CST4 = 0U;

    /* Set TGIA3 interrupt priority level */
    ICU.SLIAR223.BYTE = 0x10U;
ffc044b8:	fb 3e 00 70 08                	mov.l	#0x87000, r3
    /* Set TCIV4 interrupt priority level */
    ICU.SLIAR232.BYTE = 0x19U;
    IPR(PERIA, INTA232) = _0F_MTU_PRIORITY_LEVEL15;

    /* MTU channel 3 is used as complementary PWM mode 1 */
    MTU3.TIER.BYTE = 0x00U;
ffc044bd:	fb 4e 00 12 0c                	mov.l	#0xc1200, r4

    /* Disable read/write to MTU3, MTU4 registers */
    MTU.TRWERA.BIT.RWE = 0U;

    /* Set MTIOC3B pin */
    MPC.P22PFS.BYTE = 0x01U;
ffc044c2:	fb 1e 00 c1 08                	mov.l	#0x8c100, r1
    MSTP(MTU3) = 0U;
ffc044c7:	7a 9f                         	bclr	#9, r15
    PORT2.PMR.BYTE |= 0x04U;
ffc044c9:	fb 2e 02 c0 08                	mov.l	#0x8c002, r2
    MPC.P24PFS.BYTE = 0x01U;
    PORT2.PMR.BYTE |= 0x10U;

    /* Set MTIOC4B pin */
    MPC.P17PFS.BYTE = 0x08U;
    PORT1.PMR.BYTE |= 0x80U;
ffc044ce:	fb 7e 01 c0 08                	mov.l	#0x8c001, r7
    MSTP(MTU3) = 0U;
ffc044d3:	e7 ef 04                      	mov.l	r15, 16[r14]
    MTU.TRWERA.BIT.RWE = 1U;
ffc044d6:	f1 50 7a                      	bset	#0, 122[r5].b
    MTU.TSTRA.BIT.CST3 = 0U;
ffc044d9:	f1 5e 76                      	bclr	#6, 118[r5].b
    MTU.TSTRA.BIT.CST4 = 0U;
ffc044dc:	cd 5e 76                      	mov.b	118[r5], r14
    MPC.P25PFS.BYTE = 0x01U;
    PORT2.PMR.BYTE |= 0x20U;

    /* Set MTIOC4D pin */
    MPC.P31PFS.BYTE = 0x01U;
    PORT3.PMR.BYTE |= 0x02U;
ffc044df:	fb fe 03 c0 08                	mov.l	#0x8c003, r15
    MTU.TSTRA.BIT.CST4 = 0U;
ffc044e4:	7a 7e                         	bclr	#7, r14
ffc044e6:	c7 5e 76                      	mov.b	r14, 118[r5]
    ICU.SLIAR223.BYTE = 0x10U;
ffc044e9:	fa 34 df 09 10                	mov.b	#16, 2527[r3]
    IPR(PERIA, INTA223) = _0F_MTU_PRIORITY_LEVEL15;
ffc044ee:	ce 3e df 03                   	mov.b	991[r3], r14
ffc044f2:	65 fe                         	or	#15, r14
ffc044f4:	cb 3e df 03                   	mov.b	r14, 991[r3]
    ICU.SLIAR224.BYTE = 0x11U;
ffc044f8:	fa 34 e0 09 11                	mov.b	#17, 2528[r3]
    IPR(PERIA, INTA224) = _0F_MTU_PRIORITY_LEVEL15;
ffc044fd:	ce 3e e0 03                   	mov.b	992[r3], r14
ffc04501:	65 fe                         	or	#15, r14
ffc04503:	cb 3e e0 03                   	mov.b	r14, 992[r3]
    ICU.SLIAR228.BYTE = 0x15U;
ffc04507:	fa 34 e4 09 15                	mov.b	#21, 2532[r3]
    IPR(PERIA, INTA228) = _0F_MTU_PRIORITY_LEVEL15;
ffc0450c:	ce 3e e4 03                   	mov.b	996[r3], r14
ffc04510:	65 fe                         	or	#15, r14
ffc04512:	cb 3e e4 03                   	mov.b	r14, 996[r3]
    ICU.SLIAR229.BYTE = 0x16U;
ffc04516:	fa 34 e5 09 16                	mov.b	#22, 2533[r3]
    IPR(PERIA, INTA229) = _0F_MTU_PRIORITY_LEVEL15;
ffc0451b:	ce 3e e5 03                   	mov.b	997[r3], r14
ffc0451f:	65 fe                         	or	#15, r14
ffc04521:	cb 3e e5 03                   	mov.b	r14, 997[r3]
    ICU.SLIAR232.BYTE = 0x19U;
ffc04525:	fa 34 e8 09 19                	mov.b	#25, 2536[r3]
    IPR(PERIA, INTA232) = _0F_MTU_PRIORITY_LEVEL15;
ffc0452a:	ce 3e e8 03                   	mov.b	1000[r3], r14
ffc0452e:	65 fe                         	or	#15, r14
ffc04530:	cb 3e e8 03                   	mov.b	r14, 1000[r3]
    MTU3.TIER.BYTE = 0x00U;
ffc04534:	3c 48 00                      	mov.b	#0, 8[r4]
    MTU4.TIER.BYTE = 0x00U;
ffc04537:	3c 49 00                      	mov.b	#0, 9[r4]
    MTU.TITCR1A.BIT.T3AEN = 0U;
ffc0453a:	cd 53 26                      	mov.b	38[r5], r3
ffc0453d:	7a 73                         	bclr	#7, r3
ffc0453f:	c7 53 26                      	mov.b	r3, 38[r5]
    MTU.TITCR1A.BIT.T4VEN = 0U;
ffc04542:	f1 5b 26                      	bclr	#3, 38[r5].b
    MTU3.TCR.BYTE = _00_MTU_PCLK_1 | _00_MTU_CKCL_DIS;
ffc04545:	f8 44 00                      	mov.b	#0, [r4]
    MTU4.TCR.BYTE = _00_MTU_PCLK_1;
ffc04548:	3c 41 00                      	mov.b	#0, 1[r4]
    MTU3.TCR2.BYTE = _00_MTU_PCLK_1;
ffc0454b:	f9 44 4c 00                   	mov.b	#0, 76[r4]
    MTU4.TCR2.BYTE = _00_MTU_PCLK_1;
ffc0454f:	f9 44 4d 00                   	mov.b	#0, 77[r4]
    MTU.TGCRA.BYTE = _80_MTU_BDC_OUT;
ffc04553:	f9 54 03 80                   	mov.b	#128, 3[r5]
    MTU3.TCNT = _04B0_3TCNT_VALUE;
ffc04557:	f9 49 08 b0 04                	mov.w	#0x4b0, 16[r4]
    MTU4.TCNT = 0x0000U;
ffc0455c:	3d 49 00                      	mov.w	#0, 18[r4]
    MTU.TSYRA.BIT.SYNC3 = 0U;
ffc0455f:	f1 5e 77                      	bclr	#6, 119[r5].b
    MTU.TSYRA.BIT.SYNC4 = 0U;
ffc04562:	cd 53 77                      	mov.b	119[r5], r3
ffc04565:	7a 73                         	bclr	#7, r3
ffc04567:	c7 53 77                      	mov.b	r3, 119[r5]
    MTU3.TGRB = _0064_3TGRB_VALUE;
ffc0456a:	3d 4d 64                      	mov.w	#100, 26[r4]
    MTU3.TGRD = _0064_3TGRB_VALUE;
ffc0456d:	3d c3 64                      	mov.w	#100, 38[r4]
    MTU4.TGRA = _0064_4TGRA_VALUE;
ffc04570:	3d 4e 64                      	mov.w	#100, 28[r4]
    MTU4.TGRC = _0064_4TGRA_VALUE;
ffc04573:	3d c4 64                      	mov.w	#100, 40[r4]
    MTU4.TGRB = _0064_4TGRB_VALUE;
ffc04576:	3d 4f 64                      	mov.w	#100, 30[r4]
    MTU4.TGRD = _0064_4TGRB_VALUE;
ffc04579:	3d c5 64                      	mov.w	#100, 42[r4]
    MTU.TDERA.BIT.TDER = 1U;
ffc0457c:	f1 50 2a                      	bset	#0, 42[r5].b
    MTU.TDDRA = _04B0_TDDRA_VALUE;
ffc0457f:	f9 59 06 b0 04                	mov.w	#0x4b0, 12[r5]
    MTU.TCDRA = _1770_TCDRA_VALUE;
ffc04584:	f9 59 05 70 17                	mov.w	#0x1770, 10[r5]
    MTU.TCBRA = _1770_TCDRA_VALUE;
ffc04589:	f9 59 0c 70 17                	mov.w	#0x1770, 24[r5]
    MTU3.TGRA = _1C20_SUM_VALUE;
ffc0458e:	f9 49 0c 20 1c                	mov.w	#0x1c20, 24[r4]
    MTU3.TGRC = _1C20_SUM_VALUE;
ffc04593:	f9 49 12 20 1c                	mov.w	#0x1c20, 36[r4]
    MTU.TOCR1A.BYTE = _00_MTU_PSYE_DISABLE | _08_MTU_TOCL_DISABLE | _04_MTU_TOCS_TOCR2;
ffc04598:	3c 54 0c                      	mov.b	#12, 4[r5]
    MTU.TOCR2A.BYTE = _00_MTU_TOLBR_DIS | _00_MTU_OLS3N_HL | _00_MTU_OLS3P_HL | _00_MTU_OLS2N_HL | _00_MTU_OLS2P_HL | 
ffc0459b:	3c 55 00                      	mov.b	#0, 5[r5]
    MTU.TOLBRA.BYTE = MTU.TOCR2A.BYTE & 0x3FU;
ffc0459e:	89 5b                         	mov.b	5[r5], r3
ffc045a0:	75 23 3f                      	and	#63, r3
ffc045a3:	c7 53 2c                      	mov.b	r3, 44[r5]
    MTU3.TIER.BYTE = _01_MTU_TGIEA_ENABLE | _02_MTU_TGIEB_ENABLE | _00_MTU_TTGE_DISABLE;
ffc045a6:	3c 48 03                      	mov.b	#3, 8[r4]
    MTU4.TIER.BYTE = _01_MTU_TGIEA_ENABLE | _02_MTU_TGIEB_ENABLE | _10_MTU_TCIEV_ENABLE | _00_MTU_TTGE2_DISABLE;
ffc045a9:	3c 49 13                      	mov.b	#19, 9[r4]
    MTU.TITMRA.BIT.TITM = 0U;
ffc045ac:	f1 58 30                      	bclr	#0, 48[r5].b
    MTU.TITCR1A.BYTE = _00_MTU_TACOR_3_6_SKIP_COUNT_0 | _00_MTU_TVCOR_4_7_SKIP_COUNT_0;
ffc045af:	f9 54 26 00                   	mov.b	#0, 38[r5]
    MTU3.TMDR1.BYTE = _0D_MTU_CMT1 | _10_MTU_BFA_BUFFER | _20_MTU_BFB_BUFFER;
ffc045b3:	3c 42 3d                      	mov.b	#61, 2[r4]
    MTU.TOERA.BYTE = _E0_MTU_OE4D_ENABLE | _D0_MTU_OE4C_ENABLE | _C8_MTU_OE3D_ENABLE | _C4_MTU_OE4B_ENABLE | 
ffc045b6:	f8 54 ff                      	mov.b	#255, [r5]
    MTU.TRWERA.BIT.RWE = 0U;
ffc045b9:	f1 58 7a                      	bclr	#0, 122[r5].b
    MPC.P22PFS.BYTE = 0x01U;
ffc045bc:	f9 14 52 01                   	mov.b	#1, 82[r1]
    PORT2.PMR.BYTE |= 0x04U;
ffc045c0:	f1 22 60                      	bset	#2, 96[r2].b
    MPC.P23PFS.BYTE = 0x01U;
ffc045c3:	f9 14 53 01                   	mov.b	#1, 83[r1]
    PORT2.PMR.BYTE |= 0x08U;
ffc045c7:	f1 23 60                      	bset	#3, 96[r2].b
    MPC.P24PFS.BYTE = 0x01U;
ffc045ca:	f9 14 54 01                   	mov.b	#1, 84[r1]
    PORT2.PMR.BYTE |= 0x10U;
ffc045ce:	f1 24 60                      	bset	#4, 96[r2].b
    MPC.P17PFS.BYTE = 0x08U;
ffc045d1:	f9 14 4f 08                   	mov.b	#8, 79[r1]
    PORT1.PMR.BYTE |= 0x80U;
ffc045d5:	cd 75 60                      	mov.b	96[r7], r5
ffc045d8:	75 35 80                      	or	#-128, r5
ffc045db:	c7 75 60                      	mov.b	r5, 96[r7]
    MPC.P25PFS.BYTE = 0x01U;
ffc045de:	f9 14 55 01                   	mov.b	#1, 85[r1]
    PORT2.PMR.BYTE |= 0x20U;
ffc045e2:	f1 25 60                      	bset	#5, 96[r2].b
    MPC.P31PFS.BYTE = 0x01U;
ffc045e5:	f9 14 59 01                   	mov.b	#1, 89[r1]
    PORT3.PMR.BYTE |= 0x02U;
ffc045e9:	f1 f1 60                      	bset	#1, 96[r15].b

    R_Config_MTU3_MTU4_Create_UserInit();
}
ffc045ec:	7e b7                         	pop	r7
    R_Config_MTU3_MTU4_Create_UserInit();
ffc045ee:	04 04 00 00                   	bra.a	ffc045f2 <_Reset_Vector+0xffc045f6>

ffc045f2 <_R_Config_MTU3_MTU4_Create_UserInit>:

void R_Config_MTU3_MTU4_Create_UserInit(void)
{
    /* Start user code for user init. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffc045f2:	02                            	rts

ffc045f3 <_Check_Using_DSQRT>:
// DPFPU                x     o     o     x     x     o     o
// TFU                  x     x     x     o     o     o     o

static double Check_Using_DSQRT(double x);
static double Check_Using_DSQRT(double x)
{
ffc045f3:	75 b0 00                      	dpushm.d	dr0-dr0
ffc045f6:	75 a0 10                      	dpushm.l	dcmr-dcmr
    return sqrt(x);  // DSQRT is used here directly.
}
ffc045f9:	fd 77 81 00                   	dmov.l	r1, drl0
ffc045fd:	fd 77 82 02                   	dmov.l	r2, drh0
ffc04601:	76 90 0d 00                   	dsqrt	dr0, dr0
ffc04605:	fd 75 81 00                   	dmov.l	drl0, r1
ffc04609:	fd 75 82 02                   	dmov.l	drh0, r2

ffc0460d <.LVL21>:
ffc0460d:	75 a8 10                      	dpopm.l	dcmr-dcmr
ffc04610:	75 b8 00                      	dpopm.d	dr0-dr0
ffc04613:	02                            	rts

ffc04614 <_Check_Using_FSQRT>:

static float Check_Using_FSQRT(float x);
static float Check_Using_FSQRT(float x)
{
    return sqrtf(x); // FSQRT is used here directly.
}
ffc04614:	fc a3 11                      	fsqrt	r1, r1

ffc04617 <.LVL23>:
ffc04617:	02                            	rts

ffc04618 <_Check_Using_DSQRT_FSQRT>:

#endif

void Check_Using_DSQRT_FSQRT(void);
void Check_Using_DSQRT_FSQRT(void)
{
ffc04618:	75 b0 00                      	dpushm.d	dr0-dr0
ffc0461b:	75 a0 10                      	dpushm.l	dcmr-dcmr
    ((double (*)(double))m_debug_Check_Using_DSQRT)(4.0);
ffc0461e:	f9 03 03 00 00 10 40          	dmov.d	#0x40100000, drh0
ffc04625:	fd 75 81 00                   	dmov.l	drl0, r1
ffc04629:	fd 75 82 02                   	dmov.l	drh0, r2
ffc0462d:	fb 52 24 00 00 00             	mov.l	#36, r5
ffc04633:	ec 55                         	mov.l	[r5], r5
ffc04635:	7f 15                         	jsr	r5

ffc04637 <.LVL40>:
    ((float (*)(float))m_debug_Check_Using_FSQRT)(4.0);
ffc04637:	fb 52 20 00 00 00             	mov.l	#32, r5
ffc0463d:	ec 55                         	mov.l	[r5], r5
ffc0463f:	fb 12 00 00 80 40             	mov.l	#0x40800000, r1
ffc04645:	7f 15                         	jsr	r5

ffc04647 <.LVL41>:
}
ffc04647:	75 a8 10                      	dpopm.l	dcmr-dcmr
ffc0464a:	75 b8 00                      	dpopm.d	dr0-dr0
ffc0464d:	02                            	rts

ffc0464e <.LFE2>:
	...

ffc04650 <_Check_Not_Using_DSQRT>:
// DPFPU                x     o     o     x     x     o     o
// TFU                  x     x     x     o     o     o     o

static double Check_Not_Using_DSQRT(double x);
static double Check_Not_Using_DSQRT(double x)
{
ffc04650:	6e ab                         	pushm	r10-r11
ffc04652:	75 b0 02                      	dpushm.d	dr0-dr2
ffc04655:	75 a0 10                      	dpushm.l	dcmr-dcmr
ffc04658:	fd 77 81 00                   	dmov.l	r1, drl0
ffc0465c:	fd 77 82 02                   	dmov.l	r2, drh0
ffc04660:	f9 03 13 00 00 00 00          	dmov.d	#0, drh1
    return sqrt(x);  // DSQRT is used in library.
ffc04667:	76 90 0d 20                   	dsqrt	dr0, dr2
ffc0466b:	fd 75 8a 20                   	dmov.l	drl2, r10
ffc0466f:	fd 75 8b 22                   	dmov.l	drh2, r11
ffc04673:	76 90 08 11                   	dcmpun	dr1, dr0
ffc04677:	75 90 1b                      	mvfdr
ffc0467a:	21 0e                         	bne.b	ffc04688 <_Reset_Vector+0xffc0468c>
ffc0467c:	76 90 18 60                   	dcmple	dr0, dr1
ffc04680:	75 90 1b                      	mvfdr
ffc04683:	15                            	beq.s	ffc04688 <_Reset_Vector+0xffc0468c>
ffc04684:	05 db 00 00                   	bsr.a	ffc0475f <_Reset_Vector+0xffc04763>

ffc04688 <.LVL21>:
}
ffc04688:	ef a1                         	mov.l	r10, r1
ffc0468a:	ef b2                         	mov.l	r11, r2
ffc0468c:	75 a8 10                      	dpopm.l	dcmr-dcmr
ffc0468f:	75 b8 02                      	dpopm.d	dr0-dr2
ffc04692:	6f ab                         	popm	r10-r11
ffc04694:	02                            	rts

ffc04695 <.LFE0>:
ffc04695:	fc 13 00                      	nop	; max	r0, r0

ffc04698 <_Check_Not_Using_FSQRT>:

static float Check_Not_Using_FSQRT(float x);
static float Check_Not_Using_FSQRT(float x)
{
    return sqrtf(x); // FSQRT is used in library.
ffc04698:	04 98 00 00                   	bra.a	ffc04730 <_Reset_Vector+0xffc04734>

ffc0469c <_Check_Not_Using_DSQRT_FSQRT>:

#endif

void Check_Not_Using_DSQRT_FSQRT(void);
void Check_Not_Using_DSQRT_FSQRT(void)
{
ffc0469c:	75 b0 00                      	dpushm.d	dr0-dr0
ffc0469f:	75 a0 10                      	dpushm.l	dcmr-dcmr
    ((double (*)(double))m_debug_Check_Not_Using_DSQRT)(4.0);
ffc046a2:	f9 03 03 00 00 10 40          	dmov.d	#0x40100000, drh0
ffc046a9:	fd 75 81 00                   	dmov.l	drl0, r1
ffc046ad:	fd 75 82 02                   	dmov.l	drh0, r2
ffc046b1:	fb 52 2c 00 00 00             	mov.l	#44, r5
ffc046b7:	ec 55                         	mov.l	[r5], r5
ffc046b9:	7f 15                         	jsr	r5

ffc046bb <.LVL40>:
    ((float (*)(float))m_debug_Check_Not_Using_FSQRT)(4.0);
ffc046bb:	fb 52 28 00 00 00             	mov.l	#40, r5
ffc046c1:	ec 55                         	mov.l	[r5], r5
ffc046c3:	fb 12 00 00 80 40             	mov.l	#0x40800000, r1
ffc046c9:	7f 15                         	jsr	r5

ffc046cb <.LVL41>:
}
ffc046cb:	75 a8 10                      	dpopm.l	dcmr-dcmr
ffc046ce:	75 b8 00                      	dpopm.d	dr0-dr0
ffc046d1:	02                            	rts

ffc046d2 <.LFE2>:
ffc046d2:	00                            	brk
ffc046d3:	00                            	brk
ffc046d4:	00                            	brk
ffc046d5:	00                            	brk
	...

ffc046d8 <_main>:
#define VECT_TRAP_3 3
#define VECT_TRAP_4 4

void main(void)
{
    R_BSP_SET_IPL( MY_BSP_CFG_FIT_UNNESTED_IPL_MAX - 1 );
ffc046d8:	75 70 07                      	mvtipl	#7
    R_BSP_INT( VECT( TRAP, 0 ) );
ffc046db:	75 60 00                      	int #0
    R_BSP_INT( VECT( TRAP, 1 ) );
ffc046de:	75 60 01                      	int #1
    R_BSP_INT( VECT( TRAP, 2 ) );
ffc046e1:	75 60 02                      	int #2
    R_BSP_INT( VECT( TRAP, 3 ) );
ffc046e4:	75 60 03                      	int #3
    R_BSP_INT( VECT( TRAP, 4 ) );
ffc046e7:	75 60 04                      	int #4

    R_BSP_SET_IPL( MY_BSP_CFG_FIT_UNNESTED_IPL_MAX );
ffc046ea:	75 70 08                      	mvtipl	#8
    R_BSP_INT( VECT( TRAP, 0 ) );
ffc046ed:	75 60 00                      	int #0
    R_BSP_INT( VECT( TRAP, 1 ) );
ffc046f0:	75 60 01                      	int #1
    R_BSP_INT( VECT( TRAP, 2 ) );
ffc046f3:	75 60 02                      	int #2
    R_BSP_INT( VECT( TRAP, 3 ) );
ffc046f6:	75 60 03                      	int #3
    R_BSP_INT( VECT( TRAP, 4 ) );
ffc046f9:	75 60 04                      	int #4

    R_BSP_SET_IPL( MY_BSP_CFG_FIT_UNNESTED_IPL_MAX + 1 );
ffc046fc:	75 70 09                      	mvtipl	#9
    R_BSP_INT( VECT( TRAP, 0 ) );
ffc046ff:	75 60 00                      	int #0
    R_BSP_INT( VECT( TRAP, 1 ) );
ffc04702:	75 60 01                      	int #1
    R_BSP_INT( VECT( TRAP, 2 ) );
ffc04705:	75 60 02                      	int #2
    R_BSP_INT( VECT( TRAP, 3 ) );
ffc04708:	75 60 03                      	int #3
    R_BSP_INT( VECT( TRAP, 4 ) );
ffc0470b:	75 60 04                      	int #4
    R_BSP_INT( VECT( TRAP, 2 ) );
    R_BSP_INT( VECT( TRAP, 3 ) );
    R_BSP_INT( VECT( TRAP, 4 ) );
#endif

    R_BSP_NOP();
ffc0470e:	03                            	nop

    fp_Check_Using_DSQRT_FSQRT = &Check_Using_DSQRT_FSQRT;
ffc0470f:	fb 52 b0 08 00 00             	mov.l	#0x8b0, r5
ffc04715:	f8 52 18 46 c0 ff             	mov.l	#0xffc04618, [r5]
    fp_Check_Not_Using_DSQRT_FSQRT = &Check_Not_Using_DSQRT_FSQRT;
ffc0471b:	fb 52 b4 08 00 00             	mov.l	#0x8b4, r5
ffc04721:	f8 52 9c 46 c0 ff             	mov.l	#0xffc0469c, [r5]
ffc04727:	03                            	nop

    for(;;);
ffc04728:	2e 00                         	bra.b	ffc04728 <_Reset_Vector+0xffc0472c>

ffc0472a <.LFE3>:
ffc0472a:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffc04730 <_sqrtf>:
ffc04730:	6e 7a                         	pushm	r7-r10
ffc04732:	ef 1a                         	mov.l	r1, r10
ffc04734:	05 0f b9 ff                   	bsr.a	ffc00043 <_Reset_Vector+0xffc00047>
ffc04738:	ef 17                         	mov.l	r1, r7
ffc0473a:	ef a1                         	mov.l	r10, r1
ffc0473c:	05 63 00 00                   	bsr.a	ffc0479f <_Reset_Vector+0xffc047a3>
ffc04740:	61 01                         	cmp	#0, r1
ffc04742:	20 18                         	beq.b	ffc0475a <_Reset_Vector+0xffc0475e>
ffc04744:	fd 72 1a 00 00 00 00          	fcmp	#0, r10
ffc0474b:	26 0f                         	bpz.b	ffc0475a <_Reset_Vector+0xffc0475e>
ffc0474d:	05 d8 00 00                   	bsr.a	ffc04825 <_Reset_Vector+0xffc04829>
ffc04751:	f8 16 21                      	mov.l	#33, [r1]
ffc04754:	fb 72 00 00 80 3f             	mov.l	#0x3f800000, r7
ffc0475a:	ef 71                         	mov.l	r7, r1
ffc0475c:	3f 7a 04                      	rtsd	#16, r7-r10

ffc0475f <_sqrt>:
ffc0475f:	6e 6b                         	pushm	r6-r11
ffc04761:	ef 1b                         	mov.l	r1, r11
ffc04763:	ef 26                         	mov.l	r2, r6
ffc04765:	05 90 b9 ff                   	bsr.a	ffc000f5 <_Reset_Vector+0xffc000f9>
ffc04769:	ef 1a                         	mov.l	r1, r10
ffc0476b:	ef 27                         	mov.l	r2, r7
ffc0476d:	ef b1                         	mov.l	r11, r1
ffc0476f:	ef 62                         	mov.l	r6, r2
ffc04771:	05 60 00 00                   	bsr.a	ffc047d1 <_Reset_Vector+0xffc047d5>
ffc04775:	61 01                         	cmp	#0, r1
ffc04777:	20 21                         	beq.b	ffc04798 <_Reset_Vector+0xffc0479c>
ffc04779:	66 03                         	mov.l	#0, r3
ffc0477b:	66 04                         	mov.l	#0, r4
ffc0477d:	ef b1                         	mov.l	r11, r1
ffc0477f:	ef 62                         	mov.l	r6, r2
ffc04781:	05 ef 19 00                   	bsr.a	ffc06170 <_Reset_Vector+0xffc06174>
ffc04785:	61 01                         	cmp	#0, r1
ffc04787:	28 11                         	bge.b	ffc04798 <_Reset_Vector+0xffc0479c>
ffc04789:	05 9c 00 00                   	bsr.a	ffc04825 <_Reset_Vector+0xffc04829>
ffc0478d:	f8 16 21                      	mov.l	#33, [r1]
ffc04790:	66 0a                         	mov.l	#0, r10
ffc04792:	fb 72 00 00 f0 3f             	mov.l	#0x3ff00000, r7
ffc04798:	ef a1                         	mov.l	r10, r1
ffc0479a:	ef 72                         	mov.l	r7, r2
ffc0479c:	3f 6b 06                      	rtsd	#24, r6-r11

ffc0479f <___fpclassifyf>:
ffc0479f:	74 21 ff ff ff 7f             	and	#0x7fffffff, r1
ffc047a5:	20 23                         	beq.b	ffc047c8 <_Reset_Vector+0xffc047cc>
ffc047a7:	73 15 00 00 80                	add	#0xff800000, r1, r5
ffc047ac:	74 05 ff ff ff 7e             	cmp	#0x7effffff, r5
ffc047b2:	25 19                         	bleu.b	ffc047cb <_Reset_Vector+0xffc047cf>
ffc047b4:	71 15 ff                      	add	#-1, r1, r5
ffc047b7:	77 05 fe ff 7f                	cmp	#0x7ffffe, r5
ffc047bc:	25 12                         	bleu.b	ffc047ce <_Reset_Vector+0xffc047d2>
ffc047be:	74 01 00 00 80 7f             	cmp	#0x7f800000, r1
ffc047c4:	fc db 10                      	sceq.l	r1
ffc047c7:	02                            	rts
ffc047c8:	66 21                         	mov.l	#2, r1
ffc047ca:	02                            	rts
ffc047cb:	66 41                         	mov.l	#4, r1
ffc047cd:	02                            	rts
ffc047ce:	66 31                         	mov.l	#3, r1
ffc047d0:	02                            	rts

ffc047d1 <___fpclassifyd>:
ffc047d1:	fb 42 ff ff ff 7f             	mov.l	#0x7fffffff, r4
ffc047d7:	53 24                         	and	r2, r4
ffc047d9:	20 44                         	beq.b	ffc0481d <_Reset_Vector+0xffc04821>
ffc047db:	73 25 00 00 f0                	add	#0xfff00000, r2, r5
ffc047e0:	74 05 ff ff df 7f             	cmp	#0x7fdfffff, r5
ffc047e6:	25 2b                         	bleu.b	ffc04811 <_Reset_Vector+0xffc04815>
ffc047e8:	70 23 00 00 f0 7f             	add	#0x7ff00000, r2, r3
ffc047ee:	66 45                         	mov.l	#4, r5
ffc047f0:	74 03 ff ff df 7f             	cmp	#0x7fdfffff, r3
ffc047f6:	25 18                         	bleu.b	ffc0480e <_Reset_Vector+0xffc04812>
ffc047f8:	fd 70 c2 00 00 f0 7f          	tst	#0x7ff00000, r2
ffc047ff:	20 16                         	beq.b	ffc04815 <_Reset_Vector+0xffc04819>
ffc04801:	74 04 00 00 f0 7f             	cmp	#0x7ff00000, r4
ffc04807:	21 12                         	bne.b	ffc04819 <_Reset_Vector+0xffc0481d>
ffc04809:	61 01                         	cmp	#0, r1
ffc0480b:	fc db 50                      	sceq.l	r5
ffc0480e:	ef 51                         	mov.l	r5, r1
ffc04810:	02                            	rts
ffc04811:	66 45                         	mov.l	#4, r5
ffc04813:	2e fb                         	bra.b	ffc0480e <_Reset_Vector+0xffc04812>
ffc04815:	66 35                         	mov.l	#3, r5
ffc04817:	2e f7                         	bra.b	ffc0480e <_Reset_Vector+0xffc04812>
ffc04819:	66 05                         	mov.l	#0, r5
ffc0481b:	2e f3                         	bra.b	ffc0480e <_Reset_Vector+0xffc04812>
ffc0481d:	61 01                         	cmp	#0, r1
ffc0481f:	21 d9                         	bne.b	ffc047f8 <_Reset_Vector+0xffc047fc>
ffc04821:	66 25                         	mov.l	#2, r5
ffc04823:	2e eb                         	bra.b	ffc0480e <_Reset_Vector+0xffc04812>

ffc04825 <___errno>:
ffc04825:	fb 52 34 00 00 00             	mov.l	#52, r5
ffc0482b:	ec 51                         	mov.l	[r5], r1
ffc0482d:	02                            	rts

ffc0482e <__sci_iic_int_sci_iic1_txi_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(sci_iic_int_sci_iic1_txi_isr, VECT_SCI1_TXI1)
ffc0482e:	7e a1                         	push.l	r1
ffc04830:	fd 6a 01                      	mvfc	psw, r1
ffc04833:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc04838:	61 81                         	cmp	#8, r1
ffc0483a:	22 05                         	bc.b	ffc0483f <_Reset_Vector+0xffc04843>
ffc0483c:	75 70 08                      	mvtipl	#8
ffc0483f:	7f a8                         	setpsw	i
ffc04841:	fd 6a 01                      	mvfc	psw, r1
ffc04844:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc04849:	fd 76 c1 00                   	save	r1
ffc0484d:	ef 16                         	mov.l	r1, r6
ffc0484f:	39 0b 00                      	bsr.w	ffc0485a <_Reset_Vector+0xffc0485e>
ffc04852:	fd 76 d6 00                   	rstr	r6
ffc04856:	7e b1                         	pop	r1
ffc04858:	7f 95                         	rte

ffc0485a <_sci_iic_int_sci_iic1_txi_isr>:
    r_sci_iic_txi_isr_processing(SCI_IIC_NUM_CH1);
ffc0485a:	66 11                         	mov.l	#1, r1
ffc0485c:	05 04 ca ff                   	bsr.a	ffc01260 <_Reset_Vector+0xffc01264>

ffc04860 <.LVL116>:
    r_sci_iic_advance(g_sci_iic_handles[SCI_IIC_NUM_CH1]->psci_iic_info_ch);
ffc04860:	fb 52 04 00 00 00             	mov.l	#4, r5
ffc04866:	a9 d1                         	mov.l	24[r5], r1
ffc04868:	04 a0 c8 ff                   	bra.a	ffc01108 <_Reset_Vector+0xffc0110c>

ffc0486c <__riic1_txi_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(riic1_txi_isr, VECT(RIIC1,TXI1))
ffc0486c:	7e a1                         	push.l	r1
ffc0486e:	fd 6a 01                      	mvfc	psw, r1
ffc04871:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc04876:	61 81                         	cmp	#8, r1
ffc04878:	22 05                         	bc.b	ffc0487d <_Reset_Vector+0xffc04881>
ffc0487a:	75 70 08                      	mvtipl	#8
ffc0487d:	7f a8                         	setpsw	i
ffc0487f:	fd 6a 01                      	mvfc	psw, r1
ffc04882:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc04887:	fd 76 c1 00                   	save	r1
ffc0488b:	ef 16                         	mov.l	r1, r6
ffc0488d:	39 0b 00                      	bsr.w	ffc04898 <_Reset_Vector+0xffc0489c>
ffc04890:	fd 76 d6 00                   	rstr	r6
ffc04894:	7e b1                         	pop	r1
ffc04896:	7f 95                         	rte

ffc04898 <_riic1_txi_isr>:
    riic1_txi_sub();
ffc04898:	04 d0 e8 ff                   	bra.a	ffc03168 <_Reset_Vector+0xffc0316c>

ffc0489c <__riic1_rxi_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(riic1_rxi_isr, VECT(RIIC1,RXI1))
ffc0489c:	7e a1                         	push.l	r1
ffc0489e:	fd 6a 01                      	mvfc	psw, r1
ffc048a1:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc048a6:	61 81                         	cmp	#8, r1
ffc048a8:	22 05                         	bc.b	ffc048ad <_Reset_Vector+0xffc048b1>
ffc048aa:	75 70 08                      	mvtipl	#8
ffc048ad:	7f a8                         	setpsw	i
ffc048af:	fd 6a 01                      	mvfc	psw, r1
ffc048b2:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc048b7:	fd 76 c1 00                   	save	r1
ffc048bb:	ef 16                         	mov.l	r1, r6
ffc048bd:	39 0b 00                      	bsr.w	ffc048c8 <_Reset_Vector+0xffc048cc>
ffc048c0:	fd 76 d6 00                   	rstr	r6
ffc048c4:	7e b1                         	pop	r1
ffc048c6:	7f 95                         	rte

ffc048c8 <_riic1_rxi_isr>:
    riic1_rxi_sub();
ffc048c8:	04 20 e9 ff                   	bra.a	ffc031e8 <_Reset_Vector+0xffc031ec>

ffc048cc <.LFE24>:
ffc048cc:	00                            	brk
ffc048cd:	00                            	brk
	...

ffc048d0 <__group_bl0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_bl0_handler_isr, VECT(ICU,GROUPBL0))
ffc048d0:	7e a1                         	push.l	r1
ffc048d2:	fd 6a 01                      	mvfc	psw, r1
ffc048d5:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc048da:	61 81                         	cmp	#8, r1
ffc048dc:	22 05                         	bc.b	ffc048e1 <_Reset_Vector+0xffc048e5>
ffc048de:	75 70 08                      	mvtipl	#8
ffc048e1:	7f a8                         	setpsw	i
ffc048e3:	fd 6a 01                      	mvfc	psw, r1
ffc048e6:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc048eb:	fd 76 c1 00                   	save	r1
ffc048ef:	ef 16                         	mov.l	r1, r6
ffc048f1:	39 0b 00                      	bsr.w	ffc048fc <_Reset_Vector+0xffc04900>
ffc048f4:	fd 76 d6 00                   	rstr	r6
ffc048f8:	7e b1                         	pop	r1
ffc048fa:	7f 95                         	rte

ffc048fc <_group_bl0_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_bl0_handler_isr (void)
{
    /* BL0 IS1 */
    if (1 == ICU.GRPBL0.BIT.IS1)
ffc048fc:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04901:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04905:	7c 15                         	btst	#1, r5
ffc04907:	3b a0 01                      	bne.w	ffc04aa7 <_Reset_Vector+0xffc04aab>
        /* BSP_INT_SRC_BL0_SCI0_ERI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI0_ERI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS0 */
    if (1 == ICU.GRPBL0.BIT.IS0)
ffc0490a:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0490f:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04913:	7c 05                         	btst	#0, r5
ffc04915:	3b b3 01                      	bne.w	ffc04ac8 <_Reset_Vector+0xffc04acc>
        /* BSP_INT_SRC_BL0_SCI0_TEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS3 */
    if (1 == ICU.GRPBL0.BIT.IS3)
ffc04918:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0491d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04921:	7c 35                         	btst	#3, r5
ffc04923:	3b c5 01                      	bne.w	ffc04ae8 <_Reset_Vector+0xffc04aec>
ffc04926:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI1_ERI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_ERI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS2 */
    if (1 == ICU.GRPBL0.BIT.IS2)
ffc04928:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0492d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04931:	7c 25                         	btst	#2, r5
ffc04933:	3b d5 01                      	bne.w	ffc04b08 <_Reset_Vector+0xffc04b0c>
ffc04936:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI1_TEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS5 */
    if (1 == ICU.GRPBL0.BIT.IS5)
ffc04938:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0493d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04941:	7c 55                         	btst	#5, r5
ffc04943:	3b e5 01                      	bne.w	ffc04b28 <_Reset_Vector+0xffc04b2c>
ffc04946:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI2_ERI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI2_ERI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS4 */
    if (1 == ICU.GRPBL0.BIT.IS4)
ffc04948:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0494d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04951:	7c 45                         	btst	#4, r5
ffc04953:	3b f5 01                      	bne.w	ffc04b48 <_Reset_Vector+0xffc04b4c>
ffc04956:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI2_TEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI2_TEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS7 */
    if (1 == ICU.GRPBL0.BIT.IS7)
ffc04958:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0495d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04961:	7c 75                         	btst	#7, r5
ffc04963:	3b 05 02                      	bne.w	ffc04b68 <_Reset_Vector+0xffc04b6c>
ffc04966:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI3_ERI3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI3_ERI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS6 */
    if (1 == ICU.GRPBL0.BIT.IS6)
ffc04968:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0496d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04971:	7c 65                         	btst	#6, r5
ffc04973:	3b 15 02                      	bne.w	ffc04b88 <_Reset_Vector+0xffc04b8c>
ffc04976:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI3_TEI3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI3_TEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS9 */
    if (1 == ICU.GRPBL0.BIT.IS9)
ffc04978:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0497d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04981:	7c 95                         	btst	#9, r5
ffc04983:	3b 25 02                      	bne.w	ffc04ba8 <_Reset_Vector+0xffc04bac>
ffc04986:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI4_ERI4 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI4_ERI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS8 */
    if (1 == ICU.GRPBL0.BIT.IS8)
ffc04988:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0498d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04991:	7c 85                         	btst	#8, r5
ffc04993:	3b 35 02                      	bne.w	ffc04bc8 <_Reset_Vector+0xffc04bcc>
ffc04996:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI4_TEI4 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI4_TEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS11 */
    if (1 == ICU.GRPBL0.BIT.IS11)
ffc04998:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0499d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc049a1:	7c b5                         	btst	#11, r5
ffc049a3:	3b 45 02                      	bne.w	ffc04be8 <_Reset_Vector+0xffc04bec>
ffc049a6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI5_ERI5 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_ERI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS10 */
    if (1 == ICU.GRPBL0.BIT.IS10)
ffc049a8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc049ad:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc049b1:	7c a5                         	btst	#10, r5
ffc049b3:	3b 55 02                      	bne.w	ffc04c08 <_Reset_Vector+0xffc04c0c>
ffc049b6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI5_TEI5 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_TEI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS13 */
    if (1 == ICU.GRPBL0.BIT.IS13)
ffc049b8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc049bd:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc049c1:	7c d5                         	btst	#13, r5
ffc049c3:	3b 65 02                      	bne.w	ffc04c28 <_Reset_Vector+0xffc04c2c>
ffc049c6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI6_ERI6 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_ERI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS12 */
    if (1 == ICU.GRPBL0.BIT.IS12)
ffc049c8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc049cd:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc049d1:	7c c5                         	btst	#12, r5
ffc049d3:	3b 75 02                      	bne.w	ffc04c48 <_Reset_Vector+0xffc04c4c>
ffc049d6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI6_TEI6 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_TEI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS17 */
    if (1 == ICU.GRPBL0.BIT.IS17)
ffc049d8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc049dd:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc049e1:	7d 15                         	btst	#17, r5
ffc049e3:	3b 85 02                      	bne.w	ffc04c68 <_Reset_Vector+0xffc04c6c>
ffc049e6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_ERI12 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_ERI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS16 */
    if (1 == ICU.GRPBL0.BIT.IS16)
ffc049e8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc049ed:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc049f1:	7d 05                         	btst	#16, r5
ffc049f3:	3b 95 02                      	bne.w	ffc04c88 <_Reset_Vector+0xffc04c8c>
ffc049f6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_TEI12 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_TEI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS18 */
    if (1 == ICU.GRPBL0.BIT.IS18)
ffc049f8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc049fd:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a01:	7d 25                         	btst	#18, r5
ffc04a03:	3b a5 02                      	bne.w	ffc04ca8 <_Reset_Vector+0xffc04cac>
ffc04a06:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS19 */
    if (1 == ICU.GRPBL0.BIT.IS19)
ffc04a08:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a0d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a11:	7d 35                         	btst	#19, r5
ffc04a13:	3b b5 02                      	bne.w	ffc04cc8 <_Reset_Vector+0xffc04ccc>
ffc04a16:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS20 */
    if (1 == ICU.GRPBL0.BIT.IS20)
ffc04a18:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a1d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a21:	7d 45                         	btst	#20, r5
ffc04a23:	3b c5 02                      	bne.w	ffc04ce8 <_Reset_Vector+0xffc04cec>
ffc04a26:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS21 */
    if (1 == ICU.GRPBL0.BIT.IS21)
ffc04a28:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a2d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a31:	7d 55                         	btst	#21, r5
ffc04a33:	3b d5 02                      	bne.w	ffc04d08 <_Reset_Vector+0xffc04d0c>
ffc04a36:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS24 */
    if (1 == ICU.GRPBL0.BIT.IS24)
ffc04a38:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a3d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a41:	7d 85                         	btst	#24, r5
ffc04a43:	3b e5 02                      	bne.w	ffc04d28 <_Reset_Vector+0xffc04d2c>
ffc04a46:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_QSPI_QSPSSLI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_QSPI_QSPSSLI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS26 */
    if (1 == ICU.GRPBL0.BIT.IS26)
ffc04a48:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a4d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a51:	7d a5                         	btst	#26, r5
ffc04a53:	3b f5 02                      	bne.w	ffc04d48 <_Reset_Vector+0xffc04d4c>
ffc04a56:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_FERRI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_FERRI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS27 */
    if (1 == ICU.GRPBL0.BIT.IS27)
ffc04a58:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a5d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a61:	7d b5                         	btst	#27, r5
ffc04a63:	3b 05 03                      	bne.w	ffc04d68 <_Reset_Vector+0xffc04d6c>
ffc04a66:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_MENDI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_MENDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS28 */
    if (1 == ICU.GRPBL0.BIT.IS28)
ffc04a68:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a6d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a71:	7d c5                         	btst	#28, r5
ffc04a73:	3b 15 03                      	bne.w	ffc04d88 <_Reset_Vector+0xffc04d8c>
ffc04a76:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_OVFI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_OVFI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS29 */
    if (1 == ICU.GRPBL0.BIT.IS29)
ffc04a78:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a7d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a81:	7d d5                         	btst	#29, r5
ffc04a83:	3b 25 03                      	bne.w	ffc04da8 <_Reset_Vector+0xffc04dac>
ffc04a86:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_DOC_DOPCI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_DOC_DOPCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS31 */
    if (1 == ICU.GRPBL0.BIT.IS31)
ffc04a88:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a8d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04a91:	61 05                         	cmp	#0, r5
ffc04a93:	28 05                         	bge.b	ffc04a98 <_Reset_Vector+0xffc04a9c>
ffc04a95:	38 33 03                      	bra.w	ffc04dc8 <_Reset_Vector+0xffc04dcc>
        /* BSP_INT_SRC_BL0_PDC_PCERI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_PDC_PCERI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS30 */
    if (1 == ICU.GRPBL0.BIT.IS30)
ffc04a98:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04a9d:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04aa1:	7d e5                         	btst	#30, r5
ffc04aa3:	3b 45 03                      	bne.w	ffc04de8 <_Reset_Vector+0xffc04dec>
    {
        /* BSP_INT_SRC_BL0_PDC_PCFEI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_PDC_PCFEI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_bl0_handler_isr() */
ffc04aa6:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI0_ERI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04aa7:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04aad:	66 02                         	mov.l	#0, r2
ffc04aaf:	75 41 1b                      	mov.l	#27, r1
ffc04ab2:	05 96 f2 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04ab6 <.LVL0>:
    if (1 == ICU.GRPBL0.BIT.IS0)
ffc04ab6:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04abb:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04abf:	7c 05                         	btst	#0, r5
ffc04ac1:	3a 57 fe                      	beq.w	ffc04918 <_Reset_Vector+0xffc0491c>
ffc04ac4:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04ac8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04ace:	66 02                         	mov.l	#0, r2
ffc04ad0:	75 41 1a                      	mov.l	#26, r1
ffc04ad3:	05 75 f2 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04ad7 <.LVL1>:
    if (1 == ICU.GRPBL0.BIT.IS3)
ffc04ad7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04adc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04ae0:	7c 35                         	btst	#3, r5
ffc04ae2:	3a 46 fe                      	beq.w	ffc04928 <_Reset_Vector+0xffc0492c>
ffc04ae5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_ERI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04ae8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04aee:	66 02                         	mov.l	#0, r2
ffc04af0:	75 41 1d                      	mov.l	#29, r1
ffc04af3:	05 55 f2 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04af7 <.LVL2>:
    if (1 == ICU.GRPBL0.BIT.IS2)
ffc04af7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04afc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04b00:	7c 25                         	btst	#2, r5
ffc04b02:	3a 36 fe                      	beq.w	ffc04938 <_Reset_Vector+0xffc0493c>
ffc04b05:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04b08:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04b0e:	66 02                         	mov.l	#0, r2
ffc04b10:	75 41 1c                      	mov.l	#28, r1
ffc04b13:	05 35 f2 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04b17 <.LVL3>:
    if (1 == ICU.GRPBL0.BIT.IS5)
ffc04b17:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04b1c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04b20:	7c 55                         	btst	#5, r5
ffc04b22:	3a 26 fe                      	beq.w	ffc04948 <_Reset_Vector+0xffc0494c>
ffc04b25:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI2_ERI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04b28:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04b2e:	66 02                         	mov.l	#0, r2
ffc04b30:	75 41 1f                      	mov.l	#31, r1
ffc04b33:	05 15 f2 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04b37 <.LVL4>:
    if (1 == ICU.GRPBL0.BIT.IS4)
ffc04b37:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04b3c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04b40:	7c 45                         	btst	#4, r5
ffc04b42:	3a 16 fe                      	beq.w	ffc04958 <_Reset_Vector+0xffc0495c>
ffc04b45:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI2_TEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04b48:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04b4e:	66 02                         	mov.l	#0, r2
ffc04b50:	75 41 1e                      	mov.l	#30, r1
ffc04b53:	05 f5 f1 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04b57 <.LVL5>:
    if (1 == ICU.GRPBL0.BIT.IS7)
ffc04b57:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04b5c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04b60:	7c 75                         	btst	#7, r5
ffc04b62:	3a 06 fe                      	beq.w	ffc04968 <_Reset_Vector+0xffc0496c>
ffc04b65:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI3_ERI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04b68:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04b6e:	66 02                         	mov.l	#0, r2
ffc04b70:	75 41 21                      	mov.l	#33, r1
ffc04b73:	05 d5 f1 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04b77 <.LVL6>:
    if (1 == ICU.GRPBL0.BIT.IS6)
ffc04b77:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04b7c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04b80:	7c 65                         	btst	#6, r5
ffc04b82:	3a f6 fd                      	beq.w	ffc04978 <_Reset_Vector+0xffc0497c>
ffc04b85:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI3_TEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04b88:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04b8e:	66 02                         	mov.l	#0, r2
ffc04b90:	75 41 20                      	mov.l	#32, r1
ffc04b93:	05 b5 f1 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04b97 <.LVL7>:
    if (1 == ICU.GRPBL0.BIT.IS9)
ffc04b97:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04b9c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04ba0:	7c 95                         	btst	#9, r5
ffc04ba2:	3a e6 fd                      	beq.w	ffc04988 <_Reset_Vector+0xffc0498c>
ffc04ba5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI4_ERI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04ba8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04bae:	66 02                         	mov.l	#0, r2
ffc04bb0:	75 41 23                      	mov.l	#35, r1
ffc04bb3:	05 95 f1 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04bb7 <.LVL8>:
    if (1 == ICU.GRPBL0.BIT.IS8)
ffc04bb7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04bbc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04bc0:	7c 85                         	btst	#8, r5
ffc04bc2:	3a d6 fd                      	beq.w	ffc04998 <_Reset_Vector+0xffc0499c>
ffc04bc5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI4_TEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04bc8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04bce:	66 02                         	mov.l	#0, r2
ffc04bd0:	75 41 22                      	mov.l	#34, r1
ffc04bd3:	05 75 f1 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04bd7 <.LVL9>:
    if (1 == ICU.GRPBL0.BIT.IS11)
ffc04bd7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04bdc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04be0:	7c b5                         	btst	#11, r5
ffc04be2:	3a c6 fd                      	beq.w	ffc049a8 <_Reset_Vector+0xffc049ac>
ffc04be5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_ERI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04be8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04bee:	66 02                         	mov.l	#0, r2
ffc04bf0:	75 41 25                      	mov.l	#37, r1
ffc04bf3:	05 55 f1 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04bf7 <.LVL10>:
    if (1 == ICU.GRPBL0.BIT.IS10)
ffc04bf7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04bfc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04c00:	7c a5                         	btst	#10, r5
ffc04c02:	3a b6 fd                      	beq.w	ffc049b8 <_Reset_Vector+0xffc049bc>
ffc04c05:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_TEI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04c08:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04c0e:	66 02                         	mov.l	#0, r2
ffc04c10:	75 41 24                      	mov.l	#36, r1
ffc04c13:	05 35 f1 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04c17 <.LVL11>:
    if (1 == ICU.GRPBL0.BIT.IS13)
ffc04c17:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04c1c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04c20:	7c d5                         	btst	#13, r5
ffc04c22:	3a a6 fd                      	beq.w	ffc049c8 <_Reset_Vector+0xffc049cc>
ffc04c25:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_ERI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04c28:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04c2e:	66 02                         	mov.l	#0, r2
ffc04c30:	75 41 27                      	mov.l	#39, r1
ffc04c33:	05 15 f1 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04c37 <.LVL12>:
    if (1 == ICU.GRPBL0.BIT.IS12)
ffc04c37:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04c3c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04c40:	7c c5                         	btst	#12, r5
ffc04c42:	3a 96 fd                      	beq.w	ffc049d8 <_Reset_Vector+0xffc049dc>
ffc04c45:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_TEI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04c48:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04c4e:	66 02                         	mov.l	#0, r2
ffc04c50:	75 41 26                      	mov.l	#38, r1
ffc04c53:	05 f5 f0 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04c57 <.LVL13>:
    if (1 == ICU.GRPBL0.BIT.IS17)
ffc04c57:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04c5c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04c60:	7d 15                         	btst	#17, r5
ffc04c62:	3a 86 fd                      	beq.w	ffc049e8 <_Reset_Vector+0xffc049ec>
ffc04c65:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_ERI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04c68:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04c6e:	66 02                         	mov.l	#0, r2
ffc04c70:	75 41 29                      	mov.l	#41, r1
ffc04c73:	05 d5 f0 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04c77 <.LVL14>:
    if (1 == ICU.GRPBL0.BIT.IS16)
ffc04c77:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04c7c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04c80:	7d 05                         	btst	#16, r5
ffc04c82:	3a 76 fd                      	beq.w	ffc049f8 <_Reset_Vector+0xffc049fc>
ffc04c85:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_TEI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04c88:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04c8e:	66 02                         	mov.l	#0, r2
ffc04c90:	75 41 28                      	mov.l	#40, r1
ffc04c93:	05 b5 f0 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04c97 <.LVL15>:
    if (1 == ICU.GRPBL0.BIT.IS18)
ffc04c97:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04c9c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04ca0:	7d 25                         	btst	#18, r5
ffc04ca2:	3a 66 fd                      	beq.w	ffc04a08 <_Reset_Vector+0xffc04a0c>
ffc04ca5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04ca8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04cae:	66 02                         	mov.l	#0, r2
ffc04cb0:	75 41 2a                      	mov.l	#42, r1
ffc04cb3:	05 95 f0 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04cb7 <.LVL16>:
    if (1 == ICU.GRPBL0.BIT.IS19)
ffc04cb7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04cbc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04cc0:	7d 35                         	btst	#19, r5
ffc04cc2:	3a 56 fd                      	beq.w	ffc04a18 <_Reset_Vector+0xffc04a1c>
ffc04cc5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04cc8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04cce:	66 02                         	mov.l	#0, r2
ffc04cd0:	75 41 2b                      	mov.l	#43, r1
ffc04cd3:	05 75 f0 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04cd7 <.LVL17>:
    if (1 == ICU.GRPBL0.BIT.IS20)
ffc04cd7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04cdc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04ce0:	7d 45                         	btst	#20, r5
ffc04ce2:	3a 46 fd                      	beq.w	ffc04a28 <_Reset_Vector+0xffc04a2c>
ffc04ce5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04ce8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04cee:	66 02                         	mov.l	#0, r2
ffc04cf0:	75 41 2c                      	mov.l	#44, r1
ffc04cf3:	05 55 f0 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04cf7 <.LVL18>:
    if (1 == ICU.GRPBL0.BIT.IS21)
ffc04cf7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04cfc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04d00:	7d 55                         	btst	#21, r5
ffc04d02:	3a 36 fd                      	beq.w	ffc04a38 <_Reset_Vector+0xffc04a3c>
ffc04d05:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04d08:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04d0e:	66 02                         	mov.l	#0, r2
ffc04d10:	75 41 2d                      	mov.l	#45, r1
ffc04d13:	05 35 f0 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04d17 <.LVL19>:
    if (1 == ICU.GRPBL0.BIT.IS24)
ffc04d17:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04d1c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04d20:	7d 85                         	btst	#24, r5
ffc04d22:	3a 26 fd                      	beq.w	ffc04a48 <_Reset_Vector+0xffc04a4c>
ffc04d25:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_QSPI_QSPSSLI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04d28:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04d2e:	66 02                         	mov.l	#0, r2
ffc04d30:	75 41 2e                      	mov.l	#46, r1
ffc04d33:	05 15 f0 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04d37 <.LVL20>:
    if (1 == ICU.GRPBL0.BIT.IS26)
ffc04d37:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04d3c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04d40:	7d a5                         	btst	#26, r5
ffc04d42:	3a 16 fd                      	beq.w	ffc04a58 <_Reset_Vector+0xffc04a5c>
ffc04d45:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_FERRI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04d48:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04d4e:	66 02                         	mov.l	#0, r2
ffc04d50:	75 41 2f                      	mov.l	#47, r1
ffc04d53:	05 f5 ef ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04d57 <.LVL21>:
    if (1 == ICU.GRPBL0.BIT.IS27)
ffc04d57:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04d5c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04d60:	7d b5                         	btst	#27, r5
ffc04d62:	3a 06 fd                      	beq.w	ffc04a68 <_Reset_Vector+0xffc04a6c>
ffc04d65:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_MENDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04d68:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04d6e:	66 02                         	mov.l	#0, r2
ffc04d70:	75 41 30                      	mov.l	#48, r1
ffc04d73:	05 d5 ef ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04d77 <.LVL22>:
    if (1 == ICU.GRPBL0.BIT.IS28)
ffc04d77:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04d7c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04d80:	7d c5                         	btst	#28, r5
ffc04d82:	3a f6 fc                      	beq.w	ffc04a78 <_Reset_Vector+0xffc04a7c>
ffc04d85:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_OVFI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04d88:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04d8e:	66 02                         	mov.l	#0, r2
ffc04d90:	75 41 31                      	mov.l	#49, r1
ffc04d93:	05 b5 ef ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04d97 <.LVL23>:
    if (1 == ICU.GRPBL0.BIT.IS29)
ffc04d97:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04d9c:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04da0:	7d d5                         	btst	#29, r5
ffc04da2:	3a e6 fc                      	beq.w	ffc04a88 <_Reset_Vector+0xffc04a8c>
ffc04da5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_DOC_DOPCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04da8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04dae:	66 02                         	mov.l	#0, r2
ffc04db0:	75 41 32                      	mov.l	#50, r1
ffc04db3:	05 95 ef ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04db7 <.LVL24>:
    if (1 == ICU.GRPBL0.BIT.IS31)
ffc04db7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04dbc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04dc0:	61 05                         	cmp	#0, r5
ffc04dc2:	29 05                         	blt.b	ffc04dc7 <_Reset_Vector+0xffc04dcb>
ffc04dc4:	38 d4 fc                      	bra.w	ffc04a98 <_Reset_Vector+0xffc04a9c>
ffc04dc7:	03                            	nop
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_PDC_PCERI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04dc8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04dce:	66 02                         	mov.l	#0, r2
ffc04dd0:	75 41 34                      	mov.l	#52, r1
ffc04dd3:	05 75 ef ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04dd7 <.LVL25>:
    if (1 == ICU.GRPBL0.BIT.IS30)
ffc04dd7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04ddc:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffc04de0:	7d e5                         	btst	#30, r5
ffc04de2:	3a c4 fc                      	beq.w	ffc04aa6 <_Reset_Vector+0xffc04aaa>
ffc04de5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_PDC_PCFEI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04de8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04dee:	66 02                         	mov.l	#0, r2
ffc04df0:	75 41 33                      	mov.l	#51, r1
ffc04df3:	04 55 ef ff                   	bra.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04df7 <.LFE11>:
ffc04df7:	03                            	nop

ffc04df8 <__group_bl1_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_bl1_handler_isr, VECT(ICU,GROUPBL1))
ffc04df8:	7e a1                         	push.l	r1
ffc04dfa:	fd 6a 01                      	mvfc	psw, r1
ffc04dfd:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc04e02:	61 81                         	cmp	#8, r1
ffc04e04:	22 05                         	bc.b	ffc04e09 <_Reset_Vector+0xffc04e0d>
ffc04e06:	75 70 08                      	mvtipl	#8
ffc04e09:	7f a8                         	setpsw	i
ffc04e0b:	fd 6a 01                      	mvfc	psw, r1
ffc04e0e:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc04e13:	fd 76 c1 00                   	save	r1
ffc04e17:	ef 16                         	mov.l	r1, r6
ffc04e19:	39 0b 00                      	bsr.w	ffc04e24 <_Reset_Vector+0xffc04e28>
ffc04e1c:	fd 76 d6 00                   	rstr	r6
ffc04e20:	7e b1                         	pop	r1
ffc04e22:	7f 95                         	rte

ffc04e24 <_group_bl1_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_bl1_handler_isr (void)
{
    /* BL1 IS3 */
    if (1 == ICU.GRPBL1.BIT.IS3)
ffc04e24:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04e29:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04e2d:	7c 35                         	btst	#3, r5
ffc04e2f:	3b 50 01                      	bne.w	ffc04f7f <_Reset_Vector+0xffc04f83>
        /* BSP_INT_SRC_BL1_SDHI_CDETI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_CDETI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS4 */
    if (1 == ICU.GRPBL1.BIT.IS4)
ffc04e32:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04e37:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04e3b:	7c 45                         	btst	#4, r5
ffc04e3d:	3b 63 01                      	bne.w	ffc04fa0 <_Reset_Vector+0xffc04fa4>
        /* BSP_INT_SRC_BL1_SDHI_CACI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_CACI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS5 */
    if (1 == ICU.GRPBL1.BIT.IS5)
ffc04e40:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04e45:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04e49:	7c 55                         	btst	#5, r5
ffc04e4b:	3b 75 01                      	bne.w	ffc04fc0 <_Reset_Vector+0xffc04fc4>
ffc04e4e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SDHI_SDACI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_SDACI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS6 */
    if (1 == ICU.GRPBL1.BIT.IS6)
ffc04e50:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04e55:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04e59:	7c 65                         	btst	#6, r5
ffc04e5b:	3b 85 01                      	bne.w	ffc04fe0 <_Reset_Vector+0xffc04fe4>
ffc04e5e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_MMCIF_CDETIO */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_CDETIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS7 */
    if (1 == ICU.GRPBL1.BIT.IS7)
ffc04e60:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04e65:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04e69:	7c 75                         	btst	#7, r5
ffc04e6b:	3b 95 01                      	bne.w	ffc05000 <_Reset_Vector+0xffc05004>
ffc04e6e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_MMCIF_ERRIO */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_ERRIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS8 */
    if (1 == ICU.GRPBL1.BIT.IS8)
ffc04e70:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04e75:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04e79:	7c 85                         	btst	#8, r5
ffc04e7b:	3b a5 01                      	bne.w	ffc05020 <_Reset_Vector+0xffc05024>
ffc04e7e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_MMCIF_ACCIO */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_ACCIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS9 */
    if (1 == ICU.GRPBL1.BIT.IS9)
ffc04e80:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04e85:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04e89:	7c 95                         	btst	#9, r5
ffc04e8b:	3b b5 01                      	bne.w	ffc05040 <_Reset_Vector+0xffc05044>
ffc04e8e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS10 */
    if (1 == ICU.GRPBL1.BIT.IS10)
ffc04e90:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04e95:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04e99:	7c a5                         	btst	#10, r5
ffc04e9b:	3b c5 01                      	bne.w	ffc05060 <_Reset_Vector+0xffc05064>
ffc04e9e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS11 */
    if (1 == ICU.GRPBL1.BIT.IS11)
ffc04ea0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04ea5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04ea9:	7c b5                         	btst	#11, r5
ffc04eab:	3b d5 01                      	bne.w	ffc05080 <_Reset_Vector+0xffc05084>
ffc04eae:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS12 */
    if (1 == ICU.GRPBL1.BIT.IS12)
ffc04eb0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04eb5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04eb9:	7c c5                         	btst	#12, r5
ffc04ebb:	3b e5 01                      	bne.w	ffc050a0 <_Reset_Vector+0xffc050a4>
ffc04ebe:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI4 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS14 */
    if (1 == ICU.GRPBL1.BIT.IS14)
ffc04ec0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04ec5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04ec9:	7c e5                         	btst	#14, r5
ffc04ecb:	3b f5 01                      	bne.w	ffc050c0 <_Reset_Vector+0xffc050c4>
ffc04ece:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC0_EEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_EEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS13 */
    if (1 == ICU.GRPBL1.BIT.IS13)
ffc04ed0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04ed5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04ed9:	7c d5                         	btst	#13, r5
ffc04edb:	3b 05 02                      	bne.w	ffc050e0 <_Reset_Vector+0xffc050e4>
ffc04ede:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC0_TEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS16 */
    if (1 == ICU.GRPBL1.BIT.IS16)
ffc04ee0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04ee5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04ee9:	7d 05                         	btst	#16, r5
ffc04eeb:	3b 15 02                      	bne.w	ffc05100 <_Reset_Vector+0xffc05104>
ffc04eee:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC2_EEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC2_EEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS15 */
    if (1 == ICU.GRPBL1.BIT.IS15)
ffc04ef0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04ef5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04ef9:	7c f5                         	btst	#15, r5
ffc04efb:	3b 25 02                      	bne.w	ffc05120 <_Reset_Vector+0xffc05124>
ffc04efe:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC2_TEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC2_TEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS17 */
    if (1 == ICU.GRPBL1.BIT.IS17)
ffc04f00:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f05:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f09:	7d 15                         	btst	#17, r5
ffc04f0b:	3b 35 02                      	bne.w	ffc05140 <_Reset_Vector+0xffc05144>
ffc04f0e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SSIE0_SSIF0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SSIE0_SSIF0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS18 */
    if (1 == ICU.GRPBL1.BIT.IS18)
ffc04f10:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f15:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f19:	7d 25                         	btst	#18, r5
ffc04f1b:	3b 45 02                      	bne.w	ffc05160 <_Reset_Vector+0xffc05164>
ffc04f1e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SSIE1_SSIF1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SSIE1_SSIF1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS20 */
    if (1 == ICU.GRPBL1.BIT.IS20)
ffc04f20:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f25:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f29:	7d 45                         	btst	#20, r5
ffc04f2b:	3b 55 02                      	bne.w	ffc05180 <_Reset_Vector+0xffc05184>
ffc04f2e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD0_S12CMPAI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS21 */
    if (1 == ICU.GRPBL1.BIT.IS21)
ffc04f30:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f35:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f39:	7d 55                         	btst	#21, r5
ffc04f3b:	3b 65 02                      	bne.w	ffc051a0 <_Reset_Vector+0xffc051a4>
ffc04f3e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD0_S12CMPBI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS22 */
    if (1 == ICU.GRPBL1.BIT.IS22)
ffc04f40:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f45:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f49:	7d 65                         	btst	#22, r5
ffc04f4b:	3b 75 02                      	bne.w	ffc051c0 <_Reset_Vector+0xffc051c4>
ffc04f4e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD1_S12CMPAI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPAI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS23 */
    if (1 == ICU.GRPBL1.BIT.IS23)
ffc04f50:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f55:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f59:	7d 75                         	btst	#23, r5
ffc04f5b:	3b 85 02                      	bne.w	ffc051e0 <_Reset_Vector+0xffc051e4>
ffc04f5e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD1_S12CMPBI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPBI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS29 */
    if (1 == ICU.GRPBL1.BIT.IS29)
ffc04f60:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f65:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f69:	7d d5                         	btst	#29, r5
ffc04f6b:	3b 95 02                      	bne.w	ffc05200 <_Reset_Vector+0xffc05204>
ffc04f6e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC1_EEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC1_EEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS28 */
    if (1 == ICU.GRPBL1.BIT.IS28)
ffc04f70:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f75:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f79:	7d c5                         	btst	#28, r5
ffc04f7b:	3b a5 02                      	bne.w	ffc05220 <_Reset_Vector+0xffc05224>
    {
        /* BSP_INT_SRC_BL1_RIIC1_TEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_bl1_handler_isr() */
ffc04f7e:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_CDETI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04f7f:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04f85:	66 02                         	mov.l	#0, r2
ffc04f87:	75 41 36                      	mov.l	#54, r1
ffc04f8a:	05 be ed ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04f8e <.LVL27>:
    if (1 == ICU.GRPBL1.BIT.IS4)
ffc04f8e:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04f93:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04f97:	7c 45                         	btst	#4, r5
ffc04f99:	3a a7 fe                      	beq.w	ffc04e40 <_Reset_Vector+0xffc04e44>
ffc04f9c:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_CACI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04fa0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04fa6:	66 02                         	mov.l	#0, r2
ffc04fa8:	75 41 37                      	mov.l	#55, r1
ffc04fab:	05 9d ed ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04faf <.LVL28>:
    if (1 == ICU.GRPBL1.BIT.IS5)
ffc04faf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04fb4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04fb8:	7c 55                         	btst	#5, r5
ffc04fba:	3a 96 fe                      	beq.w	ffc04e50 <_Reset_Vector+0xffc04e54>
ffc04fbd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_SDACI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04fc0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04fc6:	66 02                         	mov.l	#0, r2
ffc04fc8:	75 41 38                      	mov.l	#56, r1
ffc04fcb:	05 7d ed ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04fcf <.LVL29>:
    if (1 == ICU.GRPBL1.BIT.IS6)
ffc04fcf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04fd4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04fd8:	7c 65                         	btst	#6, r5
ffc04fda:	3a 86 fe                      	beq.w	ffc04e60 <_Reset_Vector+0xffc04e64>
ffc04fdd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_CDETIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc04fe0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc04fe6:	66 02                         	mov.l	#0, r2
ffc04fe8:	75 41 39                      	mov.l	#57, r1
ffc04feb:	05 5d ed ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc04fef <.LVL30>:
    if (1 == ICU.GRPBL1.BIT.IS7)
ffc04fef:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc04ff4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc04ff8:	7c 75                         	btst	#7, r5
ffc04ffa:	3a 76 fe                      	beq.w	ffc04e70 <_Reset_Vector+0xffc04e74>
ffc04ffd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_ERRIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05000:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05006:	66 02                         	mov.l	#0, r2
ffc05008:	75 41 3a                      	mov.l	#58, r1
ffc0500b:	05 3d ed ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0500f <.LVL31>:
    if (1 == ICU.GRPBL1.BIT.IS8)
ffc0500f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05014:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05018:	7c 85                         	btst	#8, r5
ffc0501a:	3a 66 fe                      	beq.w	ffc04e80 <_Reset_Vector+0xffc04e84>
ffc0501d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_ACCIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05020:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05026:	66 02                         	mov.l	#0, r2
ffc05028:	75 41 3b                      	mov.l	#59, r1
ffc0502b:	05 1d ed ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0502f <.LVL32>:
    if (1 == ICU.GRPBL1.BIT.IS9)
ffc0502f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05034:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05038:	7c 95                         	btst	#9, r5
ffc0503a:	3a 56 fe                      	beq.w	ffc04e90 <_Reset_Vector+0xffc04e94>
ffc0503d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05040:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05046:	66 02                         	mov.l	#0, r2
ffc05048:	75 41 3c                      	mov.l	#60, r1
ffc0504b:	05 fd ec ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0504f <.LVL33>:
    if (1 == ICU.GRPBL1.BIT.IS10)
ffc0504f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05054:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05058:	7c a5                         	btst	#10, r5
ffc0505a:	3a 46 fe                      	beq.w	ffc04ea0 <_Reset_Vector+0xffc04ea4>
ffc0505d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05060:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05066:	66 02                         	mov.l	#0, r2
ffc05068:	75 41 3d                      	mov.l	#61, r1
ffc0506b:	05 dd ec ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0506f <.LVL34>:
    if (1 == ICU.GRPBL1.BIT.IS11)
ffc0506f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05074:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05078:	7c b5                         	btst	#11, r5
ffc0507a:	3a 36 fe                      	beq.w	ffc04eb0 <_Reset_Vector+0xffc04eb4>
ffc0507d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05080:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05086:	66 02                         	mov.l	#0, r2
ffc05088:	75 41 3e                      	mov.l	#62, r1
ffc0508b:	05 bd ec ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0508f <.LVL35>:
    if (1 == ICU.GRPBL1.BIT.IS12)
ffc0508f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05094:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05098:	7c c5                         	btst	#12, r5
ffc0509a:	3a 26 fe                      	beq.w	ffc04ec0 <_Reset_Vector+0xffc04ec4>
ffc0509d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc050a0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc050a6:	66 02                         	mov.l	#0, r2
ffc050a8:	75 41 3f                      	mov.l	#63, r1
ffc050ab:	05 9d ec ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc050af <.LVL36>:
    if (1 == ICU.GRPBL1.BIT.IS14)
ffc050af:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc050b4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc050b8:	7c e5                         	btst	#14, r5
ffc050ba:	3a 16 fe                      	beq.w	ffc04ed0 <_Reset_Vector+0xffc04ed4>
ffc050bd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_EEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc050c0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc050c6:	66 02                         	mov.l	#0, r2
ffc050c8:	75 41 41                      	mov.l	#65, r1
ffc050cb:	05 7d ec ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc050cf <.LVL37>:
    if (1 == ICU.GRPBL1.BIT.IS13)
ffc050cf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc050d4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc050d8:	7c d5                         	btst	#13, r5
ffc050da:	3a 06 fe                      	beq.w	ffc04ee0 <_Reset_Vector+0xffc04ee4>
ffc050dd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc050e0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc050e6:	66 02                         	mov.l	#0, r2
ffc050e8:	75 41 40                      	mov.l	#64, r1
ffc050eb:	05 5d ec ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc050ef <.LVL38>:
    if (1 == ICU.GRPBL1.BIT.IS16)
ffc050ef:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc050f4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc050f8:	7d 05                         	btst	#16, r5
ffc050fa:	3a f6 fd                      	beq.w	ffc04ef0 <_Reset_Vector+0xffc04ef4>
ffc050fd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC2_EEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05100:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05106:	66 02                         	mov.l	#0, r2
ffc05108:	75 41 43                      	mov.l	#67, r1
ffc0510b:	05 3d ec ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0510f <.LVL39>:
    if (1 == ICU.GRPBL1.BIT.IS15)
ffc0510f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05114:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05118:	7c f5                         	btst	#15, r5
ffc0511a:	3a e6 fd                      	beq.w	ffc04f00 <_Reset_Vector+0xffc04f04>
ffc0511d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC2_TEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05120:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05126:	66 02                         	mov.l	#0, r2
ffc05128:	75 41 42                      	mov.l	#66, r1
ffc0512b:	05 1d ec ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0512f <.LVL40>:
    if (1 == ICU.GRPBL1.BIT.IS17)
ffc0512f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05134:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05138:	7d 15                         	btst	#17, r5
ffc0513a:	3a d6 fd                      	beq.w	ffc04f10 <_Reset_Vector+0xffc04f14>
ffc0513d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SSIE0_SSIF0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05140:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05146:	66 02                         	mov.l	#0, r2
ffc05148:	75 41 44                      	mov.l	#68, r1
ffc0514b:	05 fd eb ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0514f <.LVL41>:
    if (1 == ICU.GRPBL1.BIT.IS18)
ffc0514f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05154:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05158:	7d 25                         	btst	#18, r5
ffc0515a:	3a c6 fd                      	beq.w	ffc04f20 <_Reset_Vector+0xffc04f24>
ffc0515d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SSIE1_SSIF1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05160:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05166:	66 02                         	mov.l	#0, r2
ffc05168:	75 41 45                      	mov.l	#69, r1
ffc0516b:	05 dd eb ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0516f <.LVL42>:
    if (1 == ICU.GRPBL1.BIT.IS20)
ffc0516f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05174:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05178:	7d 45                         	btst	#20, r5
ffc0517a:	3a b6 fd                      	beq.w	ffc04f30 <_Reset_Vector+0xffc04f34>
ffc0517d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05180:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05186:	66 02                         	mov.l	#0, r2
ffc05188:	75 41 46                      	mov.l	#70, r1
ffc0518b:	05 bd eb ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0518f <.LVL43>:
    if (1 == ICU.GRPBL1.BIT.IS21)
ffc0518f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05194:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05198:	7d 55                         	btst	#21, r5
ffc0519a:	3a a6 fd                      	beq.w	ffc04f40 <_Reset_Vector+0xffc04f44>
ffc0519d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc051a0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc051a6:	66 02                         	mov.l	#0, r2
ffc051a8:	75 41 47                      	mov.l	#71, r1
ffc051ab:	05 9d eb ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc051af <.LVL44>:
    if (1 == ICU.GRPBL1.BIT.IS22)
ffc051af:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc051b4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc051b8:	7d 65                         	btst	#22, r5
ffc051ba:	3a 96 fd                      	beq.w	ffc04f50 <_Reset_Vector+0xffc04f54>
ffc051bd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPAI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc051c0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc051c6:	66 02                         	mov.l	#0, r2
ffc051c8:	75 41 48                      	mov.l	#72, r1
ffc051cb:	05 7d eb ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc051cf <.LVL45>:
    if (1 == ICU.GRPBL1.BIT.IS23)
ffc051cf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc051d4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc051d8:	7d 75                         	btst	#23, r5
ffc051da:	3a 86 fd                      	beq.w	ffc04f60 <_Reset_Vector+0xffc04f64>
ffc051dd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPBI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc051e0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc051e6:	66 02                         	mov.l	#0, r2
ffc051e8:	75 41 49                      	mov.l	#73, r1
ffc051eb:	05 5d eb ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc051ef <.LVL46>:
    if (1 == ICU.GRPBL1.BIT.IS29)
ffc051ef:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc051f4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc051f8:	7d d5                         	btst	#29, r5
ffc051fa:	3a 76 fd                      	beq.w	ffc04f70 <_Reset_Vector+0xffc04f74>
ffc051fd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC1_EEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05200:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05206:	66 02                         	mov.l	#0, r2
ffc05208:	75 41 4b                      	mov.l	#75, r1
ffc0520b:	05 3d eb ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0520f <.LVL47>:
    if (1 == ICU.GRPBL1.BIT.IS28)
ffc0520f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05214:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffc05218:	7d c5                         	btst	#28, r5
ffc0521a:	3a 64 fd                      	beq.w	ffc04f7e <_Reset_Vector+0xffc04f82>
ffc0521d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05220:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05226:	66 02                         	mov.l	#0, r2
ffc05228:	75 41 4a                      	mov.l	#74, r1
ffc0522b:	04 1d eb ff                   	bra.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0522f <.LFE12>:
ffc0522f:	03                            	nop

ffc05230 <__group_bl2_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_bl2_handler_isr, VECT(ICU,GROUPBL2))
ffc05230:	7e a1                         	push.l	r1
ffc05232:	fd 6a 01                      	mvfc	psw, r1
ffc05235:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc0523a:	61 81                         	cmp	#8, r1
ffc0523c:	22 05                         	bc.b	ffc05241 <_Reset_Vector+0xffc05245>
ffc0523e:	75 70 08                      	mvtipl	#8
ffc05241:	7f a8                         	setpsw	i
ffc05243:	fd 6a 01                      	mvfc	psw, r1
ffc05246:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc0524b:	fd 76 c1 00                   	save	r1
ffc0524f:	ef 16                         	mov.l	r1, r6
ffc05251:	39 0b 00                      	bsr.w	ffc0525c <_Reset_Vector+0xffc05260>
ffc05254:	fd 76 d6 00                   	rstr	r6
ffc05258:	7e b1                         	pop	r1
ffc0525a:	7f 95                         	rte

ffc0525c <_group_bl2_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_bl2_handler_isr (void)
{
    /* BL2 IS7 */
    if (1 == ICU.GRPBL2.BIT.IS7)
ffc0525c:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05261:	ee 55 8e 01                   	mov.l	1592[r5], r5
ffc05265:	7c 75                         	btst	#7, r5
ffc05267:	21 2f                         	bne.b	ffc05296 <_Reset_Vector+0xffc0529a>
        /* BSP_INT_SRC_BL2_POEG_POEGGAI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_POEG_POEGGAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL2 IS8 */
    if (1 == ICU.GRPBL2.BIT.IS8)
ffc05269:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0526e:	ee 55 8e 01                   	mov.l	1592[r5], r5
ffc05272:	7c 85                         	btst	#8, r5
ffc05274:	21 3e                         	bne.b	ffc052b2 <_Reset_Vector+0xffc052b6>
ffc05276:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL2_POEG_POEGGBI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_POEG_POEGGBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL2 IS9 */
    if (1 == ICU.GRPBL2.BIT.IS9)
ffc05278:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0527d:	ee 55 8e 01                   	mov.l	1592[r5], r5
ffc05281:	7c 95                         	btst	#9, r5
ffc05283:	21 4d                         	bne.b	ffc052d0 <_Reset_Vector+0xffc052d4>
ffc05285:	fc 13 00                      	nop	; max	r0, r0
        /* BSP_INT_SRC_BL2_POEG_POEGGCI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_POEG_POEGGCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL2 IS10 */
    if (1 == ICU.GRPBL2.BIT.IS10)
ffc05288:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0528d:	ee 55 8e 01                   	mov.l	1592[r5], r5
ffc05291:	7c a5                         	btst	#10, r5
ffc05293:	21 5d                         	bne.b	ffc052f0 <_Reset_Vector+0xffc052f4>
    {
        /* BSP_INT_SRC_BL2_POEG_POEGGDI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_POEG_POEGGDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_bl2_handler_isr() */
ffc05295:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_POEG_POEGGAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05296:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0529c:	66 02                         	mov.l	#0, r2
ffc0529e:	75 41 4d                      	mov.l	#77, r1
ffc052a1:	05 a7 ea ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc052a5 <.LVL49>:
    if (1 == ICU.GRPBL2.BIT.IS8)
ffc052a5:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc052aa:	ee 55 8e 01                   	mov.l	1592[r5], r5
ffc052ae:	7c 85                         	btst	#8, r5
ffc052b0:	20 c8                         	beq.b	ffc05278 <_Reset_Vector+0xffc0527c>
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_POEG_POEGGBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc052b2:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc052b8:	66 02                         	mov.l	#0, r2
ffc052ba:	75 41 4e                      	mov.l	#78, r1
ffc052bd:	05 8b ea ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc052c1 <.LVL50>:
    if (1 == ICU.GRPBL2.BIT.IS9)
ffc052c1:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc052c6:	ee 55 8e 01                   	mov.l	1592[r5], r5
ffc052ca:	7c 95                         	btst	#9, r5
ffc052cc:	20 bc                         	beq.b	ffc05288 <_Reset_Vector+0xffc0528c>
ffc052ce:	ef 00                         	nop	; mov.l	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_POEG_POEGGCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc052d0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc052d6:	66 02                         	mov.l	#0, r2
ffc052d8:	75 41 4f                      	mov.l	#79, r1
ffc052db:	05 6d ea ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc052df <.LVL51>:
    if (1 == ICU.GRPBL2.BIT.IS10)
ffc052df:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc052e4:	ee 55 8e 01                   	mov.l	1592[r5], r5
ffc052e8:	7c a5                         	btst	#10, r5
ffc052ea:	20 ab                         	beq.b	ffc05295 <_Reset_Vector+0xffc05299>
ffc052ec:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_POEG_POEGGDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc052f0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc052f6:	66 02                         	mov.l	#0, r2
ffc052f8:	75 41 50                      	mov.l	#80, r1
ffc052fb:	04 4d ea ff                   	bra.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc052ff <.LFE13>:
ffc052ff:	03                            	nop

ffc05300 <__group_al0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_al0_handler_isr, VECT(ICU,GROUPAL0))
ffc05300:	7e a1                         	push.l	r1
ffc05302:	fd 6a 01                      	mvfc	psw, r1
ffc05305:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc0530a:	61 81                         	cmp	#8, r1
ffc0530c:	22 05                         	bc.b	ffc05311 <_Reset_Vector+0xffc05315>
ffc0530e:	75 70 08                      	mvtipl	#8
ffc05311:	7f a8                         	setpsw	i
ffc05313:	fd 6a 01                      	mvfc	psw, r1
ffc05316:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc0531b:	fd 76 c1 00                   	save	r1
ffc0531f:	ef 16                         	mov.l	r1, r6
ffc05321:	39 0b 00                      	bsr.w	ffc0532c <_Reset_Vector+0xffc05330>
ffc05324:	fd 76 d6 00                   	rstr	r6
ffc05328:	7e b1                         	pop	r1
ffc0532a:	7f 95                         	rte

ffc0532c <_group_al0_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_al0_handler_isr (void)
{
    /* AL0 IS1 */
    if (1 == ICU.GRPAL0.BIT.IS1)
ffc0532c:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05331:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05335:	7c 15                         	btst	#1, r5
ffc05337:	3b f0 00                      	bne.w	ffc05427 <_Reset_Vector+0xffc0542b>
        /* BSP_INT_SRC_AL0_SCI8_ERI8 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI8_ERI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS0 */
    if (1 == ICU.GRPAL0.BIT.IS0)
ffc0533a:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0533f:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05343:	7c 05                         	btst	#0, r5
ffc05345:	3b 03 01                      	bne.w	ffc05448 <_Reset_Vector+0xffc0544c>
        /* BSP_INT_SRC_AL0_SCI8_TEI8 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI8_TEI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS5 */
    if (1 == ICU.GRPAL0.BIT.IS5)
ffc05348:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0534d:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05351:	7c 55                         	btst	#5, r5
ffc05353:	3b 15 01                      	bne.w	ffc05468 <_Reset_Vector+0xffc0546c>
ffc05356:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI9_ERI9 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI9_ERI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS4 */
    if (1 == ICU.GRPAL0.BIT.IS4)
ffc05358:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0535d:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05361:	7c 45                         	btst	#4, r5
ffc05363:	3b 25 01                      	bne.w	ffc05488 <_Reset_Vector+0xffc0548c>
ffc05366:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI9_TEI9 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI9_TEI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS9 */
    if (1 == ICU.GRPAL0.BIT.IS9)
ffc05368:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0536d:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05371:	7c 95                         	btst	#9, r5
ffc05373:	3b 35 01                      	bne.w	ffc054a8 <_Reset_Vector+0xffc054ac>
ffc05376:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI10_ERI10 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI10_ERI10, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS8 */
    if (1 == ICU.GRPAL0.BIT.IS8)
ffc05378:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0537d:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05381:	7c 85                         	btst	#8, r5
ffc05383:	3b 45 01                      	bne.w	ffc054c8 <_Reset_Vector+0xffc054cc>
ffc05386:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI10_TEI10 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI10_TEI10, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS13 */
    if (1 == ICU.GRPAL0.BIT.IS13)
ffc05388:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0538d:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05391:	7c d5                         	btst	#13, r5
ffc05393:	3b 55 01                      	bne.w	ffc054e8 <_Reset_Vector+0xffc054ec>
ffc05396:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI11_ERI11 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_ERI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS12 */
    if (1 == ICU.GRPAL0.BIT.IS12)
ffc05398:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0539d:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc053a1:	7c c5                         	btst	#12, r5
ffc053a3:	3b 65 01                      	bne.w	ffc05508 <_Reset_Vector+0xffc0550c>
ffc053a6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI11_TEI11 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_TEI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS17 */
    if (1 == ICU.GRPAL0.BIT.IS17)
ffc053a8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc053ad:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc053b1:	7d 15                         	btst	#17, r5
ffc053b3:	3b 75 01                      	bne.w	ffc05528 <_Reset_Vector+0xffc0552c>
ffc053b6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI0_SPEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS16 */
    if (1 == ICU.GRPAL0.BIT.IS16)
ffc053b8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc053bd:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc053c1:	7d 05                         	btst	#16, r5
ffc053c3:	3b 85 01                      	bne.w	ffc05548 <_Reset_Vector+0xffc0554c>
ffc053c6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI0_SPII0 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPII0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS19 */
    if (1 == ICU.GRPAL0.BIT.IS19)
ffc053c8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc053cd:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc053d1:	7d 35                         	btst	#19, r5
ffc053d3:	3b 95 01                      	bne.w	ffc05568 <_Reset_Vector+0xffc0556c>
ffc053d6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI1_SPEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI1_SPEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS18 */
    if (1 == ICU.GRPAL0.BIT.IS18)
ffc053d8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc053dd:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc053e1:	7d 25                         	btst	#18, r5
ffc053e3:	3b a5 01                      	bne.w	ffc05588 <_Reset_Vector+0xffc0558c>
ffc053e6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI1_SPII1 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI1_SPII1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS21 */
    if (1 == ICU.GRPAL0.BIT.IS21)
ffc053e8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc053ed:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc053f1:	7d 55                         	btst	#21, r5
ffc053f3:	3b b5 01                      	bne.w	ffc055a8 <_Reset_Vector+0xffc055ac>
ffc053f6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI2_SPEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI2_SPEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS20 */
    if (1 == ICU.GRPAL0.BIT.IS20)
ffc053f8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc053fd:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05401:	7d 45                         	btst	#20, r5
ffc05403:	3b c5 01                      	bne.w	ffc055c8 <_Reset_Vector+0xffc055cc>
ffc05406:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI2_SPII2 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI2_SPII2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS23 */
    if (1 == ICU.GRPAL0.BIT.IS23)
ffc05408:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0540d:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05411:	7d 75                         	btst	#23, r5
ffc05413:	3b d5 01                      	bne.w	ffc055e8 <_Reset_Vector+0xffc055ec>
ffc05416:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI7_ERI7 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI7_ERI7, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS22 */
    if (1 == ICU.GRPAL0.BIT.IS22)
ffc05418:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0541d:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05421:	7d 65                         	btst	#22, r5
ffc05423:	3b e5 01                      	bne.w	ffc05608 <_Reset_Vector+0xffc0560c>
    {
        /* BSP_INT_SRC_AL0_SCI7_TEI7 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI7_TEI7, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_al0_handler_isr() */
ffc05426:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI8_ERI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05427:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0542d:	66 02                         	mov.l	#0, r2
ffc0542f:	75 41 53                      	mov.l	#83, r1
ffc05432:	05 16 e9 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05436 <.LVL53>:
    if (1 == ICU.GRPAL0.BIT.IS0)
ffc05436:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0543b:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc0543f:	7c 05                         	btst	#0, r5
ffc05441:	3a 07 ff                      	beq.w	ffc05348 <_Reset_Vector+0xffc0534c>
ffc05444:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI8_TEI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05448:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0544e:	66 02                         	mov.l	#0, r2
ffc05450:	75 41 52                      	mov.l	#82, r1
ffc05453:	05 f5 e8 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05457 <.LVL54>:
    if (1 == ICU.GRPAL0.BIT.IS5)
ffc05457:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0545c:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05460:	7c 55                         	btst	#5, r5
ffc05462:	3a f6 fe                      	beq.w	ffc05358 <_Reset_Vector+0xffc0535c>
ffc05465:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI9_ERI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05468:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0546e:	66 02                         	mov.l	#0, r2
ffc05470:	75 41 55                      	mov.l	#85, r1
ffc05473:	05 d5 e8 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05477 <.LVL55>:
    if (1 == ICU.GRPAL0.BIT.IS4)
ffc05477:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0547c:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05480:	7c 45                         	btst	#4, r5
ffc05482:	3a e6 fe                      	beq.w	ffc05368 <_Reset_Vector+0xffc0536c>
ffc05485:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI9_TEI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05488:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0548e:	66 02                         	mov.l	#0, r2
ffc05490:	75 41 54                      	mov.l	#84, r1
ffc05493:	05 b5 e8 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05497 <.LVL56>:
    if (1 == ICU.GRPAL0.BIT.IS9)
ffc05497:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0549c:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc054a0:	7c 95                         	btst	#9, r5
ffc054a2:	3a d6 fe                      	beq.w	ffc05378 <_Reset_Vector+0xffc0537c>
ffc054a5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI10_ERI10, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc054a8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc054ae:	66 02                         	mov.l	#0, r2
ffc054b0:	75 41 57                      	mov.l	#87, r1
ffc054b3:	05 95 e8 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc054b7 <.LVL57>:
    if (1 == ICU.GRPAL0.BIT.IS8)
ffc054b7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc054bc:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc054c0:	7c 85                         	btst	#8, r5
ffc054c2:	3a c6 fe                      	beq.w	ffc05388 <_Reset_Vector+0xffc0538c>
ffc054c5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI10_TEI10, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc054c8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc054ce:	66 02                         	mov.l	#0, r2
ffc054d0:	75 41 56                      	mov.l	#86, r1
ffc054d3:	05 75 e8 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc054d7 <.LVL58>:
    if (1 == ICU.GRPAL0.BIT.IS13)
ffc054d7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc054dc:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc054e0:	7c d5                         	btst	#13, r5
ffc054e2:	3a b6 fe                      	beq.w	ffc05398 <_Reset_Vector+0xffc0539c>
ffc054e5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_ERI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc054e8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc054ee:	66 02                         	mov.l	#0, r2
ffc054f0:	75 41 59                      	mov.l	#89, r1
ffc054f3:	05 55 e8 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc054f7 <.LVL59>:
    if (1 == ICU.GRPAL0.BIT.IS12)
ffc054f7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc054fc:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05500:	7c c5                         	btst	#12, r5
ffc05502:	3a a6 fe                      	beq.w	ffc053a8 <_Reset_Vector+0xffc053ac>
ffc05505:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_TEI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05508:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0550e:	66 02                         	mov.l	#0, r2
ffc05510:	75 41 58                      	mov.l	#88, r1
ffc05513:	05 35 e8 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05517 <.LVL60>:
    if (1 == ICU.GRPAL0.BIT.IS17)
ffc05517:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0551c:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05520:	7d 15                         	btst	#17, r5
ffc05522:	3a 96 fe                      	beq.w	ffc053b8 <_Reset_Vector+0xffc053bc>
ffc05525:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05528:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0552e:	66 02                         	mov.l	#0, r2
ffc05530:	75 41 5b                      	mov.l	#91, r1
ffc05533:	05 15 e8 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05537 <.LVL61>:
    if (1 == ICU.GRPAL0.BIT.IS16)
ffc05537:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0553c:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05540:	7d 05                         	btst	#16, r5
ffc05542:	3a 86 fe                      	beq.w	ffc053c8 <_Reset_Vector+0xffc053cc>
ffc05545:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPII0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05548:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0554e:	66 02                         	mov.l	#0, r2
ffc05550:	75 41 5a                      	mov.l	#90, r1
ffc05553:	05 f5 e7 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05557 <.LVL62>:
    if (1 == ICU.GRPAL0.BIT.IS19)
ffc05557:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0555c:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05560:	7d 35                         	btst	#19, r5
ffc05562:	3a 76 fe                      	beq.w	ffc053d8 <_Reset_Vector+0xffc053dc>
ffc05565:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI1_SPEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05568:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0556e:	66 02                         	mov.l	#0, r2
ffc05570:	75 41 5d                      	mov.l	#93, r1
ffc05573:	05 d5 e7 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05577 <.LVL63>:
    if (1 == ICU.GRPAL0.BIT.IS18)
ffc05577:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0557c:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05580:	7d 25                         	btst	#18, r5
ffc05582:	3a 66 fe                      	beq.w	ffc053e8 <_Reset_Vector+0xffc053ec>
ffc05585:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI1_SPII1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05588:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0558e:	66 02                         	mov.l	#0, r2
ffc05590:	75 41 5c                      	mov.l	#92, r1
ffc05593:	05 b5 e7 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05597 <.LVL64>:
    if (1 == ICU.GRPAL0.BIT.IS21)
ffc05597:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0559c:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc055a0:	7d 55                         	btst	#21, r5
ffc055a2:	3a 56 fe                      	beq.w	ffc053f8 <_Reset_Vector+0xffc053fc>
ffc055a5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI2_SPEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc055a8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc055ae:	66 02                         	mov.l	#0, r2
ffc055b0:	75 41 5f                      	mov.l	#95, r1
ffc055b3:	05 95 e7 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc055b7 <.LVL65>:
    if (1 == ICU.GRPAL0.BIT.IS20)
ffc055b7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc055bc:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc055c0:	7d 45                         	btst	#20, r5
ffc055c2:	3a 46 fe                      	beq.w	ffc05408 <_Reset_Vector+0xffc0540c>
ffc055c5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI2_SPII2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc055c8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc055ce:	66 02                         	mov.l	#0, r2
ffc055d0:	75 41 5e                      	mov.l	#94, r1
ffc055d3:	05 75 e7 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc055d7 <.LVL66>:
    if (1 == ICU.GRPAL0.BIT.IS23)
ffc055d7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc055dc:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc055e0:	7d 75                         	btst	#23, r5
ffc055e2:	3a 36 fe                      	beq.w	ffc05418 <_Reset_Vector+0xffc0541c>
ffc055e5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI7_ERI7, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc055e8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc055ee:	66 02                         	mov.l	#0, r2
ffc055f0:	75 41 61                      	mov.l	#97, r1
ffc055f3:	05 55 e7 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc055f7 <.LVL67>:
    if (1 == ICU.GRPAL0.BIT.IS22)
ffc055f7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc055fc:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffc05600:	7d 65                         	btst	#22, r5
ffc05602:	3a 24 fe                      	beq.w	ffc05426 <_Reset_Vector+0xffc0542a>
ffc05605:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI7_TEI7, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05608:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0560e:	66 02                         	mov.l	#0, r2
ffc05610:	75 41 60                      	mov.l	#96, r1
ffc05613:	04 35 e7 ff                   	bra.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05617 <.LFE14>:
ffc05617:	03                            	nop

ffc05618 <__group_al1_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_al1_handler_isr, VECT(ICU,GROUPAL1))
ffc05618:	7e a1                         	push.l	r1
ffc0561a:	fd 6a 01                      	mvfc	psw, r1
ffc0561d:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05622:	61 81                         	cmp	#8, r1
ffc05624:	22 05                         	bc.b	ffc05629 <_Reset_Vector+0xffc0562d>
ffc05626:	75 70 08                      	mvtipl	#8
ffc05629:	7f a8                         	setpsw	i
ffc0562b:	fd 6a 01                      	mvfc	psw, r1
ffc0562e:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05633:	fd 76 c1 00                   	save	r1
ffc05637:	ef 16                         	mov.l	r1, r6
ffc05639:	39 0b 00                      	bsr.w	ffc05644 <_Reset_Vector+0xffc05648>
ffc0563c:	fd 76 d6 00                   	rstr	r6
ffc05640:	7e b1                         	pop	r1
ffc05642:	7f 95                         	rte

ffc05644 <_group_al1_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_al1_handler_isr (void)
{
    /* AL1 IS4 */
    if (1 == ICU.GRPAL1.BIT.IS4)
ffc05644:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05649:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc0564d:	7c 45                         	btst	#4, r5
ffc0564f:	21 3f                         	bne.b	ffc0568e <_Reset_Vector+0xffc05692>
        /* BSP_INT_SRC_AL1_EDMAC0_EINT0 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_EDMAC0_EINT0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL1 IS9 */
    if (1 == ICU.GRPAL1.BIT.IS9)
ffc05651:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05656:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc0565a:	7c 95                         	btst	#9, r5
ffc0565c:	21 4e                         	bne.b	ffc056aa <_Reset_Vector+0xffc056ae>
ffc0565e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL1_GLCDC_GR1UF */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_GR1UF, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL1 IS10 */
    if (1 == ICU.GRPAL1.BIT.IS10)
ffc05660:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05665:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc05669:	7c a5                         	btst	#10, r5
ffc0566b:	21 5d                         	bne.b	ffc056c8 <_Reset_Vector+0xffc056cc>
ffc0566d:	fc 13 00                      	nop	; max	r0, r0
        /* BSP_INT_SRC_AL1_GLCDC_GR2UF */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_GR2UF, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL1 IS8 */
    if (1 == ICU.GRPAL1.BIT.IS8)
ffc05670:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05675:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc05679:	7c 85                         	btst	#8, r5
ffc0567b:	21 6d                         	bne.b	ffc056e8 <_Reset_Vector+0xffc056ec>
ffc0567d:	fc 13 00                      	nop	; max	r0, r0
        /* BSP_INT_SRC_AL1_GLCDC_VPOS */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_VPOS, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL1 IS11 */
    if (1 == ICU.GRPAL1.BIT.IS11)
ffc05680:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05685:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc05689:	7c b5                         	btst	#11, r5
ffc0568b:	21 7d                         	bne.b	ffc05708 <_Reset_Vector+0xffc0570c>
    {
        /* BSP_INT_SRC_AL1_DRW2D_DRW_IRQ */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_DRW2D_DRW_IRQ, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_al1_handler_isr() */
ffc0568d:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_EDMAC0_EINT0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc0568e:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc05694:	66 02                         	mov.l	#0, r2
ffc05696:	75 41 63                      	mov.l	#99, r1
ffc05699:	05 af e6 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0569d <.LVL69>:
    if (1 == ICU.GRPAL1.BIT.IS9)
ffc0569d:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc056a2:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc056a6:	7c 95                         	btst	#9, r5
ffc056a8:	20 b8                         	beq.b	ffc05660 <_Reset_Vector+0xffc05664>
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_GR1UF, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc056aa:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc056b0:	66 02                         	mov.l	#0, r2
ffc056b2:	75 41 65                      	mov.l	#101, r1
ffc056b5:	05 93 e6 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc056b9 <.LVL70>:
    if (1 == ICU.GRPAL1.BIT.IS10)
ffc056b9:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc056be:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc056c2:	7c a5                         	btst	#10, r5
ffc056c4:	20 ac                         	beq.b	ffc05670 <_Reset_Vector+0xffc05674>
ffc056c6:	ef 00                         	nop	; mov.l	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_GR2UF, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc056c8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc056ce:	66 02                         	mov.l	#0, r2
ffc056d0:	75 41 66                      	mov.l	#102, r1
ffc056d3:	05 75 e6 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc056d7 <.LVL71>:
    if (1 == ICU.GRPAL1.BIT.IS8)
ffc056d7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc056dc:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc056e0:	7c 85                         	btst	#8, r5
ffc056e2:	20 9e                         	beq.b	ffc05680 <_Reset_Vector+0xffc05684>
ffc056e4:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_VPOS, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc056e8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc056ee:	66 02                         	mov.l	#0, r2
ffc056f0:	75 41 64                      	mov.l	#100, r1
ffc056f3:	05 55 e6 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc056f7 <.LVL72>:
    if (1 == ICU.GRPAL1.BIT.IS11)
ffc056f7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc056fc:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffc05700:	7c b5                         	btst	#11, r5
ffc05702:	20 8b                         	beq.b	ffc0568d <_Reset_Vector+0xffc05691>
ffc05704:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_DRW2D_DRW_IRQ, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05708:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffc0570e:	66 02                         	mov.l	#0, r2
ffc05710:	75 41 67                      	mov.l	#103, r1
ffc05713:	04 35 e6 ff                   	bra.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05717 <.LFE15>:
ffc05717:	03                            	nop

ffc05718 <__group_ie0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_ie0_handler_isr, VECT(ICU,GROUPIE0))
ffc05718:	7e a1                         	push.l	r1
ffc0571a:	fd 6a 01                      	mvfc	psw, r1
ffc0571d:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05722:	61 81                         	cmp	#8, r1
ffc05724:	22 05                         	bc.b	ffc05729 <_Reset_Vector+0xffc0572d>
ffc05726:	75 70 08                      	mvtipl	#8
ffc05729:	7f a8                         	setpsw	i
ffc0572b:	fd 6a 01                      	mvfc	psw, r1
ffc0572e:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05733:	fd 76 c1 00                   	save	r1
ffc05737:	ef 16                         	mov.l	r1, r6
ffc05739:	39 0b 00                      	bsr.w	ffc05744 <_Reset_Vector+0xffc05748>
ffc0573c:	fd 76 d6 00                   	rstr	r6
ffc05740:	7e b1                         	pop	r1
ffc05742:	7f 95                         	rte

ffc05744 <_group_ie0_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_ie0_handler_isr (void)
{
    /* IE0 IS0 */
    if (1 == ICU.GRPIE0.BIT.IS0)
ffc05744:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc05749:	ee 54 6c 01                   	mov.l	1456[r5], r4
ffc0574d:	7c 04                         	btst	#0, r4
ffc0574f:	21 03                         	bne.b	ffc05752 <_Reset_Vector+0xffc05756>
        ICU.GCRIE0.BIT.CLR0 = 1;

        /* BSP_INT_SRC_IE0_DPFPU_DPFPUEX */
        R_BSP_InterruptControl(BSP_INT_SRC_IE0_DPFPU_DPFPUEX, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_ie0_handler_isr() */
ffc05751:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_IE0_DPFPU_DPFPUEX, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05752:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
        ICU.GCRIE0.BIT.CLR0 = 1;
ffc05758:	ee 54 6e 01                   	mov.l	1464[r5], r4
        R_BSP_InterruptControl(BSP_INT_SRC_IE0_DPFPU_DPFPUEX, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc0575c:	66 02                         	mov.l	#0, r2
ffc0575e:	75 41 14                      	mov.l	#20, r1
        ICU.GCRIE0.BIT.CLR0 = 1;
ffc05761:	78 04                         	bset	#0, r4
ffc05763:	eb 54 6e 01                   	mov.l	r4, 1464[r5]
        R_BSP_InterruptControl(BSP_INT_SRC_IE0_DPFPU_DPFPUEX, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05767:	04 e1 e5 ff                   	bra.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc0576b <.LFE16>:
ffc0576b:	00                            	brk
ffc0576c:	00                            	brk
ffc0576d:	00                            	brk
	...

ffc05770 <__group_be0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_be0_handler_isr, VECT(ICU,GROUPBE0))
ffc05770:	7e a1                         	push.l	r1
ffc05772:	fd 6a 01                      	mvfc	psw, r1
ffc05775:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc0577a:	61 81                         	cmp	#8, r1
ffc0577c:	22 05                         	bc.b	ffc05781 <_Reset_Vector+0xffc05785>
ffc0577e:	75 70 08                      	mvtipl	#8
ffc05781:	7f a8                         	setpsw	i
ffc05783:	fd 6a 01                      	mvfc	psw, r1
ffc05786:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc0578b:	fd 76 c1 00                   	save	r1
ffc0578f:	ef 16                         	mov.l	r1, r6
ffc05791:	39 0b 00                      	bsr.w	ffc0579c <_Reset_Vector+0xffc057a0>
ffc05794:	fd 76 d6 00                   	rstr	r6
ffc05798:	7e b1                         	pop	r1
ffc0579a:	7f 95                         	rte

ffc0579c <_group_be0_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_be0_handler_isr (void)
{
    /* BE0 IS0 */
    if (1 == ICU.GRPBE0.BIT.IS0)
ffc0579c:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc057a1:	ee 54 80 01                   	mov.l	1536[r5], r4
ffc057a5:	7c 04                         	btst	#0, r4
ffc057a7:	21 1f                         	bne.b	ffc057c6 <_Reset_Vector+0xffc057ca>
        /* BSP_INT_SRC_BE0_CAN0_ERS0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BE0 IS1 */
    if (1 == ICU.GRPBE0.BIT.IS1)
ffc057a9:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc057ae:	ee 54 80 01                   	mov.l	1536[r5], r4
ffc057b2:	7c 14                         	btst	#1, r4
ffc057b4:	21 3c                         	bne.b	ffc057f0 <_Reset_Vector+0xffc057f4>
ffc057b6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BE0_CAN1_ERS1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN1_ERS1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BE0 IS2 */
    if (1 == ICU.GRPBE0.BIT.IS2)
ffc057b8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc057bd:	ee 54 80 01                   	mov.l	1536[r5], r4
ffc057c1:	7c 24                         	btst	#2, r4
ffc057c3:	21 55                         	bne.b	ffc05818 <_Reset_Vector+0xffc0581c>
        ICU.GCRBE0.BIT.CLR2 = 1;

        /* BSP_INT_SRC_BE0_CAN2_ERS2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN2_ERS2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_be0_handler_isr() */
ffc057c5:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc057c6:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
        ICU.GCRBE0.BIT.CLR0 = 1;
ffc057cc:	ee 54 a0 01                   	mov.l	1664[r5], r4
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc057d0:	66 02                         	mov.l	#0, r2
ffc057d2:	75 41 16                      	mov.l	#22, r1
        ICU.GCRBE0.BIT.CLR0 = 1;
ffc057d5:	78 04                         	bset	#0, r4
ffc057d7:	eb 54 a0 01                   	mov.l	r4, 1664[r5]
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc057db:	05 6d e5 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc057df <.LVL75>:
    if (1 == ICU.GRPBE0.BIT.IS1)
ffc057df:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc057e4:	ee 54 80 01                   	mov.l	1536[r5], r4
ffc057e8:	7c 14                         	btst	#1, r4
ffc057ea:	20 ce                         	beq.b	ffc057b8 <_Reset_Vector+0xffc057bc>
ffc057ec:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN1_ERS1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc057f0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
        ICU.GCRBE0.BIT.CLR1 = 1;
ffc057f6:	ee 54 a0 01                   	mov.l	1664[r5], r4
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN1_ERS1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc057fa:	66 02                         	mov.l	#0, r2
ffc057fc:	75 41 17                      	mov.l	#23, r1
        ICU.GCRBE0.BIT.CLR1 = 1;
ffc057ff:	78 14                         	bset	#1, r4
ffc05801:	eb 54 a0 01                   	mov.l	r4, 1664[r5]
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN1_ERS1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05805:	05 43 e5 ff                   	bsr.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05809 <.LVL76>:
    if (1 == ICU.GRPBE0.BIT.IS2)
ffc05809:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffc0580e:	ee 54 80 01                   	mov.l	1536[r5], r4
ffc05812:	7c 24                         	btst	#2, r4
ffc05814:	20 b1                         	beq.b	ffc057c5 <_Reset_Vector+0xffc057c9>
ffc05816:	ef 00                         	nop	; mov.l	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN2_ERS2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05818:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
        ICU.GCRBE0.BIT.CLR2 = 1;
ffc0581e:	ee 54 a0 01                   	mov.l	1664[r5], r4
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN2_ERS2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc05822:	66 02                         	mov.l	#0, r2
ffc05824:	75 41 18                      	mov.l	#24, r1
        ICU.GCRBE0.BIT.CLR2 = 1;
ffc05827:	78 24                         	bset	#2, r4
ffc05829:	eb 54 a0 01                   	mov.l	r4, 1664[r5]
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN2_ERS2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffc0582d:	04 1b e5 ff                   	bra.a	ffc03d48 <_Reset_Vector+0xffc03d4c>

ffc05831 <.LFE17>:
ffc05831:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc05838 <_r_Config_SCI0_transmit_interrupt>:
void r_Config_SCI0_transmit_interrupt(void)
ffc05838:	7e a1                         	push.l	r1
ffc0583a:	fd 6a 01                      	mvfc	psw, r1
ffc0583d:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05842:	61 81                         	cmp	#8, r1
ffc05844:	22 05                         	bc.b	ffc05849 <_Reset_Vector+0xffc0584d>
ffc05846:	75 70 08                      	mvtipl	#8
ffc05849:	7f a8                         	setpsw	i
ffc0584b:	fd 6a 01                      	mvfc	psw, r1
ffc0584e:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05853:	fd 76 c1 00                   	save	r1
ffc05857:	ef 16                         	mov.l	r1, r6
ffc05859:	39 0b 00                      	bsr.w	ffc05864 <_Reset_Vector+0xffc05868>
ffc0585c:	fd 76 d6 00                   	rstr	r6
ffc05860:	7e b1                         	pop	r1
ffc05862:	7f 95                         	rte

ffc05864 <__r_Config_SCI0_transmit_interrupt>:
    if (1U == SCI0.SISR.BIT.IICACKR)
ffc05864:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffc05869:	8b 54                         	mov.b	12[r5], r4
ffc0586b:	7c 04                         	btst	#0, r4
ffc0586d:	20 23                         	beq.b	ffc05890 <_Reset_Vector+0xffc05894>
        *gp_sci0_rx_address = SCI0.RDR;
ffc0586f:	fb 42 80 08 00 00             	mov.l	#0x880, r4
ffc05875:	89 5b                         	mov.b	5[r5], r3
ffc05877:	ec 45                         	mov.l	[r4], r5
        g_sci0_rx_count++;
ffc05879:	fb 22 8a 08 00 00             	mov.l	#0x88a, r2
        *gp_sci0_rx_address = SCI0.RDR;
ffc0587f:	c3 53                         	mov.b	r3, [r5]
        gp_sci0_rx_address++;
ffc05881:	ec 43                         	mov.l	[r4], r3
        g_sci0_rx_count++;
ffc05883:	dc 25                         	mov.w	[r2], r5
        gp_sci0_rx_address++;
ffc05885:	62 13                         	add	#1, r3
        g_sci0_rx_count++;
ffc05887:	62 15                         	add	#1, r5
        gp_sci0_rx_address++;
ffc05889:	e3 43                         	mov.l	r3, [r4]
        g_sci0_rx_count++;
ffc0588b:	d3 25                         	mov.w	r5, [r2]
ffc0588d:	fc 13 00                      	nop	; max	r0, r0
    g_sci0_iic_cycle_flag = _00_SCI_IIC_STOP_CYCLE;
ffc05890:	fb 52 89 08 00 00             	mov.l	#0x889, r5
ffc05896:	f8 54 00                      	mov.b	#0, [r5]
    R_Config_SCI0_IIC_StopCondition();
ffc05899:	04 82 eb ff                   	bra.a	ffc0441b <_Reset_Vector+0xffc0441f>

ffc0589d <.LFE5>:
ffc0589d:	fc 13 00                      	nop	; max	r0, r0

ffc058a0 <_r_Config_SCI0_receive_interrupt>:
* Description  : This function is RXI0 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_SCI0_receive_interrupt(void)
ffc058a0:	7e a1                         	push.l	r1
ffc058a2:	fd 6a 01                      	mvfc	psw, r1
ffc058a5:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc058aa:	61 81                         	cmp	#8, r1
ffc058ac:	22 05                         	bc.b	ffc058b1 <_Reset_Vector+0xffc058b5>
ffc058ae:	75 70 08                      	mvtipl	#8
ffc058b1:	7f a8                         	setpsw	i
ffc058b3:	fd 6a 01                      	mvfc	psw, r1
ffc058b6:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc058bb:	fd 76 c1 00                   	save	r1
ffc058bf:	ef 16                         	mov.l	r1, r6
ffc058c1:	39 0b 00                      	bsr.w	ffc058cc <_Reset_Vector+0xffc058d0>
ffc058c4:	fd 76 d6 00                   	rstr	r6
ffc058c8:	7e b1                         	pop	r1
ffc058ca:	7f 95                         	rte

ffc058cc <__r_Config_SCI0_receive_interrupt>:
{
    volatile uint8_t dummy;

    if (0U == SCI0.SISR.BIT.IICACKR)
ffc058cc:	fb 4e 00 a0 08                	mov.l	#0x8a000, r4
ffc058d1:	8b 45                         	mov.b	12[r4], r5
ffc058d3:	7c 05                         	btst	#0, r5
ffc058d5:	3b 92 00                      	bne.w	ffc05967 <_Reset_Vector+0xffc0596b>
    {
        if (_80_SCI_IIC_TRANSMISSION == g_sci0_iic_transmit_receive_flag)
ffc058d8:	fb 32 84 08 00 00             	mov.l	#0x884, r3
ffc058de:	58 35                         	movu.b	[r3], r5
ffc058e0:	75 55 80                      	cmp	#128, r5
ffc058e3:	20 62                         	beq.b	ffc05945 <_Reset_Vector+0xffc05949>
                /* Generate stop condition */
                g_sci0_iic_cycle_flag = _00_SCI_IIC_STOP_CYCLE;
                R_Config_SCI0_IIC_StopCondition();
            }
        }
        else if (_00_SCI_IIC_RECEPTION == g_sci0_iic_transmit_receive_flag)
ffc058e5:	58 35                         	movu.b	[r3], r5
ffc058e7:	61 05                         	cmp	#0, r5
ffc058e9:	21 5b                         	bne.b	ffc05944 <_Reset_Vector+0xffc05948>
        {
            if (0U == SCI0.SIMR2.BIT.IICACKT)
ffc058eb:	8a c5                         	mov.b	10[r4], r5
ffc058ed:	7c 55                         	btst	#5, r5
ffc058ef:	3b 85 00                      	bne.w	ffc05974 <_Reset_Vector+0xffc05978>
            {
                if (g_sci0_rx_length > g_sci0_rx_count)
ffc058f2:	fb 22 90 08 00 00             	mov.l	#0x890, r2
ffc058f8:	fb 32 8a 08 00 00             	mov.l	#0x88a, r3
ffc058fe:	dc 21                         	mov.w	[r2], r1
ffc05900:	dc 35                         	mov.w	[r3], r5
ffc05902:	5f 11                         	movu.w	r1, r1
ffc05904:	5f 55                         	movu.w	r5, r5
ffc05906:	47 51                         	cmp	r5, r1
ffc05908:	25 1a                         	bleu.b	ffc05922 <_Reset_Vector+0xffc05926>
                {
                    *gp_sci0_rx_address = SCI0.RDR;
ffc0590a:	fb 12 80 08 00 00             	mov.l	#0x880, r1
ffc05910:	89 4c                         	mov.b	5[r4], r4
ffc05912:	ec 15                         	mov.l	[r1], r5
ffc05914:	c3 54                         	mov.b	r4, [r5]
                    gp_sci0_rx_address++;
ffc05916:	ec 14                         	mov.l	[r1], r4
                    g_sci0_rx_count++;
ffc05918:	dc 35                         	mov.w	[r3], r5
                    gp_sci0_rx_address++;
ffc0591a:	62 14                         	add	#1, r4
                    g_sci0_rx_count++;
ffc0591c:	62 15                         	add	#1, r5
                    gp_sci0_rx_address++;
ffc0591e:	e3 14                         	mov.l	r4, [r1]
                    g_sci0_rx_count++;
ffc05920:	d3 35                         	mov.w	r5, [r3]
            else
            {
                dummy = SCI0.RDR;
            }

            if (0U == g_sci0_rx_count)
ffc05922:	5c 35                         	movu.w	[r3], r5
ffc05924:	61 05                         	cmp	#0, r5
ffc05926:	3b 9f 00                      	bne.w	ffc059c5 <_Reset_Vector+0xffc059c9>
            {
                if(1U == g_sci0_rx_length)
ffc05929:	5c 25                         	movu.w	[r2], r5
ffc0592b:	61 15                         	cmp	#1, r5
                {
                    SCI0.SIMR2.BIT.IICACKT = 1U;
ffc0592d:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
                if(1U == g_sci0_rx_length)
ffc05932:	3a a7 00                      	beq.w	ffc059d9 <_Reset_Vector+0xffc059dd>
                }
                else
                {
                    SCI0.SIMR2.BIT.IICACKT = 0U; 
ffc05935:	f1 5d 0a                      	bclr	#5, 10[r5].b
                    SCI0.SCR.BIT.RIE = 1U;
ffc05938:	f1 56 02                      	bset	#6, 2[r5].b
            {
                /* Do nothing */
            }

            /* Write dummy */
            SCI0.TDR = 0xFFU;
ffc0593b:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffc05940:	f9 54 03 ff                   	mov.b	#255, 3[r5]
ffc05944:	02                            	rts
            if (g_sci0_tx_count > 0U)
ffc05945:	fb 32 86 08 00 00             	mov.l	#0x886, r3
ffc0594b:	5c 35                         	movu.w	[r3], r5
ffc0594d:	61 05                         	cmp	#0, r5
ffc0594f:	20 18                         	beq.b	ffc05967 <_Reset_Vector+0xffc0596b>
                SCI0.TDR = *gp_sci0_tx_address;
ffc05951:	fb 12 8c 08 00 00             	mov.l	#0x88c, r1
ffc05957:	ec 12                         	mov.l	[r1], r2
ffc05959:	fd 28 25                      	mov.b	[r2+], r5
ffc0595c:	80 cd                         	mov.b	r5, 3[r4]
                g_sci0_tx_count--;
ffc0595e:	dc 35                         	mov.w	[r3], r5
                gp_sci0_tx_address++;
ffc05960:	e3 12                         	mov.l	r2, [r1]
                g_sci0_tx_count--;
ffc05962:	60 15                         	sub	#1, r5
ffc05964:	d3 35                         	mov.w	r5, [r3]
ffc05966:	02                            	rts
        }
    }
    else
    {
        /* Generate stop condition */
        g_sci0_iic_cycle_flag = _00_SCI_IIC_STOP_CYCLE;
ffc05967:	fb 52 89 08 00 00             	mov.l	#0x889, r5
ffc0596d:	f8 54 00                      	mov.b	#0, [r5]
        R_Config_SCI0_IIC_StopCondition();
ffc05970:	04 ab ea ff                   	bra.a	ffc0441b <_Reset_Vector+0xffc0441f>

ffc05974 <.LVL1>:
{
ffc05974:	60 40                         	sub	#4, r0
                dummy = SCI0.RDR;
ffc05976:	89 4d                         	mov.b	5[r4], r5
ffc05978:	fb 22 90 08 00 00             	mov.l	#0x890, r2
ffc0597e:	fb 32 8a 08 00 00             	mov.l	#0x88a, r3
ffc05984:	c3 05                         	mov.b	r5, [r0]
            if (0U == g_sci0_rx_count)
ffc05986:	5c 35                         	movu.w	[r3], r5
ffc05988:	61 05                         	cmp	#0, r5
ffc0598a:	21 21                         	bne.b	ffc059ab <_Reset_Vector+0xffc059af>
                if(1U == g_sci0_rx_length)
ffc0598c:	5c 25                         	movu.w	[r2], r5
ffc0598e:	61 15                         	cmp	#1, r5
                    SCI0.SIMR2.BIT.IICACKT = 1U;
ffc05990:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
                if(1U == g_sci0_rx_length)
ffc05995:	20 2b                         	beq.b	ffc059c0 <_Reset_Vector+0xffc059c4>
                    SCI0.SIMR2.BIT.IICACKT = 0U; 
ffc05997:	f1 5d 0a                      	bclr	#5, 10[r5].b
                    SCI0.SCR.BIT.RIE = 1U;
ffc0599a:	f1 56 02                      	bset	#6, 2[r5].b
ffc0599d:	fc 13 00                      	nop	; max	r0, r0
            SCI0.TDR = 0xFFU;
ffc059a0:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffc059a5:	f9 54 03 ff                   	mov.b	#255, 3[r5]
    }
}
ffc059a9:	67 01                         	rtsd	#4
            else if (g_sci0_rx_length == (g_sci0_rx_count + 1))
ffc059ab:	dc 24                         	mov.w	[r2], r4
ffc059ad:	dc 35                         	mov.w	[r3], r5
ffc059af:	5f 44                         	movu.w	r4, r4
ffc059b1:	5f 55                         	movu.w	r5, r5
ffc059b3:	62 15                         	add	#1, r5
ffc059b5:	47 54                         	cmp	r5, r4
ffc059b7:	21 e9                         	bne.b	ffc059a0 <_Reset_Vector+0xffc059a4>
                 SCI0.SIMR2.BIT.IICACKT = 1U;
ffc059b9:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffc059be:	ef 00                         	nop	; mov.l	r0, r0
ffc059c0:	f1 55 0a                      	bset	#5, 10[r5].b
ffc059c3:	2e dd                         	bra.b	ffc059a0 <_Reset_Vector+0xffc059a4>
            else if (g_sci0_rx_length == (g_sci0_rx_count + 1))
ffc059c5:	dc 24                         	mov.w	[r2], r4
ffc059c7:	dc 35                         	mov.w	[r3], r5
ffc059c9:	5f 44                         	movu.w	r4, r4
ffc059cb:	5f 55                         	movu.w	r5, r5
ffc059cd:	62 15                         	add	#1, r5
ffc059cf:	47 54                         	cmp	r5, r4
ffc059d1:	3b 6a ff                      	bne.w	ffc0593b <_Reset_Vector+0xffc0593f>
                 SCI0.SIMR2.BIT.IICACKT = 1U;
ffc059d4:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffc059d9:	f1 55 0a                      	bset	#5, 10[r5].b
ffc059dc:	38 5f ff                      	bra.w	ffc0593b <_Reset_Vector+0xffc0593f>

ffc059df <.LFE8>:
ffc059df:	03                            	nop

ffc059e0 <_r_Config_RIIC0_transmit_interrupt>:
void r_Config_RIIC0_transmit_interrupt(void)
ffc059e0:	7e a1                         	push.l	r1
ffc059e2:	fd 6a 01                      	mvfc	psw, r1
ffc059e5:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc059ea:	61 81                         	cmp	#8, r1
ffc059ec:	22 05                         	bc.b	ffc059f1 <_Reset_Vector+0xffc059f5>
ffc059ee:	75 70 08                      	mvtipl	#8
ffc059f1:	7f a8                         	setpsw	i
ffc059f3:	fd 6a 01                      	mvfc	psw, r1
ffc059f6:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc059fb:	fd 76 c1 00                   	save	r1
ffc059ff:	ef 16                         	mov.l	r1, r6
ffc05a01:	39 0b 00                      	bsr.w	ffc05a0c <_Reset_Vector+0xffc05a10>
ffc05a04:	fd 76 d6 00                   	rstr	r6
ffc05a08:	7e b1                         	pop	r1
ffc05a0a:	7f 95                         	rte

ffc05a0c <__r_Config_RIIC0_transmit_interrupt>:
    if (_0D_IIC_MASTER_TRANSMIT == g_riic0_mode_flag)
ffc05a0c:	fb 42 98 08 00 00             	mov.l	#0x898, r4
ffc05a12:	58 45                         	movu.b	[r4], r5
ffc05a14:	61 d5                         	cmp	#13, r5
ffc05a16:	20 43                         	beq.b	ffc05a59 <_Reset_Vector+0xffc05a5d>
    else if (_0C_IIC_MASTER_RECEIVE == g_riic0_mode_flag)
ffc05a18:	58 45                         	movu.b	[r4], r5
ffc05a1a:	61 c5                         	cmp	#12, r5
ffc05a1c:	20 03                         	beq.b	ffc05a1f <_Reset_Vector+0xffc05a23>
}
ffc05a1e:	02                            	rts
        if (_00_IIC_MASTER_SENDS_ADR_7_R == g_riic0_state)
ffc05a1f:	fb 42 ac 08 00 00             	mov.l	#0x8ac, r4
ffc05a25:	58 45                         	movu.b	[r4], r5
ffc05a27:	61 05                         	cmp	#0, r5
ffc05a29:	20 76                         	beq.b	ffc05a9f <_Reset_Vector+0xffc05aa3>
        else if (_02_IIC_MASTER_SENDS_ADR_10A_W == g_riic0_state)
ffc05a2b:	58 45                         	movu.b	[r4], r5
ffc05a2d:	61 25                         	cmp	#2, r5
ffc05a2f:	3a dc 00                      	beq.w	ffc05b0b <_Reset_Vector+0xffc05b0f>
        else if (_04_IIC_MASTER_SENDS_ADR_10B == g_riic0_state)
ffc05a32:	58 45                         	movu.b	[r4], r5
ffc05a34:	61 45                         	cmp	#4, r5
ffc05a36:	3a c2 00                      	beq.w	ffc05af8 <_Reset_Vector+0xffc05afc>
        else if (_03_IIC_MASTER_SENDS_ADR_10A_R == g_riic0_state)
ffc05a39:	58 45                         	movu.b	[r4], r5
ffc05a3b:	61 35                         	cmp	#3, r5
ffc05a3d:	21 e1                         	bne.b	ffc05a1e <_Reset_Vector+0xffc05a22>
            RIIC0.ICDRT = (uint8_t)(((g_riic0_slave_address & 0x0300U) >> 7U) | 0x00F1U);
ffc05a3f:	fb 52 9e 08 00 00             	mov.l	#0x89e, r5
ffc05a45:	dc 55                         	mov.w	[r5], r5
ffc05a47:	68 75                         	shlr	#7, r5
ffc05a49:	64 65                         	and	#6, r5
ffc05a4b:	75 35 f1                      	or	#-15, r5
ffc05a4e:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffc05a53:	84 b5                         	mov.b	r5, 18[r3]
            g_riic0_state = _08_IIC_MASTER_RECEIVES_START;
ffc05a55:	f8 44 08                      	mov.b	#8, [r4]
}
ffc05a58:	02                            	rts
        if (_01_IIC_MASTER_SENDS_ADR_7_W == g_riic0_state)
ffc05a59:	fb 52 ac 08 00 00             	mov.l	#0x8ac, r5
ffc05a5f:	58 54                         	movu.b	[r5], r4
ffc05a61:	61 14                         	cmp	#1, r4
ffc05a63:	20 6d                         	beq.b	ffc05ad0 <_Reset_Vector+0xffc05ad4>
        else if (_02_IIC_MASTER_SENDS_ADR_10A_W == g_riic0_state)
ffc05a65:	58 54                         	movu.b	[r5], r4
ffc05a67:	61 24                         	cmp	#2, r4
ffc05a69:	20 4d                         	beq.b	ffc05ab6 <_Reset_Vector+0xffc05aba>
        else if (_04_IIC_MASTER_SENDS_ADR_10B == g_riic0_state)
ffc05a6b:	58 54                         	movu.b	[r5], r4
ffc05a6d:	61 44                         	cmp	#4, r4
ffc05a6f:	20 76                         	beq.b	ffc05ae5 <_Reset_Vector+0xffc05ae9>
        else if (_05_IIC_MASTER_SENDS_DATA == g_riic0_state)
ffc05a71:	58 54                         	movu.b	[r5], r4
ffc05a73:	61 54                         	cmp	#5, r4
ffc05a75:	21 a9                         	bne.b	ffc05a1e <_Reset_Vector+0xffc05a22>
            if (0U < g_riic0_tx_count)
ffc05a77:	fb 32 9a 08 00 00             	mov.l	#0x89a, r3
ffc05a7d:	5c 34                         	movu.w	[r3], r4
ffc05a7f:	61 04                         	cmp	#0, r4
ffc05a81:	3a a4 00                      	beq.w	ffc05b25 <_Reset_Vector+0xffc05b29>
                RIIC0.ICDRT = *gp_riic0_tx_address;
ffc05a84:	fb 22 94 08 00 00             	mov.l	#0x894, r2
ffc05a8a:	ec 24                         	mov.l	[r2], r4
ffc05a8c:	fd 28 41                      	mov.b	[r4+], r1
ffc05a8f:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc05a94:	84 d1                         	mov.b	r1, 18[r5]
                g_riic0_tx_count--;
ffc05a96:	dc 35                         	mov.w	[r3], r5
                gp_riic0_tx_address++;
ffc05a98:	e3 24                         	mov.l	r4, [r2]
                g_riic0_tx_count--;
ffc05a9a:	60 15                         	sub	#1, r5
ffc05a9c:	d3 35                         	mov.w	r5, [r3]
ffc05a9e:	02                            	rts
            RIIC0.ICDRT = (uint8_t)((g_riic0_slave_address << 1U) | 0x0001U);
ffc05a9f:	fb 52 9e 08 00 00             	mov.l	#0x89e, r5
ffc05aa5:	dc 55                         	mov.w	[r5], r5
ffc05aa7:	6c 15                         	shll	#1, r5
ffc05aa9:	78 05                         	bset	#0, r5
ffc05aab:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffc05ab0:	84 b5                         	mov.b	r5, 18[r3]
            g_riic0_state = _08_IIC_MASTER_RECEIVES_START;
ffc05ab2:	f8 44 08                      	mov.b	#8, [r4]
ffc05ab5:	02                            	rts
            RIIC0.ICDRT = (uint8_t)(((g_riic0_slave_address & 0x0300U) >> 7U) | 0x00F0U);
ffc05ab6:	fb 42 9e 08 00 00             	mov.l	#0x89e, r4
ffc05abc:	dc 44                         	mov.w	[r4], r4
ffc05abe:	68 74                         	shlr	#7, r4
ffc05ac0:	64 64                         	and	#6, r4
ffc05ac2:	75 34 f0                      	or	#-16, r4
ffc05ac5:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffc05aca:	84 b4                         	mov.b	r4, 18[r3]
            g_riic0_state = _04_IIC_MASTER_SENDS_ADR_10B;
ffc05acc:	f8 54 04                      	mov.b	#4, [r5]
ffc05acf:	02                            	rts
            RIIC0.ICDRT = (uint8_t)(g_riic0_slave_address << 1U);
ffc05ad0:	fb 42 9e 08 00 00             	mov.l	#0x89e, r4
ffc05ad6:	dc 44                         	mov.w	[r4], r4
ffc05ad8:	6c 14                         	shll	#1, r4
ffc05ada:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffc05adf:	84 b4                         	mov.b	r4, 18[r3]
            g_riic0_state = _05_IIC_MASTER_SENDS_DATA;
ffc05ae1:	f8 54 05                      	mov.b	#5, [r5]
ffc05ae4:	02                            	rts
            RIIC0.ICDRT = (uint8_t)(g_riic0_slave_address & 0x00FFU);
ffc05ae5:	fb 42 9e 08 00 00             	mov.l	#0x89e, r4
ffc05aeb:	dc 43                         	mov.w	[r4], r3
ffc05aed:	fb 4e 00 83 08                	mov.l	#0x88300, r4
ffc05af2:	84 c3                         	mov.b	r3, 18[r4]
            g_riic0_state = _05_IIC_MASTER_SENDS_DATA;
ffc05af4:	f8 54 05                      	mov.b	#5, [r5]
ffc05af7:	02                            	rts
            RIIC0.ICDRT = (uint8_t)(g_riic0_slave_address & 0x00FFU);
ffc05af8:	fb 52 9e 08 00 00             	mov.l	#0x89e, r5
ffc05afe:	dc 53                         	mov.w	[r5], r3
ffc05b00:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc05b05:	84 d3                         	mov.b	r3, 18[r5]
            g_riic0_state = _0E_IIC_MASTER_RECEIVES_RESTART;
ffc05b07:	f8 44 0e                      	mov.b	#14, [r4]
ffc05b0a:	02                            	rts
            RIIC0.ICDRT = (uint8_t)(((g_riic0_slave_address & 0x0300U) >> 7U) | 0x00F0U);
ffc05b0b:	fb 52 9e 08 00 00             	mov.l	#0x89e, r5
ffc05b11:	dc 55                         	mov.w	[r5], r5
ffc05b13:	68 75                         	shlr	#7, r5
ffc05b15:	64 65                         	and	#6, r5
ffc05b17:	75 35 f0                      	or	#-16, r5
ffc05b1a:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffc05b1f:	84 b5                         	mov.b	r5, 18[r3]
            g_riic0_state = _04_IIC_MASTER_SENDS_ADR_10B;
ffc05b21:	f8 44 04                      	mov.b	#4, [r4]
ffc05b24:	02                            	rts
                g_riic0_state = _06_IIC_MASTER_SENDS_END;
ffc05b25:	f8 54 06                      	mov.b	#6, [r5]
ffc05b28:	02                            	rts

ffc05b29 <.LFE5>:
ffc05b29:	00                            	brk
ffc05b2a:	00                            	brk
ffc05b2b:	00                            	brk
ffc05b2c:	00                            	brk
ffc05b2d:	00                            	brk
	...

ffc05b30 <_r_Config_RIIC0_receive_interrupt>:
void r_Config_RIIC0_receive_interrupt(void)
ffc05b30:	7e a1                         	push.l	r1
ffc05b32:	fd 6a 01                      	mvfc	psw, r1
ffc05b35:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05b3a:	61 81                         	cmp	#8, r1
ffc05b3c:	22 05                         	bc.b	ffc05b41 <_Reset_Vector+0xffc05b45>
ffc05b3e:	75 70 08                      	mvtipl	#8
ffc05b41:	7f a8                         	setpsw	i
ffc05b43:	fd 6a 01                      	mvfc	psw, r1
ffc05b46:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05b4b:	fd 76 c1 00                   	save	r1
ffc05b4f:	ef 16                         	mov.l	r1, r6
ffc05b51:	39 0b 00                      	bsr.w	ffc05b5c <_Reset_Vector+0xffc05b60>
ffc05b54:	fd 76 d6 00                   	rstr	r6
ffc05b58:	7e b1                         	pop	r1
ffc05b5a:	7f 95                         	rte

ffc05b5c <__r_Config_RIIC0_receive_interrupt>:
    if (_08_IIC_MASTER_RECEIVES_START == g_riic0_state)
ffc05b5c:	fb 42 ac 08 00 00             	mov.l	#0x8ac, r4
ffc05b62:	58 45                         	movu.b	[r4], r5
ffc05b64:	61 85                         	cmp	#8, r5
ffc05b66:	20 63                         	beq.b	ffc05bc9 <_Reset_Vector+0xffc05bcd>
    else if (_09_IIC_MASTER_RECEIVES_DATA == g_riic0_state)
ffc05b68:	58 45                         	movu.b	[r4], r5
ffc05b6a:	61 95                         	cmp	#9, r5
ffc05b6c:	11                            	beq.s	ffc05b75 <_Reset_Vector+0xffc05b79>
    else if (_0A_IIC_MASTER_RECEIVES_STOPPING == g_riic0_state)
ffc05b6d:	58 45                         	movu.b	[r4], r5
ffc05b6f:	61 a5                         	cmp	#10, r5
ffc05b71:	3a 94 00                      	beq.w	ffc05c05 <_Reset_Vector+0xffc05c09>
ffc05b74:	02                            	rts
        if (g_riic0_rx_count < g_riic0_rx_length)
ffc05b75:	fb 22 a0 08 00 00             	mov.l	#0x8a0, r2
ffc05b7b:	fb 12 aa 08 00 00             	mov.l	#0x8aa, r1
ffc05b81:	dc 23                         	mov.w	[r2], r3
ffc05b83:	dc 15                         	mov.w	[r1], r5
ffc05b85:	5f 33                         	movu.w	r3, r3
ffc05b87:	5f 55                         	movu.w	r5, r5
ffc05b89:	47 53                         	cmp	r5, r3
ffc05b8b:	22 e9                         	bc.b	ffc05b74 <_Reset_Vector+0xffc05b78>
            if (g_riic0_rx_count == (g_riic0_rx_length - 3))
ffc05b8d:	dc 23                         	mov.w	[r2], r3
ffc05b8f:	dc 15                         	mov.w	[r1], r5
ffc05b91:	fb e2 a4 08 00 00             	mov.l	#0x8a4, r14
ffc05b97:	5f 55                         	movu.w	r5, r5
ffc05b99:	5f 33                         	movu.w	r3, r3
ffc05b9b:	60 35                         	sub	#3, r5
ffc05b9d:	ec ef                         	mov.l	[r14], r15
ffc05b9f:	47 53                         	cmp	r5, r3
ffc05ba1:	3a bd 00                      	beq.w	ffc05c5e <_Reset_Vector+0xffc05c62>
            else if (g_riic0_rx_count == (g_riic0_rx_length - 2))
ffc05ba4:	dc 23                         	mov.w	[r2], r3
ffc05ba6:	dc 15                         	mov.w	[r1], r5
ffc05ba8:	5f 33                         	movu.w	r3, r3
ffc05baa:	5f 55                         	movu.w	r5, r5
ffc05bac:	60 25                         	sub	#2, r5
ffc05bae:	47 53                         	cmp	r5, r3
                RIIC0.ICMR3.BIT.ACKWP = 1U;
ffc05bb0:	fb 5e 00 83 08                	mov.l	#0x88300, r5
            else if (g_riic0_rx_count == (g_riic0_rx_length - 2))
ffc05bb5:	3a 8f 00                      	beq.w	ffc05c44 <_Reset_Vector+0xffc05c48>
                *gp_riic0_rx_address = RIIC0.ICDRR;
ffc05bb8:	8c dd                         	mov.b	19[r5], r5
ffc05bba:	c3 f5                         	mov.b	r5, [r15]
                gp_riic0_rx_address++;
ffc05bbc:	ec e4                         	mov.l	[r14], r4
                g_riic0_rx_count++;
ffc05bbe:	dc 25                         	mov.w	[r2], r5
                gp_riic0_rx_address++;
ffc05bc0:	62 14                         	add	#1, r4
                g_riic0_rx_count++;
ffc05bc2:	62 15                         	add	#1, r5
                gp_riic0_rx_address++;
ffc05bc4:	e3 e4                         	mov.l	r4, [r14]
                g_riic0_rx_count++;
ffc05bc6:	d3 25                         	mov.w	r5, [r2]
ffc05bc8:	02                            	rts
{
ffc05bc9:	60 40                         	sub	#4, r0
        if ((2U == g_riic0_rx_length) || (1U == g_riic0_rx_length))
ffc05bcb:	fb 52 aa 08 00 00             	mov.l	#0x8aa, r5
ffc05bd1:	5c 53                         	movu.w	[r5], r3
ffc05bd3:	61 23                         	cmp	#2, r3
ffc05bd5:	20 65                         	beq.b	ffc05c3a <_Reset_Vector+0xffc05c3e>
ffc05bd7:	5c 53                         	movu.w	[r5], r3
ffc05bd9:	61 13                         	cmp	#1, r3
ffc05bdb:	20 5f                         	beq.b	ffc05c3a <_Reset_Vector+0xffc05c3e>
ffc05bdd:	fc 13 00                      	nop	; max	r0, r0
        if (1U == g_riic0_rx_length)
ffc05be0:	5c 53                         	movu.w	[r5], r3
ffc05be2:	61 13                         	cmp	#1, r3
ffc05be4:	21 0d                         	bne.b	ffc05bf1 <_Reset_Vector+0xffc05bf5>
            RIIC0.ICMR3.BIT.ACKWP = 1U;
ffc05be6:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffc05beb:	f1 34 04                      	bset	#4, 4[r3].b
            RIIC0.ICMR3.BIT.ACKBT = 1U;
ffc05bee:	f1 33 04                      	bset	#3, 4[r3].b
        dummy = RIIC0.ICDRR;
ffc05bf1:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffc05bf6:	8c bb                         	mov.b	19[r3], r3
ffc05bf8:	c3 03                         	mov.b	r3, [r0]
        g_riic0_state = _09_IIC_MASTER_RECEIVES_DATA;
ffc05bfa:	f8 44 09                      	mov.b	#9, [r4]
        if (1U == g_riic0_rx_length)
ffc05bfd:	5c 55                         	movu.w	[r5], r5
ffc05bff:	61 15                         	cmp	#1, r5
ffc05c01:	20 34                         	beq.b	ffc05c35 <_Reset_Vector+0xffc05c39>
}
ffc05c03:	67 01                         	rtsd	#4
        RIIC0.ICSR2.BIT.STOP = 0U;
ffc05c05:	fb 5e 00 83 08                	mov.l	#0x88300, r5
        *gp_riic0_rx_address = RIIC0.ICDRR;
ffc05c0a:	fb 32 a4 08 00 00             	mov.l	#0x8a4, r3
        RIIC0.ICSR2.BIT.STOP = 0U;
ffc05c10:	f1 5b 09                      	bclr	#3, 9[r5].b
        RIIC0.ICCR2.BIT.SP = 1U;
ffc05c13:	f1 53 01                      	bset	#3, 1[r5].b
        *gp_riic0_rx_address = RIIC0.ICDRR;
ffc05c16:	8c d9                         	mov.b	19[r5], r1
ffc05c18:	ec 32                         	mov.l	[r3], r2
        g_riic0_rx_count++;
ffc05c1a:	fb e2 a0 08 00 00             	mov.l	#0x8a0, r14
        *gp_riic0_rx_address = RIIC0.ICDRR;
ffc05c20:	c3 21                         	mov.b	r1, [r2]
        g_riic0_rx_count++;
ffc05c22:	dc e1                         	mov.w	[r14], r1
        gp_riic0_rx_address++;
ffc05c24:	ec 32                         	mov.l	[r3], r2
        g_riic0_rx_count++;
ffc05c26:	62 11                         	add	#1, r1
        gp_riic0_rx_address++;
ffc05c28:	62 12                         	add	#1, r2
        g_riic0_rx_count++;
ffc05c2a:	d3 e1                         	mov.w	r1, [r14]
        gp_riic0_rx_address++;
ffc05c2c:	e3 32                         	mov.l	r2, [r3]
        RIIC0.ICMR3.BIT.WAIT = 0U;
ffc05c2e:	f1 5e 04                      	bclr	#6, 4[r5].b
        g_riic0_state = _0B_IIC_MASTER_RECEIVES_STOP;
ffc05c31:	f8 44 0b                      	mov.b	#11, [r4]
}
ffc05c34:	02                            	rts
            g_riic0_state = _0A_IIC_MASTER_RECEIVES_STOPPING;
ffc05c35:	f8 44 0a                      	mov.b	#10, [r4]
}
ffc05c38:	67 01                         	rtsd	#4
            RIIC0.ICMR3.BIT.WAIT = 1U;
ffc05c3a:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffc05c3f:	f1 36 04                      	bset	#6, 4[r3].b
ffc05c42:	2e 9e                         	bra.b	ffc05be0 <_Reset_Vector+0xffc05be4>
                RIIC0.ICMR3.BIT.ACKWP = 1U;
ffc05c44:	f1 54 04                      	bset	#4, 4[r5].b
                RIIC0.ICMR3.BIT.ACKBT = 1U;
ffc05c47:	f1 53 04                      	bset	#3, 4[r5].b
                *gp_riic0_rx_address = RIIC0.ICDRR;
ffc05c4a:	8c dd                         	mov.b	19[r5], r5
ffc05c4c:	c3 f5                         	mov.b	r5, [r15]
                g_riic0_rx_count++;
ffc05c4e:	dc 23                         	mov.w	[r2], r3
                gp_riic0_rx_address++;
ffc05c50:	ec e5                         	mov.l	[r14], r5
                g_riic0_rx_count++;
ffc05c52:	62 13                         	add	#1, r3
                gp_riic0_rx_address++;
ffc05c54:	62 15                         	add	#1, r5
                g_riic0_rx_count++;
ffc05c56:	d3 23                         	mov.w	r3, [r2]
                gp_riic0_rx_address++;
ffc05c58:	e3 e5                         	mov.l	r5, [r14]
                g_riic0_state = _0A_IIC_MASTER_RECEIVES_STOPPING;
ffc05c5a:	f8 44 0a                      	mov.b	#10, [r4]
ffc05c5d:	02                            	rts
                RIIC0.ICMR3.BIT.WAIT = 1U;
ffc05c5e:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffc05c63:	f1 56 04                      	bset	#6, 4[r5].b
                *gp_riic0_rx_address = RIIC0.ICDRR;
ffc05c66:	38 52 ff                      	bra.w	ffc05bb8 <_Reset_Vector+0xffc05bbc>

ffc05c69 <.LFE8>:
ffc05c69:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffc05c70 <_r_Config_MTU3_MTU4_tgia3_interrupt>:
* Description  : This function is TGIA3 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_tgia3_interrupt(void)
ffc05c70:	7f a8                         	setpsw	i
ffc05c72:	fd 76 e0 0f                   	save	#15
ffc05c76:	39 09 00                      	bsr.w	ffc05c7f <_Reset_Vector+0xffc05c83>
ffc05c79:	fd 76 f0 0f                   	rstr	#15
ffc05c7d:	7f 95                         	rte

ffc05c7f <__r_Config_MTU3_MTU4_tgia3_interrupt>:
{
    /* Start user code for r_Config_MTU3_MTU4_tgia3_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffc05c7f:	02                            	rts

ffc05c80 <_r_Config_MTU3_MTU4_c4_tgia4_interrupt>:
* Description  : This function is TGIA4 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_c4_tgia4_interrupt(void)
ffc05c80:	7f a8                         	setpsw	i
ffc05c82:	fd 76 e0 0f                   	save	#15
ffc05c86:	39 09 00                      	bsr.w	ffc05c8f <_Reset_Vector+0xffc05c93>
ffc05c89:	fd 76 f0 0f                   	rstr	#15
ffc05c8d:	7f 95                         	rte

ffc05c8f <__r_Config_MTU3_MTU4_c4_tgia4_interrupt>:
{
    /* Start user code for r_Config_MTU3_MTU4_c4_tgia4_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffc05c8f:	02                            	rts

ffc05c90 <_r_Config_MTU3_MTU4_tgib3_interrupt>:
* Description  : This function is TGIB3 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_tgib3_interrupt(void)
ffc05c90:	7f a8                         	setpsw	i
ffc05c92:	fd 76 e0 0f                   	save	#15
ffc05c96:	39 09 00                      	bsr.w	ffc05c9f <_Reset_Vector+0xffc05ca3>
ffc05c99:	fd 76 f0 0f                   	rstr	#15
ffc05c9d:	7f 95                         	rte

ffc05c9f <__r_Config_MTU3_MTU4_tgib3_interrupt>:
{
    /* Start user code for r_Config_MTU3_MTU4_tgib3_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffc05c9f:	02                            	rts

ffc05ca0 <_r_Config_MTU3_MTU4_c4_tgib4_interrupt>:
* Description  : This function is TGIB4 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_c4_tgib4_interrupt(void)
ffc05ca0:	7f a8                         	setpsw	i
ffc05ca2:	fd 76 e0 0f                   	save	#15
ffc05ca6:	39 09 00                      	bsr.w	ffc05caf <_Reset_Vector+0xffc05cb3>
ffc05ca9:	fd 76 f0 0f                   	rstr	#15
ffc05cad:	7f 95                         	rte

ffc05caf <__r_Config_MTU3_MTU4_c4_tgib4_interrupt>:
{
    /* Start user code for r_Config_MTU3_MTU4_c4_tgib4_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffc05caf:	02                            	rts

ffc05cb0 <_r_Config_MTU3_MTU4_c4_tciv4_interrupt>:
* Description  : This function is TCIV4 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_c4_tciv4_interrupt(void)
ffc05cb0:	7f a8                         	setpsw	i
ffc05cb2:	fd 76 e0 0f                   	save	#15
ffc05cb6:	39 09 00                      	bsr.w	ffc05cbf <_Reset_Vector+0xffc05cc3>
ffc05cb9:	fd 76 f0 0f                   	rstr	#15
ffc05cbd:	7f 95                         	rte

ffc05cbf <__r_Config_MTU3_MTU4_c4_tciv4_interrupt>:
{
    /* Start user code for r_Config_MTU3_MTU4_c4_tciv4_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffc05cbf:	02                            	rts

ffc05cc0 <__trap0_isr>:
}

uint32_t debug = 0x5a5a5a5a;

R_BSP_PRAGMA_STATIC_INTERRUPT(trap0_isr, VECT(TRAP, 0))
ffc05cc0:	7e a1                         	push.l	r1
ffc05cc2:	fd 6a 01                      	mvfc	psw, r1
ffc05cc5:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05cca:	61 81                         	cmp	#8, r1
ffc05ccc:	22 05                         	bc.b	ffc05cd1 <_Reset_Vector+0xffc05cd5>
ffc05cce:	75 70 08                      	mvtipl	#8
ffc05cd1:	7f a8                         	setpsw	i
ffc05cd3:	fd 6a 01                      	mvfc	psw, r1
ffc05cd6:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05cdb:	fd 76 c1 00                   	save	r1
ffc05cdf:	ef 16                         	mov.l	r1, r6
ffc05ce1:	39 0b 00                      	bsr.w	ffc05cec <_Reset_Vector+0xffc05cf0>
ffc05ce4:	fd 76 d6 00                   	rstr	r6
ffc05ce8:	7e b1                         	pop	r1
ffc05cea:	7f 95                         	rte

ffc05cec <_trap0_isr>:
R_BSP_ATTRIB_STATIC_INTERRUPT void trap0_isr(void)
{
    debug = 0;
ffc05cec:	fb 52 30 00 00 00             	mov.l	#48, r5
ffc05cf2:	f8 56 00                      	mov.l	#0, [r5]
}
ffc05cf5:	02                            	rts

ffc05cf6 <_trap1_isr>:

void trap1_isr(void) __attribute__ ((interrupt(".rvectors", VECT(TRAP, 1))));
/**/
#define trap1_isr(...) R_CG_ATTRIB_INTERRUPT_FIT_IPL_MAX_EI(trap1_isr, __VA_ARGS__)
/**/
void trap1_isr(void)
ffc05cf6:	7e a1                         	push.l	r1
ffc05cf8:	fd 6a 01                      	mvfc	psw, r1
ffc05cfb:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05d00:	61 81                         	cmp	#8, r1
ffc05d02:	22 05                         	bc.b	ffc05d07 <_Reset_Vector+0xffc05d0b>
ffc05d04:	75 70 08                      	mvtipl	#8
ffc05d07:	7f a8                         	setpsw	i
ffc05d09:	fd 6a 01                      	mvfc	psw, r1
ffc05d0c:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
ffc05d11:	fd 76 c1 00                   	save	r1
ffc05d15:	ef 16                         	mov.l	r1, r6
ffc05d17:	39 0b 00                      	bsr.w	ffc05d22 <_Reset_Vector+0xffc05d26>
ffc05d1a:	fd 76 d6 00                   	rstr	r6
ffc05d1e:	7e b1                         	pop	r1
ffc05d20:	7f 95                         	rte

ffc05d22 <__trap1_isr>:
{
    debug = 1;
ffc05d22:	fb 52 30 00 00 00             	mov.l	#48, r5
ffc05d28:	f8 56 01                      	mov.l	#1, [r5]
}
ffc05d2b:	02                            	rts

ffc05d2c <_trap2_isr>:

void trap2_isr(void) __attribute__ ((interrupt(".rvectors", VECT(TRAP, 2))));
/**/
#define trap2_isr(...) R_CG_ATTRIB_INTERRUPT_EI(trap2_isr, __VA_ARGS__)
/**/
void trap2_isr(void)
ffc05d2c:	7f a8                         	setpsw	i
ffc05d2e:	2e 02                         	bra.b	ffc05d30 <_Reset_Vector+0xffc05d34>

ffc05d30 <__trap2_isr>:
{
ffc05d30:	6e 56                         	pushm	r5-r6
ffc05d32:	fd 1f 15                      	mvfaclo	#0, a0, r5
ffc05d35:	fd 1f 06                      	mvfachi	#0, a0, r6
ffc05d38:	6e 56                         	pushm	r5-r6
ffc05d3a:	fd 1f 35                      	mvfacgu	#0, a0, r5
ffc05d3d:	fd 1f 96                      	mvfaclo	#0, a1, r6
ffc05d40:	6e 56                         	pushm	r5-r6
ffc05d42:	fd 1f 85                      	mvfachi	#0, a1, r5
ffc05d45:	fd 1f b6                      	mvfacgu	#0, a1, r6
ffc05d48:	6e 56                         	pushm	r5-r6
    debug = 2;
ffc05d4a:	fb 52 30 00 00 00             	mov.l	#48, r5
ffc05d50:	f8 56 02                      	mov.l	#2, [r5]
}
ffc05d53:	6f 56                         	popm	r5-r6
ffc05d55:	fd 17 85                      	mvtachi	r5, a1
ffc05d58:	fd 17 b6                      	mvtacgu	r6, a1
ffc05d5b:	6f 56                         	popm	r5-r6
ffc05d5d:	fd 17 35                      	mvtacgu	r5, a0
ffc05d60:	fd 17 96                      	mvtaclo	r6, a1
ffc05d63:	6f 56                         	popm	r5-r6
ffc05d65:	fd 17 15                      	mvtaclo	r5, a0
ffc05d68:	fd 17 06                      	mvtachi	r6, a0
ffc05d6b:	6f 56                         	popm	r5-r6
ffc05d6d:	7f 95                         	rte

ffc05d6f <_trap3_isr>:

void trap3_isr(void) __attribute__ ((interrupt(".rvectors", VECT(TRAP, 3))));
/**/
#define trap3_isr(...) R_CG_ATTRIB_INTERRUPT_BANK(trap3_isr, 15, __VA_ARGS__)
/**/
void trap3_isr(void)
ffc05d6f:	fd 76 e0 0f                   	save	#15
ffc05d73:	39 09 00                      	bsr.w	ffc05d7c <_Reset_Vector+0xffc05d80>
ffc05d76:	fd 76 f0 0f                   	rstr	#15
ffc05d7a:	7f 95                         	rte

ffc05d7c <__trap3_isr>:
{
    debug = 3;
ffc05d7c:	fb 52 30 00 00 00             	mov.l	#48, r5
ffc05d82:	f8 56 03                      	mov.l	#3, [r5]
}
ffc05d85:	02                            	rts

ffc05d86 <_trap4_isr>:

void trap4_isr(void) __attribute__ ((interrupt(".rvectors", VECT(TRAP, 4))));
/**/
#define trap4_isr(...) R_CG_ATTRIB_INTERRUPT_BANK_EI(trap4_isr, 15, __VA_ARGS__)
/**/
void trap4_isr(void)
ffc05d86:	7f a8                         	setpsw	i
ffc05d88:	fd 76 e0 0f                   	save	#15
ffc05d8c:	39 09 00                      	bsr.w	ffc05d95 <_Reset_Vector+0xffc05d99>
ffc05d8f:	fd 76 f0 0f                   	rstr	#15
ffc05d93:	7f 95                         	rte

ffc05d95 <__trap4_isr>:
{
    debug = 4;
ffc05d95:	fb 52 30 00 00 00             	mov.l	#48, r5
ffc05d9b:	f8 56 04                      	mov.l	#4, [r5]
}
ffc05d9e:	02                            	rts

ffc05d9f <.LFE13>:
	...

ffc05da0 <__COM_DIV64u>:
ffc05da0:	6e 6c                         	pushm	r6-r12
ffc05da2:	61 04                         	cmp	#0, r4
ffc05da4:	3b 6e 01                      	bne.w	ffc05f12 <_Reset_Vector+0xffc05f16>
ffc05da7:	ef 45                         	mov.l	r4, r5
ffc05da9:	ef 3f                         	mov.l	r3, r15
ffc05dab:	ef 17                         	mov.l	r1, r7
ffc05dad:	47 23                         	cmp	r2, r3
ffc05daf:	24 05                         	bgtu.b	ffc05db4 <_Reset_Vector+0xffc05db8>
ffc05db1:	38 b6 00                      	bra.w	ffc05e67 <_Reset_Vector+0xffc05e6b>
ffc05db4:	ef 2a                         	mov.l	r2, r10
ffc05db6:	77 03 ff ff 00                	cmp	#0xffff, r3
ffc05dbb:	24 05                         	bgtu.b	ffc05dc0 <_Reset_Vector+0xffc05dc4>
ffc05dbd:	38 bd 01                      	bra.w	ffc05f7a <_Reset_Vector+0xffc05f7e>
ffc05dc0:	74 03 ff ff ff 00             	cmp	#0xffffff, r3
ffc05dc6:	24 05                         	bgtu.b	ffc05dcb <_Reset_Vector+0xffc05dcf>
ffc05dc8:	38 69 03                      	bra.w	ffc06131 <_Reset_Vector+0xffc06135>
ffc05dcb:	fd 98 36                      	shlr	#24, r3, r6
ffc05dce:	75 45 18                      	mov.l	#24, r5
ffc05dd1:	fb 42 70 6d c0 ff             	mov.l	#0xffc06d70, r4
ffc05dd7:	fe c6 44                      	movu.b	[r6, r4], r4
ffc05dda:	4b 45                         	add	r4, r5
ffc05ddc:	75 46 20                      	mov.l	#32, r6
ffc05ddf:	43 56                         	sub	r5, r6
ffc05de1:	20 18                         	beq.b	ffc05df9 <_Reset_Vector+0xffc05dfd>
ffc05de3:	ef 2e                         	mov.l	r2, r14
ffc05de5:	fd 62 6e                      	shll	r6, r14
ffc05de8:	ef 1a                         	mov.l	r1, r10
ffc05dea:	fd 60 5a                      	shlr	r5, r10
ffc05ded:	ef 3f                         	mov.l	r3, r15
ffc05def:	fd 62 6f                      	shll	r6, r15
ffc05df2:	57 ea                         	or	r14, r10
ffc05df4:	ef 17                         	mov.l	r1, r7
ffc05df6:	fd 62 67                      	shll	r6, r7
ffc05df9:	fd 90 f2                      	shlr	#16, r15, r2
ffc05dfc:	fb 6e ff ff 00                	mov.l	#0xffff, r6
ffc05e01:	53 f6                         	and	r15, r6
ffc05e03:	ef a5                         	mov.l	r10, r5
ffc05e05:	fc 27 25                      	divu	r2, r5
ffc05e08:	ff 34 25                      	mul 	r2, r5, r4
ffc05e0b:	43 4a                         	sub	r4, r10
ffc05e0d:	fd d0 a4                      	shll	#16, r10, r4
ffc05e10:	fd 90 7a                      	shlr	#16, r7, r10
ffc05e13:	ff 33 56                      	mul 	r5, r6, r3
ffc05e16:	57 4a                         	or	r4, r10
ffc05e18:	47 a3                         	cmp	r10, r3
ffc05e1a:	25 14                         	bleu.b	ffc05e2e <_Reset_Vector+0xffc05e32>
ffc05e1c:	4b fa                         	add	r15, r10
ffc05e1e:	71 54 ff                      	add	#-1, r5, r4
ffc05e21:	47 af                         	cmp	r10, r15
ffc05e23:	24 09                         	bgtu.b	ffc05e2c <_Reset_Vector+0xffc05e30>
ffc05e25:	47 a3                         	cmp	r10, r3
ffc05e27:	25 05                         	bleu.b	ffc05e2c <_Reset_Vector+0xffc05e30>
ffc05e29:	38 34 03                      	bra.w	ffc0615d <_Reset_Vector+0xffc06161>
ffc05e2c:	ef 45                         	mov.l	r4, r5
ffc05e2e:	43 3a                         	sub	r3, r10
ffc05e30:	77 27 ff ff 00                	and	#0xffff, r7
ffc05e35:	ef a1                         	mov.l	r10, r1
ffc05e37:	fc 27 21                      	divu	r2, r1
ffc05e3a:	4f 12                         	mul	r1, r2
ffc05e3c:	43 2a                         	sub	r2, r10
ffc05e3e:	ef 13                         	mov.l	r1, r3
ffc05e40:	6d 0a                         	shll	#16, r10
ffc05e42:	ff 32 16                      	mul 	r1, r6, r2
ffc05e45:	57 a7                         	or	r10, r7
ffc05e47:	47 72                         	cmp	r7, r2
ffc05e49:	25 14                         	bleu.b	ffc05e5d <_Reset_Vector+0xffc05e61>
ffc05e4b:	4b f7                         	add	r15, r7
ffc05e4d:	71 1a ff                      	add	#-1, r1, r10
ffc05e50:	47 7f                         	cmp	r7, r15
ffc05e52:	24 09                         	bgtu.b	ffc05e5b <_Reset_Vector+0xffc05e5f>
ffc05e54:	47 72                         	cmp	r7, r2
ffc05e56:	25 05                         	bleu.b	ffc05e5b <_Reset_Vector+0xffc05e5f>
ffc05e58:	38 00 03                      	bra.w	ffc06158 <_Reset_Vector+0xffc0615c>
ffc05e5b:	ef a3                         	mov.l	r10, r3
ffc05e5d:	fd d0 51                      	shll	#16, r5, r1
ffc05e60:	66 02                         	mov.l	#0, r2
ffc05e62:	57 31                         	or	r3, r1
ffc05e64:	3f 6c 07                      	rtsd	#28, r6-r12
ffc05e67:	61 03                         	cmp	#0, r3
ffc05e69:	1f                            	bne.s	ffc05e70 <_Reset_Vector+0xffc05e74>
ffc05e6a:	66 1f                         	mov.l	#1, r15
ffc05e6c:	fd 74 9f 00                   	divu	#0, r15
ffc05e70:	77 0f ff ff 00                	cmp	#0xffff, r15
ffc05e75:	24 05                         	bgtu.b	ffc05e7a <_Reset_Vector+0xffc05e7e>
ffc05e77:	38 f3 00                      	bra.w	ffc05f6a <_Reset_Vector+0xffc05f6e>
ffc05e7a:	74 0f ff ff ff 00             	cmp	#0xffffff, r15
ffc05e80:	24 05                         	bgtu.b	ffc05e85 <_Reset_Vector+0xffc05e89>
ffc05e82:	38 a6 02                      	bra.w	ffc06128 <_Reset_Vector+0xffc0612c>
ffc05e85:	fd 98 f4                      	shlr	#24, r15, r4
ffc05e88:	75 45 18                      	mov.l	#24, r5
ffc05e8b:	77 10 01 00 00                	nop	; mul	#1, r0
ffc05e90:	fb a2 70 6d c0 ff             	mov.l	#0xffc06d70, r10
ffc05e96:	fe c4 a4                      	movu.b	[r4, r10], r4
ffc05e99:	4b 54                         	add	r5, r4
ffc05e9b:	75 43 20                      	mov.l	#32, r3
ffc05e9e:	43 43                         	sub	r4, r3
ffc05ea0:	3b ea 00                      	bne.w	ffc05f8a <_Reset_Vector+0xffc05f8e>
ffc05ea3:	ff 0e f2                      	sub	r15, r2, r14
ffc05ea6:	fd 90 f6                      	shlr	#16, r15, r6
ffc05ea9:	fb ae ff ff 00                	mov.l	#0xffff, r10
ffc05eae:	53 fa                         	and	r15, r10
ffc05eb0:	66 12                         	mov.l	#1, r2
ffc05eb2:	ef e5                         	mov.l	r14, r5
ffc05eb4:	fc 27 65                      	divu	r6, r5
ffc05eb7:	ff 34 65                      	mul 	r6, r5, r4
ffc05eba:	43 4e                         	sub	r4, r14
ffc05ebc:	6d 0e                         	shll	#16, r14
ffc05ebe:	fd 90 74                      	shlr	#16, r7, r4
ffc05ec1:	ff 33 a5                      	mul 	r10, r5, r3
ffc05ec4:	57 e4                         	or	r14, r4
ffc05ec6:	47 43                         	cmp	r4, r3
ffc05ec8:	25 14                         	bleu.b	ffc05edc <_Reset_Vector+0xffc05ee0>
ffc05eca:	4b f4                         	add	r15, r4
ffc05ecc:	71 51 ff                      	add	#-1, r5, r1
ffc05ecf:	47 4f                         	cmp	r4, r15
ffc05ed1:	24 09                         	bgtu.b	ffc05eda <_Reset_Vector+0xffc05ede>
ffc05ed3:	47 43                         	cmp	r4, r3
ffc05ed5:	25 05                         	bleu.b	ffc05eda <_Reset_Vector+0xffc05ede>
ffc05ed7:	38 8d 02                      	bra.w	ffc06164 <_Reset_Vector+0xffc06168>
ffc05eda:	ef 15                         	mov.l	r1, r5
ffc05edc:	43 34                         	sub	r3, r4
ffc05ede:	77 27 ff ff 00                	and	#0xffff, r7
ffc05ee3:	ef 41                         	mov.l	r4, r1
ffc05ee5:	fc 27 61                      	divu	r6, r1
ffc05ee8:	4f 16                         	mul	r1, r6
ffc05eea:	43 64                         	sub	r6, r4
ffc05eec:	ef 13                         	mov.l	r1, r3
ffc05eee:	6d 04                         	shll	#16, r4
ffc05ef0:	4f 1a                         	mul	r1, r10
ffc05ef2:	57 74                         	or	r7, r4
ffc05ef4:	47 4a                         	cmp	r4, r10
ffc05ef6:	25 14                         	bleu.b	ffc05f0a <_Reset_Vector+0xffc05f0e>
ffc05ef8:	4b f4                         	add	r15, r4
ffc05efa:	71 17 ff                      	add	#-1, r1, r7
ffc05efd:	47 4f                         	cmp	r4, r15
ffc05eff:	24 09                         	bgtu.b	ffc05f08 <_Reset_Vector+0xffc05f0c>
ffc05f01:	47 4a                         	cmp	r4, r10
ffc05f03:	25 05                         	bleu.b	ffc05f08 <_Reset_Vector+0xffc05f0c>
ffc05f05:	38 4e 02                      	bra.w	ffc06153 <_Reset_Vector+0xffc06157>
ffc05f08:	ef 73                         	mov.l	r7, r3
ffc05f0a:	fd d0 51                      	shll	#16, r5, r1
ffc05f0d:	57 31                         	or	r3, r1
ffc05f0f:	3f 6c 07                      	rtsd	#28, r6-r12
ffc05f12:	47 24                         	cmp	r2, r4
ffc05f14:	24 40                         	bgtu.b	ffc05f54 <_Reset_Vector+0xffc05f58>
ffc05f16:	77 04 ff ff 00                	cmp	#0xffff, r4
ffc05f1b:	25 40                         	bleu.b	ffc05f5b <_Reset_Vector+0xffc05f5f>
ffc05f1d:	74 04 ff ff ff 00             	cmp	#0xffffff, r4
ffc05f23:	24 05                         	bgtu.b	ffc05f28 <_Reset_Vector+0xffc05f2c>
ffc05f25:	38 e7 01                      	bra.w	ffc0610c <_Reset_Vector+0xffc06110>
ffc05f28:	fd 98 45                      	shlr	#24, r4, r5
ffc05f2b:	75 4a 18                      	mov.l	#24, r10
ffc05f2e:	ef 00                         	nop	; mov.l	r0, r0
ffc05f30:	fb 72 70 6d c0 ff             	mov.l	#0xffc06d70, r7
ffc05f36:	fe c5 75                      	movu.b	[r5, r7], r5
ffc05f39:	4b a5                         	add	r10, r5
ffc05f3b:	75 4a 20                      	mov.l	#32, r10
ffc05f3e:	43 5a                         	sub	r5, r10
ffc05f40:	3b dd 00                      	bne.w	ffc0601d <_Reset_Vector+0xffc06021>
ffc05f43:	47 24                         	cmp	r2, r4
ffc05f45:	22 05                         	bc.b	ffc05f4a <_Reset_Vector+0xffc05f4e>
ffc05f47:	38 ce 01                      	bra.w	ffc06115 <_Reset_Vector+0xffc06119>
ffc05f4a:	47 13                         	cmp	r1, r3
ffc05f4c:	fc db 15                      	scleu.l	r1
ffc05f4f:	66 02                         	mov.l	#0, r2
ffc05f51:	3f 6c 07                      	rtsd	#28, r6-r12
ffc05f54:	66 02                         	mov.l	#0, r2
ffc05f56:	66 01                         	mov.l	#0, r1
ffc05f58:	3f 6c 07                      	rtsd	#28, r6-r12
ffc05f5b:	75 54 ff                      	cmp	#255, r4
ffc05f5e:	24 05                         	bgtu.b	ffc05f63 <_Reset_Vector+0xffc05f67>
ffc05f60:	38 bc 01                      	bra.w	ffc0611c <_Reset_Vector+0xffc06120>
ffc05f63:	fd 88 45                      	shlr	#8, r4, r5
ffc05f66:	66 8a                         	mov.l	#8, r10
ffc05f68:	2e c8                         	bra.b	ffc05f30 <_Reset_Vector+0xffc05f34>
ffc05f6a:	75 5f ff                      	cmp	#255, r15
ffc05f6d:	24 05                         	bgtu.b	ffc05f72 <_Reset_Vector+0xffc05f76>
ffc05f6f:	38 cb 01                      	bra.w	ffc0613a <_Reset_Vector+0xffc0613e>
ffc05f72:	fd 88 f4                      	shlr	#8, r15, r4
ffc05f75:	66 85                         	mov.l	#8, r5
ffc05f77:	38 19 ff                      	bra.w	ffc05e90 <_Reset_Vector+0xffc05e94>
ffc05f7a:	75 53 ff                      	cmp	#255, r3
ffc05f7d:	24 05                         	bgtu.b	ffc05f82 <_Reset_Vector+0xffc05f86>
ffc05f7f:	38 a4 01                      	bra.w	ffc06123 <_Reset_Vector+0xffc06127>
ffc05f82:	fd 88 36                      	shlr	#8, r3, r6
ffc05f85:	66 85                         	mov.l	#8, r5
ffc05f87:	38 4a fe                      	bra.w	ffc05dd1 <_Reset_Vector+0xffc05dd5>
ffc05f8a:	fd 62 3f                      	shll	r3, r15
ffc05f8d:	ef 25                         	mov.l	r2, r5
ffc05f8f:	fd 60 45                      	shlr	r4, r5
ffc05f92:	fd 90 f6                      	shlr	#16, r15, r6
ffc05f95:	ef 2e                         	mov.l	r2, r14
ffc05f97:	fd 62 3e                      	shll	r3, r14
ffc05f9a:	ef 57                         	mov.l	r5, r7
ffc05f9c:	fc 27 67                      	divu	r6, r7
ffc05f9f:	ef 12                         	mov.l	r1, r2
ffc05fa1:	fd 60 42                      	shlr	r4, r2
ffc05fa4:	ff 3b 67                      	mul 	r6, r7, r11
ffc05fa7:	57 2e                         	or	r2, r14
ffc05fa9:	43 b5                         	sub	r11, r5
ffc05fab:	fb ae ff ff 00                	mov.l	#0xffff, r10
ffc05fb0:	53 fa                         	and	r15, r10
ffc05fb2:	ef 74                         	mov.l	r7, r4
ffc05fb4:	6d 05                         	shll	#16, r5
ffc05fb6:	fd 90 e7                      	shlr	#16, r14, r7
ffc05fb9:	ff 32 4a                      	mul 	r4, r10, r2
ffc05fbc:	57 75                         	or	r7, r5
ffc05fbe:	ef 17                         	mov.l	r1, r7
ffc05fc0:	fd 62 37                      	shll	r3, r7
ffc05fc3:	47 52                         	cmp	r5, r2
ffc05fc5:	25 19                         	bleu.b	ffc05fde <_Reset_Vector+0xffc05fe2>
ffc05fc7:	4b f5                         	add	r15, r5
ffc05fc9:	71 43 ff                      	add	#-1, r4, r3
ffc05fcc:	47 5f                         	cmp	r5, r15
ffc05fce:	25 05                         	bleu.b	ffc05fd3 <_Reset_Vector+0xffc05fd7>
ffc05fd0:	38 7e 01                      	bra.w	ffc0614e <_Reset_Vector+0xffc06152>
ffc05fd3:	47 52                         	cmp	r5, r2
ffc05fd5:	24 05                         	bgtu.b	ffc05fda <_Reset_Vector+0xffc05fde>
ffc05fd7:	38 77 01                      	bra.w	ffc0614e <_Reset_Vector+0xffc06152>
ffc05fda:	60 24                         	sub	#2, r4
ffc05fdc:	4b f5                         	add	r15, r5
ffc05fde:	43 25                         	sub	r2, r5
ffc05fe0:	fb 3e ff ff 00                	mov.l	#0xffff, r3
ffc05fe5:	53 e3                         	and	r14, r3
ffc05fe7:	ef 52                         	mov.l	r5, r2
ffc05fe9:	fc 27 62                      	divu	r6, r2
ffc05fec:	ff 3e 62                      	mul 	r6, r2, r14
ffc05fef:	43 e5                         	sub	r14, r5
ffc05ff1:	fd d0 5e                      	shll	#16, r5, r14
ffc05ff4:	ff 35 2a                      	mul 	r2, r10, r5
ffc05ff7:	57 3e                         	or	r3, r14
ffc05ff9:	47 e5                         	cmp	r14, r5
ffc05ffb:	25 19                         	bleu.b	ffc06014 <_Reset_Vector+0xffc06018>
ffc05ffd:	4b fe                         	add	r15, r14
ffc05fff:	71 23 ff                      	add	#-1, r2, r3
ffc06002:	47 ef                         	cmp	r14, r15
ffc06004:	25 05                         	bleu.b	ffc06009 <_Reset_Vector+0xffc0600d>
ffc06006:	38 3e 01                      	bra.w	ffc06144 <_Reset_Vector+0xffc06148>
ffc06009:	47 e5                         	cmp	r14, r5
ffc0600b:	24 05                         	bgtu.b	ffc06010 <_Reset_Vector+0xffc06014>
ffc0600d:	38 37 01                      	bra.w	ffc06144 <_Reset_Vector+0xffc06148>
ffc06010:	60 22                         	sub	#2, r2
ffc06012:	4b fe                         	add	r15, r14
ffc06014:	6d 04                         	shll	#16, r4
ffc06016:	43 5e                         	sub	r5, r14
ffc06018:	57 42                         	or	r4, r2
ffc0601a:	38 98 fe                      	bra.w	ffc05eb2 <_Reset_Vector+0xffc05eb6>
ffc0601d:	fd 62 a4                      	shll	r10, r4
ffc06020:	ef 37                         	mov.l	r3, r7
ffc06022:	fd 60 57                      	shlr	r5, r7
ffc06025:	57 74                         	or	r7, r4
ffc06027:	ef 27                         	mov.l	r2, r7
ffc06029:	fd 60 57                      	shlr	r5, r7
ffc0602c:	fd 90 4f                      	shlr	#16, r4, r15
ffc0602f:	ef 2e                         	mov.l	r2, r14
ffc06031:	fd 62 ae                      	shll	r10, r14
ffc06034:	ef 76                         	mov.l	r7, r6
ffc06036:	fc 27 f6                      	divu	r15, r6
ffc06039:	ef 12                         	mov.l	r1, r2
ffc0603b:	fd 60 52                      	shlr	r5, r2
ffc0603e:	ff 35 f6                      	mul 	r15, r6, r5
ffc06041:	57 e2                         	or	r14, r2
ffc06043:	43 57                         	sub	r5, r7
ffc06045:	fb be ff ff 00                	mov.l	#0xffff, r11
ffc0604a:	53 4b                         	and	r4, r11
ffc0604c:	6d 07                         	shll	#16, r7
ffc0604e:	fd 90 2c                      	shlr	#16, r2, r12
ffc06051:	ff 35 6b                      	mul 	r6, r11, r5
ffc06054:	57 c7                         	or	r12, r7
ffc06056:	ef 3c                         	mov.l	r3, r12
ffc06058:	fd 62 ac                      	shll	r10, r12
ffc0605b:	47 75                         	cmp	r7, r5
ffc0605d:	25 19                         	bleu.b	ffc06076 <_Reset_Vector+0xffc0607a>
ffc0605f:	4b 47                         	add	r4, r7
ffc06061:	71 63 ff                      	add	#-1, r6, r3
ffc06064:	47 74                         	cmp	r7, r4
ffc06066:	25 05                         	bleu.b	ffc0606b <_Reset_Vector+0xffc0606f>
ffc06068:	38 e1 00                      	bra.w	ffc06149 <_Reset_Vector+0xffc0614d>
ffc0606b:	47 75                         	cmp	r7, r5
ffc0606d:	24 05                         	bgtu.b	ffc06072 <_Reset_Vector+0xffc06076>
ffc0606f:	38 da 00                      	bra.w	ffc06149 <_Reset_Vector+0xffc0614d>
ffc06072:	60 26                         	sub	#2, r6
ffc06074:	4b 47                         	add	r4, r7
ffc06076:	43 57                         	sub	r5, r7
ffc06078:	fb ee ff ff 00                	mov.l	#0xffff, r14
ffc0607d:	53 2e                         	and	r2, r14
ffc0607f:	ef 75                         	mov.l	r7, r5
ffc06081:	fc 27 f5                      	divu	r15, r5
ffc06084:	ff 32 f5                      	mul 	r15, r5, r2
ffc06087:	43 27                         	sub	r2, r7
ffc06089:	fd d0 72                      	shll	#16, r7, r2
ffc0608c:	4f 5b                         	mul	r5, r11
ffc0608e:	57 e2                         	or	r14, r2
ffc06090:	47 2b                         	cmp	r2, r11
ffc06092:	25 19                         	bleu.b	ffc060ab <_Reset_Vector+0xffc060af>
ffc06094:	4b 42                         	add	r4, r2
ffc06096:	71 57 ff                      	add	#-1, r5, r7
ffc06099:	47 24                         	cmp	r2, r4
ffc0609b:	25 05                         	bleu.b	ffc060a0 <_Reset_Vector+0xffc060a4>
ffc0609d:	38 a2 00                      	bra.w	ffc0613f <_Reset_Vector+0xffc06143>
ffc060a0:	47 2b                         	cmp	r2, r11
ffc060a2:	24 05                         	bgtu.b	ffc060a7 <_Reset_Vector+0xffc060ab>
ffc060a4:	38 9b 00                      	bra.w	ffc0613f <_Reset_Vector+0xffc06143>
ffc060a7:	60 25                         	sub	#2, r5
ffc060a9:	4b 42                         	add	r4, r2
ffc060ab:	fd d0 63                      	shll	#16, r6, r3
ffc060ae:	fb 6e ff ff 00                	mov.l	#0xffff, r6
ffc060b3:	53 c6                         	and	r12, r6
ffc060b5:	57 53                         	or	r5, r3
ffc060b7:	fd 90 ce                      	shlr	#16, r12, r14
ffc060ba:	fb 7e ff ff 00                	mov.l	#0xffff, r7
ffc060bf:	53 37                         	and	r3, r7
ffc060c1:	fd 90 3c                      	shlr	#16, r3, r12
ffc060c4:	ff 34 67                      	mul 	r6, r7, r4
ffc060c7:	4f c6                         	mul	r12, r6
ffc060c9:	4f e7                         	mul	r14, r7
ffc060cb:	fd 90 45                      	shlr	#16, r4, r5
ffc060ce:	4b 67                         	add	r6, r7
ffc060d0:	43 b2                         	sub	r11, r2
ffc060d2:	4b 57                         	add	r5, r7
ffc060d4:	4f ec                         	mul	r14, r12
ffc060d6:	47 76                         	cmp	r7, r6
ffc060d8:	25 08                         	bleu.b	ffc060e0 <_Reset_Vector+0xffc060e4>
ffc060da:	73 cc 00 00 01                	add	#0x10000, r12, r12
ffc060df:	03                            	nop
ffc060e0:	fd 90 75                      	shlr	#16, r7, r5
ffc060e3:	4b 5c                         	add	r5, r12
ffc060e5:	47 c2                         	cmp	r12, r2
ffc060e7:	23 1d                         	bnc.b	ffc06104 <_Reset_Vector+0xffc06108>
ffc060e9:	10                            	beq.s	ffc060f1 <_Reset_Vector+0xffc060f5>
ffc060ea:	ef 31                         	mov.l	r3, r1
ffc060ec:	66 02                         	mov.l	#0, r2
ffc060ee:	3f 6c 07                      	rtsd	#28, r6-r12
ffc060f1:	fd d0 75                      	shll	#16, r7, r5
ffc060f4:	77 24 ff ff 00                	and	#0xffff, r4
ffc060f9:	ef 17                         	mov.l	r1, r7
ffc060fb:	fd 62 a7                      	shll	r10, r7
ffc060fe:	4b 45                         	add	r4, r5
ffc06100:	47 57                         	cmp	r5, r7
ffc06102:	22 e8                         	bc.b	ffc060ea <_Reset_Vector+0xffc060ee>
ffc06104:	71 31 ff                      	add	#-1, r3, r1
ffc06107:	66 02                         	mov.l	#0, r2
ffc06109:	3f 6c 07                      	rtsd	#28, r6-r12
ffc0610c:	fd 90 45                      	shlr	#16, r4, r5
ffc0610f:	75 4a 10                      	mov.l	#16, r10
ffc06112:	38 1e fe                      	bra.w	ffc05f30 <_Reset_Vector+0xffc05f34>
ffc06115:	66 02                         	mov.l	#0, r2
ffc06117:	66 11                         	mov.l	#1, r1
ffc06119:	3f 6c 07                      	rtsd	#28, r6-r12
ffc0611c:	ef 45                         	mov.l	r4, r5
ffc0611e:	66 0a                         	mov.l	#0, r10
ffc06120:	38 10 fe                      	bra.w	ffc05f30 <_Reset_Vector+0xffc05f34>
ffc06123:	ef 36                         	mov.l	r3, r6
ffc06125:	38 ac fc                      	bra.w	ffc05dd1 <_Reset_Vector+0xffc05dd5>
ffc06128:	fd 90 f4                      	shlr	#16, r15, r4
ffc0612b:	75 45 10                      	mov.l	#16, r5
ffc0612e:	38 62 fd                      	bra.w	ffc05e90 <_Reset_Vector+0xffc05e94>
ffc06131:	fd 90 36                      	shlr	#16, r3, r6
ffc06134:	75 45 10                      	mov.l	#16, r5
ffc06137:	38 9a fc                      	bra.w	ffc05dd1 <_Reset_Vector+0xffc05dd5>
ffc0613a:	ef f4                         	mov.l	r15, r4
ffc0613c:	38 54 fd                      	bra.w	ffc05e90 <_Reset_Vector+0xffc05e94>
ffc0613f:	ef 75                         	mov.l	r7, r5
ffc06141:	38 6a ff                      	bra.w	ffc060ab <_Reset_Vector+0xffc060af>
ffc06144:	ef 32                         	mov.l	r3, r2
ffc06146:	38 ce fe                      	bra.w	ffc06014 <_Reset_Vector+0xffc06018>
ffc06149:	ef 36                         	mov.l	r3, r6
ffc0614b:	38 2b ff                      	bra.w	ffc06076 <_Reset_Vector+0xffc0607a>
ffc0614e:	ef 34                         	mov.l	r3, r4
ffc06150:	38 8e fe                      	bra.w	ffc05fde <_Reset_Vector+0xffc05fe2>
ffc06153:	60 23                         	sub	#2, r3
ffc06155:	38 b5 fd                      	bra.w	ffc05f0a <_Reset_Vector+0xffc05f0e>
ffc06158:	60 23                         	sub	#2, r3
ffc0615a:	38 03 fd                      	bra.w	ffc05e5d <_Reset_Vector+0xffc05e61>
ffc0615d:	60 25                         	sub	#2, r5
ffc0615f:	4b fa                         	add	r15, r10
ffc06161:	38 cd fc                      	bra.w	ffc05e2e <_Reset_Vector+0xffc05e32>
ffc06164:	60 25                         	sub	#2, r5
ffc06166:	4b f4                         	add	r15, r4
ffc06168:	38 74 fd                      	bra.w	ffc05edc <_Reset_Vector+0xffc05ee0>
ffc0616b:	77 10 01 00 00                	nop	; mul	#1, r0

ffc06170 <___ltdf2>:
ffc06170:	71 00 c8                      	add	#-56, r0, r0
ffc06173:	a3 01                         	mov.l	r1, 48[r0]
ffc06175:	71 01 30                      	add	#48, r0, r1
ffc06178:	a3 0a                         	mov.l	r2, 52[r0]
ffc0617a:	75 42 14                      	mov.l	#20, r2
ffc0617d:	4b 02                         	add	r0, r2
ffc0617f:	a2 83                         	mov.l	r3, 40[r0]
ffc06181:	a2 8c                         	mov.l	r4, 44[r0]
ffc06183:	05 2d 00 00                   	bsr.a	ffc061b0 <_Reset_Vector+0xffc061b4>
ffc06187:	ef 02                         	mov.l	r0, r2
ffc06189:	71 01 28                      	add	#40, r0, r1
ffc0618c:	05 24 00 00                   	bsr.a	ffc061b0 <_Reset_Vector+0xffc061b4>
ffc06190:	a9 0d                         	mov.l	20[r0], r5
ffc06192:	61 15                         	cmp	#1, r5
ffc06194:	25 15                         	bleu.b	ffc061a9 <_Reset_Vector+0xffc061ad>
ffc06196:	ec 05                         	mov.l	[r0], r5
ffc06198:	61 15                         	cmp	#1, r5
ffc0619a:	25 0f                         	bleu.b	ffc061a9 <_Reset_Vector+0xffc061ad>
ffc0619c:	ef 02                         	mov.l	r0, r2
ffc0619e:	75 41 14                      	mov.l	#20, r1
ffc061a1:	4b 01                         	add	r0, r1
ffc061a3:	05 ad 00 00                   	bsr.a	ffc06250 <_Reset_Vector+0xffc06254>
ffc061a7:	67 0e                         	rtsd	#56
ffc061a9:	66 11                         	mov.l	#1, r1
ffc061ab:	67 0e                         	rtsd	#56
ffc061ad:	00                            	brk
	...

ffc061b0 <___unpack_d>:
ffc061b0:	ed 1e 01                      	mov.l	4[r1], r14
ffc061b3:	ec 14                         	mov.l	[r1], r4
ffc061b5:	fd 94 e3                      	shlr	#20, r14, r3
ffc061b8:	fd 9f e5                      	shlr	#31, r14, r5
ffc061bb:	76 23 ff 07                   	and	#0x7ff, r3
ffc061bf:	a0 2d                         	mov.l	r5, 4[r2]
ffc061c1:	fb 5e ff ff 0f                	mov.l	#0xfffff, r5
ffc061c6:	53 e5                         	and	r14, r5
ffc061c8:	61 03                         	cmp	#0, r3
ffc061ca:	21 38                         	bne.b	ffc06202 <_Reset_Vector+0xffc06206>
ffc061cc:	ff 53 54                      	or	r5, r4, r3
ffc061cf:	61 03                         	cmp	#0, r3
ffc061d1:	20 50                         	beq.b	ffc06221 <_Reset_Vector+0xffc06225>
ffc061d3:	6e 7a                         	pushm	r7-r10
ffc061d5:	fd 98 43                      	shlr	#24, r4, r3
ffc061d8:	6c 85                         	shll	#8, r5
ffc061da:	57 35                         	or	r3, r5
ffc061dc:	6c 84                         	shll	#8, r4
ffc061de:	fb 3a 01 fc                   	mov.l	#0xfffffc01, r3
ffc061e2:	f8 26 03                      	mov.l	#3, [r2]
ffc061e5:	ff 27 44                      	add	r4, r4, r7
ffc061e8:	fc 0b 55                      	adc	r5, r5
ffc061eb:	ef 74                         	mov.l	r7, r4
ffc061ed:	ef 31                         	mov.l	r3, r1
ffc061ef:	60 13                         	sub	#1, r3
ffc061f1:	74 05 ff ff ff 0f             	cmp	#0xfffffff, r5
ffc061f7:	25 ee                         	bleu.b	ffc061e5 <_Reset_Vector+0xffc061e9>
ffc061f9:	a0 a1                         	mov.l	r1, 8[r2]
ffc061fb:	a0 af                         	mov.l	r7, 12[r2]
ffc061fd:	a1 25                         	mov.l	r5, 16[r2]
ffc061ff:	3f 7a 04                      	rtsd	#16, r7-r10
ffc06202:	76 03 ff 07                   	cmp	#0x7ff, r3
ffc06206:	20 1f                         	beq.b	ffc06225 <_Reset_Vector+0xffc06229>
ffc06208:	fd 98 41                      	shlr	#24, r4, r1
ffc0620b:	6c 85                         	shll	#8, r5
ffc0620d:	57 15                         	or	r1, r5
ffc0620f:	72 33 01 fc                   	add	#0xfffffc01, r3, r3
ffc06213:	79 c5                         	bset	#28, r5
ffc06215:	6c 84                         	shll	#8, r4
ffc06217:	a0 a3                         	mov.l	r3, 8[r2]
ffc06219:	f8 26 03                      	mov.l	#3, [r2]
ffc0621c:	a0 ac                         	mov.l	r4, 12[r2]
ffc0621e:	a1 25                         	mov.l	r5, 16[r2]
ffc06220:	02                            	rts
ffc06221:	f8 26 02                      	mov.l	#2, [r2]
ffc06224:	02                            	rts
ffc06225:	57 45                         	or	r4, r5
ffc06227:	61 05                         	cmp	#0, r5
ffc06229:	1d                            	bne.s	ffc0622e <_Reset_Vector+0xffc06232>
ffc0622a:	f8 26 04                      	mov.l	#4, [r2]
ffc0622d:	02                            	rts
ffc0622e:	fd 98 41                      	shlr	#24, r4, r1
ffc06231:	fd c8 e3                      	shll	#8, r14, r3
ffc06234:	fd 93 e5                      	shlr	#19, r14, r5
ffc06237:	57 13                         	or	r1, r3
ffc06239:	64 15                         	and	#1, r5
ffc0623b:	6c 84                         	shll	#8, r4
ffc0623d:	74 23 ff ff ff 07             	and	#0x7ffffff, r3
ffc06243:	e3 25                         	mov.l	r5, [r2]
ffc06245:	a0 ac                         	mov.l	r4, 12[r2]
ffc06247:	a1 23                         	mov.l	r3, 16[r2]
ffc06249:	02                            	rts
ffc0624a:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffc06250 <___fpcmp_parts_d>:
ffc06250:	ec 15                         	mov.l	[r1], r5
ffc06252:	61 15                         	cmp	#1, r5
ffc06254:	25 34                         	bleu.b	ffc06288 <_Reset_Vector+0xffc0628c>
ffc06256:	ec 24                         	mov.l	[r2], r4
ffc06258:	61 14                         	cmp	#1, r4
ffc0625a:	25 2e                         	bleu.b	ffc06288 <_Reset_Vector+0xffc0628c>
ffc0625c:	61 45                         	cmp	#4, r5
ffc0625e:	20 2d                         	beq.b	ffc0628b <_Reset_Vector+0xffc0628f>
ffc06260:	61 44                         	cmp	#4, r4
ffc06262:	20 4c                         	beq.b	ffc062ae <_Reset_Vector+0xffc062b2>
ffc06264:	61 25                         	cmp	#2, r5
ffc06266:	20 44                         	beq.b	ffc062aa <_Reset_Vector+0xffc062ae>
ffc06268:	a8 1d                         	mov.l	4[r1], r5
ffc0626a:	61 24                         	cmp	#2, r4
ffc0626c:	20 34                         	beq.b	ffc062a0 <_Reset_Vector+0xffc062a4>
ffc0626e:	a8 2c                         	mov.l	4[r2], r4
ffc06270:	47 54                         	cmp	r5, r4
ffc06272:	21 2e                         	bne.b	ffc062a0 <_Reset_Vector+0xffc062a4>
ffc06274:	ed 1e 02                      	mov.l	8[r1], r14
ffc06277:	a8 a3                         	mov.l	8[r2], r3
ffc06279:	47 3e                         	cmp	r3, r14
ffc0627b:	2a 68                         	bgt.b	ffc062e3 <_Reset_Vector+0xffc062e7>
ffc0627d:	28 3c                         	bge.b	ffc062b9 <_Reset_Vector+0xffc062bd>
ffc0627f:	61 04                         	cmp	#0, r4
ffc06281:	66 11                         	mov.l	#1, r1
ffc06283:	fd 74 e1 ff                   	stz	#-1, r1
ffc06287:	02                            	rts
ffc06288:	66 11                         	mov.l	#1, r1
ffc0628a:	02                            	rts
ffc0628b:	a8 19                         	mov.l	4[r1], r1
ffc0628d:	61 44                         	cmp	#4, r4
ffc0628f:	20 4e                         	beq.b	ffc062dd <_Reset_Vector+0xffc062e1>
ffc06291:	61 01                         	cmp	#0, r1
ffc06293:	fb 16 ff                      	mov.l	#-1, r1
ffc06296:	fd 74 e1 01                   	stz	#1, r1
ffc0629a:	02                            	rts
ffc0629b:	47 21                         	cmp	r2, r1
ffc0629d:	25 2b                         	bleu.b	ffc062c8 <_Reset_Vector+0xffc062cc>
ffc0629f:	03                            	nop
ffc062a0:	61 05                         	cmp	#0, r5
ffc062a2:	fb 16 ff                      	mov.l	#-1, r1
ffc062a5:	fd 74 e1 01                   	stz	#1, r1
ffc062a9:	02                            	rts
ffc062aa:	61 24                         	cmp	#2, r4
ffc062ac:	20 21                         	beq.b	ffc062cd <_Reset_Vector+0xffc062d1>
ffc062ae:	a8 29                         	mov.l	4[r2], r1
ffc062b0:	61 01                         	cmp	#0, r1
ffc062b2:	66 11                         	mov.l	#1, r1
ffc062b4:	fd 74 e1 ff                   	stz	#-1, r1
ffc062b8:	02                            	rts
ffc062b9:	a9 14                         	mov.l	16[r1], r4
ffc062bb:	a9 23                         	mov.l	16[r2], r3
ffc062bd:	a8 99                         	mov.l	12[r1], r1
ffc062bf:	a8 aa                         	mov.l	12[r2], r2
ffc062c1:	47 34                         	cmp	r3, r4
ffc062c3:	24 dd                         	bgtu.b	ffc062a0 <_Reset_Vector+0xffc062a4>
ffc062c5:	20 d6                         	beq.b	ffc0629b <_Reset_Vector+0xffc0629f>
ffc062c7:	03                            	nop
ffc062c8:	47 43                         	cmp	r4, r3
ffc062ca:	24 0a                         	bgtu.b	ffc062d4 <_Reset_Vector+0xffc062d8>
ffc062cc:	14                            	beq.s	ffc062d0 <_Reset_Vector+0xffc062d4>
ffc062cd:	66 01                         	mov.l	#0, r1
ffc062cf:	02                            	rts
ffc062d0:	47 12                         	cmp	r1, r2
ffc062d2:	25 fb                         	bleu.b	ffc062cd <_Reset_Vector+0xffc062d1>
ffc062d4:	61 05                         	cmp	#0, r5
ffc062d6:	66 11                         	mov.l	#1, r1
ffc062d8:	fd 74 e1 ff                   	stz	#-1, r1
ffc062dc:	02                            	rts
ffc062dd:	a8 2d                         	mov.l	4[r2], r5
ffc062df:	ff 01 15                      	sub	r1, r5, r1
ffc062e2:	02                            	rts
ffc062e3:	61 04                         	cmp	#0, r4
ffc062e5:	fb 16 ff                      	mov.l	#-1, r1
ffc062e8:	fd 74 e1 01                   	stz	#1, r1
ffc062ec:	02                            	rts
ffc062ed:	fc 13 00                      	nop	; max	r0, r0
