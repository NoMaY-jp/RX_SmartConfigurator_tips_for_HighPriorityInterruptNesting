
RXv3_RX72T_Motor_CG_GCC.elf:     file format elf32-rx-le


Disassembly of section .text:

fff80000 <_PowerON_Reset>:


_PowerON_Reset_PC :
_PowerON_Reset :
;;initialise user stack pointer
    mvtc    #_ustack,USP
fff80000:	fd 73 02 00 18 00 00          	mvtc	#0x1800, usp

;;initialise interrupt stack pointer
    mvtc    #_istack,ISP
fff80007:	fd 73 0a 00 08 00 00          	mvtc	#0x800, isp

;;jump to Power ON Reset main function in RESETPRG.C
    bra     _PowerON_Reset_PC_Prg
fff8000e:	04 32 0e 00                   	bra.a	fff80e40 <_Reset_Vector+0xfff80e44>

fff80012 <__INITSCT>:
    .global __INITSCT
    .type   __INITSCT,@function
__INITSCT:

;;load data section from ROM to RAM
    pushm   r1-r3
fff80012:	6e 13                         	pushm	r1-r3
    mov     #_mdata,r2      ;;src ROM address of data section in R2
fff80014:	fb 22 00 23 f8 ff             	mov.l	#0xfff82300, r2
    mov     #_data,r1       ;;dest start RAM address of data section in R1
fff8001a:	fb 12 04 00 00 00             	mov.l	#4, r1
    mov     #_edata,r3      ;;end RAM address of data section in R3
fff80020:	fb 32 04 00 00 00             	mov.l	#4, r3
    sub     r1,r3           ;;size of data section in R3 (R3=R3-R1)
fff80026:	43 13                         	sub	r1, r3
    smovf                   ;;block copy R3 bytes from R2 to R1
fff80028:	7f 8f                         	smovf

;;bss initialisation : zero out bss
    mov    #00h,r2          ;;load R2 reg with zero
fff8002a:	66 02                         	mov.l	#0, r2
    mov    #_ebss, r3       ;;store the end address of bss in R3
fff8002c:	fb 32 b4 02 00 00             	mov.l	#692, r3
    mov    #_bss, r1        ;;store the start address of bss in R1
fff80032:	fb 12 04 00 00 00             	mov.l	#4, r1
    sub    r1,r3            ;;size of bss section in R3 (R3=R3-R1)
fff80038:	43 13                         	sub	r1, r3
    sstr.b
fff8003a:	7f 88                         	sstr.b
    popm    r1-r3
fff8003c:	6f 13                         	popm	r1-r3
    rts
fff8003e:	02                            	rts

fff8003f <_exit>:

#endif

;;call to exit
_exit:
    bra  _loop_here
fff8003f:	2e 02                         	bra.b	fff80041 <_Reset_Vector+0xfff80045>

fff80041 <_loop_here>:
_loop_here:
    bra _loop_here
fff80041:	2e 00                         	bra.b	fff80041 <_Reset_Vector+0xfff80045>

fff80043 <L0^A>:
fff80043:	00                            	brk
fff80044:	00                            	brk
fff80045:	00                            	brk
	...

fff80048 <_excep_supervisor_inst_isr>:
* Description  : Supervisor Instruction Violation ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_supervisor_inst_isr(void)
{
fff80048:	6e ef                         	pushm	r14-r15
fff8004a:	6e 15                         	pushm	r1-r5
fff8004c:	fd 1f 11                      	mvfaclo	#0, a0, r1
fff8004f:	fd 1f 02                      	mvfachi	#0, a0, r2
fff80052:	7e a1                         	push.l	r1
fff80054:	7e a2                         	push.l	r2
fff80056:	fd 1f 31                      	mvfacgu	#0, a0, r1
fff80059:	fd 1f 92                      	mvfaclo	#0, a1, r2
fff8005c:	7e a1                         	push.l	r1
fff8005e:	7e a2                         	push.l	r2
fff80060:	fd 1f 81                      	mvfachi	#0, a1, r1
fff80063:	fd 1f b2                      	mvfacgu	#0, a1, r2
fff80066:	7e a1                         	push.l	r1
fff80068:	7e a2                         	push.l	r2
fff8006a:	60 40                         	sub	#4, r0

fff8006c <.LBB218>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
fff8006c:	fb 52 0c 00 00 00             	mov.l	#12, r5
fff80072:	ec 55                         	mov.l	[r5], r5
fff80074:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
fff8007b:	10                            	beq.s	fff80083 <_Reset_Vector+0xfff80087>
                g_bsp_vectors[vector](&cb_args);
fff8007c:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
fff8007e:	f8 06 00                      	mov.l	#0, [r0]
                g_bsp_vectors[vector](&cb_args);
fff80081:	7f 15                         	jsr	r5

fff80083 <.LVL114>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_SUPERVISOR_INSTR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_supervisor_inst_isr() */
fff80083:	62 40                         	add	#4, r0
fff80085:	7e b2                         	pop	r2
fff80087:	7e b1                         	pop	r1
fff80089:	fd 17 81                      	mvtachi	r1, a1
fff8008c:	fd 17 b2                      	mvtacgu	r2, a1
fff8008f:	7e b2                         	pop	r2
fff80091:	7e b1                         	pop	r1
fff80093:	fd 17 31                      	mvtacgu	r1, a0
fff80096:	fd 17 92                      	mvtaclo	r2, a1
fff80099:	7e b2                         	pop	r2
fff8009b:	7e b1                         	pop	r1
fff8009d:	fd 17 11                      	mvtaclo	r1, a0
fff800a0:	fd 17 02                      	mvtachi	r2, a0
fff800a3:	6f 15                         	popm	r1-r5
fff800a5:	6f ef                         	popm	r14-r15
fff800a7:	7f 95                         	rte

fff800a9 <.LFE11>:
fff800a9:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

fff800b0 <_excep_access_isr>:
* Description  : Access exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_access_isr(void)
{
fff800b0:	6e ef                         	pushm	r14-r15
fff800b2:	6e 15                         	pushm	r1-r5
fff800b4:	fd 1f 11                      	mvfaclo	#0, a0, r1
fff800b7:	fd 1f 02                      	mvfachi	#0, a0, r2
fff800ba:	7e a1                         	push.l	r1
fff800bc:	7e a2                         	push.l	r2
fff800be:	fd 1f 31                      	mvfacgu	#0, a0, r1
fff800c1:	fd 1f 92                      	mvfaclo	#0, a1, r2
fff800c4:	7e a1                         	push.l	r1
fff800c6:	7e a2                         	push.l	r2
fff800c8:	fd 1f 81                      	mvfachi	#0, a1, r1
fff800cb:	fd 1f b2                      	mvfacgu	#0, a1, r2
fff800ce:	7e a1                         	push.l	r1
fff800d0:	7e a2                         	push.l	r2
fff800d2:	60 40                         	sub	#4, r0

fff800d4 <.LBB222>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
fff800d4:	fb 52 0c 00 00 00             	mov.l	#12, r5
fff800da:	a9 55                         	mov.l	16[r5], r5
fff800dc:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
fff800e3:	10                            	beq.s	fff800eb <_Reset_Vector+0xfff800ef>
                g_bsp_vectors[vector](&cb_args);
fff800e4:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
fff800e6:	f8 06 04                      	mov.l	#4, [r0]
                g_bsp_vectors[vector](&cb_args);
fff800e9:	7f 15                         	jsr	r5

fff800eb <.LVL116>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_ACCESS, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_access_isr() */
fff800eb:	62 40                         	add	#4, r0
fff800ed:	7e b2                         	pop	r2
fff800ef:	7e b1                         	pop	r1
fff800f1:	fd 17 81                      	mvtachi	r1, a1
fff800f4:	fd 17 b2                      	mvtacgu	r2, a1
fff800f7:	7e b2                         	pop	r2
fff800f9:	7e b1                         	pop	r1
fff800fb:	fd 17 31                      	mvtacgu	r1, a0
fff800fe:	fd 17 92                      	mvtaclo	r2, a1
fff80101:	7e b2                         	pop	r2
fff80103:	7e b1                         	pop	r1
fff80105:	fd 17 11                      	mvtaclo	r1, a0
fff80108:	fd 17 02                      	mvtachi	r2, a0
fff8010b:	6f 15                         	popm	r1-r5
fff8010d:	6f ef                         	popm	r14-r15
fff8010f:	7f 95                         	rte

fff80111 <.LFE12>:
fff80111:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

fff80118 <_excep_undefined_inst_isr>:
* Description  : Undefined instruction exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_undefined_inst_isr(void)
{
fff80118:	6e ef                         	pushm	r14-r15
fff8011a:	6e 15                         	pushm	r1-r5
fff8011c:	fd 1f 11                      	mvfaclo	#0, a0, r1
fff8011f:	fd 1f 02                      	mvfachi	#0, a0, r2
fff80122:	7e a1                         	push.l	r1
fff80124:	7e a2                         	push.l	r2
fff80126:	fd 1f 31                      	mvfacgu	#0, a0, r1
fff80129:	fd 1f 92                      	mvfaclo	#0, a1, r2
fff8012c:	7e a1                         	push.l	r1
fff8012e:	7e a2                         	push.l	r2
fff80130:	fd 1f 81                      	mvfachi	#0, a1, r1
fff80133:	fd 1f b2                      	mvfacgu	#0, a1, r2
fff80136:	7e a1                         	push.l	r1
fff80138:	7e a2                         	push.l	r2
fff8013a:	60 40                         	sub	#4, r0

fff8013c <.LBB226>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
fff8013c:	fb 52 0c 00 00 00             	mov.l	#12, r5
fff80142:	a8 5d                         	mov.l	4[r5], r5
fff80144:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
fff8014b:	10                            	beq.s	fff80153 <_Reset_Vector+0xfff80157>
                g_bsp_vectors[vector](&cb_args);
fff8014c:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
fff8014e:	f8 06 01                      	mov.l	#1, [r0]
                g_bsp_vectors[vector](&cb_args);
fff80151:	7f 15                         	jsr	r5

fff80153 <.LVL118>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_UNDEFINED_INSTR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_undefined_inst_isr() */
fff80153:	62 40                         	add	#4, r0
fff80155:	7e b2                         	pop	r2
fff80157:	7e b1                         	pop	r1
fff80159:	fd 17 81                      	mvtachi	r1, a1
fff8015c:	fd 17 b2                      	mvtacgu	r2, a1
fff8015f:	7e b2                         	pop	r2
fff80161:	7e b1                         	pop	r1
fff80163:	fd 17 31                      	mvtacgu	r1, a0
fff80166:	fd 17 92                      	mvtaclo	r2, a1
fff80169:	7e b2                         	pop	r2
fff8016b:	7e b1                         	pop	r1
fff8016d:	fd 17 11                      	mvtaclo	r1, a0
fff80170:	fd 17 02                      	mvtachi	r2, a0
fff80173:	6f 15                         	popm	r1-r5
fff80175:	6f ef                         	popm	r14-r15
fff80177:	7f 95                         	rte

fff80179 <.LFE13>:
fff80179:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

fff80180 <_excep_floating_point_isr>:
* Description  : Floating point exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_floating_point_isr(void)
{
fff80180:	6e ef                         	pushm	r14-r15
fff80182:	6e 15                         	pushm	r1-r5
fff80184:	fd 1f 11                      	mvfaclo	#0, a0, r1
fff80187:	fd 1f 02                      	mvfachi	#0, a0, r2
fff8018a:	7e a1                         	push.l	r1
fff8018c:	7e a2                         	push.l	r2
fff8018e:	fd 1f 31                      	mvfacgu	#0, a0, r1
fff80191:	fd 1f 92                      	mvfaclo	#0, a1, r2
fff80194:	7e a1                         	push.l	r1
fff80196:	7e a2                         	push.l	r2
fff80198:	fd 1f 81                      	mvfachi	#0, a1, r1
fff8019b:	fd 1f b2                      	mvfacgu	#0, a1, r2
fff8019e:	7e a1                         	push.l	r1
fff801a0:	7e a2                         	push.l	r2
fff801a2:	60 40                         	sub	#4, r0

fff801a4 <.LBB230>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
fff801a4:	fb 52 0c 00 00 00             	mov.l	#12, r5
fff801aa:	a8 dd                         	mov.l	12[r5], r5
fff801ac:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
fff801b3:	10                            	beq.s	fff801bb <_Reset_Vector+0xfff801bf>
                g_bsp_vectors[vector](&cb_args);
fff801b4:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
fff801b6:	f8 06 03                      	mov.l	#3, [r0]
                g_bsp_vectors[vector](&cb_args);
fff801b9:	7f 15                         	jsr	r5

fff801bb <.LVL120>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_FPU, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);

#ifdef __FPU
    /* Get current FPSW. */
    tmp_fpsw = (uint32_t)R_BSP_GET_FPSW();
fff801bb:	fd 6a 35                      	mvfc	fpsw, r5

fff801be <.LVL121>:

    /* Clear only the FPU exception flags. */
    R_BSP_SET_FPSW(tmp_fpsw & ((uint32_t)~BSP_PRV_FPU_CAUSE_FLAGS));
fff801be:	76 25 03 ff                   	and	#-253, r5

fff801c2 <.LVL122>:
fff801c2:	fd 68 53                      	mvtc	r5, fpsw
#endif
} /* End of function excep_floating_point_isr() */
fff801c5:	62 40                         	add	#4, r0
fff801c7:	7e b2                         	pop	r2
fff801c9:	7e b1                         	pop	r1
fff801cb:	fd 17 81                      	mvtachi	r1, a1
fff801ce:	fd 17 b2                      	mvtacgu	r2, a1
fff801d1:	7e b2                         	pop	r2
fff801d3:	7e b1                         	pop	r1
fff801d5:	fd 17 31                      	mvtacgu	r1, a0
fff801d8:	fd 17 92                      	mvtaclo	r2, a1
fff801db:	7e b2                         	pop	r2
fff801dd:	7e b1                         	pop	r1
fff801df:	fd 17 11                      	mvtaclo	r1, a0
fff801e2:	fd 17 02                      	mvtachi	r2, a0
fff801e5:	6f 15                         	popm	r1-r5
fff801e7:	6f ef                         	popm	r14-r15
fff801e9:	7f 95                         	rte

fff801eb <.LFE14>:
fff801eb:	77 10 01 00 00                	nop	; mul	#1, r0

fff801f0 <_non_maskable_isr>:
* Description  : Non-maskable interrupt ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void non_maskable_isr(void)
{
fff801f0:	6e 1f                         	pushm	r1-r15
fff801f2:	fd 1f 11                      	mvfaclo	#0, a0, r1
fff801f5:	fd 1f 02                      	mvfachi	#0, a0, r2
fff801f8:	6e 12                         	pushm	r1-r2
fff801fa:	fd 1f 31                      	mvfacgu	#0, a0, r1
fff801fd:	fd 1f 92                      	mvfaclo	#0, a1, r2
fff80200:	6e 12                         	pushm	r1-r2
fff80202:	fd 1f 81                      	mvfachi	#0, a1, r1
fff80205:	fd 1f b2                      	mvfacgu	#0, a1, r2
fff80208:	6e 12                         	pushm	r1-r2
    /* Determine what is the cause of this interrupt. */

#ifdef BSP_MCU_NMI_EXC_NMI_PIN
    /* EXC_NMI_PIN */
    if ((1 == ICU.NMISR.BIT.NMIST) && (1 == ICU.NMIER.BIT.NMIEN))
fff8020a:	fb 7e 00 70 08                	mov.l	#0x87000, r7
fff8020f:	ce 75 80 05                   	mov.b	1408[r7], r5
fff80213:	7c 05                         	btst	#0, r5
fff80215:	21 63                         	bne.b	fff80278 <_Reset_Vector+0xfff8027c>
fff80217:	03                            	nop
    }
#endif

#ifdef BSP_MCU_NMI_OSC_STOP_DETECT
    /* OSC_STOP_DETECT */
    if ((1 == ICU.NMISR.BIT.OSTST) && (1 == ICU.NMIER.BIT.OSTEN))
fff80218:	fb 7e 00 70 08                	mov.l	#0x87000, r7
fff8021d:	ce 75 80 05                   	mov.b	1408[r7], r5
fff80221:	7c 15                         	btst	#1, r5
fff80223:	3b fa 00                      	bne.w	fff8031d <_Reset_Vector+0xfff80321>
fff80226:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_WDT_ERROR
    /* WDT_ERROR */
    if ((1 == ICU.NMISR.BIT.WDTST) && (1 == ICU.NMIER.BIT.WDTEN))
fff80228:	fb 7e 00 70 08                	mov.l	#0x87000, r7
fff8022d:	ce 75 80 05                   	mov.b	1408[r7], r5
fff80231:	7c 25                         	btst	#2, r5
fff80233:	3b d4 00                      	bne.w	fff80307 <_Reset_Vector+0xfff8030b>
fff80236:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_IWDT_ERROR
    /* IWDT_ERROR */
    if ((1 == ICU.NMISR.BIT.IWDTST) && (1 == ICU.NMIER.BIT.IWDTEN))
fff80238:	fb 7e 00 70 08                	mov.l	#0x87000, r7
fff8023d:	ce 75 80 05                   	mov.b	1408[r7], r5
fff80241:	7c 35                         	btst	#3, r5
fff80243:	3b ae 00                      	bne.w	fff802f1 <_Reset_Vector+0xfff802f5>
fff80246:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_LVD1
    /* LVD1 */
    if ((1 == ICU.NMISR.BIT.LVD1ST) && (1 == ICU.NMIER.BIT.LVD1EN))
fff80248:	fb 7e 00 70 08                	mov.l	#0x87000, r7
fff8024d:	ce 75 80 05                   	mov.b	1408[r7], r5
fff80251:	7c 45                         	btst	#4, r5
fff80253:	3b 88 00                      	bne.w	fff802db <_Reset_Vector+0xfff802df>
fff80256:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_LVD2
    /* LVD2 */
    if ((1 == ICU.NMISR.BIT.LVD2ST) && (1 == ICU.NMIER.BIT.LVD2EN))
fff80258:	fb 7e 00 70 08                	mov.l	#0x87000, r7
fff8025d:	ce 75 80 05                   	mov.b	1408[r7], r5
fff80261:	7c 55                         	btst	#5, r5
fff80263:	21 64                         	bne.b	fff802c7 <_Reset_Vector+0xfff802cb>
fff80265:	fc 13 00                      	nop	; max	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_RAM
    /* RAM */
    if ((1 == ICU.NMISR.BIT.RAMST) && (1 == ICU.NMIER.BIT.RAMEN))
fff80268:	fb 7e 00 70 08                	mov.l	#0x87000, r7
fff8026d:	ce 75 80 05                   	mov.b	1408[r7], r5
fff80271:	7c 65                         	btst	#6, r5
fff80273:	21 19                         	bne.b	fff8028c <_Reset_Vector+0xfff80290>
    {
        /* Infinite loop. Return from Non-maskable interrupt handlling routine is prohibited.
           Never use the non-maskable interrupt with an attempt to return to the program that was being executed at 
           the time of interrupt generation after the exception handling routine is ended.
         */
         R_BSP_NOP();
fff80275:	03                            	nop
fff80276:	2e ff                         	bra.b	fff80275 <_Reset_Vector+0xfff80279>
    if ((1 == ICU.NMISR.BIT.NMIST) && (1 == ICU.NMIER.BIT.NMIEN))
fff80278:	ce 75 81 05                   	mov.b	1409[r7], r5
fff8027c:	7c 05                         	btst	#0, r5
fff8027e:	20 9a                         	beq.b	fff80218 <_Reset_Vector+0xfff8021c>
        R_BSP_InterruptControl(BSP_INT_SRC_EXC_NMI_PIN, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff80280:	66 21                         	mov.l	#2, r1
fff80282:	05 28 08 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff80286 <.LVL123>:
        ICU.NMICLR.BIT.NMICLR = 1;
fff80286:	f2 70 82 05                   	bset	#0, 1410[r7].b
fff8028a:	2e 8e                         	bra.b	fff80218 <_Reset_Vector+0xfff8021c>
    if ((1 == ICU.NMISR.BIT.RAMST) && (1 == ICU.NMIER.BIT.RAMEN))
fff8028c:	ce 75 81 05                   	mov.b	1409[r7], r5
fff80290:	7c 65                         	btst	#6, r5
fff80292:	20 e3                         	beq.b	fff80275 <_Reset_Vector+0xfff80279>
        if(1 == RAM.RAMSTS.BIT.RAMERR)
fff80294:	fb 7e 00 12 08                	mov.l	#0x81200, r7
fff80299:	88 7d                         	mov.b	1[r7], r5
fff8029b:	7c 05                         	btst	#0, r5
fff8029d:	3b 96 00                      	bne.w	fff80333 <_Reset_Vector+0xfff80337>
        if(1 == RAM.ECCRAM1STS.BIT.ECC1ERR)
fff802a0:	fb 7e 00 12 08                	mov.l	#0x81200, r7
fff802a5:	cd 75 c3                      	mov.b	195[r7], r5
fff802a8:	7c 05                         	btst	#0, r5
fff802aa:	3b 95 00                      	bne.w	fff8033f <_Reset_Vector+0xfff80343>
fff802ad:	fc 13 00                      	nop	; max	r0, r0
        if(1 == RAM.ECCRAM2STS.BIT.ECC2ERR)
fff802b0:	fb 7e 00 12 08                	mov.l	#0x81200, r7
fff802b5:	cd 75 c1                      	mov.b	193[r7], r5
fff802b8:	7c 05                         	btst	#0, r5
fff802ba:	20 bb                         	beq.b	fff80275 <_Reset_Vector+0xfff80279>
            R_BSP_InterruptControl(BSP_INT_SRC_ECCRAM_2BIT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff802bc:	66 e1                         	mov.l	#14, r1
fff802be:	05 ec 07 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff802c2 <.LVL124>:
            RAM.ECCRAM2STS.BIT.ECC2ERR = 0;
fff802c2:	f1 78 c1                      	bclr	#0, 193[r7].b
fff802c5:	2e b0                         	bra.b	fff80275 <_Reset_Vector+0xfff80279>
    if ((1 == ICU.NMISR.BIT.LVD2ST) && (1 == ICU.NMIER.BIT.LVD2EN))
fff802c7:	ce 75 81 05                   	mov.b	1409[r7], r5
fff802cb:	7c 55                         	btst	#5, r5
fff802cd:	20 9b                         	beq.b	fff80268 <_Reset_Vector+0xfff8026c>
        R_BSP_InterruptControl(BSP_INT_SRC_LVD2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff802cf:	66 91                         	mov.l	#9, r1
fff802d1:	05 d9 07 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff802d5 <.LVL125>:
        ICU.NMICLR.BIT.LVD2CLR = 1;
fff802d5:	f2 75 82 05                   	bset	#5, 1410[r7].b
fff802d9:	2e 8f                         	bra.b	fff80268 <_Reset_Vector+0xfff8026c>
    if ((1 == ICU.NMISR.BIT.LVD1ST) && (1 == ICU.NMIER.BIT.LVD1EN))
fff802db:	ce 75 81 05                   	mov.b	1409[r7], r5
fff802df:	7c 45                         	btst	#4, r5
fff802e1:	3a 77 ff                      	beq.w	fff80258 <_Reset_Vector+0xfff8025c>
        R_BSP_InterruptControl(BSP_INT_SRC_LVD1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff802e4:	66 81                         	mov.l	#8, r1
fff802e6:	05 c4 07 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff802ea <.LVL126>:
        ICU.NMICLR.BIT.LVD1CLR = 1;
fff802ea:	f2 74 82 05                   	bset	#4, 1410[r7].b
fff802ee:	38 6a ff                      	bra.w	fff80258 <_Reset_Vector+0xfff8025c>
    if ((1 == ICU.NMISR.BIT.IWDTST) && (1 == ICU.NMIER.BIT.IWDTEN))
fff802f1:	ce 75 81 05                   	mov.b	1409[r7], r5
fff802f5:	7c 35                         	btst	#3, r5
fff802f7:	3a 51 ff                      	beq.w	fff80248 <_Reset_Vector+0xfff8024c>
        R_BSP_InterruptControl(BSP_INT_SRC_IWDT_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff802fa:	66 71                         	mov.l	#7, r1
fff802fc:	05 ae 07 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff80300 <.LVL127>:
        ICU.NMICLR.BIT.IWDTCLR = 1;
fff80300:	f2 73 82 05                   	bset	#3, 1410[r7].b
fff80304:	38 44 ff                      	bra.w	fff80248 <_Reset_Vector+0xfff8024c>
    if ((1 == ICU.NMISR.BIT.WDTST) && (1 == ICU.NMIER.BIT.WDTEN))
fff80307:	ce 75 81 05                   	mov.b	1409[r7], r5
fff8030b:	7c 25                         	btst	#2, r5
fff8030d:	3a 2b ff                      	beq.w	fff80238 <_Reset_Vector+0xfff8023c>
        R_BSP_InterruptControl(BSP_INT_SRC_WDT_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff80310:	66 61                         	mov.l	#6, r1
fff80312:	05 98 07 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff80316 <.LVL128>:
        ICU.NMICLR.BIT.WDTCLR = 1;
fff80316:	f2 72 82 05                   	bset	#2, 1410[r7].b
fff8031a:	38 1e ff                      	bra.w	fff80238 <_Reset_Vector+0xfff8023c>
    if ((1 == ICU.NMISR.BIT.OSTST) && (1 == ICU.NMIER.BIT.OSTEN))
fff8031d:	ce 75 81 05                   	mov.b	1409[r7], r5
fff80321:	7c 15                         	btst	#1, r5
fff80323:	3a 05 ff                      	beq.w	fff80228 <_Reset_Vector+0xfff8022c>
        R_BSP_InterruptControl(BSP_INT_SRC_OSC_STOP_DETECT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff80326:	66 51                         	mov.l	#5, r1
fff80328:	05 82 07 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff8032c <.LVL129>:
        ICU.NMICLR.BIT.OSTCLR = 1;
fff8032c:	f2 71 82 05                   	bset	#1, 1410[r7].b
fff80330:	38 f8 fe                      	bra.w	fff80228 <_Reset_Vector+0xfff8022c>
            R_BSP_InterruptControl(BSP_INT_SRC_RAM, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff80333:	66 c1                         	mov.l	#12, r1
fff80335:	05 75 07 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff80339 <.LVL130>:
            RAM.RAMSTS.BIT.RAMERR = 0;
fff80339:	f1 78 01                      	bclr	#0, 1[r7].b
fff8033c:	38 64 ff                      	bra.w	fff802a0 <_Reset_Vector+0xfff802a4>
            R_BSP_InterruptControl(BSP_INT_SRC_ECCRAM_1BIT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff8033f:	66 d1                         	mov.l	#13, r1
fff80341:	05 69 07 00                   	bsr.a	fff80aaa <_Reset_Vector+0xfff80aae>

fff80345 <.LVL131>:
            RAM.ECCRAM1STS.BIT.ECC1ERR = 0;
fff80345:	f1 78 c3                      	bclr	#0, 195[r7].b
fff80348:	38 68 ff                      	bra.w	fff802b0 <_Reset_Vector+0xfff802b4>

fff8034b <.LFE15>:
fff8034b:	77 10 01 00 00                	nop	; mul	#1, r0

fff80350 <_undefined_interrupt_source_isr>:
*                Set a breakpoint in this function to determine which source is creating unwanted interrupts.
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void undefined_interrupt_source_isr(void)
{
fff80350:	6e ef                         	pushm	r14-r15
fff80352:	6e 15                         	pushm	r1-r5
fff80354:	fd 1f 11                      	mvfaclo	#0, a0, r1
fff80357:	fd 1f 02                      	mvfachi	#0, a0, r2
fff8035a:	7e a1                         	push.l	r1
fff8035c:	7e a2                         	push.l	r2
fff8035e:	fd 1f 31                      	mvfacgu	#0, a0, r1
fff80361:	fd 1f 92                      	mvfaclo	#0, a1, r2
fff80364:	7e a1                         	push.l	r1
fff80366:	7e a2                         	push.l	r2
fff80368:	fd 1f 81                      	mvfachi	#0, a1, r1
fff8036b:	fd 1f b2                      	mvfacgu	#0, a1, r2
fff8036e:	7e a1                         	push.l	r1
fff80370:	7e a2                         	push.l	r2
fff80372:	60 40                         	sub	#4, r0

fff80374 <.LBB234>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
fff80374:	fb 52 0c 00 00 00             	mov.l	#12, r5
fff8037a:	aa d5                         	mov.l	40[r5], r5
fff8037c:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
fff80383:	10                            	beq.s	fff8038b <_Reset_Vector+0xfff8038f>
                g_bsp_vectors[vector](&cb_args);
fff80384:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
fff80386:	f8 06 0a                      	mov.l	#10, [r0]
                g_bsp_vectors[vector](&cb_args);
fff80389:	7f 15                         	jsr	r5

fff8038b <.LVL133>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_UNDEFINED_INTERRUPT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function undefined_interrupt_source_isr() */
fff8038b:	62 40                         	add	#4, r0
fff8038d:	7e b2                         	pop	r2
fff8038f:	7e b1                         	pop	r1
fff80391:	fd 17 81                      	mvtachi	r1, a1
fff80394:	fd 17 b2                      	mvtacgu	r2, a1
fff80397:	7e b2                         	pop	r2
fff80399:	7e b1                         	pop	r1
fff8039b:	fd 17 31                      	mvtacgu	r1, a0
fff8039e:	fd 17 92                      	mvtaclo	r2, a1
fff803a1:	7e b2                         	pop	r2
fff803a3:	7e b1                         	pop	r1
fff803a5:	fd 17 11                      	mvtaclo	r1, a0
fff803a8:	fd 17 02                      	mvtachi	r2, a0
fff803ab:	6f 15                         	popm	r1-r5
fff803ad:	6f ef                         	popm	r14-r15
fff803af:	7f 95                         	rte

fff803b1 <.LFE16>:
fff803b1:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

fff803b8 <_bus_error_isr>:
*                application.
* Arguments    : none
* Return value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void bus_error_isr (void)
{
fff803b8:	6e ef                         	pushm	r14-r15
fff803ba:	6e 15                         	pushm	r1-r5
fff803bc:	fd 1f 11                      	mvfaclo	#0, a0, r1
fff803bf:	fd 1f 02                      	mvfachi	#0, a0, r2
fff803c2:	7e a1                         	push.l	r1
fff803c4:	7e a2                         	push.l	r2
fff803c6:	fd 1f 31                      	mvfacgu	#0, a0, r1
fff803c9:	fd 1f 92                      	mvfaclo	#0, a1, r2
fff803cc:	7e a1                         	push.l	r1
fff803ce:	7e a2                         	push.l	r2
fff803d0:	fd 1f 81                      	mvfachi	#0, a1, r1
fff803d3:	fd 1f b2                      	mvfacgu	#0, a1, r2
fff803d6:	7e a1                         	push.l	r1
fff803d8:	7e a2                         	push.l	r2
fff803da:	60 40                         	sub	#4, r0
    /* Clear the bus error */
    BSC.BERCLR.BIT.STSCLR = 1;
fff803dc:	fb 5e 00 13 08                	mov.l	#0x81300, r5
fff803e1:	f0 50                         	bset	#0, [r5].b

fff803e3 <.LBB238>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
fff803e3:	fb 52 0c 00 00 00             	mov.l	#12, r5
fff803e9:	aa dd                         	mov.l	44[r5], r5
fff803eb:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
fff803f2:	10                            	beq.s	fff803fa <_Reset_Vector+0xfff803fe>
                g_bsp_vectors[vector](&cb_args);
fff803f3:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
fff803f5:	f8 06 0b                      	mov.l	#11, [r0]
                g_bsp_vectors[vector](&cb_args);
fff803f8:	7f 15                         	jsr	r5

fff803fa <.LVL135>:
        The upper 13 bits of this register contain the upper 13-bits of the offending address (in 512K byte units)
    */

    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_BUS_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function bus_error_isr() */
fff803fa:	62 40                         	add	#4, r0
fff803fc:	7e b2                         	pop	r2
fff803fe:	7e b1                         	pop	r1
fff80400:	fd 17 81                      	mvtachi	r1, a1
fff80403:	fd 17 b2                      	mvtacgu	r2, a1
fff80406:	7e b2                         	pop	r2
fff80408:	7e b1                         	pop	r1
fff8040a:	fd 17 31                      	mvtacgu	r1, a0
fff8040d:	fd 17 92                      	mvtaclo	r2, a1
fff80410:	7e b2                         	pop	r2
fff80412:	7e b1                         	pop	r1
fff80414:	fd 17 11                      	mvtaclo	r1, a0
fff80417:	fd 17 02                      	mvtachi	r2, a0
fff8041a:	6f 15                         	popm	r1-r5
fff8041c:	6f ef                         	popm	r14-r15
fff8041e:	7f 95                         	rte

fff80420 <_get_iclk_freq_hz>:
*                frequency at which it is currently running.
* Arguments    : None
* Return Value : uint32_t - the iclk frequency in Hz
***********************************************************************************************************************/
uint32_t get_iclk_freq_hz(void)
{
fff80420:	60 c0                         	sub	#12, r0
    uint32_t sys_clock_src_freq;
    uint32_t pll_multiplier;
    uint32_t pll_source_freq;
    uint32_t hoco_frequency[3] = {16000000, 18000000, 20000000};
fff80422:	f8 02 00 24 f4 00             	mov.l	#0xf42400, [r0]
fff80428:	f9 02 01 80 a8 12 01          	mov.l	#0x112a880, 4[r0]

    /* Casting is valid because it matches the type to the retern value. */
    uint8_t  cksel = (uint8_t)SYSTEM.SCKCR3.BIT.CKSEL;
fff8042f:	fb 3e 00 00 08                	mov.l	#0x80000, r3
    uint32_t hoco_frequency[3] = {16000000, 18000000, 20000000};
fff80434:	f9 02 02 00 2d 31 01          	mov.l	#0x1312d00, 8[r0]
    uint8_t  cksel = (uint8_t)SYSTEM.SCKCR3.BIT.CKSEL;
fff8043b:	9c bd                         	mov.w	38[r3], r5
fff8043d:	68 85                         	shlr	#8, r5
fff8043f:	64 75                         	and	#7, r5

fff80441 <.LVL0>:

    switch (cksel)
fff80441:	5b 54                         	movu.b	r5, r4
fff80443:	61 14                         	cmp	#1, r4
fff80445:	20 34                         	beq.b	fff80479 <_Reset_Vector+0xfff8047d>
fff80447:	61 05                         	cmp	#0, r5
fff80449:	20 1b                         	beq.b	fff80464 <_Reset_Vector+0xfff80468>
fff8044b:	61 44                         	cmp	#4, r4
fff8044d:	20 44                         	beq.b	fff80491 <_Reset_Vector+0xfff80495>
            /* Set HOCO frequency. */
            sys_clock_src_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
            break;

        case BSP_PRV_CKSEL_MAIN_OSC:
            sys_clock_src_freq = BSP_CFG_XTAL_HZ;
fff8044f:	fb 1e 00 12 7a                	mov.l	#0x7a1200, r1

fff80454 <.LVL1>:
            sys_clock_src_freq = BSP_CFG_XTAL_HZ;
            break;
    }

    /* Finally, divide the system clock source frequency by the currently set ICLK divider to get the ICLK frequency */
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
fff80454:	fb 5e 00 00 08                	mov.l	#0x80000, r5

fff80459 <.LVL2>:
fff80459:	aa 55                         	mov.l	32[r5], r5
fff8045b:	69 85                         	shlr	#24, r5
fff8045d:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
fff8045f:	fd 60 51                      	shlr	r5, r1

fff80462 <.LVL3>:
fff80462:	67 03                         	rtsd	#12

fff80464 <.LVL4>:
            sys_clock_src_freq = BSP_LOCO_HZ;
fff80464:	fb 1e 80 a9 03                	mov.l	#0x3a980, r1

fff80469 <.LVL5>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
fff80469:	fb 5e 00 00 08                	mov.l	#0x80000, r5

fff8046e <.LVL6>:
fff8046e:	aa 55                         	mov.l	32[r5], r5
fff80470:	69 85                         	shlr	#24, r5
fff80472:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
fff80474:	fd 60 51                      	shlr	r5, r1

fff80477 <.LVL7>:
fff80477:	67 03                         	rtsd	#12

fff80479 <.LVL8>:
            sys_clock_src_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
fff80479:	cd 35 37                      	mov.b	55[r3], r5

fff8047c <.LVL9>:
fff8047c:	64 35                         	and	#3, r5
fff8047e:	fe 65 01                      	mov.l	[r5, r0], r1

fff80481 <.LVL10>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
fff80481:	fb 5e 00 00 08                	mov.l	#0x80000, r5
fff80486:	aa 55                         	mov.l	32[r5], r5
fff80488:	69 85                         	shlr	#24, r5
fff8048a:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
fff8048c:	fd 60 51                      	shlr	r5, r1

fff8048f <.LVL11>:
fff8048f:	67 03                         	rtsd	#12

fff80491 <.LVL12>:
            pll_multiplier = ((((uint32_t)(SYSTEM.PLLCR.BIT.STC + 1)) * BSP_PRV_NORMALIZE_X10) / 2);
fff80491:	9d 35                         	mov.w	40[r3], r5

fff80493 <.LVL13>:
            if (0x1 == SYSTEM.PLLCR.BIT.PLLSRCSEL)
fff80493:	9d 34                         	mov.w	40[r3], r4
            pll_multiplier = ((((uint32_t)(SYSTEM.PLLCR.BIT.STC + 1)) * BSP_PRV_NORMALIZE_X10) / 2);
fff80495:	fd 88 51                      	shlr	#8, r5, r1
fff80498:	75 21 3f                      	and	#63, r1
fff8049b:	62 11                         	add	#1, r1
fff8049d:	63 a1                         	mul	#10, r1
fff8049f:	fd 81 15                      	shlr	#1, r1, r5

fff804a2 <.LVL14>:
            if (0x1 == SYSTEM.PLLCR.BIT.PLLSRCSEL)
fff804a2:	7c 44                         	btst	#4, r4
fff804a4:	21 29                         	bne.b	fff804cd <_Reset_Vector+0xfff804d1>
            pll_source_freq = BSP_CFG_XTAL_HZ;
fff804a6:	fb 1e 00 12 7a                	mov.l	#0x7a1200, r1

fff804ab <.LVL15>:
            sys_clock_src_freq = ((pll_source_freq / (((uint32_t)(SYSTEM.PLLCR.BIT.PLIDIV + 1)) * BSP_PRV_NORMALIZE_X10)) * pll_multiplier);
fff804ab:	fb 4e 00 00 08                	mov.l	#0x80000, r4
fff804b0:	9d 44                         	mov.w	40[r4], r4
fff804b2:	64 34                         	and	#3, r4
fff804b4:	62 14                         	add	#1, r4
fff804b6:	63 a4                         	mul	#10, r4
fff804b8:	fc 27 41                      	divu	r4, r1

fff804bb <.LVL16>:
fff804bb:	4f 51                         	mul	r5, r1

fff804bd <.LVL17>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
fff804bd:	fb 5e 00 00 08                	mov.l	#0x80000, r5

fff804c2 <.LVL18>:
fff804c2:	aa 55                         	mov.l	32[r5], r5
fff804c4:	69 85                         	shlr	#24, r5
fff804c6:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
fff804c8:	fd 60 51                      	shlr	r5, r1

fff804cb <.LVL19>:
fff804cb:	67 03                         	rtsd	#12

fff804cd <.LVL20>:
                pll_source_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
fff804cd:	cd 34 37                      	mov.b	55[r3], r4
fff804d0:	64 34                         	and	#3, r4
fff804d2:	fe 64 01                      	mov.l	[r4, r0], r1

fff804d5 <.LVL21>:
fff804d5:	2e d6                         	bra.b	fff804ab <_Reset_Vector+0xfff804af>

fff804d7 <.LFE3>:
fff804d7:	03                            	nop

fff804d8 <_mcu_clock_setup>:
* Description  : Contains clock functions called at device restart.
* Arguments    : none
* Return value : none
***********************************************************************************************************************/
void mcu_clock_setup(void)
{
fff804d8:	7e a7                         	push.l	r7

fff804da <.LBB6>:
{
    /* Used for constructing value to write to SCKCR, SCKCR2, and SCKCR3 registers. */
    uint32_t tmp_clock = 0;

    /* Protect off. */
    SYSTEM.PRCR.WORD = 0xA50B;
fff804da:	fb 5e 00 00 08                	mov.l	#0x80000, r5
fff804df:	fa 59 ff 01 0b a5             	mov.w	#0xa50b, 1022[r5]

fff804e5 <.LBB8>:
* Return value : none
***********************************************************************************************************************/
static void clock_source_select (void)
{
    /* Set the oscillation source of the main clock oscillator. */
    SYSTEM.MOFCR.BIT.MOSEL = BSP_CFG_MAIN_CLOCK_SOURCE;
fff804e5:	f2 5e 93 c2                   	bclr	#6, 49811[r5].b
           If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
        R_BSP_NOP();
    }
#else /* (BSP_CFG_HOCO_OSCILLATE_ENABLE == 0) */
    /* If HOCO is already operating, it doesn't stop. */
    if (1 == SYSTEM.HOCOCR.BIT.HCSTP)
fff804e9:	cd 54 36                      	mov.b	54[r5], r4
fff804ec:	64 14                         	and	#1, r4
fff804ee:	61 14                         	cmp	#1, r4
fff804f0:	18                            	bne.s	fff804f8 <_Reset_Vector+0xfff804fc>
fff804f1:	38 e0 00                      	bra.w	fff805d1 <_Reset_Vector+0xfff805d5>
        /* WAIT_LOOP */
        while(0 == SYSTEM.OSCOVFSR.BIT.HCOVF)
        {
            /* The delay period needed is to make sure that the HOCO has stabilized.
               If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
            R_BSP_NOP();
fff804f4:	03                            	nop
fff804f5:	fc 13 00                      	nop	; max	r0, r0
        while(0 == SYSTEM.OSCOVFSR.BIT.HCOVF)
fff804f8:	cd 54 3c                      	mov.b	60[r5], r4
fff804fb:	7c 34                         	btst	#3, r4
fff804fd:	20 f7                         	beq.b	fff804f4 <_Reset_Vector+0xfff804f8>
fff804ff:	03                            	nop
        SYSTEM.MOFCR.BIT.MODRV2 = 2;
    }
    else
    {
        /* 8MHz. */
        SYSTEM.MOFCR.BIT.MODRV2 = 3;
fff80500:	fb 5e 00 00 08                	mov.l	#0x80000, r5
fff80505:	ce 54 93 c2                   	mov.b	49811[r5], r4
fff80509:	75 34 30                      	or	#48, r4
fff8050c:	cb 54 93 c2                   	mov.b	r4, 49811[r5]
    }

    /* Set the oscillation stabilization wait time of the main clock oscillator. */
#if BSP_CFG_MAIN_CLOCK_SOURCE == 0 /* Resonator */
    SYSTEM.MOSCWTCR.BYTE = BSP_CFG_MOSC_WAIT_TIME;
fff80510:	f9 54 a2 53                   	mov.b	#83, 162[r5]
#else
    #error "Error! Invalid setting for BSP_CFG_MAIN_CLOCK_SOURCE in r_bsp_config.h"
#endif

    /* Set the main clock to operating. */
    SYSTEM.MOSCCR.BYTE = 0x00;
fff80514:	f9 54 32 00                   	mov.b	#0, 50[r5]

    /* Dummy read and compare. cf."5. I/O Registers", "(2) Notes on writing to I/O registers" in User's manual.
       This is done to ensure that the register has been written before the next register access. The RX has a 
       pipeline architecture so the next instruction could be executed before the previous write had finished.
     */
    if(0x00 == SYSTEM.MOSCCR.BYTE)
fff80518:	59 55 32                      	movu.b	50[r5], r5
fff8051b:	61 05                         	cmp	#0, r5
fff8051d:	1b                            	bne.s	fff80520 <_Reset_Vector+0xfff80524>
    {
        R_BSP_NOP();
fff8051e:	03                            	nop
fff8051f:	03                            	nop
    }

    /* WAIT_LOOP */
    while(0 == SYSTEM.OSCOVFSR.BIT.MOOVF)
fff80520:	fb 5e 00 00 08                	mov.l	#0x80000, r5
fff80525:	cd 54 3c                      	mov.b	60[r5], r4
fff80528:	7c 04                         	btst	#0, r4
fff8052a:	19                            	bne.s	fff80533 <_Reset_Vector+0xfff80537>
    {
        /* The delay period needed is to make sure that the Main clock has stabilized.
           If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
        R_BSP_NOP();
fff8052b:	03                            	nop
    while(0 == SYSTEM.OSCOVFSR.BIT.MOOVF)
fff8052c:	cd 54 3c                      	mov.b	60[r5], r4
fff8052f:	7c 04                         	btst	#0, r4
fff80531:	20 fa                         	beq.b	fff8052b <_Reset_Vector+0xfff8052f>
#endif /* BSP_CFG_MAIN_CLOCK_OSCILLATE_ENABLE == 1 */

#if BSP_PRV_PLL_CLK_OPERATING == 1

    /* Set PLL Input Divisor. */
    SYSTEM.PLLCR.BIT.PLIDIV = BSP_CFG_PLL_DIV - 1;
fff80533:	fb 5e 00 00 08                	mov.l	#0x80000, r5
fff80538:	9d 54                         	mov.w	40[r5], r4
fff8053a:	75 24 fc                      	and	#-4, r4
fff8053d:	95 54                         	mov.w	r4, 40[r5]

    #if BSP_CFG_PLL_SRC == 0
    /* Clear PLL clock source if PLL clock source is Main clock. */
    SYSTEM.PLLCR.BIT.PLLSRCSEL = 0;
fff8053f:	9d 57                         	mov.w	40[r5], r7
fff80541:	7a 47                         	bclr	#4, r7
fff80543:	95 57                         	mov.w	r7, 40[r5]
    /* Set PLL clock source if PLL clock source is HOCO clock. */
    SYSTEM.PLLCR.BIT.PLLSRCSEL = 1;
    #endif

    /* Set PLL Multiplier. */
    SYSTEM.PLLCR.BIT.STC = ((uint8_t)((float)BSP_CFG_PLL_MUL * 2.0)) - 1;
fff80545:	9d 54                         	mov.w	40[r5], r4
fff80547:	76 24 ff c0                   	and	#0xffffc0ff, r4
fff8054b:	76 34 00 31                   	or	#0x3100, r4
fff8054f:	95 54                         	mov.w	r4, 40[r5]

    /* Set the PLL to operating. */
    SYSTEM.PLLCR2.BYTE = 0x00;
fff80551:	f9 54 2a 00                   	mov.b	#0, 42[r5]

    /* WAIT_LOOP */
    while(0 == SYSTEM.OSCOVFSR.BIT.PLOVF)
fff80555:	cd 54 3c                      	mov.b	60[r5], r4
fff80558:	7c 24                         	btst	#2, r4
fff8055a:	19                            	bne.s	fff80563 <_Reset_Vector+0xfff80567>
    {
        /* The delay period needed is to make sure that the PLL has stabilized.
           If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
        R_BSP_NOP();
fff8055b:	03                            	nop
    while(0 == SYSTEM.OSCOVFSR.BIT.PLOVF)
fff8055c:	cd 54 3c                      	mov.b	60[r5], r4
fff8055f:	7c 24                         	btst	#2, r4
fff80561:	20 fa                         	beq.b	fff8055b <_Reset_Vector+0xfff8055f>
    /* RX72T has a MEMWAIT register which controls the cycle waiting for access to code flash memory.
       It is set as zero coming out of reset. We only want to set this if we are > 120 MHz. */
    if (BSP_ICLK_HZ > BSP_MCU_MEMWAIT_FREQ_THRESHOLD)
    {
        /* Set MEMWAIT */
        SYSTEM.MEMWAIT.BYTE = 0x01;
fff80563:	fb 7e 00 00 08                	mov.l	#0x80000, r7
fff80568:	fa 74 1c 10 01                	mov.b	#1, 4124[r7]

        /* Dummy read and compare. cf."5. I/O Registers", "(2) Notes on writing to I/O registers" in User's manual.
           This is done to ensure that the register has been written before the next register access. The RX has a 
           pipeline architecture so the next instruction could be executed before the previous write had finished.
        */
        if(0x01 == SYSTEM.MEMWAIT.BYTE)
fff8056d:	5a 75 1c 10                   	movu.b	4124[r7], r5
fff80571:	61 15                         	cmp	#1, r5
fff80573:	1d                            	bne.s	fff80578 <_Reset_Vector+0xfff8057c>
        {
            R_BSP_NOP();
fff80574:	03                            	nop
fff80575:	fc 13 00                      	nop	; max	r0, r0

fff80578 <.LBE8>:
    SYSTEM.SCKCR.LONG = tmp_clock;
fff80578:	fb 7e 00 00 08                	mov.l	#0x80000, r7
fff8057d:	f9 72 08 02 12 82 20          	mov.l	#0x20821202, 32[r7]
    if(tmp_clock == SYSTEM.SCKCR.LONG)
fff80584:	aa 77                         	mov.l	32[r7], r7
fff80586:	74 07 02 12 82 20             	cmp	#0x20821202, r7
fff8058c:	1c                            	bne.s	fff80590 <_Reset_Vector+0xfff80594>
        R_BSP_NOP();
fff8058d:	03                            	nop
fff8058e:	ef 00                         	nop	; mov.l	r0, r0

fff80590 <.LVL24>:
    SYSTEM.SCKCR2.WORD = (uint16_t)tmp_clock;
fff80590:	fb 7e 00 00 08                	mov.l	#0x80000, r7
fff80595:	3d f2 11                      	mov.w	#17, 36[r7]
    if((uint16_t)tmp_clock == SYSTEM.SCKCR2.WORD)
fff80598:	bc f5                         	movu.w	36[r7], r5
fff8059a:	75 55 11                      	cmp	#17, r5
fff8059d:	21 03                         	bne.b	fff805a0 <_Reset_Vector+0xfff805a4>
        R_BSP_NOP();
fff8059f:	03                            	nop

fff805a0 <.LVL25>:
    SYSTEM.SCKCR3.WORD = (uint16_t)tmp_clock;
fff805a0:	fb 7e 00 00 08                	mov.l	#0x80000, r7
fff805a5:	f9 79 13 00 04                	mov.w	#0x400, 38[r7]
    if((uint16_t)tmp_clock == SYSTEM.SCKCR3.WORD)
fff805aa:	bc fd                         	movu.w	38[r7], r5
fff805ac:	76 05 00 04                   	cmp	#0x400, r5
fff805b0:	21 03                         	bne.b	fff805b3 <_Reset_Vector+0xfff805b7>
        R_BSP_NOP();
fff805b2:	03                            	nop
    SYSTEM.LOCOCR.BYTE = 0x01;
fff805b3:	fb 7e 00 00 08                	mov.l	#0x80000, r7
    R_BSP_SoftwareDelay((uint32_t)25, BSP_DELAY_MICROSECS);
fff805b8:	fb 2e 40 42 0f                	mov.l	#0xf4240, r2
fff805bd:	75 41 19                      	mov.l	#25, r1
    SYSTEM.LOCOCR.BYTE = 0x01;
fff805c0:	f9 74 34 01                   	mov.b	#1, 52[r7]
    R_BSP_SoftwareDelay((uint32_t)25, BSP_DELAY_MICROSECS);
fff805c4:	05 3c 02 00                   	bsr.a	fff80800 <_Reset_Vector+0xfff80804>

fff805c8 <.LVL26>:
    SYSTEM.PRCR.WORD = 0xA500;
fff805c8:	fa 79 ff 01 00 a5             	mov.w	#0xa500, 1022[r7]

fff805ce <.LBE6>:
} /* End of function mcu_clock_setup() */
fff805ce:	3f 77 01                      	rtsd	#4, r7-r7

fff805d1 <.LBB11>:
        SYSTEM.HOCOPCR.BYTE = 0x01;
fff805d1:	cb 54 94 c2                   	mov.b	r4, 49812[r5]
fff805d5:	38 2b ff                      	bra.w	fff80500 <_Reset_Vector+0xfff80504>

fff805d8 <_bsp_non_existent_port_init>:
*                power.
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
void bsp_non_existent_port_init (void)
{
fff805d8:	6e 6d                         	pushm	r6-r13
fff805da:	60 40                         	sub	#4, r0
    /* OR in missing pin masks from above. */

    /* Set PORT0.PDR */
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
fff805dc:	fb ae 00 c0 08                	mov.l	#0x8c000, r10

    /* Set PORT1.PDR */
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
fff805e1:	fb 7e 01 c0 08                	mov.l	#0x8c001, r7
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
fff805e6:	cc a3                         	mov.b	[r10], r3

    /* Set PORT2.PDR */
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
fff805e8:	fb 4e 02 c0 08                	mov.l	#0x8c002, r4

    /* Set PORT3.PDR */
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
fff805ed:	fb 5e 03 c0 08                	mov.l	#0x8c003, r5

    /* Set PORT4.PDR */
    PORT4.PDR.BYTE |= BSP_PRV_PORT4_NE_PIN_MASK;
fff805f2:	fb de 04 c0 08                	mov.l	#0x8c004, r13
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
fff805f7:	c3 a3                         	mov.b	r3, [r10]

    /* Set PORT5.PDR */
    PORT5.PDR.BYTE |= BSP_PRV_PORT5_NE_PIN_MASK;
fff805f9:	fb 8e 05 c0 08                	mov.l	#0x8c005, r8
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
fff805fe:	cc 7a                         	mov.b	[r7], r10

    /* Set PORT6.PDR */
    PORT6.PDR.BYTE |= BSP_PRV_PORT6_NE_PIN_MASK;
fff80600:	fb 9e 06 c0 08                	mov.l	#0x8c006, r9

    /* Set PORT7.PDR */
    PORT7.PDR.BYTE |= BSP_PRV_PORT7_NE_PIN_MASK;
fff80605:	fb ce 07 c0 08                	mov.l	#0x8c007, r12

    /* Set PORT8.PDR */
    PORT8.PDR.BYTE |= BSP_PRV_PORT8_NE_PIN_MASK;
fff8060a:	fb be 08 c0 08                	mov.l	#0x8c008, r11
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
fff8060f:	c3 7a                         	mov.b	r10, [r7]

    /* Set PORT9.PDR */
    PORT9.PDR.BYTE |= BSP_PRV_PORT9_NE_PIN_MASK;
fff80611:	fb 6e 09 c0 08                	mov.l	#0x8c009, r6
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
fff80616:	cc 43                         	mov.b	[r4], r3

    /* Set PORTA.PDR */
    PORTA.PDR.BYTE |= BSP_PRV_PORTA_NE_PIN_MASK;
fff80618:	fb ae 0a c0 08                	mov.l	#0x8c00a, r10

    /* Set PORTB.PDR */
    PORTB.PDR.BYTE |= BSP_PRV_PORTB_NE_PIN_MASK;
fff8061d:	fb 7e 0b c0 08                	mov.l	#0x8c00b, r7

    /* Set PORTC.PDR */
    PORTC.PDR.BYTE |= BSP_PRV_PORTC_NE_PIN_MASK;
fff80622:	fb fe 0c c0 08                	mov.l	#0x8c00c, r15
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
fff80627:	c3 43                         	mov.b	r3, [r4]

    /* Set PORTD.PDR */
    PORTD.PDR.BYTE |= BSP_PRV_PORTD_NE_PIN_MASK;
fff80629:	fb ee 0d c0 08                	mov.l	#0x8c00d, r14
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
fff8062e:	cc 54                         	mov.b	[r5], r4

    /* Set PORTE.PDR */
    PORTE.PDR.BYTE |= BSP_PRV_PORTE_NE_PIN_MASK;
fff80630:	fb 1e 0e c0 08                	mov.l	#0x8c00e, r1

    /* Set PORTF.PDR */
    PORTF.PDR.BYTE |= BSP_PRV_PORTF_NE_PIN_MASK;
fff80635:	fb 2e 0f c0 08                	mov.l	#0x8c00f, r2

    /* Set PORTG.PDR */
    PORTG.PDR.BYTE |= BSP_PRV_PORTG_NE_PIN_MASK;
fff8063a:	fb 3e 10 c0 08                	mov.l	#0x8c010, r3
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
fff8063f:	c3 54                         	mov.b	r4, [r5]

    /* Set PORTH.PDR */
    PORTH.PDR.BYTE |= BSP_PRV_PORTH_NE_PIN_MASK;
fff80641:	fb 4e 11 c0 08                	mov.l	#0x8c011, r4
    PORT4.PDR.BYTE |= BSP_PRV_PORT4_NE_PIN_MASK;
fff80646:	c0 d0                         	mov.b	[r13], [r0]

    /* Set PORTK.PDR */
    PORTK.PDR.BYTE |= BSP_PRV_PORTK_NE_PIN_MASK;
fff80648:	fb 5e 13 c0 08                	mov.l	#0x8c013, r5
    PORT4.PDR.BYTE |= BSP_PRV_PORT4_NE_PIN_MASK;
fff8064d:	c0 0d                         	mov.b	[r0], [r13]
    PORT5.PDR.BYTE |= BSP_PRV_PORT5_NE_PIN_MASK;
fff8064f:	cc 8d                         	mov.b	[r8], r13
fff80651:	c3 8d                         	mov.b	r13, [r8]
    PORT6.PDR.BYTE |= BSP_PRV_PORT6_NE_PIN_MASK;
fff80653:	cc 98                         	mov.b	[r9], r8
fff80655:	c3 98                         	mov.b	r8, [r9]
    PORT7.PDR.BYTE |= BSP_PRV_PORT7_NE_PIN_MASK;
fff80657:	cc c9                         	mov.b	[r12], r9
fff80659:	c3 c9                         	mov.b	r9, [r12]
    PORT8.PDR.BYTE |= BSP_PRV_PORT8_NE_PIN_MASK;
fff8065b:	cc bc                         	mov.b	[r11], r12
fff8065d:	c3 bc                         	mov.b	r12, [r11]
    PORT9.PDR.BYTE |= BSP_PRV_PORT9_NE_PIN_MASK;
fff8065f:	cc 6b                         	mov.b	[r6], r11
fff80661:	c3 6b                         	mov.b	r11, [r6]
    PORTA.PDR.BYTE |= BSP_PRV_PORTA_NE_PIN_MASK;
fff80663:	cc a6                         	mov.b	[r10], r6
fff80665:	c3 a6                         	mov.b	r6, [r10]
    PORTB.PDR.BYTE |= BSP_PRV_PORTB_NE_PIN_MASK;
fff80667:	cc 7a                         	mov.b	[r7], r10
fff80669:	c3 7a                         	mov.b	r10, [r7]
    PORTC.PDR.BYTE |= BSP_PRV_PORTC_NE_PIN_MASK;
fff8066b:	cc f7                         	mov.b	[r15], r7
fff8066d:	c3 f7                         	mov.b	r7, [r15]
    PORTD.PDR.BYTE |= BSP_PRV_PORTD_NE_PIN_MASK;
fff8066f:	cc e7                         	mov.b	[r14], r7
fff80671:	c3 e7                         	mov.b	r7, [r14]
    PORTE.PDR.BYTE |= BSP_PRV_PORTE_NE_PIN_MASK;
fff80673:	cc 17                         	mov.b	[r1], r7
fff80675:	c3 17                         	mov.b	r7, [r1]
    PORTF.PDR.BYTE |= BSP_PRV_PORTF_NE_PIN_MASK;
fff80677:	cc 27                         	mov.b	[r2], r7
fff80679:	c3 27                         	mov.b	r7, [r2]
    PORTG.PDR.BYTE |= BSP_PRV_PORTG_NE_PIN_MASK;
fff8067b:	cc 37                         	mov.b	[r3], r7
fff8067d:	c3 37                         	mov.b	r7, [r3]
    PORTH.PDR.BYTE |= BSP_PRV_PORTH_NE_PIN_MASK;
fff8067f:	cc 47                         	mov.b	[r4], r7
fff80681:	c3 47                         	mov.b	r7, [r4]
    PORTK.PDR.BYTE |= BSP_PRV_PORTK_NE_PIN_MASK;
fff80683:	cc 57                         	mov.b	[r5], r7
fff80685:	c3 57                         	mov.b	r7, [r5]
} /* End of function bsp_non_existent_port_init() */
fff80687:	3f 6d 09                      	rtsd	#36, r6-r13

fff8068a <.LFE3>:
fff8068a:	00                            	brk
fff8068b:	00                            	brk
fff8068c:	00                            	brk
fff8068d:	00                            	brk
	...

fff80690 <_bsp_interrupt_enable_disable>:
#ifdef __FPU
    uint32_t      tmp_fpsw;
#endif
    bsp_int_err_t err = BSP_INT_SUCCESS;

    switch (vector)
fff80690:	61 31                         	cmp	#3, r1
fff80692:	20 4b                         	beq.b	fff806dd <_Reset_Vector+0xfff806e1>
fff80694:	61 b1                         	cmp	#11, r1
fff80696:	20 1a                         	beq.b	fff806b0 <_Reset_Vector+0xfff806b4>
fff80698:	61 21                         	cmp	#2, r1
fff8069a:	14                            	beq.s	fff8069e <_Reset_Vector+0xfff806a2>

fff8069b <.LVL43>:
                ICU.NMIER.BIT.NMIEN = 1;
            }
            else
            {
                /* NMI pin interrupts cannot be disabled after being enabled. */
                err = BSP_INT_ERR_UNSUPPORTED;
fff8069b:	66 31                         	mov.l	#3, r1

fff8069d <.LVL44>:
            err = BSP_INT_ERR_UNSUPPORTED;
            break;
    }

    return err;
} /* End of function bsp_interrupt_enable_disable() */
fff8069d:	02                            	rts

fff8069e <.LVL45>:
            if (true == enable)
fff8069e:	5b 22                         	movu.b	r2, r2
fff806a0:	61 02                         	cmp	#0, r2
fff806a2:	20 f9                         	beq.b	fff8069b <_Reset_Vector+0xfff8069f>
                ICU.NMIER.BIT.NMIEN = 1;
fff806a4:	fb 5e 00 70 08                	mov.l	#0x87000, r5
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff806a9:	66 01                         	mov.l	#0, r1

fff806ab <.LVL46>:
                ICU.NMIER.BIT.NMIEN = 1;
fff806ab:	f2 50 81 05                   	bset	#0, 1409[r5].b
fff806af:	02                            	rts

fff806b0 <.LVL47>:
            if (true == enable)
fff806b0:	5b 22                         	movu.b	r2, r2
fff806b2:	61 02                         	cmp	#0, r2
fff806b4:	20 46                         	beq.b	fff806fa <_Reset_Vector+0xfff806fe>
                IR(BSC,BUSERR) = 0;
fff806b6:	fb 5e 00 70 08                	mov.l	#0x87000, r5
                R_BSP_InterruptRequestEnable(VECT(BSC,BUSERR));
fff806bb:	75 41 10                      	mov.l	#16, r1

fff806be <.LVL48>:
                IR(BSC,BUSERR) = 0;
fff806be:	f1 58 10                      	bclr	#0, 16[r5].b
                IPR(BSC,BUSERR) = 0x0F;
fff806c1:	ce 54 00 03                   	mov.b	768[r5], r4
fff806c5:	65 f4                         	or	#15, r4
fff806c7:	cb 54 00 03                   	mov.b	r4, 768[r5]
                R_BSP_InterruptRequestEnable(VECT(BSC,BUSERR));
fff806cb:	05 00 04 00                   	bsr.a	fff80acb <_Reset_Vector+0xfff80acf>

fff806cf <.LVL49>:
                BSC.BEREN.BIT.IGAEN = 1;
fff806cf:	fb 5e 00 13 08                	mov.l	#0x81300, r5
fff806d4:	f1 50 04                      	bset	#0, 4[r5].b
                BSC.BEREN.BIT.TOEN = 1;
fff806d7:	f1 51 04                      	bset	#1, 4[r5].b
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff806da:	66 01                         	mov.l	#0, r1
fff806dc:	02                            	rts

fff806dd <.LVL50>:
            tmp_fpsw = (uint32_t)R_BSP_GET_FPSW();
fff806dd:	fd 6a 35                      	mvfc	fpsw, r5

fff806e0 <.LVL51>:
            if (true == enable)
fff806e0:	5b 22                         	movu.b	r2, r2
fff806e2:	61 02                         	cmp	#0, r2
fff806e4:	20 0c                         	beq.b	fff806f0 <_Reset_Vector+0xfff806f4>
                R_BSP_SET_FPSW((tmp_fpsw | (uint32_t)BSP_PRV_FPU_EXCEPTIONS_ENABLE));
fff806e6:	76 35 00 7c                   	or	#0x7c00, r5

fff806ea <.LVL52>:
fff806ea:	fd 68 53                      	mvtc	r5, fpsw
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff806ed:	66 01                         	mov.l	#0, r1

fff806ef <.LVL53>:
fff806ef:	02                            	rts

fff806f0 <.LVL54>:
                R_BSP_SET_FPSW((tmp_fpsw & (uint32_t)~BSP_PRV_FPU_EXCEPTIONS_ENABLE));
fff806f0:	76 25 ff 83                   	and	#0xffff83ff, r5

fff806f4 <.LVL55>:
fff806f4:	fd 68 53                      	mvtc	r5, fpsw
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff806f7:	66 01                         	mov.l	#0, r1

fff806f9 <.LVL56>:
fff806f9:	02                            	rts

fff806fa <.LVL57>:
                R_BSP_InterruptRequestDisable(VECT(BSC,BUSERR));
fff806fa:	75 41 10                      	mov.l	#16, r1

fff806fd <.LVL58>:
fff806fd:	05 de 03 00                   	bsr.a	fff80adb <_Reset_Vector+0xfff80adf>

fff80701 <.LVL59>:
                BSC.BEREN.BIT.IGAEN = 0;
fff80701:	fb 5e 00 13 08                	mov.l	#0x81300, r5
fff80706:	f1 58 04                      	bclr	#0, 4[r5].b
                BSC.BEREN.BIT.TOEN = 0;
fff80709:	f1 59 04                      	bclr	#1, 4[r5].b
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff8070c:	66 01                         	mov.l	#0, r1
fff8070e:	02                            	rts

fff8070f <.LFE7>:
fff8070f:	03                            	nop

fff80710 <_bsp_mapped_interrupt_open>:
***********************************************************************************************************************/
void bsp_mapped_interrupt_open (void)
{
#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIA0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIA0) = BSP_PRV_INT_A_NUM_MTU0_TGIA0;
fff80710:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff80715:	fa 54 d0 09 01                	mov.b	#1, 2512[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIB0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIB0) = BSP_PRV_INT_A_NUM_MTU0_TGIB0;
fff8071a:	fa 54 d1 09 02                	mov.b	#2, 2513[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIC0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIC0) = BSP_PRV_INT_A_NUM_MTU0_TGIC0;
fff8071f:	fa 54 d2 09 03                	mov.b	#3, 2514[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGID0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGID0) = BSP_PRV_INT_A_NUM_MTU0_TGID0;
fff80724:	fa 54 d3 09 04                	mov.b	#4, 2515[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TCIV0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TCIV0) = BSP_PRV_INT_A_NUM_MTU0_TCIV0;
fff80729:	fa 54 d4 09 05                	mov.b	#5, 2516[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIE0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIE0) = BSP_PRV_INT_A_NUM_MTU0_TGIE0;
fff8072e:	fa 54 d5 09 06                	mov.b	#6, 2517[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIF0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIF0) = BSP_PRV_INT_A_NUM_MTU0_TGIF0;
fff80733:	fa 54 d6 09 07                	mov.b	#7, 2518[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIA1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIA1) = BSP_PRV_INT_A_NUM_MTU1_TGIA1;
fff80738:	fa 54 d7 09 08                	mov.b	#8, 2519[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIB1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIB1) = BSP_PRV_INT_A_NUM_MTU1_TGIB1;
fff8073d:	fa 54 d8 09 09                	mov.b	#9, 2520[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIV1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIV1) = BSP_PRV_INT_A_NUM_MTU1_TCIV1;
fff80742:	fa 54 d9 09 0a                	mov.b	#10, 2521[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIU1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIU1) = BSP_PRV_INT_A_NUM_MTU1_TCIU1;
fff80747:	fa 54 da 09 0b                	mov.b	#11, 2522[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIA2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIA2) = BSP_PRV_INT_A_NUM_MTU2_TGIA2;
fff8074c:	fa 54 db 09 0c                	mov.b	#12, 2523[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIB2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIB2) = BSP_PRV_INT_A_NUM_MTU2_TGIB2;
fff80751:	fa 54 dc 09 0d                	mov.b	#13, 2524[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIV2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIV2) = BSP_PRV_INT_A_NUM_MTU2_TCIV2;
fff80756:	fa 54 dd 09 0e                	mov.b	#14, 2525[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIU2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIU2) = BSP_PRV_INT_A_NUM_MTU2_TCIU2;
fff8075b:	fa 54 de 09 0f                	mov.b	#15, 2526[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIA3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIA3) = BSP_PRV_INT_A_NUM_MTU3_TGIA3;
fff80760:	fa 54 df 09 10                	mov.b	#16, 2527[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIB3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIB3) = BSP_PRV_INT_A_NUM_MTU3_TGIB3;
fff80765:	fa 54 e0 09 11                	mov.b	#17, 2528[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIC3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIC3) = BSP_PRV_INT_A_NUM_MTU3_TGIC3;
fff8076a:	fa 54 e1 09 12                	mov.b	#18, 2529[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGID3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGID3) = BSP_PRV_INT_A_NUM_MTU3_TGID3;
fff8076f:	fa 54 e2 09 13                	mov.b	#19, 2530[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TCIV3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TCIV3) = BSP_PRV_INT_A_NUM_MTU3_TCIV3;
fff80774:	fa 54 e3 09 14                	mov.b	#20, 2531[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIA4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIA4) = BSP_PRV_INT_A_NUM_MTU4_TGIA4;
fff80779:	fa 54 e4 09 15                	mov.b	#21, 2532[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIB4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIB4) = BSP_PRV_INT_A_NUM_MTU4_TGIB4;
fff8077e:	fa 54 e5 09 16                	mov.b	#22, 2533[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIC4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIC4) = BSP_PRV_INT_A_NUM_MTU4_TGIC4;
fff80783:	fa 54 e6 09 17                	mov.b	#23, 2534[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGID4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGID4) = BSP_PRV_INT_A_NUM_MTU4_TGID4;
fff80788:	fa 54 e7 09 18                	mov.b	#24, 2535[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TCIV4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TCIV4) = BSP_PRV_INT_A_NUM_MTU4_TCIV4;
fff8078d:	fa 54 e8 09 19                	mov.b	#25, 2536[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIU5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIU5) = BSP_PRV_INT_A_NUM_MTU5_TGIU5;
fff80792:	fa 54 e9 09 1b                	mov.b	#27, 2537[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIV5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIV5) = BSP_PRV_INT_A_NUM_MTU5_TGIV5;
fff80797:	fa 54 ea 09 1c                	mov.b	#28, 2538[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIW5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIW5) = BSP_PRV_INT_A_NUM_MTU5_TGIW5;
fff8079c:	fa 54 eb 09 1d                	mov.b	#29, 2539[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIA6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIA6) = BSP_PRV_INT_A_NUM_MTU6_TGIA6;
fff807a1:	fa 54 ec 09 1e                	mov.b	#30, 2540[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIB6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIB6) = BSP_PRV_INT_A_NUM_MTU6_TGIB6;
fff807a6:	fa 54 ed 09 1f                	mov.b	#31, 2541[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIC6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIC6) = BSP_PRV_INT_A_NUM_MTU6_TGIC6;
fff807ab:	fa 54 ee 09 20                	mov.b	#32, 2542[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGID6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGID6) = BSP_PRV_INT_A_NUM_MTU6_TGID6;
fff807b0:	fa 54 ef 09 21                	mov.b	#33, 2543[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TCIV6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TCIV6) = BSP_PRV_INT_A_NUM_MTU6_TCIV6;
fff807b5:	fa 54 f0 09 22                	mov.b	#34, 2544[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIA7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIA7) = BSP_PRV_INT_A_NUM_MTU7_TGIA7;
fff807ba:	fa 54 f1 09 23                	mov.b	#35, 2545[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIB7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIB7) = BSP_PRV_INT_A_NUM_MTU7_TGIB7;
fff807bf:	fa 54 f2 09 24                	mov.b	#36, 2546[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIC7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIC7) = BSP_PRV_INT_A_NUM_MTU7_TGIC7;
fff807c4:	fa 54 f3 09 25                	mov.b	#37, 2547[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGID7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGID7) = BSP_PRV_INT_A_NUM_MTU7_TGID7;
fff807c9:	fa 54 f4 09 26                	mov.b	#38, 2548[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TCIV7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TCIV7) = BSP_PRV_INT_A_NUM_MTU7_TCIV7;
fff807ce:	fa 54 f5 09 27                	mov.b	#39, 2549[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIA9)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIA9) = BSP_PRV_INT_A_NUM_MTU9_TGIA9;
fff807d3:	fa 54 f6 09 2f                	mov.b	#47, 2550[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIB9)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIB9) = BSP_PRV_INT_A_NUM_MTU9_TGIB9;
fff807d8:	fa 54 f7 09 30                	mov.b	#48, 2551[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIC9)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIC9) = BSP_PRV_INT_A_NUM_MTU9_TGIC9;
fff807dd:	fa 54 f8 09 31                	mov.b	#49, 2552[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGID9)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGID9) = BSP_PRV_INT_A_NUM_MTU9_TGID9;
fff807e2:	fa 54 f9 09 32                	mov.b	#50, 2553[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TCIV9)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TCIV9) = BSP_PRV_INT_A_NUM_MTU9_TCIV9;
fff807e7:	fa 54 fa 09 33                	mov.b	#51, 2554[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIE9)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIE9) = BSP_PRV_INT_A_NUM_MTU9_TGIE9;
fff807ec:	fa 54 fb 09 34                	mov.b	#52, 2555[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIF9)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU9_TGIF9) = BSP_PRV_INT_A_NUM_MTU9_TGIF9;
fff807f1:	fa 54 fc 09 35                	mov.b	#53, 2556[r5]
#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_GPTW9_GTCIU9)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_GPTW9_GTCIU9) = BSP_PRV_INT_A_NUM_GPTW9_GTCIU9;
#endif

} /* End of function bsp_mapped_interrupt_open() */
fff807f6:	02                            	rts

fff807f7 <_delay_wait>:
***********************************************************************************************************************/
R_BSP_PRAGMA_STATIC_INLINE_ASM(delay_wait)
void delay_wait (unsigned long loop_cnt)
{
    R_BSP_ASM_INTERNAL_USED(loop_cnt)
    R_BSP_ASM_BEGIN
fff807f7:	2e 03                         	bra.b	fff807fa <_Reset_Vector+0xfff807fe>
fff807f9:	03                            	nop
fff807fa:	03                            	nop
fff807fb:	60 11                         	sub	#1, r1
fff807fd:	21 fd                         	bne.b	fff807fa <_Reset_Vector+0xfff807fe>
fff807ff:	02                            	rts

fff80800 <_R_BSP_SoftwareDelay>:
 * The actual delay time is plus the overhead at a specified duration. The overhead changes under the influence of 
 * the compiler, operating frequency and ROM cache. When the operating frequency is low, or the specified duration in 
 * units of microsecond level, please note that the error becomes large.
 */
bool R_BSP_SoftwareDelay(uint32_t delay, bsp_delay_units_t units)
{
fff80800:	6e 7a                         	pushm	r7-r10
fff80802:	71 00 e4                      	add	#-28, r0, r0
fff80805:	ef 27                         	mov.l	r2, r7
fff80807:	ef 1a                         	mov.l	r1, r10
    volatile uint32_t loop_cnt;
    volatile uint64_t delay_cycles_64;
    volatile uint64_t loop_cnt_64;

#ifdef BSP_CFG_PARAM_CHECKING_ENABLE
    if ((BSP_DELAY_MICROSECS != units) && (BSP_DELAY_MILLISECS != units) && (BSP_DELAY_SECS != units))
fff80809:	77 02 40 42 0f                	cmp	#0xf4240, r2
fff8080e:	20 72                         	beq.b	fff80880 <_Reset_Vector+0xfff80884>
fff80810:	76 02 e8 03                   	cmp	#0x3e8, r2
fff80814:	16                            	beq.s	fff8081a <_Reset_Vector+0xfff8081e>
fff80815:	61 12                         	cmp	#1, r2
fff80817:	3b aa 00                      	bne.w	fff808c1 <_Reset_Vector+0xfff808c5>

fff8081a <.LBB4>:
    return get_iclk_freq_hz();  // Get the MCU specific ICLK frequency
fff8081a:	05 06 fc ff                   	bsr.a	fff80420 <_Reset_Vector+0xfff80424>

fff8081e <.LBE4>:
    {
        return(false);
    }
#endif

    iclk_rate = R_BSP_GetIClkFreqHz();  /* Get the current ICLK frequency */
fff8081e:	a1 81                         	mov.l	r1, 24[r0]
        }
    }
    else
    {
        /* Casting is valid because it matches the type to the right side or argument. */
        delay_cycles_64 = (((uint64_t)iclk_rate * (uint64_t)delay) / units);
fff80820:	ed 0e 06                      	mov.l	24[r0], r14
fff80823:	ef 73                         	mov.l	r7, r3
fff80825:	66 04                         	mov.l	#0, r4
fff80827:	fc 1f ae                      	emulu	r10, r14
fff8082a:	ef e1                         	mov.l	r14, r1
fff8082c:	ef f2                         	mov.l	r15, r2
fff8082e:	05 c2 11 00                   	bsr.a	fff819f0 <_Reset_Vector+0xfff819f4>
fff80832:	a0 81                         	mov.l	r1, 8[r0]
fff80834:	a0 8a                         	mov.l	r2, 12[r0]

        if (delay_cycles_64 > BSP_PRV_OVERHEAD_CYCLES_64)
fff80836:	ed 0a 02                      	mov.l	8[r0], r10

fff80839 <.LVL5>:
fff80839:	a8 8f                         	mov.l	12[r0], r7

fff8083b <.LVL6>:
fff8083b:	61 07                         	cmp	#0, r7
fff8083d:	3b 8b 00                      	bne.w	fff808c8 <_Reset_Vector+0xfff808cc>
fff80840:	61 2a                         	cmp	#2, r10
fff80842:	25 05                         	bleu.b	fff80847 <_Reset_Vector+0xfff8084b>
fff80844:	38 84 00                      	bra.w	fff808c8 <_Reset_Vector+0xfff808cc>
        {
            delay_cycles_64 -= BSP_PRV_OVERHEAD_CYCLES_64;
        }
        else
        {
            delay_cycles = 0;
fff80847:	3e 05 00                      	mov.l	#0, 20[r0]
        }

        loop_cnt_64 = delay_cycles_64 / CPU_CYCLES_PER_LOOP;
fff8084a:	a8 81                         	mov.l	8[r0], r1
fff8084c:	a8 8a                         	mov.l	12[r0], r2
fff8084e:	66 33                         	mov.l	#3, r3
fff80850:	66 04                         	mov.l	#0, r4
fff80852:	05 9e 11 00                   	bsr.a	fff819f0 <_Reset_Vector+0xfff819f4>
fff80856:	e3 01                         	mov.l	r1, [r0]
fff80858:	a0 0a                         	mov.l	r2, 4[r0]

        if ((loop_cnt_64 > 0xFFFFFFFFUL) || (0 == loop_cnt_64))
fff8085a:	ec 07                         	mov.l	[r0], r7
fff8085c:	a8 0f                         	mov.l	4[r0], r7
fff8085e:	61 07                         	cmp	#0, r7
fff80860:	21 61                         	bne.b	fff808c1 <_Reset_Vector+0xfff808c5>
fff80862:	ec 07                         	mov.l	[r0], r7
fff80864:	06 95 07 01                   	or	4[r0].l, r7
fff80868:	61 07                         	cmp	#0, r7
fff8086a:	20 57                         	beq.b	fff808c1 <_Reset_Vector+0xfff808c5>
             * also results in the minimum possible delay. */
            return(false);
        }

        /* Casting is valid because it matches the type to the right side or argument. */
        loop_cnt = (uint32_t)loop_cnt_64;
fff8086c:	ec 07                         	mov.l	[r0], r7
fff8086e:	ed 0a 01                      	mov.l	4[r0], r10
fff80871:	a1 07                         	mov.l	r7, 16[r0]
    }

    delay_wait(loop_cnt);
fff80873:	a9 01                         	mov.l	16[r0], r1
fff80875:	05 82 ff ff                   	bsr.a	fff807f7 <_Reset_Vector+0xfff807fb>

fff80879 <.LVL8>:

    return(true);
fff80879:	66 11                         	mov.l	#1, r1
fff8087b:	5b 11                         	movu.b	r1, r1
} /* End of function R_BSP_SoftwareDelay() */
fff8087d:	3f 7a 0b                      	rtsd	#44, r7-r10

fff80880 <.LBB7>:
    return get_iclk_freq_hz();  // Get the MCU specific ICLK frequency
fff80880:	05 a0 fb ff                   	bsr.a	fff80420 <_Reset_Vector+0xfff80424>

fff80884 <.LBE7>:
    iclk_rate = R_BSP_GetIClkFreqHz();  /* Get the current ICLK frequency */
fff80884:	a1 81                         	mov.l	r1, 24[r0]
         (delay <= (0xFFFFFFFFUL / iclk_rate)) )  /* Ensure (iclk_rate * delay) will not exceed 32 bits */
fff80886:	a9 84                         	mov.l	24[r0], r4
fff80888:	fc 1f a4                      	emulu	r10, r4
fff8088b:	61 05                         	cmp	#0, r5
fff8088d:	21 93                         	bne.b	fff80820 <_Reset_Vector+0xfff80824>
        delay_cycles = ((iclk_rate * delay) / units);
fff8088f:	ed 0e 06                      	mov.l	24[r0], r14
fff80892:	4f ae                         	mul	r10, r14
fff80894:	fb a2 83 de 1b 43             	mov.l	#0x431bde83, r10

fff8089a <.LVL11>:
fff8089a:	fc 1f ae                      	emulu	r10, r14
fff8089d:	fd 92 f7                      	shlr	#18, r15, r7

fff808a0 <.LVL12>:
fff808a0:	a1 0f                         	mov.l	r7, 20[r0]
        if (delay_cycles > BSP_PRV_OVERHEAD_CYCLES)
fff808a2:	a9 0f                         	mov.l	20[r0], r7
fff808a4:	61 27                         	cmp	#2, r7
fff808a6:	24 35                         	bgtu.b	fff808db <_Reset_Vector+0xfff808df>
            delay_cycles = 0;
fff808a8:	3e 05 00                      	mov.l	#0, 20[r0]
        loop_cnt = delay_cycles / CPU_CYCLES_PER_LOOP;
fff808ab:	a9 0c                         	mov.l	20[r0], r4
fff808ad:	fb 72 ab aa aa aa             	mov.l	#0xaaaaaaab, r7
fff808b3:	fc 1f 74                      	emulu	r7, r4
fff808b6:	fd 81 57                      	shlr	#1, r5, r7
fff808b9:	a1 07                         	mov.l	r7, 16[r0]
        if (0 == loop_cnt)
fff808bb:	a9 07                         	mov.l	16[r0], r7
fff808bd:	61 07                         	cmp	#0, r7
fff808bf:	21 b4                         	bne.b	fff80873 <_Reset_Vector+0xfff80877>
        return(false);
fff808c1:	66 01                         	mov.l	#0, r1
fff808c3:	5b 11                         	movu.b	r1, r1
} /* End of function R_BSP_SoftwareDelay() */
fff808c5:	3f 7a 0b                      	rtsd	#44, r7-r10
            delay_cycles_64 -= BSP_PRV_OVERHEAD_CYCLES_64;
fff808c8:	ed 0a 02                      	mov.l	8[r0], r10
fff808cb:	a8 8f                         	mov.l	12[r0], r7
fff808cd:	71 a5 fe                      	add	#-2, r10, r5
fff808d0:	fd 74 27 ff                   	adc	#-1, r7
fff808d4:	a0 85                         	mov.l	r5, 8[r0]
fff808d6:	a0 8f                         	mov.l	r7, 12[r0]
fff808d8:	38 72 ff                      	bra.w	fff8084a <_Reset_Vector+0xfff8084e>
            delay_cycles -= BSP_PRV_OVERHEAD_CYCLES;
fff808db:	a9 0f                         	mov.l	20[r0], r7
fff808dd:	60 27                         	sub	#2, r7
fff808df:	a1 0f                         	mov.l	r7, 20[r0]
fff808e1:	2e ca                         	bra.b	fff808ab <_Reset_Vector+0xfff808af>

fff808e3 <.LFE6>:
fff808e3:	77 10 01 00 00                	nop	; mul	#1, r0

fff808e8 <_R_BSP_CpuInterruptLevelRead>:
{
    /* Use the compiler intrinsic function to read the CPU IPL. */
    uint32_t psw_value;

    /* Casting is valid because it matches the type to the right side or argument. */
    psw_value = (uint32_t)R_BSP_GET_PSW();
fff808e8:	fd 6a 01                      	mvfc	psw, r1

fff808eb <.LVL2>:
    psw_value = psw_value & 0x0f000000;
    psw_value = psw_value >> 24;
fff808eb:	69 81                         	shlr	#24, r1

fff808ed <.LVL3>:

    return psw_value;
} /* End of function R_BSP_CpuInterruptLevelRead() */
fff808ed:	64 f1                         	and	#15, r1

fff808ef <.LVL4>:
fff808ef:	02                            	rts

fff808f0 <_R_BSP_CpuInterruptLevelWrite>:
       The MVTIPL instruction needs to set an immediate value to src. */

    ret = false;

    /* Read current processor mode. */
    pmode = (R_BSP_GET_PSW() & 0x00100000);
fff808f0:	fd 6a 05                      	mvfc	psw, r5

fff808f3 <.LVL6>:

    /* Check current processor mode. */
    if (0 == pmode)
fff808f3:	7d 45                         	btst	#20, r5
fff808f5:	21 12                         	bne.b	fff80907 <_Reset_Vector+0xfff8090b>

fff808f7 <.LVL7>:
    {
        ret = true;

        /* Use the compiler intrinsic function to set the CPU IPL. */
        switch (level)
fff808f7:	61 f1                         	cmp	#15, r1
fff808f9:	24 0e                         	bgtu.b	fff80907 <_Reset_Vector+0xfff8090b>
fff808fb:	6c 21                         	shll	#2, r1

fff808fd <.LVL8>:
fff808fd:	70 11 c0 21 f8 ff             	add	#0xfff821c0, r1, r1
fff80903:	ec 15                         	mov.l	[r1], r5

fff80905 <.LVL9>:
fff80905:	7f 05                         	jmp	r5

fff80907 <.LVL10>:
                R_BSP_SET_IPL(15);
                break;
    #endif /* BSP_MCU_IPL_MAX */

            default:
                ret = false;
fff80907:	66 01                         	mov.l	#0, r1

fff80909 <.LVL11>:
                break;
        }
    }

    return ret;
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80909:	64 11                         	and	#1, r1

fff8090b <.LVL12>:
fff8090b:	02                            	rts

fff8090c <.L11>:
                R_BSP_SET_IPL(14);
fff8090c:	75 70 0e                      	mvtipl	#14
        ret = true;
fff8090f:	66 11                         	mov.l	#1, r1

fff80911 <.LVL14>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80911:	64 11                         	and	#1, r1

fff80913 <.LVL15>:
fff80913:	02                            	rts

fff80914 <.L9>:
                R_BSP_SET_IPL(15);
fff80914:	75 70 0f                      	mvtipl	#15
        ret = true;
fff80917:	66 11                         	mov.l	#1, r1

fff80919 <.LVL16>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80919:	64 11                         	and	#1, r1

fff8091b <.LVL17>:
fff8091b:	02                            	rts

fff8091c <.L25>:
                R_BSP_SET_IPL(0);
fff8091c:	75 70 00                      	mvtipl	#0
        ret = true;
fff8091f:	66 11                         	mov.l	#1, r1

fff80921 <.LVL18>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80921:	64 11                         	and	#1, r1

fff80923 <.LVL19>:
fff80923:	02                            	rts

fff80924 <.L24>:
                R_BSP_SET_IPL(1);
fff80924:	75 70 01                      	mvtipl	#1
        ret = true;
fff80927:	66 11                         	mov.l	#1, r1

fff80929 <.LVL20>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80929:	64 11                         	and	#1, r1

fff8092b <.LVL21>:
fff8092b:	02                            	rts

fff8092c <.L23>:
                R_BSP_SET_IPL(2);
fff8092c:	75 70 02                      	mvtipl	#2
        ret = true;
fff8092f:	66 11                         	mov.l	#1, r1

fff80931 <.LVL22>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80931:	64 11                         	and	#1, r1

fff80933 <.LVL23>:
fff80933:	02                            	rts

fff80934 <.L22>:
                R_BSP_SET_IPL(3);
fff80934:	75 70 03                      	mvtipl	#3
        ret = true;
fff80937:	66 11                         	mov.l	#1, r1

fff80939 <.LVL24>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80939:	64 11                         	and	#1, r1

fff8093b <.LVL25>:
fff8093b:	02                            	rts

fff8093c <.L21>:
                R_BSP_SET_IPL(4);
fff8093c:	75 70 04                      	mvtipl	#4
        ret = true;
fff8093f:	66 11                         	mov.l	#1, r1

fff80941 <.LVL26>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80941:	64 11                         	and	#1, r1

fff80943 <.LVL27>:
fff80943:	02                            	rts

fff80944 <.L20>:
                R_BSP_SET_IPL(5);
fff80944:	75 70 05                      	mvtipl	#5
        ret = true;
fff80947:	66 11                         	mov.l	#1, r1

fff80949 <.LVL28>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80949:	64 11                         	and	#1, r1

fff8094b <.LVL29>:
fff8094b:	02                            	rts

fff8094c <.L19>:
                R_BSP_SET_IPL(6);
fff8094c:	75 70 06                      	mvtipl	#6
        ret = true;
fff8094f:	66 11                         	mov.l	#1, r1

fff80951 <.LVL30>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80951:	64 11                         	and	#1, r1

fff80953 <.LVL31>:
fff80953:	02                            	rts

fff80954 <.L18>:
                R_BSP_SET_IPL(7);
fff80954:	75 70 07                      	mvtipl	#7
        ret = true;
fff80957:	66 11                         	mov.l	#1, r1

fff80959 <.LVL32>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80959:	64 11                         	and	#1, r1

fff8095b <.LVL33>:
fff8095b:	02                            	rts

fff8095c <.L17>:
                R_BSP_SET_IPL(8);
fff8095c:	75 70 08                      	mvtipl	#8
        ret = true;
fff8095f:	66 11                         	mov.l	#1, r1

fff80961 <.LVL34>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80961:	64 11                         	and	#1, r1

fff80963 <.LVL35>:
fff80963:	02                            	rts

fff80964 <.L16>:
                R_BSP_SET_IPL(9);
fff80964:	75 70 09                      	mvtipl	#9
        ret = true;
fff80967:	66 11                         	mov.l	#1, r1

fff80969 <.LVL36>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80969:	64 11                         	and	#1, r1

fff8096b <.LVL37>:
fff8096b:	02                            	rts

fff8096c <.L15>:
                R_BSP_SET_IPL(10);
fff8096c:	75 70 0a                      	mvtipl	#10
        ret = true;
fff8096f:	66 11                         	mov.l	#1, r1

fff80971 <.LVL38>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80971:	64 11                         	and	#1, r1

fff80973 <.LVL39>:
fff80973:	02                            	rts

fff80974 <.L14>:
                R_BSP_SET_IPL(11);
fff80974:	75 70 0b                      	mvtipl	#11
        ret = true;
fff80977:	66 11                         	mov.l	#1, r1

fff80979 <.LVL40>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80979:	64 11                         	and	#1, r1

fff8097b <.LVL41>:
fff8097b:	02                            	rts

fff8097c <.L13>:
                R_BSP_SET_IPL(12);
fff8097c:	75 70 0c                      	mvtipl	#12
        ret = true;
fff8097f:	66 11                         	mov.l	#1, r1

fff80981 <.LVL42>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80981:	64 11                         	and	#1, r1

fff80983 <.LVL43>:
fff80983:	02                            	rts

fff80984 <.L12>:
                R_BSP_SET_IPL(13);
fff80984:	75 70 0d                      	mvtipl	#13
        ret = true;
fff80987:	66 11                         	mov.l	#1, r1

fff80989 <.LVL44>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
fff80989:	64 11                         	and	#1, r1

fff8098b <.LVL45>:
fff8098b:	02                            	rts

fff8098c <.LFE6>:
fff8098c:	00                            	brk
fff8098d:	00                            	brk
	...

fff80990 <_R_BSP_VoltageLevelSetting>:
    uint8_t  *p_volsr_addr;

#if BSP_CFG_PARAM_CHECKING_ENABLE == 1
    /* ---- CHECK ARGUMENTS ---- */
#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_USB
    if (BSP_PRV_USBVON_CONFLICT == (ctrl_ptn & BSP_PRV_USBVON_CONFLICT))
fff80990:	66 35                         	mov.l	#3, r5
fff80992:	53 15                         	and	r1, r5
fff80994:	61 35                         	cmp	#3, r5
fff80996:	3a 96 00                      	beq.w	fff80a2c <_Reset_Vector+0xfff80a30>
        return false;
    }
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_USB */

#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_AD
    if (BSP_PRV_PGAVLS_CONFLICT == (ctrl_ptn & BSP_PRV_PGAVLS_CONFLICT))
fff80999:	66 c4                         	mov.l	#12, r4
fff8099b:	53 14                         	and	r1, r4
fff8099d:	61 c4                         	cmp	#12, r4
fff8099f:	3a 8d 00                      	beq.w	fff80a2c <_Reset_Vector+0xfff80a30>
        return false;
    }
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_AD */

#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_RIIC
    if (BSP_PRV_RICVLS_CONFLICT == (ctrl_ptn & BSP_PRV_RICVLS_CONFLICT))
fff809a2:	75 42 30                      	mov.l	#48, r2
fff809a5:	53 12                         	and	r1, r2
fff809a7:	75 52 30                      	cmp	#48, r2
fff809aa:	3a 82 00                      	beq.w	fff80a2c <_Reset_Vector+0xfff80a30>
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_RIIC */
#endif /* BSP_CFG_PARAM_CHECKING_ENABLE == 1 */

#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_USB
    /* Check USB module stop state. */
    if(0 != (ctrl_ptn & BSP_PRV_USBVON_CONFLICT))
fff809ad:	61 05                         	cmp	#0, r5
fff809af:	20 11                         	beq.b	fff809c0 <_Reset_Vector+0xfff809c4>
    {
        /* Casting is valid because it matches the type to the right side or argument. */
        if(0 == MSTP(USB0))
fff809b1:	fb 5e 00 00 08                	mov.l	#0x80000, r5
fff809b6:	a9 5b                         	mov.l	20[r5], r3
fff809b8:	69 33                         	shlr	#19, r3
fff809ba:	64 13                         	and	#1, r3
fff809bc:	cf 35                         	mov.b	r3, r5
fff809be:	20 70                         	beq.b	fff80a2e <_Reset_Vector+0xfff80a32>
    }
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_USB */

#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_AD
    /* Check AD module stop state. */
    if(0 != (ctrl_ptn & BSP_PRV_PGAVLS_CONFLICT))
fff809c0:	61 04                         	cmp	#0, r4
fff809c2:	20 1b                         	beq.b	fff809dd <_Reset_Vector+0xfff809e1>
    {
        /* Casting is valid because it matches the type to the right side or argument. */
        if((0 == MSTP(S12AD)) || (0 == MSTP(S12AD1)))
fff809c4:	fb 3e 00 00 08                	mov.l	#0x80000, r3
fff809c9:	a9 34                         	mov.l	16[r3], r4
fff809cb:	69 14                         	shlr	#17, r4
fff809cd:	64 14                         	and	#1, r4
fff809cf:	cf 45                         	mov.b	r4, r5
fff809d1:	20 5d                         	beq.b	fff80a2e <_Reset_Vector+0xfff80a32>
fff809d3:	a9 34                         	mov.l	16[r3], r4
fff809d5:	69 04                         	shlr	#16, r4
fff809d7:	64 14                         	and	#1, r4
fff809d9:	cf 45                         	mov.b	r4, r5
fff809db:	20 53                         	beq.b	fff80a2e <_Reset_Vector+0xfff80a32>
    }
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_AD */

#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_RIIC
    /* Check RIIC module stop state. */
    if(0 != (ctrl_ptn & BSP_PRV_RICVLS_CONFLICT))
fff809dd:	61 02                         	cmp	#0, r2
fff809df:	20 11                         	beq.b	fff809f0 <_Reset_Vector+0xfff809f4>
    {
        /* Casting is valid because it matches the type to the right side or argument. */
#ifdef RIIC0
        if(0 == MSTP(RIIC0))
fff809e1:	fb 5e 00 00 08                	mov.l	#0x80000, r5
fff809e6:	a9 5c                         	mov.l	20[r5], r4
fff809e8:	69 54                         	shlr	#21, r4
fff809ea:	64 14                         	and	#1, r4
fff809ec:	cf 45                         	mov.b	r4, r5
fff809ee:	20 40                         	beq.b	fff80a2e <_Reset_Vector+0xfff80a32>
{
fff809f0:	7e a6                         	push.l	r6
fff809f2:	cf 16                         	mov.b	r1, r6
#endif
    }
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_RIIC */

    /* Protect off. */
    SYSTEM.PRCR.WORD = 0xA502;
fff809f4:	fb 5e 00 00 08                	mov.l	#0x80000, r5
fff809f9:	fa 59 ff 01 02 a5             	mov.w	#0xa502, 1022[r5]

fff809ff <.LVL60>:
    /* Casting is valid because it matches the type to the right side or argument. */
    p_volsr_addr = (uint8_t *)&SYSTEM.VOLSR.BYTE;

#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_RIIC
    /* Updated the RICVLS bit. */
    if(0 != (ctrl_ptn & BSP_VOL_RIIC_UNDER_4_5V))
fff809ff:	7c 56                         	btst	#5, r6
fff80a01:	21 73                         	bne.b	fff80a74 <_Reset_Vector+0xfff80a78>

fff80a03 <.LVL61>:
    {
        R_BSP_BIT_SET(p_volsr_addr, BSP_PRV_VOLSR_RICVLS_BIT_NUM);
    }

    if(0 != (ctrl_ptn & BSP_VOL_RIIC_4_5V_OROVER))
fff80a03:	7c 46                         	btst	#4, r6
fff80a05:	21 62                         	bne.b	fff80a67 <_Reset_Vector+0xfff80a6b>
fff80a07:	03                            	nop
    }
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_RIIC */

#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_AD
    /* Updated the PGAVLS bit. */
    if(0 != (ctrl_ptn & BSP_VOL_AD_NEGATIVE_VOLTAGE_NOINPUT))
fff80a08:	7c 36                         	btst	#3, r6
fff80a0a:	21 50                         	bne.b	fff80a5a <_Reset_Vector+0xfff80a5e>
    {
        R_BSP_BIT_SET(p_volsr_addr, BSP_PRV_VOLSR_PGAVLS_BIT_NUM);
    }

    if(0 != (ctrl_ptn & BSP_VOL_AD_NEGATIVE_VOLTAGE_INPUT))
fff80a0c:	7c 26                         	btst	#2, r6
fff80a0e:	21 3f                         	bne.b	fff80a4d <_Reset_Vector+0xfff80a51>
    }
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_AD */

#ifdef BSP_MCU_VOLTAGE_LEVEL_SETTING_USB
    /* Updated the USBVON bit. */
    if(0 != (ctrl_ptn & BSP_VOL_USB_POWERON))
fff80a10:	7c 16                         	btst	#1, r6
fff80a12:	21 2e                         	bne.b	fff80a40 <_Reset_Vector+0xfff80a44>
    {
        R_BSP_BIT_SET(p_volsr_addr, BSP_PRV_VOLSR_USBVON_BIT_NUM);
    }

    if(0 != (ctrl_ptn & BSP_VOL_USB_POWEROFF))
fff80a14:	7c 06                         	btst	#0, r6
fff80a16:	21 1d                         	bne.b	fff80a33 <_Reset_Vector+0xfff80a37>
#endif /* BSP_MCU_VOLTAGE_LEVEL_SETTING_USB */

    /* Protect on. */
    SYSTEM.PRCR.WORD = 0xA500;

    return true;
fff80a18:	66 15                         	mov.l	#1, r5
    SYSTEM.PRCR.WORD = 0xA500;
fff80a1a:	fb 4e 00 00 08                	mov.l	#0x80000, r4
fff80a1f:	fa 49 ff 01 00 a5             	mov.w	#0xa500, 1022[r4]
}  /* End of function R_BSP_VoltageLevelSetting() */ 
fff80a25:	66 11                         	mov.l	#1, r1
fff80a27:	53 51                         	and	r5, r1
fff80a29:	3f 66 01                      	rtsd	#4, r6-r6

fff80a2c <.LVL62>:
        return false;
fff80a2c:	66 05                         	mov.l	#0, r5
}  /* End of function R_BSP_VoltageLevelSetting() */ 
fff80a2e:	66 11                         	mov.l	#1, r1

fff80a30 <.LVL63>:
fff80a30:	53 51                         	and	r5, r1
fff80a32:	02                            	rts

fff80a33 <.LVL64>:
        R_BSP_BIT_CLEAR(p_volsr_addr, BSP_PRV_VOLSR_USBVON_BIT_NUM);
fff80a33:	66 22                         	mov.l	#2, r2
fff80a35:	fb 1e 95 c2 08                	mov.l	#0x8c295, r1
fff80a3a:	05 f2 03 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80a3e <.LVL65>:
fff80a3e:	2e da                         	bra.b	fff80a18 <_Reset_Vector+0xfff80a1c>
        R_BSP_BIT_SET(p_volsr_addr, BSP_PRV_VOLSR_USBVON_BIT_NUM);
fff80a40:	66 22                         	mov.l	#2, r2
fff80a42:	fb 1e 95 c2 08                	mov.l	#0x8c295, r1
fff80a47:	05 e1 03 00                   	bsr.a	fff80e28 <_Reset_Vector+0xfff80e2c>

fff80a4b <.LVL66>:
fff80a4b:	2e c9                         	bra.b	fff80a14 <_Reset_Vector+0xfff80a18>
        R_BSP_BIT_CLEAR(p_volsr_addr, BSP_PRV_VOLSR_PGAVLS_BIT_NUM);
fff80a4d:	66 62                         	mov.l	#6, r2
fff80a4f:	fb 1e 95 c2 08                	mov.l	#0x8c295, r1
fff80a54:	05 d8 03 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80a58 <.LVL67>:
fff80a58:	2e b8                         	bra.b	fff80a10 <_Reset_Vector+0xfff80a14>
        R_BSP_BIT_SET(p_volsr_addr, BSP_PRV_VOLSR_PGAVLS_BIT_NUM);
fff80a5a:	66 62                         	mov.l	#6, r2
fff80a5c:	fb 1e 95 c2 08                	mov.l	#0x8c295, r1
fff80a61:	05 c7 03 00                   	bsr.a	fff80e28 <_Reset_Vector+0xfff80e2c>

fff80a65 <.LVL68>:
fff80a65:	2e a7                         	bra.b	fff80a0c <_Reset_Vector+0xfff80a10>
        R_BSP_BIT_CLEAR(p_volsr_addr, BSP_PRV_VOLSR_RICVLS_BIT_NUM);
fff80a67:	66 72                         	mov.l	#7, r2
fff80a69:	fb 1e 95 c2 08                	mov.l	#0x8c295, r1
fff80a6e:	05 be 03 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80a72 <.LVL69>:
fff80a72:	2e 96                         	bra.b	fff80a08 <_Reset_Vector+0xfff80a0c>

fff80a74 <.LVL70>:
        R_BSP_BIT_SET(p_volsr_addr, BSP_PRV_VOLSR_RICVLS_BIT_NUM);
fff80a74:	66 72                         	mov.l	#7, r2
fff80a76:	fb 1e 95 c2 08                	mov.l	#0x8c295, r1

fff80a7b <.LVL71>:
fff80a7b:	05 ad 03 00                   	bsr.a	fff80e28 <_Reset_Vector+0xfff80e2c>

fff80a7f <.LVL72>:
fff80a7f:	2e 84                         	bra.b	fff80a03 <_Reset_Vector+0xfff80a07>

fff80a81 <.LFE9>:
fff80a81:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

fff80a88 <_bsp_register_protect_open>:

    /* Initialize reference counters to 0. */
    /* WAIT_LOOP */
    for (i = 0; i < BSP_REG_PROTECT_TOTAL_ITEMS; i++)
    {
        s_protect_counters[i] = 0;
fff80a88:	fb 52 04 00 00 00             	mov.l	#4, r5
fff80a8e:	f8 55 00                      	mov.w	#0, [r5]

fff80a91 <.LVL75>:
fff80a91:	3d 51 00                      	mov.w	#0, 2[r5]

fff80a94 <.LVL76>:
fff80a94:	3d 52 00                      	mov.w	#0, 4[r5]

fff80a97 <.LVL77>:
fff80a97:	3d 53 00                      	mov.w	#0, 6[r5]

fff80a9a <.LVL78>:
    }
#else
    /* No registers to protect. */
#endif
} /* End of function bsp_register_protect_open() */
fff80a9a:	02                            	rts

fff80a9b <_bsp_ram_initialize>:
{
    uint32_t i;

    /* Initialize g_bsp_Locks to 0. */
    /* WAIT_LOOP */
    for (i = 0; i < BSP_NUM_LOCKS; i++)
fff80a9b:	fb 12 18 01 00 00             	mov.l	#280, r1
fff80aa1:	fb 3a 9c 01                   	mov.l	#412, r3
fff80aa5:	66 02                         	mov.l	#0, r2
fff80aa7:	7f 88                         	sstr.b
    {
        g_bsp_Locks[i].lock = 0;
    }
} /* End of function bsp_ram_initialize() */
fff80aa9:	02                            	rts

fff80aaa <_R_BSP_InterruptControl.constprop.2>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
fff80aaa:	fb 52 0c 00 00 00             	mov.l	#12, r5
fff80ab0:	fe 61 55                      	mov.l	[r1, r5], r5
fff80ab3:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
fff80aba:	20 0e                         	beq.b	fff80ac8 <_Reset_Vector+0xfff80acc>
bsp_int_err_t R_BSP_InterruptControl (bsp_int_src_t vector, bsp_int_cmd_t cmd, void * pdata)
fff80abc:	60 40                         	sub	#4, r0
                cb_args.vector = vector;
fff80abe:	e3 01                         	mov.l	r1, [r0]
                g_bsp_vectors[vector](&cb_args);
fff80ac0:	ef 01                         	mov.l	r0, r1

fff80ac2 <.LVL1>:
fff80ac2:	7f 15                         	jsr	r5

fff80ac4 <.LVL2>:
    err = BSP_INT_SUCCESS;
fff80ac4:	66 01                         	mov.l	#0, r1
} /* End of function R_BSP_InterruptControl() */
fff80ac6:	67 01                         	rtsd	#4

fff80ac8 <.LVL3>:
                err = BSP_INT_ERR_NO_REGISTERED_CALLBACK;
fff80ac8:	66 11                         	mov.l	#1, r1

fff80aca <.LVL4>:
} /* End of function R_BSP_InterruptControl() */
fff80aca:	02                            	rts

fff80acb <_R_BSP_InterruptRequestEnable>:
    ier_reg_num = vector >> 3;
fff80acb:	fd 83 15                      	shlr	#3, r1, r5

fff80ace <.LVL6>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80ace:	66 72                         	mov.l	#7, r2
fff80ad0:	53 12                         	and	r1, r2

fff80ad2 <.LVL7>:
fff80ad2:	73 51 00 72 08                	add	#0x87200, r5, r1

fff80ad7 <.LVL8>:
fff80ad7:	04 51 03 00                   	bra.a	fff80e28 <_Reset_Vector+0xfff80e2c>

fff80adb <_R_BSP_InterruptRequestDisable>:
    ier_reg_num = vector >> 3;
fff80adb:	fd 83 15                      	shlr	#3, r1, r5

fff80ade <.LVL11>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80ade:	66 72                         	mov.l	#7, r2
fff80ae0:	53 12                         	and	r1, r2

fff80ae2 <.LVL12>:
fff80ae2:	73 51 00 72 08                	add	#0x87200, r5, r1

fff80ae7 <.LVL13>:
fff80ae7:	04 45 03 00                   	bra.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80aeb <.LFE4>:
fff80aeb:	00                            	brk
fff80aec:	00                            	brk
fff80aed:	00                            	brk
	...

fff80af0 <_bsp_interrupt_open>:
{
fff80af0:	7e a7                         	push.l	r7

fff80af2 <.LVL15>:
    for (i = 0; i < BSP_INT_SRC_TOTAL_ITEMS; i++)
fff80af2:	fb 52 0c 00 00 00             	mov.l	#12, r5

fff80af8 <.LVL16>:
        g_bsp_vectors[i] = FIT_NO_FUNC;
fff80af8:	fb 72 00 00 00 10             	mov.l	#0x10000000, r7
fff80afe:	fd 22 57                      	mov.l	r7, [r5+]
    for (i = 0; i < BSP_INT_SRC_TOTAL_ITEMS; i++)
fff80b01:	74 05 18 01 00 00             	cmp	#280, r5
fff80b07:	21 f1                         	bne.b	fff80af8 <_Reset_Vector+0xfff80afc>
} /* End of function bsp_interrupt_open() */
fff80b09:	7e b7                         	pop	r7
    bsp_mapped_interrupt_open();
fff80b0b:	04 05 fc ff                   	bra.a	fff80710 <_Reset_Vector+0xfff80714>

fff80b0f <.LFE5>:
fff80b0f:	03                            	nop

fff80b10 <_R_BSP_InterruptWrite>:
        g_bsp_vectors[vector] = FIT_NO_FUNC;
fff80b10:	fd 70 c2 ff ff ff ef          	tst	#0xefffffff, r2
fff80b17:	fd 70 e2 00 00 00 10          	stz	#0x10000000, r2

fff80b1e <.LVL19>:
fff80b1e:	fb 52 0c 00 00 00             	mov.l	#12, r5
fff80b24:	fe 21 52                      	mov.l	r2, [r1, r5]
} /* End of function R_BSP_InterruptWrite() */
fff80b27:	66 01                         	mov.l	#0, r1

fff80b29 <.LVL20>:
fff80b29:	02                            	rts

fff80b2a <.LFE6>:
fff80b2a:	00                            	brk
fff80b2b:	00                            	brk
fff80b2c:	00                            	brk
fff80b2d:	00                            	brk
	...

fff80b30 <_R_BSP_InterruptControl>:
{
fff80b30:	6e 7a                         	pushm	r7-r10
fff80b32:	60 80                         	sub	#8, r0

fff80b34 <.LVL26>:
fff80b34:	ef 17                         	mov.l	r1, r7
    switch (cmd)
fff80b36:	61 32                         	cmp	#3, r2
fff80b38:	3a 9d 00                      	beq.w	fff80bd5 <_Reset_Vector+0xfff80bd9>
fff80b3b:	24 24                         	bgtu.b	fff80b5f <_Reset_Vector+0xfff80b63>
fff80b3d:	61 12                         	cmp	#1, r2
fff80b3f:	20 61                         	beq.b	fff80ba0 <_Reset_Vector+0xfff80ba4>
fff80b41:	24 5a                         	bgtu.b	fff80b9b <_Reset_Vector+0xfff80b9f>
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
fff80b43:	fb a2 0c 00 00 00             	mov.l	#12, r10
fff80b49:	fe 61 aa                      	mov.l	[r1, r10], r10
fff80b4c:	fd 70 ca ff ff ff ef          	tst	#0xefffffff, r10
fff80b53:	20 58                         	beq.b	fff80bab <_Reset_Vector+0xfff80baf>
                cb_args.vector = vector;
fff80b55:	e3 01                         	mov.l	r1, [r0]
                g_bsp_vectors[vector](&cb_args);
fff80b57:	ef 01                         	mov.l	r0, r1

fff80b59 <.LVL27>:
    err = BSP_INT_SUCCESS;
fff80b59:	ef 27                         	mov.l	r2, r7

fff80b5b <.LVL28>:
                g_bsp_vectors[vector](&cb_args);
fff80b5b:	7f 1a                         	jsr	r10

fff80b5d <.LVL29>:
fff80b5d:	2e 39                         	bra.b	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80b5f <.LVL30>:
    switch (cmd)
fff80b5f:	61 52                         	cmp	#5, r2
fff80b61:	20 4e                         	beq.b	fff80baf <_Reset_Vector+0xfff80bb3>
fff80b63:	22 05                         	bc.b	fff80b68 <_Reset_Vector+0xfff80b6c>
fff80b65:	38 e1 00                      	bra.w	fff80c46 <_Reset_Vector+0xfff80c4a>
fff80b68:	61 62                         	cmp	#6, r2
fff80b6a:	21 2a                         	bne.b	fff80b94 <_Reset_Vector+0xfff80b98>

fff80b6c <.LBB126>:
    if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
fff80b6c:	61 03                         	cmp	#0, r3
fff80b6e:	20 26                         	beq.b	fff80b94 <_Reset_Vector+0xfff80b98>
fff80b70:	74 03 00 00 00 10             	cmp	#0x10000000, r3
fff80b76:	20 1e                         	beq.b	fff80b94 <_Reset_Vector+0xfff80b98>
        pmode = (R_BSP_GET_PSW() & 0x00100000);
fff80b78:	fd 6a 07                      	mvfc	psw, r7

fff80b7b <.LVL32>:
        if (0 == pmode)
fff80b7b:	7d 47                         	btst	#20, r7
fff80b7d:	3b 08 01                      	bne.w	fff80c85 <_Reset_Vector+0xfff80c89>

fff80b80 <.LBB128>:
                pdata->ipl = R_BSP_CpuInterruptLevelRead();
fff80b80:	a0 0b                         	mov.l	r3, 4[r0]
fff80b82:	05 66 fd ff                   	bsr.a	fff808e8 <_Reset_Vector+0xfff808ec>

fff80b86 <.LVL34>:
fff80b86:	a8 0b                         	mov.l	4[r0], r3
fff80b88:	e3 31                         	mov.l	r1, [r3]

fff80b8a <.LVL35>:
            if (pdata->ipl < BSP_CFG_FIT_IPL_MAX)
fff80b8a:	61 a1                         	cmp	#10, r1
fff80b8c:	24 05                         	bgtu.b	fff80b91 <_Reset_Vector+0xfff80b95>
fff80b8e:	38 22 01                      	bra.w	fff80cb0 <_Reset_Vector+0xfff80cb4>

fff80b91 <.LBB136>:
                    err = BSP_INT_ERR_INVALID_IPL;
fff80b91:	66 57                         	mov.l	#5, r7
fff80b93:	0b                            	bra.s	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80b94 <.LBE136>:
                 err = BSP_INT_ERR_INVALID_ARG;
fff80b94:	66 27                         	mov.l	#2, r7

fff80b96 <.LVL38>:
} /* End of function R_BSP_InterruptControl() */
fff80b96:	ef 71                         	mov.l	r7, r1
fff80b98:	3f 7a 06                      	rtsd	#24, r7-r10

fff80b9b <.LVL39>:
            err = bsp_interrupt_enable_disable(vector, false);
fff80b9b:	66 02                         	mov.l	#0, r2

fff80b9d <.LVL40>:
fff80b9d:	fc 13 00                      	nop	; max	r0, r0
fff80ba0:	05 f0 fa ff                   	bsr.a	fff80690 <_Reset_Vector+0xfff80694>

fff80ba4 <.LVL41>:
fff80ba4:	ef 17                         	mov.l	r1, r7

fff80ba6 <.LVL42>:
} /* End of function R_BSP_InterruptControl() */
fff80ba6:	ef 71                         	mov.l	r7, r1
fff80ba8:	3f 7a 06                      	rtsd	#24, r7-r10

fff80bab <.LVL43>:
                err = BSP_INT_ERR_NO_REGISTERED_CALLBACK;
fff80bab:	66 17                         	mov.l	#1, r7
fff80bad:	2e e9                         	bra.b	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80baf <.LBB147>:
    if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
fff80baf:	61 03                         	cmp	#0, r3
fff80bb1:	20 e3                         	beq.b	fff80b94 <_Reset_Vector+0xfff80b98>
fff80bb3:	74 03 00 00 00 10             	cmp	#0x10000000, r3
fff80bb9:	20 db                         	beq.b	fff80b94 <_Reset_Vector+0xfff80b98>
        pmode = (R_BSP_GET_PSW() & 0x00100000);
fff80bbb:	fd 6a 07                      	mvfc	psw, r7

fff80bbe <.LVL45>:
        if (0 == pmode)
fff80bbe:	7d 47                         	btst	#20, r7
fff80bc0:	3b c5 00                      	bne.w	fff80c85 <_Reset_Vector+0xfff80c89>

fff80bc3 <.LBB142>:
                ipl_value = pdata->ipl;
fff80bc3:	ec 31                         	mov.l	[r3], r1

fff80bc5 <.LVL47>:
            if (pdata->ipl < BSP_CFG_FIT_IPL_MAX)
fff80bc5:	61 a1                         	cmp	#10, r1
fff80bc7:	24 ca                         	bgtu.b	fff80b91 <_Reset_Vector+0xfff80b95>

fff80bc9 <.LBB132>:
                ret = R_BSP_CpuInterruptLevelWrite(ipl_value);
fff80bc9:	05 27 fd ff                   	bsr.a	fff808f0 <_Reset_Vector+0xfff808f4>

fff80bcd <.LVL49>:
                if (false == ret)
fff80bcd:	61 01                         	cmp	#0, r1
fff80bcf:	20 c2                         	beq.b	fff80b91 <_Reset_Vector+0xfff80b95>

fff80bd1 <.LBB143>:
            err = BSP_INT_SUCCESS;
fff80bd1:	66 07                         	mov.l	#0, r7
fff80bd3:	2e c3                         	bra.b	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80bd5 <.LBE143>:
            if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
fff80bd5:	61 03                         	cmp	#0, r3
fff80bd7:	20 bd                         	beq.b	fff80b94 <_Reset_Vector+0xfff80b98>
fff80bd9:	74 03 00 00 00 10             	cmp	#0x10000000, r3
fff80bdf:	20 b5                         	beq.b	fff80b94 <_Reset_Vector+0xfff80b98>
                err = bsp_gr_int_enable_disable(vector, true, ((bsp_int_ctrl_t *)pdata)->ipl);
fff80be1:	ec 3a                         	mov.l	[r3], r10

fff80be3 <.LBB150>:
    if ((true == enable) && ((BSP_MCU_IPL_MIN == ipl) || (ipl > BSP_MCU_IPL_MAX)))
fff80be3:	71 a5 ff                      	add	#-1, r10, r5
fff80be6:	61 e5                         	cmp	#14, r5
fff80be8:	24 ac                         	bgtu.b	fff80b94 <_Reset_Vector+0xfff80b98>
    else if ((vector > BSP_INT_SRC_GR_INT_BE0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL0_TOP))
fff80bea:	75 51 12                      	cmp	#18, r1
fff80bed:	3a c8 00                      	beq.w	fff80cb5 <_Reset_Vector+0xfff80cb9>

fff80bf0 <.LBB152>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL1_TOP))
fff80bf0:	71 15 ec                      	add	#-20, r1, r5
fff80bf3:	61 f5                         	cmp	#15, r5
fff80bf5:	25 05                         	bleu.b	fff80bfa <_Reset_Vector+0xfff80bfe>
fff80bf7:	38 63 01                      	bra.w	fff80d5a <_Reset_Vector+0xfff80d5e>

fff80bfa <.LBB154>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80bfa:	66 62                         	mov.l	#6, r2

fff80bfc <.LVL54>:
fff80bfc:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80c01 <.LVL55>:
fff80c01:	05 2b 02 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80c05 <.LVL56>:
            IR(ICU, GROUPBL0)  = 0;
fff80c05:	fb 7e 00 70 08                	mov.l	#0x87000, r7

fff80c0a <.LVL57>:
fff80c0a:	f1 78 6e                      	bclr	#0, 110[r7].b
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
fff80c0d:	ce 75 6e 03                   	mov.b	878[r7], r5
fff80c11:	64 f5                         	and	#15, r5
fff80c13:	47 5a                         	cmp	r5, r10
fff80c15:	24 05                         	bgtu.b	fff80c1a <_Reset_Vector+0xfff80c1e>
fff80c17:	38 a0 01                      	bra.w	fff80db7 <_Reset_Vector+0xfff80dbb>
fff80c1a:	66 f5                         	mov.l	#15, r5
fff80c1c:	53 a5                         	and	r10, r5
fff80c1e:	ef 00                         	nop	; mov.l	r0, r0
fff80c20:	fb 4e 00 70 08                	mov.l	#0x87000, r4
fff80c25:	66 fa                         	mov.l	#15, r10

fff80c27 <.LVL58>:
fff80c27:	53 5a                         	and	r5, r10

fff80c29 <.LBB156>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80c29:	66 62                         	mov.l	#6, r2

fff80c2b <.LBE156>:
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
fff80c2b:	ce 45 6e 03                   	mov.b	878[r4], r5

fff80c2f <.LBB160>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80c2f:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80c34 <.LBE160>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff80c34:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
fff80c36:	75 25 f0                      	and	#-16, r5
fff80c39:	57 a5                         	or	r10, r5
fff80c3b:	cb 45 6e 03                   	mov.b	r5, 878[r4]

fff80c3f <.LBB161>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80c3f:	05 e9 01 00                   	bsr.a	fff80e28 <_Reset_Vector+0xfff80e2c>

fff80c43 <.LVL60>:
fff80c43:	38 53 ff                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80c46 <.LBB192>:
    else if ((vector > BSP_INT_SRC_GR_INT_BE0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL0_TOP))
fff80c46:	75 51 12                      	cmp	#18, r1
fff80c49:	3a bb 00                      	beq.w	fff80d04 <_Reset_Vector+0xfff80d08>

fff80c4c <.LBB194>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL1_TOP))
fff80c4c:	71 1a ec                      	add	#-20, r1, r10
fff80c4f:	61 fa                         	cmp	#15, r10
fff80c51:	25 39                         	bleu.b	fff80c8a <_Reset_Vector+0xfff80c8e>
    else if ((vector > BSP_INT_SRC_GR_INT_BL1_TOP) && (vector < BSP_INT_SRC_GR_INT_BL2_TOP))
fff80c53:	71 1a db                      	add	#-37, r1, r10
fff80c56:	75 5a 14                      	cmp	#20, r10
fff80c59:	25 05                         	bleu.b	fff80c5e <_Reset_Vector+0xfff80c62>
fff80c5b:	38 cf 00                      	bra.w	fff80d2a <_Reset_Vector+0xfff80d2e>
            if (0 == ICU.GENBL1.LONG)
fff80c5e:	fb ae 00 70 08                	mov.l	#0x87000, r10
fff80c63:	ee a7 9d 01                   	mov.l	1652[r10], r7
fff80c67:	61 07                         	cmp	#0, r7
fff80c69:	3b 96 00                      	bne.w	fff80cff <_Reset_Vector+0xfff80d03>

fff80c6c <.LBB196>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80c6c:	66 72                         	mov.l	#7, r2

fff80c6e <.LVL64>:
fff80c6e:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80c73 <.LVL65>:
fff80c73:	05 b9 01 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80c77 <.LVL66>:
                IPR(ICU, GROUPBL1) = 0;
fff80c77:	ce a5 6f 03                   	mov.b	879[r10], r5
fff80c7b:	75 25 f0                      	and	#-16, r5
fff80c7e:	cb a5 6f 03                   	mov.b	r5, 879[r10]
fff80c82:	38 14 ff                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80c85 <.LBB210>:
            err = BSP_INT_ERR_UNSUPPORTED;
fff80c85:	66 37                         	mov.l	#3, r7
fff80c87:	38 0f ff                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80c8a <.LBB204>:
            if (0 == ICU.GENBL0.LONG)
fff80c8a:	fb ae 00 70 08                	mov.l	#0x87000, r10
fff80c8f:	ee a7 9c 01                   	mov.l	1648[r10], r7
fff80c93:	61 07                         	cmp	#0, r7
fff80c95:	21 6a                         	bne.b	fff80cff <_Reset_Vector+0xfff80d03>

fff80c97 <.LBB198>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80c97:	66 62                         	mov.l	#6, r2

fff80c99 <.LVL70>:
fff80c99:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80c9e <.LVL71>:
fff80c9e:	05 8e 01 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80ca2 <.LVL72>:
                IPR(ICU, GROUPBL0) = 0;
fff80ca2:	ce a5 6e 03                   	mov.b	878[r10], r5
fff80ca6:	75 25 f0                      	and	#-16, r5
fff80ca9:	cb a5 6e 03                   	mov.b	r5, 878[r10]
fff80cad:	38 e9 fe                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80cb0 <.LBB133>:
                ret = R_BSP_CpuInterruptLevelWrite(ipl_value);
fff80cb0:	66 b1                         	mov.l	#11, r1
fff80cb2:	38 17 ff                      	bra.w	fff80bc9 <_Reset_Vector+0xfff80bcd>

fff80cb5 <.LBB180>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80cb5:	66 22                         	mov.l	#2, r2

fff80cb7 <.LVL75>:
fff80cb7:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80cbc <.LVL76>:
fff80cbc:	05 70 01 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80cc0 <.LVL77>:
            IR(ICU, GROUPBE0)  = 0;
fff80cc0:	fb 7e 00 70 08                	mov.l	#0x87000, r7

fff80cc5 <.LVL78>:
fff80cc5:	f1 78 6a                      	bclr	#0, 106[r7].b
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
fff80cc8:	ce 75 6a 03                   	mov.b	874[r7], r5
fff80ccc:	64 f5                         	and	#15, r5
fff80cce:	47 5a                         	cmp	r5, r10
fff80cd0:	24 05                         	bgtu.b	fff80cd5 <_Reset_Vector+0xfff80cd9>
fff80cd2:	38 dc 00                      	bra.w	fff80dae <_Reset_Vector+0xfff80db2>
fff80cd5:	66 f5                         	mov.l	#15, r5
fff80cd7:	53 a5                         	and	r10, r5
fff80cd9:	fb 4e 00 70 08                	mov.l	#0x87000, r4
fff80cde:	66 fa                         	mov.l	#15, r10

fff80ce0 <.LVL79>:
fff80ce0:	53 5a                         	and	r5, r10

fff80ce2 <.LBB182>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80ce2:	66 22                         	mov.l	#2, r2

fff80ce4 <.LBE182>:
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
fff80ce4:	ce 45 6a 03                   	mov.b	874[r4], r5

fff80ce8 <.LBB186>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80ce8:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80ced <.LBE186>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff80ced:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
fff80cef:	75 25 f0                      	and	#-16, r5
fff80cf2:	57 a5                         	or	r10, r5
fff80cf4:	cb 45 6a 03                   	mov.b	r5, 874[r4]

fff80cf8 <.LBB187>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80cf8:	05 30 01 00                   	bsr.a	fff80e28 <_Reset_Vector+0xfff80e2c>

fff80cfc <.LVL81>:
fff80cfc:	38 9a fe                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80cff <.LBB214>:
                err = BSP_INT_ERR_GROUP_STILL_ENABLED;
fff80cff:	ef 27                         	mov.l	r2, r7
fff80d01:	38 95 fe                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>
            if (0 == ICU.GENBE0.LONG)
fff80d04:	fb ae 00 70 08                	mov.l	#0x87000, r10
fff80d09:	ee a7 90 01                   	mov.l	1600[r10], r7
fff80d0d:	61 07                         	cmp	#0, r7
fff80d0f:	21 f0                         	bne.b	fff80cff <_Reset_Vector+0xfff80d03>

fff80d11 <.LBB205>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80d11:	66 22                         	mov.l	#2, r2

fff80d13 <.LVL84>:
fff80d13:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80d18 <.LVL85>:
fff80d18:	05 14 01 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80d1c <.LVL86>:
                IPR(ICU, GROUPBE0) = 0;
fff80d1c:	ce a5 6a 03                   	mov.b	874[r10], r5
fff80d20:	75 25 f0                      	and	#-16, r5
fff80d23:	cb a5 6a 03                   	mov.b	r5, 874[r10]
fff80d27:	38 6f fe                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80d2a <.LBB207>:
    else if ((vector > BSP_INT_SRC_GR_INT_AL0_TOP) && (vector < BSP_INT_SRC_GR_INT_AL1_TOP))
fff80d2a:	71 77 c4                      	add	#-60, r7, r7
fff80d2d:	61 37                         	cmp	#3, r7
fff80d2f:	25 05                         	bleu.b	fff80d34 <_Reset_Vector+0xfff80d38>
fff80d31:	38 63 fe                      	bra.w	fff80b94 <_Reset_Vector+0xfff80b98>
            if (0 == ICU.GENAL0.LONG)
fff80d34:	fb ae 00 70 08                	mov.l	#0x87000, r10
fff80d39:	ee a7 1c 02                   	mov.l	2160[r10], r7
fff80d3d:	61 07                         	cmp	#0, r7
fff80d3f:	21 c0                         	bne.b	fff80cff <_Reset_Vector+0xfff80d03>

fff80d41 <.LBB200>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80d41:	66 02                         	mov.l	#0, r2

fff80d43 <.LVL89>:
fff80d43:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

fff80d48 <.LVL90>:
fff80d48:	05 e4 00 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80d4c <.LVL91>:
                IPR(ICU, GROUPAL0) = 0;
fff80d4c:	ce a5 70 03                   	mov.b	880[r10], r5
fff80d50:	75 25 f0                      	and	#-16, r5
fff80d53:	cb a5 70 03                   	mov.b	r5, 880[r10]
fff80d57:	38 3f fe                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80d5a <.LBB188>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL1_TOP) && (vector < BSP_INT_SRC_GR_INT_BL2_TOP))
fff80d5a:	71 15 db                      	add	#-37, r1, r5
fff80d5d:	75 55 14                      	cmp	#20, r5
fff80d60:	24 60                         	bgtu.b	fff80dc0 <_Reset_Vector+0xfff80dc4>

fff80d62 <.LBB162>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80d62:	66 72                         	mov.l	#7, r2

fff80d64 <.LVL94>:
fff80d64:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80d69 <.LVL95>:
fff80d69:	05 c3 00 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80d6d <.LVL96>:
            IR(ICU, GROUPBL1)  = 0;
fff80d6d:	fb 7e 00 70 08                	mov.l	#0x87000, r7

fff80d72 <.LVL97>:
fff80d72:	f1 78 6f                      	bclr	#0, 111[r7].b
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
fff80d75:	ce 75 6f 03                   	mov.b	879[r7], r5
fff80d79:	64 f5                         	and	#15, r5
fff80d7b:	47 5a                         	cmp	r5, r10
fff80d7d:	24 05                         	bgtu.b	fff80d82 <_Reset_Vector+0xfff80d86>
fff80d7f:	38 92 00                      	bra.w	fff80e11 <_Reset_Vector+0xfff80e15>
fff80d82:	66 f4                         	mov.l	#15, r4
fff80d84:	53 a4                         	and	r10, r4
fff80d86:	ef 00                         	nop	; mov.l	r0, r0
fff80d88:	fb 3e 00 70 08                	mov.l	#0x87000, r3
fff80d8d:	64 f4                         	and	#15, r4

fff80d8f <.LBB164>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80d8f:	66 72                         	mov.l	#7, r2

fff80d91 <.LBE164>:
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
fff80d91:	ce 35 6f 03                   	mov.b	879[r3], r5

fff80d95 <.LBB168>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80d95:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

fff80d9a <.LBE168>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff80d9a:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
fff80d9c:	fb a6 f0                      	mov.l	#-16, r10

fff80d9f <.LVL98>:
fff80d9f:	53 5a                         	and	r5, r10
fff80da1:	57 4a                         	or	r4, r10
fff80da3:	cb 3a 6f 03                   	mov.b	r10, 879[r3]

fff80da7 <.LBB169>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80da7:	05 81 00 00                   	bsr.a	fff80e28 <_Reset_Vector+0xfff80e2c>

fff80dab <.LVL100>:
fff80dab:	38 eb fd                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80dae <.LBE169>:
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
fff80dae:	ce 75 6a 03                   	mov.b	874[r7], r5
fff80db2:	64 f5                         	and	#15, r5
fff80db4:	38 25 ff                      	bra.w	fff80cd9 <_Reset_Vector+0xfff80cdd>

fff80db7 <.LBB189>:
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
fff80db7:	ce 75 6e 03                   	mov.b	878[r7], r5
fff80dbb:	64 f5                         	and	#15, r5
fff80dbd:	38 63 fe                      	bra.w	fff80c20 <_Reset_Vector+0xfff80c24>

fff80dc0 <.LVL103>:
    else if ((vector > BSP_INT_SRC_GR_INT_AL0_TOP) && (vector < BSP_INT_SRC_GR_INT_AL1_TOP))
fff80dc0:	71 77 c4                      	add	#-60, r7, r7
fff80dc3:	61 37                         	cmp	#3, r7
fff80dc5:	25 05                         	bleu.b	fff80dca <_Reset_Vector+0xfff80dce>
fff80dc7:	38 cd fd                      	bra.w	fff80b94 <_Reset_Vector+0xfff80b98>

fff80dca <.LBB170>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
fff80dca:	66 02                         	mov.l	#0, r2

fff80dcc <.LVL105>:
fff80dcc:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

fff80dd1 <.LVL106>:
fff80dd1:	05 5b 00 00                   	bsr.a	fff80e2c <_Reset_Vector+0xfff80e30>

fff80dd5 <.LVL107>:
            IR(ICU, GROUPAL0)  = 0;
fff80dd5:	fb 7e 00 70 08                	mov.l	#0x87000, r7

fff80dda <.LVL108>:
fff80dda:	f1 78 70                      	bclr	#0, 112[r7].b
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
fff80ddd:	ce 75 70 03                   	mov.b	880[r7], r5
fff80de1:	64 f5                         	and	#15, r5
fff80de3:	47 5a                         	cmp	r5, r10
fff80de5:	25 35                         	bleu.b	fff80e1a <_Reset_Vector+0xfff80e1e>
fff80de7:	66 f5                         	mov.l	#15, r5
fff80de9:	53 a5                         	and	r10, r5
fff80deb:	fb 4e 00 70 08                	mov.l	#0x87000, r4
fff80df0:	66 fa                         	mov.l	#15, r10

fff80df2 <.LVL109>:
fff80df2:	53 5a                         	and	r5, r10

fff80df4 <.LBB172>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80df4:	66 02                         	mov.l	#0, r2

fff80df6 <.LBE172>:
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
fff80df6:	ce 45 70 03                   	mov.b	880[r4], r5

fff80dfa <.LBB176>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80dfa:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

fff80dff <.LBE176>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
fff80dff:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
fff80e01:	75 25 f0                      	and	#-16, r5
fff80e04:	57 5a                         	or	r5, r10
fff80e06:	cb 4a 70 03                   	mov.b	r10, 880[r4]

fff80e0a <.LBB177>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
fff80e0a:	05 1e 00 00                   	bsr.a	fff80e28 <_Reset_Vector+0xfff80e2c>

fff80e0e <.LVL111>:
fff80e0e:	38 88 fd                      	bra.w	fff80b96 <_Reset_Vector+0xfff80b9a>

fff80e11 <.LBE177>:
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
fff80e11:	ce 74 6f 03                   	mov.b	879[r7], r4
fff80e15:	64 f4                         	and	#15, r4
fff80e17:	38 71 ff                      	bra.w	fff80d88 <_Reset_Vector+0xfff80d8c>
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
fff80e1a:	ce 75 70 03                   	mov.b	880[r7], r5
fff80e1e:	64 f5                         	and	#15, r5
fff80e20:	2e cb                         	bra.b	fff80deb <_Reset_Vector+0xfff80def>

fff80e22 <.LBE189>:
fff80e22:	74 10 01 00 00 00             	nop	; mul	#1, r0

fff80e28 <_R_BSP_BitSet>:
void R_BSP_BitSet(uint8_t *data, uint32_t bit)
{
    R_BSP_ASM_INTERNAL_USED(data)
    R_BSP_ASM_INTERNAL_USED(bit)

    R_BSP_ASM_BEGIN
fff80e28:	fc 60 12                      	bset	r2, [r1].b
fff80e2b:	02                            	rts

fff80e2c <_R_BSP_BitClear>:
void R_BSP_BitClear(uint8_t *data, uint32_t bit)
{
    R_BSP_ASM_INTERNAL_USED(data)
    R_BSP_ASM_INTERNAL_USED(bit)

    R_BSP_ASM_BEGIN
fff80e2c:	fc 64 12                      	bclr	r2, [r1].b
fff80e2f:	02                            	rts

fff80e30 <_R_BSP_InitTFU>:
* Return Value : none
***********************************************************************************************************************/
R_BSP_PRAGMA_INLINE_ASM(R_BSP_InitTFU)
void R_BSP_InitTFU(void)
{
    R_BSP_ASM_BEGIN
fff80e30:	7e a1                         	push.l	r1
fff80e32:	fb 1e 00 14 08                	mov.l	#0x81400, r1
fff80e37:	f8 14 07                      	mov.b	#7, [r1]
fff80e3a:	3c 11 07                      	mov.b	#7, 1[r1]
fff80e3d:	7e b1                         	pop	r1
fff80e3f:	02                            	rts

fff80e40 <_PowerON_Reset_PC_Prg>:
#endif

#if defined(__CCRX__) || defined(__GNUC__)

    /* Initialize the Interrupt Table Register */
    R_BSP_SET_INTB(R_BSP_SECTOP_INTVECTTBL);
fff80e40:	fd 73 0c c0 1d f8 ff          	mvtc	#0xfff81dc0, intb

#ifdef BSP_MCU_EXCEPTION_TABLE
    /* Initialize the Exception Table Register */
    R_BSP_SET_EXTB(R_BSP_SECTOP_EXCEPTVECTTBL);
fff80e47:	fd 73 0d 80 ff ff ff          	mvtc	#-128, extb
#endif

#ifdef BSP_MCU_FLOATING_POINT
#ifdef __FPU
    /* Initialize the Floating-Point Status Word Register. */
    R_BSP_SET_FPSW(BSP_PRV_FPSW_INIT | BSP_PRV_FPU_ROUND | BSP_PRV_FPU_DENOM);
fff80e4e:	fd 77 03 00                   	mvtc	#0, fpsw
#endif

    /* Initializes the trigonometric function unit. */
#ifdef BSP_MCU_TRIGONOMETRIC
#ifdef __TFU
    R_BSP_INIT_TFU();
fff80e52:	05 de ff ff                   	bsr.a	fff80e30 <_Reset_Vector+0xfff80e34>

fff80e56 <.LVL0>:
#ifdef BSP_MCU_VBATT_INITIALIZE
    vbatt_voltage_stability_wait();
#endif

    /* Switch to high-speed operation */ 
    mcu_clock_setup();
fff80e56:	05 82 f6 ff                   	bsr.a	fff804d8 <_Reset_Vector+0xfff804dc>

fff80e5a <.LVL1>:
#if BSP_CFG_USER_WARM_START_CALLBACK_PRE_INITC_ENABLED == 1
    BSP_CFG_USER_WARM_START_PRE_C_FUNCTION();
#endif

    /* Initialize C runtime environment */
    _INITSCT();
fff80e5a:	05 b8 f1 ff                   	bsr.a	fff80012 <_Reset_Vector+0xfff80016>

fff80e5e <.LVL2>:
    /* Initialize C++ global class object */
    _CALL_INIT();
#endif

    /* Initialize RAM */
    bsp_ram_initialize();
fff80e5e:	05 3d fc ff                   	bsr.a	fff80a9b <_Reset_Vector+0xfff80a9f>

fff80e62 <.LVL3>:
    init_iolib();
#endif /* defined(__CCRX__) */
#endif

    /* Initialize MCU interrupt callbacks. */
    bsp_interrupt_open();
fff80e62:	05 8e fc ff                   	bsr.a	fff80af0 <_Reset_Vector+0xfff80af4>

fff80e66 <.LVL4>:

    /* Initialize register protection functionality. */
    bsp_register_protect_open();
fff80e66:	05 22 fc ff                   	bsr.a	fff80a88 <_Reset_Vector+0xfff80a8c>

fff80e6a <.LVL5>:

    /* Configure the MCU and board hardware */
    hardware_setup();
fff80e6a:	05 1f 00 00                   	bsr.a	fff80e89 <_Reset_Vector+0xfff80e8d>

fff80e6e <.LVL6>:

    /* Enable interrupt and select the I stack or the U stack */
    R_BSP_SET_PSW(BSP_PRV_PSW_INIT);
fff80e6e:	fd 7f 00 00 00 03             	mvtc	#0x30000, psw
    #endif
#endif /* BSP_CFG_RUN_IN_USER_MODE */
#endif /* BSP_CFG_RTOS_USED */

    /* Enable the bus error interrupt to catch accesses to illegal/reserved areas of memory */
    R_BSP_InterruptControl(BSP_INT_SRC_BUS_ERROR, BSP_INT_CMD_INTERRUPT_ENABLE, FIT_NO_PTR);
fff80e74:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff80e7a:	66 12                         	mov.l	#1, r2
fff80e7c:	66 b1                         	mov.l	#11, r1
fff80e7e:	05 b2 fc ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff80e82 <.LVL7>:

#if (BSP_CFG_RTOS_USED == 0) || (BSP_CFG_RTOS_USED == 5)    /* Non-OS or Azure RTOS */
    /* Call the main program function (should not return) */
    R_BSP_MAIN_FUNCTION();
fff80e82:	05 f5 02 00                   	bsr.a	fff81177 <_Reset_Vector+0xfff8117b>

fff80e86 <.LVL8>:
    /* Infinite loop is intended here. */
    /* WAIT_LOOP */
    while(1)
    {
        /* Infinite loop. Put a breakpoint here if you want to catch an exit of main(). */
        R_BSP_NOP();
fff80e86:	03                            	nop
fff80e87:	2e ff                         	bra.b	fff80e86 <_Reset_Vector+0xfff80e8a>

fff80e89 <_hardware_setup>:
#if BSP_CFG_NONCACHEABLE_AREA1_ENABLE == 1
    rom_cache_noncacheable_area1_set();
#endif /* BSP_CFG_NONCACHEABLE_AREA1_ENABLE == 1 */

    /* Invalidates the contents of the ROM cache. */
    FLASH.ROMCIV.WORD = 0x0001;
fff80e89:	fb 5e 00 10 08                	mov.l	#0x81000, r5
fff80e8e:	3d 52 01                      	mov.w	#1, 4[r5]

    /* Enables the ROM cache. */
    FLASH.ROMCE.WORD = 0x0001;
fff80e91:	f8 55 01                      	mov.w	#1, [r5]

fff80e94 <.LBB14>:
* Return value : none
***********************************************************************************************************************/
static void output_ports_configure(void)
{
    /* Add code here to setup additional output ports */
    R_BSP_NOP();
fff80e94:	03                            	nop

fff80e95 <.LBB16>:
* Return value : none
***********************************************************************************************************************/
static void interrupts_configure(void)
{
    /* Add code here to setup additional interrupts */
    R_BSP_NOP();
fff80e95:	03                            	nop

fff80e96 <.LBB18>:
    tmp_arg |= BSP_VOL_RIIC_UNDER_4_5V;
#else
    #error "Error! Invalid setting for BSP_CFG_MCU_VCC_MV in r_bsp_config.h"
#endif

    R_BSP_VoltageLevelSetting(tmp_arg);
fff80e96:	75 41 28                      	mov.l	#40, r1
fff80e99:	05 f7 fa ff                   	bsr.a	fff80990 <_Reset_Vector+0xfff80994>

fff80e9d <.LBB20>:
    R_Systeminit();
fff80e9d:	05 09 00 00                   	bsr.a	fff80ea6 <_Reset_Vector+0xfff80eaa>

fff80ea1 <.LVL2>:
    bsp_non_existent_port_init();
fff80ea1:	04 37 f7 ff                   	bra.a	fff805d8 <_Reset_Vector+0xfff805dc>

fff80ea5 <_r_undefined_exception>:

void r_undefined_exception(void)
{
    /* Start user code for r_undefined_exception. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
fff80ea5:	02                            	rts

fff80ea6 <_R_Systeminit>:
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void R_Systeminit(void)
{
fff80ea6:	6e 7a                         	pushm	r7-r10
    /* Enable writing to registers related to operating modes, LPC, CGC and software reset */
    SYSTEM.PRCR.WORD = 0xA50BU;
fff80ea8:	fb ae 00 00 08                	mov.l	#0x80000, r10

    /* Enable writing to MPC pin function control registers */
    MPC.PWPR.BIT.B0WI = 0U;
fff80ead:	fb 7e 00 c1 08                	mov.l	#0x8c100, r7
    SYSTEM.PRCR.WORD = 0xA50BU;
fff80eb2:	fa a9 ff 01 0b a5             	mov.w	#0xa50b, 1022[r10]
    MPC.PWPR.BIT.B0WI = 0U;
fff80eb8:	8f fd                         	mov.b	31[r7], r5
fff80eba:	7a 75                         	bclr	#7, r5
fff80ebc:	87 fd                         	mov.b	r5, 31[r7]
    MPC.PWPR.BIT.PFSWE = 1U;
fff80ebe:	f1 76 1f                      	bset	#6, 31[r7].b

    /* Write 0 to the target bits in the POECR2 registers */
    POE.POECR2.WORD = 0x0000U;
fff80ec1:	fb 5e 00 e4 09                	mov.l	#0x9e400, r5
fff80ec6:	3d 56 00                      	mov.w	#0, 12[r5]

    /* Initialize clocks settings */
    R_CGC_Create();
fff80ec9:	05 26 00 00                   	bsr.a	fff80eef <_Reset_Vector+0xfff80ef3>

fff80ecd <.LVL0>:

    /* Set peripheral settings */
    R_Config_MTU3_MTU4_Create();
fff80ecd:	05 27 00 00                   	bsr.a	fff80ef4 <_Reset_Vector+0xfff80ef8>

fff80ed1 <.LVL1>:

    /* Register undefined interrupt */
    R_BSP_InterruptWrite(BSP_INT_SRC_UNDEFINED_INTERRUPT,(bsp_int_cb_t)r_undefined_exception);
fff80ed1:	fb 22 a5 0e f8 ff             	mov.l	#0xfff80ea5, r2
fff80ed7:	66 a1                         	mov.l	#10, r1
fff80ed9:	05 37 fc ff                   	bsr.a	fff80b10 <_Reset_Vector+0xfff80b14>

fff80edd <.LVL2>:

    /* Disable writing to MPC pin function control registers */
    MPC.PWPR.BIT.PFSWE = 0U;
fff80edd:	f1 7e 1f                      	bclr	#6, 31[r7].b
    MPC.PWPR.BIT.B0WI = 1U;
fff80ee0:	8f fd                         	mov.b	31[r7], r5
fff80ee2:	78 75                         	bset	#7, r5
fff80ee4:	87 fd                         	mov.b	r5, 31[r7]

    /* Enable protection */
    SYSTEM.PRCR.WORD = 0xA500U;
fff80ee6:	fa a9 ff 01 00 a5             	mov.w	#0xa500, 1022[r10]
}
fff80eec:	3f 7a 04                      	rtsd	#16, r7-r10

fff80eef <_R_CGC_Create>:
* Return Value : None
***********************************************************************************************************************/

void R_CGC_Create(void)
{
    R_CGC_Create_UserInit();
fff80eef:	04 04 00 00                   	bra.a	fff80ef3 <_Reset_Vector+0xfff80ef7>

fff80ef3 <_R_CGC_Create_UserInit>:

void R_CGC_Create_UserInit(void)
{
    /* Start user code for user init. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
fff80ef3:	02                            	rts

fff80ef4 <_R_Config_MTU3_MTU4_Create>:
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void R_Config_MTU3_MTU4_Create(void)
{
fff80ef4:	6e 6b                         	pushm	r6-r11
    /* Release MTU channel 3 from stop state */
    MSTP(MTU3) = 0U;
fff80ef6:	fb ae 00 00 08                	mov.l	#0x80000, r10
    /* Enable read/write to MTU3, MTU4 registers */
    MTU.TRWERA.BIT.RWE = 1U;
fff80efb:	fb 5e 0a 12 0c                	mov.l	#0xc120a, r5
    MSTP(MTU3) = 0U;
fff80f00:	ed a2 04                      	mov.l	16[r10], r2
    /* Stop MTU3, MTU4 counter */
    MTU.TSTRA.BYTE = MTU.TSTRA.BYTE & 0x3FU;
    /* Set TGIA3 interrupt priority level */
    ICU.SLIAR223.BYTE = 0x10U;
fff80f03:	fb 7e 00 70 08                	mov.l	#0x87000, r7
    IPR(PERIA, INTA223) = _0F_MTR_PRIORITY_LEVEL15;

    /* Configure MTU3 and MTU4 as complementary PWM mode timer */
    MTU3.TIER.BYTE = 0x00U;
fff80f08:	fb 3e 00 12 0c                	mov.l	#0xc1200, r3
    MTU4.TIORL.BYTE = 0x00U;
    /* Disable read/write to MTU3, MTU4 registers */
    MTU.TRWERA.BIT.RWE = 0U;

    //Init Up (MTIOC3B)
    PORT1.PODR.BIT.B2 = 1U; //Active Low
fff80f0d:	fb fe 01 c0 08                	mov.l	#0x8c001, r15
    MSTP(MTU3) = 0U;
fff80f12:	7a 92                         	bclr	#9, r2
    PORT1.PDR.BIT.B2 = 1U;
    PORT1.PMR.BIT.B2 = 0U;
    MPC.P12PFS.BIT.PSEL = 0x01U;
fff80f14:	fb 4e 00 c1 08                	mov.l	#0x8c100, r4
    //Init Un (MTIOC3D)
    PORT7.PODR.BIT.B4 = 1U; //Active Low
fff80f19:	fb ee 07 c0 08                	mov.l	#0x8c007, r14
    MSTP(MTU3) = 0U;
fff80f1e:	e7 a2 04                      	mov.l	r2, 16[r10]
    MTU.TRWERA.BIT.RWE = 1U;
fff80f21:	f1 50 7a                      	bset	#0, 122[r5].b
    MTU.TSTRA.BYTE = MTU.TSTRA.BYTE & 0x3FU;
fff80f24:	cd 51 76                      	mov.b	118[r5], r1
    MPC.P76PFS.BIT.PSEL = 0x01U;

    /* Cancel S12AD module stop state */
    MSTP(S12AD) = 0U;
    /* Disable and clear interrupt flags of S12AD module */
    S12AD.ADCSR.BIT.ADIE = 0U;
fff80f27:	fb 2e 00 90 08                	mov.l	#0x89000, r2
    MTU.TSTRA.BYTE = MTU.TSTRA.BYTE & 0x3FU;
fff80f2c:	75 4b 3f                      	mov.l	#63, r11
fff80f2f:	53 1b                         	and	r1, r11
    IPR(S12AD, S12ADI) = _0F_MTR_PRIORITY_LEVEL15;

    /* Cancel S12AD1 module stop state */
    MSTP(S12AD1) = 0U;
    /* Disable and clear interrupt flags of S12AD1 module */
    S12AD1.ADCSR.BIT.ADIE = 0U;
fff80f31:	fb 1e 00 92 08                	mov.l	#0x89200, r1
    //Init AN001
    MPC.P41PFS.BIT.ASEL = 1U;
    //Init AN002
    MPC.P42PFS.BIT.ASEL = 1U;
    //Init AN003
    PORT4.PDR.BIT.B3 = 0U;
fff80f36:	fb 6e 04 c0 08                	mov.l	#0x8c004, r6
    MTU.TSTRA.BYTE = MTU.TSTRA.BYTE & 0x3FU;
fff80f3b:	c7 5b 76                      	mov.b	r11, 118[r5]
    ICU.SLIAR223.BYTE = 0x10U;
fff80f3e:	fa 74 df 09 10                	mov.b	#16, 2527[r7]
    IPR(PERIA, INTA223) = _0F_MTR_PRIORITY_LEVEL15;
fff80f43:	ce 7b df 03                   	mov.b	991[r7], r11
fff80f47:	65 fb                         	or	#15, r11
fff80f49:	cb 7b df 03                   	mov.b	r11, 991[r7]
    MTU3.TIER.BYTE = 0x00U;
fff80f4d:	3c 38 00                      	mov.b	#0, 8[r3]
    MTU4.TIER.BYTE = 0x00U;
fff80f50:	3c 39 00                      	mov.b	#0, 9[r3]
    MTU.TITCR1A.BIT.T3AEN = 0U;
fff80f53:	cd 5b 26                      	mov.b	38[r5], r11
fff80f56:	7a 7b                         	bclr	#7, r11
fff80f58:	c7 5b 26                      	mov.b	r11, 38[r5]
    MTU.TITCR1A.BIT.T4VEN = 0U;
fff80f5b:	f1 5b 26                      	bclr	#3, 38[r5].b
    MTU3.TCR.BYTE = _00_MTR_MTU_PCLK_1 | _00_MTR_MTU_CKEG_RISE;
fff80f5e:	f8 34 00                      	mov.b	#0, [r3]
    MTU4.TCR.BYTE = _00_MTR_MTU_PCLK_1 | _00_MTR_MTU_CKEG_RISE;
fff80f61:	3c 31 00                      	mov.b	#0, 1[r3]
    MTU3.TCR2.BYTE = _00_MTR_MTU_PCLK_1;
fff80f64:	f9 34 4c 00                   	mov.b	#0, 76[r3]
    MTU4.TCR2.BYTE = _00_MTR_MTU_PCLK_1;
fff80f68:	f9 34 4d 00                   	mov.b	#0, 77[r3]
    MTU3.TCNT = _07D0_3TCNT_VALUE;
fff80f6c:	f9 39 08 d0 07                	mov.w	#0x7d0, 16[r3]
    MTU4.TCNT = 0x0000U;
fff80f71:	3d 39 00                      	mov.w	#0, 18[r3]
    MTU.TSYRA.BIT.SYNC3 = 0U;
fff80f74:	f1 5e 77                      	bclr	#6, 119[r5].b
    MTU.TSYRA.BIT.SYNC4 = 0U;
fff80f77:	cd 5b 77                      	mov.b	119[r5], r11
fff80f7a:	7a 7b                         	bclr	#7, r11
fff80f7c:	c7 5b 77                      	mov.b	r11, 119[r5]
    MTU3.TGRB = _1770_3TGRB_VALUE;
fff80f7f:	f9 39 0d 70 17                	mov.w	#0x1770, 26[r3]
    MTU3.TGRD = _1770_3TGRB_VALUE;
fff80f84:	f9 39 13 70 17                	mov.w	#0x1770, 38[r3]
    MTU4.TGRA = _1770_4TGRA_VALUE;
fff80f89:	f9 39 0e 70 17                	mov.w	#0x1770, 28[r3]
    MTU4.TGRC = _1770_4TGRA_VALUE;
fff80f8e:	f9 39 14 70 17                	mov.w	#0x1770, 40[r3]
    MTU4.TGRB = _1770_4TGRB_VALUE;
fff80f93:	f9 39 0f 70 17                	mov.w	#0x1770, 30[r3]
    MTU4.TGRD = _1770_4TGRB_VALUE;
fff80f98:	f9 39 15 70 17                	mov.w	#0x1770, 42[r3]
    MTU.TDERA.BIT.TDER = 1U;
fff80f9d:	f1 50 2a                      	bset	#0, 42[r5].b
    MTU.TDDRA = _07D0_TDDRA_VALUE;
fff80fa0:	f9 59 06 d0 07                	mov.w	#0x7d0, 12[r5]
    MTU.TCDRA = _2710_TCDRA_VALUE;
fff80fa5:	f9 59 05 10 27                	mov.w	#0x2710, 10[r5]
    MTU.TCBRA = _2710_TCDRA_VALUE;
fff80faa:	f9 59 0c 10 27                	mov.w	#0x2710, 24[r5]
    MTU3.TGRA = _2EE0_SUM_VALUE;
fff80faf:	f9 39 0c e0 2e                	mov.w	#0x2ee0, 24[r3]
    MTU3.TGRC = _2EE0_SUM_VALUE;
fff80fb4:	f9 39 12 e0 2e                	mov.w	#0x2ee0, 36[r3]
    MTU.TOCR1A.BYTE = _00_MTR_MTU_PSYE_DISABLE | _08_MTR_MTU_TOCL_DISABLE | _04_MTR_MTU_TOCS_TOCR2;
fff80fb9:	3c 54 0c                      	mov.b	#12, 4[r5]
    MTU.TOCR2A.BYTE = _00_MTR_MTU_OLS3N_HL | _00_MTR_MTU_OLS3P_HL | _00_MTR_MTU_OLS2N_HL | _00_MTR_MTU_OLS2P_HL | 
fff80fbc:	3c 55 00                      	mov.b	#0, 5[r5]
    MTU.TOLBRA.BYTE = MTU.TOCR2A.BYTE & 0x3FU;
fff80fbf:	cd 5b 05                      	mov.b	5[r5], r11
fff80fc2:	75 2b 3f                      	and	#63, r11
fff80fc5:	c7 5b 2c                      	mov.b	r11, 44[r5]
    MTU3.TIER.BYTE = _01_MTR_MTU_TGIEA_ENABLE;
fff80fc8:	3c 38 01                      	mov.b	#1, 8[r3]
    MTU4.TADCORA = _0002_MTR_MTU_TADCORA_VALUE;
fff80fcb:	f9 35 22 02                   	mov.w	#2, 68[r3]
    MTU4.TADCOBRA = _0002_MTR_MTU_TADCORA_VALUE;
fff80fcf:	f9 35 24 02                   	mov.w	#2, 72[r3]
    MTU4.TADCR.WORD = _0000_MTR_MTU_ADSYNCH_DISABLE | _0080_MTR_MTU_UTAE_ENABLE;
fff80fd3:	f9 39 20 80 00                	mov.w	#128, 64[r3]
    MTU.TITMRA.BIT.TITM = 0U;
fff80fd8:	f1 58 30                      	bclr	#0, 48[r5].b
    MTU.TITCR1A.BYTE = _00_MTR_MTU_INT_SKIP_DISABLE << 4U | _00_MTR_MTU_INT_SKIP_DISABLE;
fff80fdb:	f9 54 26 00                   	mov.b	#0, 38[r5]
    MTU3.TMDR1.BYTE = _0E_MTR_MTU_CMT2 | _10_MTR_MTU_BFA_BUFFER | _20_MTR_MTU_BFB_BUFFER;
fff80fdf:	3c 32 3e                      	mov.b	#62, 2[r3]
    MTU.TOERA.BYTE = 0xC0U;
fff80fe2:	f8 54 c0                      	mov.b	#192, [r5]
    MTU3.TIORH.BYTE = 0x00U;
fff80fe5:	3c 34 00                      	mov.b	#0, 4[r3]
    MTU3.TIORL.BYTE = 0x00U;
fff80fe8:	3c 35 00                      	mov.b	#0, 5[r3]
    MTU4.TIORH.BYTE = 0x00U;
fff80feb:	3c 36 00                      	mov.b	#0, 6[r3]
    MTU4.TIORL.BYTE = 0x00U;
fff80fee:	3c 37 00                      	mov.b	#0, 7[r3]
    MTU.TRWERA.BIT.RWE = 0U;
fff80ff1:	f1 58 7a                      	bclr	#0, 122[r5].b
    PORT1.PODR.BIT.B2 = 1U; //Active Low
fff80ff4:	f1 f2 20                      	bset	#2, 32[r15].b
    PORT1.PDR.BIT.B2 = 1U;
fff80ff7:	f0 f2                         	bset	#2, [r15].b
    PORT1.PMR.BIT.B2 = 0U;
fff80ff9:	f1 fa 60                      	bclr	#2, 96[r15].b
    MPC.P12PFS.BIT.PSEL = 0x01U;
fff80ffc:	cd 45 4a                      	mov.b	74[r4], r5
fff80fff:	75 25 c0                      	and	#-64, r5
fff81002:	78 05                         	bset	#0, r5
fff81004:	c7 45 4a                      	mov.b	r5, 74[r4]
    PORT7.PODR.BIT.B4 = 1U; //Active Low
fff81007:	f1 e4 20                      	bset	#4, 32[r14].b
    PORT7.PDR.BIT.B4 = 1U;
fff8100a:	f0 e4                         	bset	#4, [r14].b
    PORT7.PMR.BIT.B4 = 0U;
fff8100c:	f1 ec 60                      	bclr	#4, 96[r14].b
    MPC.P74PFS.BIT.PSEL = 0x01U;
fff8100f:	cd 45 7c                      	mov.b	124[r4], r5
fff81012:	75 25 c0                      	and	#-64, r5
fff81015:	78 05                         	bset	#0, r5
fff81017:	c7 45 7c                      	mov.b	r5, 124[r4]
    PORT1.PODR.BIT.B3 = 1U; //Active Low
fff8101a:	f1 f3 20                      	bset	#3, 32[r15].b
    PORT1.PDR.BIT.B3 = 1U;
fff8101d:	f0 f3                         	bset	#3, [r15].b
    PORT1.PMR.BIT.B3 = 0U;
fff8101f:	f1 fb 60                      	bclr	#3, 96[r15].b
    MPC.P13PFS.BIT.PSEL = 0x01U;
fff81022:	cd 45 4b                      	mov.b	75[r4], r5
fff81025:	75 25 c0                      	and	#-64, r5
fff81028:	78 05                         	bset	#0, r5
fff8102a:	c7 45 4b                      	mov.b	r5, 75[r4]
    PORT1.PODR.BIT.B4 = 1U; //Active Low
fff8102d:	f1 f4 20                      	bset	#4, 32[r15].b
    PORT1.PDR.BIT.B4 = 1U;
fff81030:	f0 f4                         	bset	#4, [r15].b
    PORT1.PMR.BIT.B4 = 0U;
fff81032:	f1 fc 60                      	bclr	#4, 96[r15].b
    MPC.P14PFS.BIT.PSEL = 0x01U;
fff81035:	cd 45 4c                      	mov.b	76[r4], r5
fff81038:	75 25 c0                      	and	#-64, r5
fff8103b:	78 05                         	bset	#0, r5
fff8103d:	c7 45 4c                      	mov.b	r5, 76[r4]
    PORT7.PODR.BIT.B5 = 1U; //Active Low
fff81040:	f1 e5 20                      	bset	#5, 32[r14].b
    PORT7.PDR.BIT.B5 = 1U;
fff81043:	f0 e5                         	bset	#5, [r14].b
    PORT7.PMR.BIT.B5 = 0U;
fff81045:	f1 ed 60                      	bclr	#5, 96[r14].b
    MPC.P75PFS.BIT.PSEL = 0x01U;
fff81048:	cd 45 7d                      	mov.b	125[r4], r5
fff8104b:	75 25 c0                      	and	#-64, r5
fff8104e:	78 05                         	bset	#0, r5
fff81050:	c7 45 7d                      	mov.b	r5, 125[r4]
    PORT7.PODR.BIT.B6 = 1U; //Active Low
fff81053:	f1 e6 20                      	bset	#6, 32[r14].b
    PORT7.PDR.BIT.B6 = 1U;
fff81056:	f0 e6                         	bset	#6, [r14].b
    PORT7.PMR.BIT.B6 = 0U;
fff81058:	f1 ee 60                      	bclr	#6, 96[r14].b
    MPC.P76PFS.BIT.PSEL = 0x01U;
fff8105b:	cd 45 7e                      	mov.b	126[r4], r5
fff8105e:	75 25 c0                      	and	#-64, r5
fff81061:	78 05                         	bset	#0, r5
fff81063:	c7 45 7e                      	mov.b	r5, 126[r4]
    MSTP(S12AD) = 0U;
fff81066:	ed a5 04                      	mov.l	16[r10], r5
fff81069:	7b 15                         	bclr	#17, r5
fff8106b:	e7 a5 04                      	mov.l	r5, 16[r10]
    S12AD.ADCSR.BIT.ADIE = 0U;
fff8106e:	dc 25                         	mov.w	[r2], r5
fff81070:	7a c5                         	bclr	#12, r5
fff81072:	d3 25                         	mov.w	r5, [r2]
    IEN(S12AD, S12ADI) = 0U;
fff81074:	f2 78 10 02                   	bclr	#0, 528[r7].b
    S12AD.ADCSR.WORD = _0000_MTR_AD_SINGLE_SCAN_MODE;
fff81078:	f8 25 00                      	mov.w	#0, [r2]
    S12AD.ADSTRGR.WORD = _0900_MTR_AD_TRSA_TRG4AN;
fff8107b:	f9 29 08 00 09                	mov.w	#0x900, 16[r2]
    S12AD.ADANSA0.WORD = _0001_MTR_AD_AN000_USED | _0002_MTR_AD_AN001_USED | _0004_MTR_AD_AN002_USED | 
fff81080:	3d 22 0f                      	mov.w	#15, 4[r2]
    S12AD.ADSHCR.BIT.SHANS = _01_MTR_AD_DSH_AN000_SELECT | _02_MTR_AD_DSH_AN001_SELECT | _04_MTR_AD_DSH_AN002_SELECT;
fff81083:	dd 25 33                      	mov.w	102[r2], r5
fff81086:	76 35 00 07                   	or	#0x700, r5
fff8108a:	d7 25 33                      	mov.w	r5, 102[r2]
    S12AD.ADPGADCR0.BIT.P000DEN = 0U;
fff8108d:	dd 25 d8                      	mov.w	432[r2], r5
fff81090:	7a 35                         	bclr	#3, r5
fff81092:	d7 25 d8                      	mov.w	r5, 432[r2]
    S12AD.ADPGACR.BIT.P000CR = 1U;
fff81095:	dd 25 d0                      	mov.w	416[r2], r5
fff81098:	75 25 f0                      	and	#-16, r5
fff8109b:	78 05                         	bset	#0, r5
fff8109d:	d7 25 d0                      	mov.w	r5, 416[r2]
    S12AD.ADPGADCR0.BIT.P001DEN = 0U;
fff810a0:	dd 25 d8                      	mov.w	432[r2], r5
fff810a3:	7a 75                         	bclr	#7, r5
fff810a5:	d7 25 d8                      	mov.w	r5, 432[r2]
    S12AD.ADPGACR.BIT.P001CR = 1U;
fff810a8:	dd 25 d0                      	mov.w	416[r2], r5
fff810ab:	76 25 0f ff                   	and	#-241, r5
fff810af:	78 45                         	bset	#4, r5
fff810b1:	d7 25 d0                      	mov.w	r5, 416[r2]
    S12AD.ADPGADCR0.BIT.P002DEN = 0U;
fff810b4:	dd 25 d8                      	mov.w	432[r2], r5
fff810b7:	7a b5                         	bclr	#11, r5
fff810b9:	d7 25 d8                      	mov.w	r5, 432[r2]
    S12AD.ADPGACR.BIT.P002CR = 1U;
fff810bc:	dd 25 d0                      	mov.w	416[r2], r5
fff810bf:	76 25 ff f0                   	and	#0xfffff0ff, r5
fff810c3:	78 85                         	bset	#8, r5
fff810c5:	d7 25 d0                      	mov.w	r5, 416[r2]
    S12AD.ADCSR.WORD |= _1000_MTR_AD_SCAN_END_INTERRUPT_ENABLE;
fff810c8:	dc 25                         	mov.w	[r2], r5
fff810ca:	78 c5                         	bset	#12, r5
fff810cc:	d3 25                         	mov.w	r5, [r2]
    IPR(S12AD, S12ADI) = _0F_MTR_PRIORITY_LEVEL15;
fff810ce:	ce 75 80 03                   	mov.b	896[r7], r5
fff810d2:	65 f5                         	or	#15, r5
fff810d4:	cb 75 80 03                   	mov.b	r5, 896[r7]
    MSTP(S12AD1) = 0U;
fff810d8:	ed a7 04                      	mov.l	16[r10], r7
fff810db:	7b 07                         	bclr	#16, r7
fff810dd:	e7 a7 04                      	mov.l	r7, 16[r10]
    S12AD1.ADCSR.BIT.ADIE = 0U;
fff810e0:	dc 17                         	mov.w	[r1], r7
fff810e2:	7a c7                         	bclr	#12, r7
fff810e4:	d3 17                         	mov.w	r7, [r1]
    S12AD1.ADCSR.WORD = _0000_MTR_AD_SINGLE_SCAN_MODE;
fff810e6:	f8 15 00                      	mov.w	#0, [r1]
    S12AD1.ADSTRGR.WORD = _0900_MTR_AD_TRSA_TRG4AN;
fff810e9:	f9 19 08 00 09                	mov.w	#0x900, 16[r1]
    S12AD1.ADANSA0.WORD = _0001_MTR_AD_AN100_USED | _0002_MTR_AD_AN101_USED | _0004_MTR_AD_AN102_USED;
fff810ee:	3d 12 07                      	mov.w	#7, 4[r1]
    S12AD1.ADSHCR.BIT.SHANS = _01_MTR_AD_DSH_AN100_SELECT | _02_MTR_AD_DSH_AN101_SELECT | _04_MTR_AD_DSH_AN102_SELECT;
fff810f1:	dd 15 33                      	mov.w	102[r1], r5
fff810f4:	76 35 00 07                   	or	#0x700, r5
fff810f8:	d7 15 33                      	mov.w	r5, 102[r1]
    S12AD1.ADPGADCR0.BIT.P100DEN = 0U;
fff810fb:	dd 17 d8                      	mov.w	432[r1], r7
fff810fe:	7a 37                         	bclr	#3, r7
fff81100:	d7 17 d8                      	mov.w	r7, 432[r1]
    S12AD1.ADPGACR.BIT.P100CR = 1U;
fff81103:	dd 15 d0                      	mov.w	416[r1], r5
fff81106:	75 25 f0                      	and	#-16, r5
fff81109:	78 05                         	bset	#0, r5
fff8110b:	d7 15 d0                      	mov.w	r5, 416[r1]
    S12AD1.ADPGADCR0.BIT.P101DEN = 0U;
fff8110e:	dd 17 d8                      	mov.w	432[r1], r7
fff81111:	7a 77                         	bclr	#7, r7
fff81113:	d7 17 d8                      	mov.w	r7, 432[r1]
    S12AD1.ADPGACR.BIT.P101CR = 1U;
fff81116:	dd 15 d0                      	mov.w	416[r1], r5
fff81119:	76 25 0f ff                   	and	#-241, r5
fff8111d:	78 45                         	bset	#4, r5
fff8111f:	d7 15 d0                      	mov.w	r5, 416[r1]
    S12AD1.ADPGADCR0.BIT.P102DEN = 0U;
fff81122:	dd 17 d8                      	mov.w	432[r1], r7
fff81125:	7a b7                         	bclr	#11, r7
fff81127:	d7 17 d8                      	mov.w	r7, 432[r1]
    S12AD1.ADPGACR.BIT.P102CR = 1U;
fff8112a:	dd 15 d0                      	mov.w	416[r1], r5
fff8112d:	76 25 ff f0                   	and	#0xfffff0ff, r5
fff81131:	78 85                         	bset	#8, r5
fff81133:	d7 15 d0                      	mov.w	r5, 416[r1]
    MPC.P40PFS.BIT.ASEL = 1U;
fff81136:	cd 47 60                      	mov.b	96[r4], r7
fff81139:	78 77                         	bset	#7, r7
fff8113b:	c7 47 60                      	mov.b	r7, 96[r4]
    MPC.P41PFS.BIT.ASEL = 1U;
fff8113e:	cd 47 61                      	mov.b	97[r4], r7
fff81141:	78 77                         	bset	#7, r7
fff81143:	c7 47 61                      	mov.b	r7, 97[r4]
    MPC.P42PFS.BIT.ASEL = 1U;
fff81146:	cd 47 62                      	mov.b	98[r4], r7
fff81149:	78 77                         	bset	#7, r7
fff8114b:	c7 47 62                      	mov.b	r7, 98[r4]
    PORT4.PDR.BIT.B3 = 0U;
fff8114e:	f0 6b                         	bclr	#3, [r6].b
    MPC.P43PFS.BIT.ASEL = 1U;
fff81150:	cd 47 63                      	mov.b	99[r4], r7
fff81153:	78 77                         	bset	#7, r7
fff81155:	c7 47 63                      	mov.b	r7, 99[r4]
    //Init AN100
    MPC.P44PFS.BIT.ASEL = 1U;
fff81158:	cd 47 64                      	mov.b	100[r4], r7
fff8115b:	78 77                         	bset	#7, r7
fff8115d:	c7 47 64                      	mov.b	r7, 100[r4]
    //Init AN101
    MPC.P45PFS.BIT.ASEL = 1U;
fff81160:	cd 47 65                      	mov.b	101[r4], r7
fff81163:	78 77                         	bset	#7, r7
fff81165:	c7 47 65                      	mov.b	r7, 101[r4]
    //Init AN102
    MPC.P46PFS.BIT.ASEL = 1U;
fff81168:	cd 47 66                      	mov.b	102[r4], r7
fff8116b:	78 77                         	bset	#7, r7
fff8116d:	c7 47 66                      	mov.b	r7, 102[r4]

    R_Config_MTU3_MTU4_Create_UserInit();
}
fff81170:	6f 6b                         	popm	r6-r11
    R_Config_MTU3_MTU4_Create_UserInit();
fff81172:	04 04 00 00                   	bra.a	fff81176 <_Reset_Vector+0xfff8117a>

fff81176 <_R_Config_MTU3_MTU4_Create_UserInit>:

void R_Config_MTU3_MTU4_Create_UserInit(void)
{
    /* Start user code for user init. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
fff81176:	02                            	rts

fff81177 <_main>:

void main(void);

void main(void)
{
}
fff81177:	02                            	rts

fff81178 <_CrestFunction>:
#include "r_smc_entry.h"

void CrestFunction(void)
{
}
fff81178:	02                            	rts

fff81179 <_AdFunction>:
fff81179:	02                            	rts
fff8117a:	00                            	brk
fff8117b:	00                            	brk
fff8117c:	00                            	brk
fff8117d:	00                            	brk
	...

fff81180 <__group_bl0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_bl0_handler_isr, VECT(ICU,GROUPBL0))
fff81180:	7e a1                         	push.l	r1
fff81182:	fd 6a 01                      	mvfc	psw, r1
fff81185:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
fff8118a:	61 81                         	cmp	#8, r1
fff8118c:	22 05                         	bc.b	fff81191 <_Reset_Vector+0xfff81195>
fff8118e:	75 70 08                      	mvtipl	#8
fff81191:	7f a8                         	setpsw	i
fff81193:	fd 6a 01                      	mvfc	psw, r1
fff81196:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
fff8119b:	fd 76 c1 00                   	save	r1
fff8119f:	ef 16                         	mov.l	r1, r6
fff811a1:	39 0b 00                      	bsr.w	fff811ac <_Reset_Vector+0xfff811b0>
fff811a4:	fd 76 d6 00                   	rstr	r6
fff811a8:	7e b1                         	pop	r1
fff811aa:	7f 95                         	rte

fff811ac <_group_bl0_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_bl0_handler_isr (void)
{
    /* BL0 IS3 */
    if (1 == ICU.GRPBL0.BIT.IS3)
fff811ac:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff811b1:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff811b5:	7c 35                         	btst	#3, r5
fff811b7:	3b f0 00                      	bne.w	fff812a7 <_Reset_Vector+0xfff812ab>
        /* BSP_INT_SRC_BL0_SCI1_ERI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_ERI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS2 */
    if (1 == ICU.GRPBL0.BIT.IS2)
fff811ba:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff811bf:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff811c3:	7c 25                         	btst	#2, r5
fff811c5:	3b 03 01                      	bne.w	fff812c8 <_Reset_Vector+0xfff812cc>
        /* BSP_INT_SRC_BL0_SCI1_TEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS11 */
    if (1 == ICU.GRPBL0.BIT.IS11)
fff811c8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff811cd:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff811d1:	7c b5                         	btst	#11, r5
fff811d3:	3b 15 01                      	bne.w	fff812e8 <_Reset_Vector+0xfff812ec>
fff811d6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI5_ERI5 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_ERI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS10 */
    if (1 == ICU.GRPBL0.BIT.IS10)
fff811d8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff811dd:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff811e1:	7c a5                         	btst	#10, r5
fff811e3:	3b 25 01                      	bne.w	fff81308 <_Reset_Vector+0xfff8130c>
fff811e6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI5_TEI5 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_TEI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS13 */
    if (1 == ICU.GRPBL0.BIT.IS13)
fff811e8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff811ed:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff811f1:	7c d5                         	btst	#13, r5
fff811f3:	3b 35 01                      	bne.w	fff81328 <_Reset_Vector+0xfff8132c>
fff811f6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI6_ERI6 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_ERI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS12 */
    if (1 == ICU.GRPBL0.BIT.IS12)
fff811f8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff811fd:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81201:	7c c5                         	btst	#12, r5
fff81203:	3b 45 01                      	bne.w	fff81348 <_Reset_Vector+0xfff8134c>
fff81206:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI6_TEI6 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_TEI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS17 */
    if (1 == ICU.GRPBL0.BIT.IS17)
fff81208:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8120d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81211:	7d 15                         	btst	#17, r5
fff81213:	3b 55 01                      	bne.w	fff81368 <_Reset_Vector+0xfff8136c>
fff81216:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_ERI12 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_ERI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS16 */
    if (1 == ICU.GRPBL0.BIT.IS16)
fff81218:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8121d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81221:	7d 05                         	btst	#16, r5
fff81223:	3b 65 01                      	bne.w	fff81388 <_Reset_Vector+0xfff8138c>
fff81226:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_TEI12 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_TEI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS118 */
    if (1 == ICU.GRPBL0.BIT.IS18)
fff81228:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8122d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81231:	7d 25                         	btst	#18, r5
fff81233:	3b 75 01                      	bne.w	fff813a8 <_Reset_Vector+0xfff813ac>
fff81236:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS19 */
    if (1 == ICU.GRPBL0.BIT.IS19)
fff81238:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8123d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81241:	7d 35                         	btst	#19, r5
fff81243:	3b 85 01                      	bne.w	fff813c8 <_Reset_Vector+0xfff813cc>
fff81246:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS20 */
    if (1 == ICU.GRPBL0.BIT.IS20)
fff81248:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8124d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81251:	7d 45                         	btst	#20, r5
fff81253:	3b 95 01                      	bne.w	fff813e8 <_Reset_Vector+0xfff813ec>
fff81256:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS21 */
    if (1 == ICU.GRPBL0.BIT.IS21)
fff81258:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8125d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81261:	7d 55                         	btst	#21, r5
fff81263:	3b a5 01                      	bne.w	fff81408 <_Reset_Vector+0xfff8140c>
fff81266:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS26 */
    if (1 == ICU.GRPBL0.BIT.IS26)
fff81268:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8126d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81271:	7d a5                         	btst	#26, r5
fff81273:	3b b5 01                      	bne.w	fff81428 <_Reset_Vector+0xfff8142c>
fff81276:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_FERRI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_FERRI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS27 */
    if (1 == ICU.GRPBL0.BIT.IS27)
fff81278:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8127d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81281:	7d b5                         	btst	#27, r5
fff81283:	3b c5 01                      	bne.w	fff81448 <_Reset_Vector+0xfff8144c>
fff81286:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_MENDI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_MENDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS28 */
    if (1 == ICU.GRPBL0.BIT.IS28)
fff81288:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8128d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81291:	7d c5                         	btst	#28, r5
fff81293:	3b d5 01                      	bne.w	fff81468 <_Reset_Vector+0xfff8146c>
fff81296:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_OVFI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_OVFI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS29 */
    if (1 == ICU.GRPBL0.BIT.IS29)
fff81298:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8129d:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff812a1:	7d d5                         	btst	#29, r5
fff812a3:	3b e5 01                      	bne.w	fff81488 <_Reset_Vector+0xfff8148c>
    {
        /* BSP_INT_SRC_BL0_DOC_DOPCI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_DOC_DOPCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_bl0_handler_isr() */
fff812a6:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_ERI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff812a7:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff812ad:	66 02                         	mov.l	#0, r2
fff812af:	75 41 15                      	mov.l	#21, r1
fff812b2:	05 7e f8 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff812b6 <.LVL0>:
    if (1 == ICU.GRPBL0.BIT.IS2)
fff812b6:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff812bb:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff812bf:	7c 25                         	btst	#2, r5
fff812c1:	3a 07 ff                      	beq.w	fff811c8 <_Reset_Vector+0xfff811cc>
fff812c4:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff812c8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff812ce:	66 02                         	mov.l	#0, r2
fff812d0:	75 41 14                      	mov.l	#20, r1
fff812d3:	05 5d f8 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff812d7 <.LVL1>:
    if (1 == ICU.GRPBL0.BIT.IS11)
fff812d7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff812dc:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff812e0:	7c b5                         	btst	#11, r5
fff812e2:	3a f6 fe                      	beq.w	fff811d8 <_Reset_Vector+0xfff811dc>
fff812e5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_ERI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff812e8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff812ee:	66 02                         	mov.l	#0, r2
fff812f0:	75 41 17                      	mov.l	#23, r1
fff812f3:	05 3d f8 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff812f7 <.LVL2>:
    if (1 == ICU.GRPBL0.BIT.IS10)
fff812f7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff812fc:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81300:	7c a5                         	btst	#10, r5
fff81302:	3a e6 fe                      	beq.w	fff811e8 <_Reset_Vector+0xfff811ec>
fff81305:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_TEI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81308:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8130e:	66 02                         	mov.l	#0, r2
fff81310:	75 41 16                      	mov.l	#22, r1
fff81313:	05 1d f8 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81317 <.LVL3>:
    if (1 == ICU.GRPBL0.BIT.IS13)
fff81317:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8131c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81320:	7c d5                         	btst	#13, r5
fff81322:	3a d6 fe                      	beq.w	fff811f8 <_Reset_Vector+0xfff811fc>
fff81325:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_ERI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81328:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8132e:	66 02                         	mov.l	#0, r2
fff81330:	75 41 19                      	mov.l	#25, r1
fff81333:	05 fd f7 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81337 <.LVL4>:
    if (1 == ICU.GRPBL0.BIT.IS12)
fff81337:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8133c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81340:	7c c5                         	btst	#12, r5
fff81342:	3a c6 fe                      	beq.w	fff81208 <_Reset_Vector+0xfff8120c>
fff81345:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_TEI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81348:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8134e:	66 02                         	mov.l	#0, r2
fff81350:	75 41 18                      	mov.l	#24, r1
fff81353:	05 dd f7 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81357 <.LVL5>:
    if (1 == ICU.GRPBL0.BIT.IS17)
fff81357:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8135c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81360:	7d 15                         	btst	#17, r5
fff81362:	3a b6 fe                      	beq.w	fff81218 <_Reset_Vector+0xfff8121c>
fff81365:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_ERI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81368:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8136e:	66 02                         	mov.l	#0, r2
fff81370:	75 41 1b                      	mov.l	#27, r1
fff81373:	05 bd f7 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81377 <.LVL6>:
    if (1 == ICU.GRPBL0.BIT.IS16)
fff81377:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8137c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81380:	7d 05                         	btst	#16, r5
fff81382:	3a a6 fe                      	beq.w	fff81228 <_Reset_Vector+0xfff8122c>
fff81385:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_TEI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81388:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8138e:	66 02                         	mov.l	#0, r2
fff81390:	75 41 1a                      	mov.l	#26, r1
fff81393:	05 9d f7 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81397 <.LVL7>:
    if (1 == ICU.GRPBL0.BIT.IS18)
fff81397:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8139c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff813a0:	7d 25                         	btst	#18, r5
fff813a2:	3a 96 fe                      	beq.w	fff81238 <_Reset_Vector+0xfff8123c>
fff813a5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff813a8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff813ae:	66 02                         	mov.l	#0, r2
fff813b0:	75 41 1c                      	mov.l	#28, r1
fff813b3:	05 7d f7 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff813b7 <.LVL8>:
    if (1 == ICU.GRPBL0.BIT.IS19)
fff813b7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff813bc:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff813c0:	7d 35                         	btst	#19, r5
fff813c2:	3a 86 fe                      	beq.w	fff81248 <_Reset_Vector+0xfff8124c>
fff813c5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff813c8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff813ce:	66 02                         	mov.l	#0, r2
fff813d0:	75 41 1d                      	mov.l	#29, r1
fff813d3:	05 5d f7 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff813d7 <.LVL9>:
    if (1 == ICU.GRPBL0.BIT.IS20)
fff813d7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff813dc:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff813e0:	7d 45                         	btst	#20, r5
fff813e2:	3a 76 fe                      	beq.w	fff81258 <_Reset_Vector+0xfff8125c>
fff813e5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff813e8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff813ee:	66 02                         	mov.l	#0, r2
fff813f0:	75 41 1e                      	mov.l	#30, r1
fff813f3:	05 3d f7 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff813f7 <.LVL10>:
    if (1 == ICU.GRPBL0.BIT.IS21)
fff813f7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff813fc:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81400:	7d 55                         	btst	#21, r5
fff81402:	3a 66 fe                      	beq.w	fff81268 <_Reset_Vector+0xfff8126c>
fff81405:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81408:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8140e:	66 02                         	mov.l	#0, r2
fff81410:	75 41 1f                      	mov.l	#31, r1
fff81413:	05 1d f7 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81417 <.LVL11>:
    if (1 == ICU.GRPBL0.BIT.IS26)
fff81417:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8141c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81420:	7d a5                         	btst	#26, r5
fff81422:	3a 56 fe                      	beq.w	fff81278 <_Reset_Vector+0xfff8127c>
fff81425:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_FERRI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81428:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8142e:	66 02                         	mov.l	#0, r2
fff81430:	75 41 20                      	mov.l	#32, r1
fff81433:	05 fd f6 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81437 <.LVL12>:
    if (1 == ICU.GRPBL0.BIT.IS27)
fff81437:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8143c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81440:	7d b5                         	btst	#27, r5
fff81442:	3a 46 fe                      	beq.w	fff81288 <_Reset_Vector+0xfff8128c>
fff81445:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_MENDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81448:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8144e:	66 02                         	mov.l	#0, r2
fff81450:	75 41 21                      	mov.l	#33, r1
fff81453:	05 dd f6 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81457 <.LVL13>:
    if (1 == ICU.GRPBL0.BIT.IS28)
fff81457:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8145c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81460:	7d c5                         	btst	#28, r5
fff81462:	3a 36 fe                      	beq.w	fff81298 <_Reset_Vector+0xfff8129c>
fff81465:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_OVFI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81468:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8146e:	66 02                         	mov.l	#0, r2
fff81470:	75 41 22                      	mov.l	#34, r1
fff81473:	05 bd f6 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81477 <.LVL14>:
    if (1 == ICU.GRPBL0.BIT.IS29)
fff81477:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8147c:	ee 55 8c 01                   	mov.l	1584[r5], r5
fff81480:	7d d5                         	btst	#29, r5
fff81482:	3a 24 fe                      	beq.w	fff812a6 <_Reset_Vector+0xfff812aa>
fff81485:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_DOC_DOPCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81488:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8148e:	66 02                         	mov.l	#0, r2
fff81490:	75 41 23                      	mov.l	#35, r1
fff81493:	04 9d f6 ff                   	bra.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81497 <.LFE8>:
fff81497:	03                            	nop

fff81498 <__group_bl1_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_bl1_handler_isr, VECT(ICU,GROUPBL1))
fff81498:	7e a1                         	push.l	r1
fff8149a:	fd 6a 01                      	mvfc	psw, r1
fff8149d:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
fff814a2:	61 81                         	cmp	#8, r1
fff814a4:	22 05                         	bc.b	fff814a9 <_Reset_Vector+0xfff814ad>
fff814a6:	75 70 08                      	mvtipl	#8
fff814a9:	7f a8                         	setpsw	i
fff814ab:	fd 6a 01                      	mvfc	psw, r1
fff814ae:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
fff814b3:	fd 76 c1 00                   	save	r1
fff814b7:	ef 16                         	mov.l	r1, r6
fff814b9:	39 0b 00                      	bsr.w	fff814c4 <_Reset_Vector+0xfff814c8>
fff814bc:	fd 76 d6 00                   	rstr	r6
fff814c0:	7e b1                         	pop	r1
fff814c2:	7f 95                         	rte

fff814c4 <_group_bl1_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_bl1_handler_isr (void)
{
    /* BL1 IS0 */
    if (1 == ICU.GRPBL1.BIT.IS0)
fff814c4:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff814c9:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff814cd:	7c 05                         	btst	#0, r5
fff814cf:	3b 40 01                      	bne.w	fff8160f <_Reset_Vector+0xfff81613>
        /* BSP_INT_SRC_BL1_POEG_POEGGAI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POEG_POEGGAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS1 */
    if (1 == ICU.GRPBL1.BIT.IS1)
fff814d2:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff814d7:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff814db:	7c 15                         	btst	#1, r5
fff814dd:	3b 53 01                      	bne.w	fff81630 <_Reset_Vector+0xfff81634>
        /* BSP_INT_SRC_BL1_POEG_POEGGBI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POEG_POEGGBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS2 */
    if (1 == ICU.GRPBL1.BIT.IS2)
fff814e0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff814e5:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff814e9:	7c 25                         	btst	#2, r5
fff814eb:	3b 65 01                      	bne.w	fff81650 <_Reset_Vector+0xfff81654>
fff814ee:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POEG_POEGGCI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POEG_POEGGCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS3 */
    if (1 == ICU.GRPBL1.BIT.IS3)
fff814f0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff814f5:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff814f9:	7c 35                         	btst	#3, r5
fff814fb:	3b 75 01                      	bne.w	fff81670 <_Reset_Vector+0xfff81674>
fff814fe:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POEG_POEGGDI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POEG_POEGGDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS8 */
    if (1 == ICU.GRPBL1.BIT.IS8)
fff81500:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81505:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81509:	7c 85                         	btst	#8, r5
fff8150b:	3b 85 01                      	bne.w	fff81690 <_Reset_Vector+0xfff81694>
fff8150e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI5 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS9 */
    if (1 == ICU.GRPBL1.BIT.IS9)
fff81510:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81515:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81519:	7c 95                         	btst	#9, r5
fff8151b:	3b 95 01                      	bne.w	fff816b0 <_Reset_Vector+0xfff816b4>
fff8151e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS10 */
    if (1 == ICU.GRPBL1.BIT.IS10)
fff81520:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81525:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81529:	7c a5                         	btst	#10, r5
fff8152b:	3b a5 01                      	bne.w	fff816d0 <_Reset_Vector+0xfff816d4>
fff8152e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS11 */
    if (1 == ICU.GRPBL1.BIT.IS11)
fff81530:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81535:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81539:	7c b5                         	btst	#11, r5
fff8153b:	3b b5 01                      	bne.w	fff816f0 <_Reset_Vector+0xfff816f4>
fff8153e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS12 */
    if (1 == ICU.GRPBL1.BIT.IS12)
fff81540:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81545:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81549:	7c c5                         	btst	#12, r5
fff8154b:	3b c5 01                      	bne.w	fff81710 <_Reset_Vector+0xfff81714>
fff8154e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI4 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS14 */
    if (1 == ICU.GRPBL1.BIT.IS14)
fff81550:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81555:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81559:	7c e5                         	btst	#14, r5
fff8155b:	3b d5 01                      	bne.w	fff81730 <_Reset_Vector+0xfff81734>
fff8155e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC0_EEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_EEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS13 */
    if (1 == ICU.GRPBL1.BIT.IS13)
fff81560:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81565:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81569:	7c d5                         	btst	#13, r5
fff8156b:	3b e5 01                      	bne.w	fff81750 <_Reset_Vector+0xfff81754>
fff8156e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC0_TEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS18 */
    if (1 == ICU.GRPBL1.BIT.IS18)
fff81570:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81575:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81579:	7d 25                         	btst	#18, r5
fff8157b:	3b f5 01                      	bne.w	fff81770 <_Reset_Vector+0xfff81774>
fff8157e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD2_S12CMPAI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD2_S12CMPAI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS19 */
    if (1 == ICU.GRPBL1.BIT.IS19)
fff81580:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81585:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81589:	7d 35                         	btst	#19, r5
fff8158b:	3b 05 02                      	bne.w	fff81790 <_Reset_Vector+0xfff81794>
fff8158e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD2_S12CMPBI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD2_S12CMPBI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS20 */
    if (1 == ICU.GRPBL1.BIT.IS20)
fff81590:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81595:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81599:	7d 45                         	btst	#20, r5
fff8159b:	3b 15 02                      	bne.w	fff817b0 <_Reset_Vector+0xfff817b4>
fff8159e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD0_S12CMPAI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS21 */
    if (1 == ICU.GRPBL1.BIT.IS21)
fff815a0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff815a5:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff815a9:	7d 55                         	btst	#21, r5
fff815ab:	3b 25 02                      	bne.w	fff817d0 <_Reset_Vector+0xfff817d4>
fff815ae:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD0_S12CMPBI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS22 */
    if (1 == ICU.GRPBL1.BIT.IS22)
fff815b0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff815b5:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff815b9:	7d 65                         	btst	#22, r5
fff815bb:	3b 35 02                      	bne.w	fff817f0 <_Reset_Vector+0xfff817f4>
fff815be:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD1_S12CMPAI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPAI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS23 */
    if (1 == ICU.GRPBL1.BIT.IS23)
fff815c0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff815c5:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff815c9:	7d 75                         	btst	#23, r5
fff815cb:	3b 45 02                      	bne.w	fff81810 <_Reset_Vector+0xfff81814>
fff815ce:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD1_S12CMPBI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPBI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS25 */
    if (1 == ICU.GRPBL1.BIT.IS25)
fff815d0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff815d5:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff815d9:	7d 95                         	btst	#25, r5
fff815db:	3b 55 02                      	bne.w	fff81830 <_Reset_Vector+0xfff81834>
fff815de:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SCI8_ERI8 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI8_ERI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS24 */
    if (1 == ICU.GRPBL1.BIT.IS24)
fff815e0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff815e5:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff815e9:	7d 85                         	btst	#24, r5
fff815eb:	3b 65 02                      	bne.w	fff81850 <_Reset_Vector+0xfff81854>
fff815ee:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SCI8_TEI8 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI8_TEI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS27 */
    if (1 == ICU.GRPBL1.BIT.IS27)
fff815f0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff815f5:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff815f9:	7d b5                         	btst	#27, r5
fff815fb:	3b 75 02                      	bne.w	fff81870 <_Reset_Vector+0xfff81874>
fff815fe:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SCI9_ERI9 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI9_ERI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS26 */
    if (1 == ICU.GRPBL1.BIT.IS26)
fff81600:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81605:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81609:	7d a5                         	btst	#26, r5
fff8160b:	3b 85 02                      	bne.w	fff81890 <_Reset_Vector+0xfff81894>
    {
        /* BSP_INT_SRC_BL1_SCI9_TEI9 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI9_TEI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_bl1_handler_isr() */
fff8160e:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POEG_POEGGAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff8160f:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81615:	66 02                         	mov.l	#0, r2
fff81617:	75 41 25                      	mov.l	#37, r1
fff8161a:	05 16 f5 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8161e <.LVL16>:
    if (1 == ICU.GRPBL1.BIT.IS1)
fff8161e:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81623:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81627:	7c 15                         	btst	#1, r5
fff81629:	3a b7 fe                      	beq.w	fff814e0 <_Reset_Vector+0xfff814e4>
fff8162c:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POEG_POEGGBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81630:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81636:	66 02                         	mov.l	#0, r2
fff81638:	75 41 26                      	mov.l	#38, r1
fff8163b:	05 f5 f4 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8163f <.LVL17>:
    if (1 == ICU.GRPBL1.BIT.IS2)
fff8163f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81644:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81648:	7c 25                         	btst	#2, r5
fff8164a:	3a a6 fe                      	beq.w	fff814f0 <_Reset_Vector+0xfff814f4>
fff8164d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POEG_POEGGCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81650:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81656:	66 02                         	mov.l	#0, r2
fff81658:	75 41 27                      	mov.l	#39, r1
fff8165b:	05 d5 f4 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8165f <.LVL18>:
    if (1 == ICU.GRPBL1.BIT.IS3)
fff8165f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81664:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81668:	7c 35                         	btst	#3, r5
fff8166a:	3a 96 fe                      	beq.w	fff81500 <_Reset_Vector+0xfff81504>
fff8166d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POEG_POEGGDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81670:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81676:	66 02                         	mov.l	#0, r2
fff81678:	75 41 28                      	mov.l	#40, r1
fff8167b:	05 b5 f4 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8167f <.LVL19>:
    if (1 == ICU.GRPBL1.BIT.IS8)
fff8167f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81684:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81688:	7c 85                         	btst	#8, r5
fff8168a:	3a 86 fe                      	beq.w	fff81510 <_Reset_Vector+0xfff81514>
fff8168d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81690:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81696:	66 02                         	mov.l	#0, r2
fff81698:	75 41 29                      	mov.l	#41, r1
fff8169b:	05 95 f4 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8169f <.LVL20>:
    if (1 == ICU.GRPBL1.BIT.IS9)
fff8169f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff816a4:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff816a8:	7c 95                         	btst	#9, r5
fff816aa:	3a 76 fe                      	beq.w	fff81520 <_Reset_Vector+0xfff81524>
fff816ad:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff816b0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff816b6:	66 02                         	mov.l	#0, r2
fff816b8:	75 41 2a                      	mov.l	#42, r1
fff816bb:	05 75 f4 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff816bf <.LVL21>:
    if (1 == ICU.GRPBL1.BIT.IS10)
fff816bf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff816c4:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff816c8:	7c a5                         	btst	#10, r5
fff816ca:	3a 66 fe                      	beq.w	fff81530 <_Reset_Vector+0xfff81534>
fff816cd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff816d0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff816d6:	66 02                         	mov.l	#0, r2
fff816d8:	75 41 2b                      	mov.l	#43, r1
fff816db:	05 55 f4 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff816df <.LVL22>:
    if (1 == ICU.GRPBL1.BIT.IS11)
fff816df:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff816e4:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff816e8:	7c b5                         	btst	#11, r5
fff816ea:	3a 56 fe                      	beq.w	fff81540 <_Reset_Vector+0xfff81544>
fff816ed:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff816f0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff816f6:	66 02                         	mov.l	#0, r2
fff816f8:	75 41 2c                      	mov.l	#44, r1
fff816fb:	05 35 f4 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff816ff <.LVL23>:
    if (1 == ICU.GRPBL1.BIT.IS12)
fff816ff:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81704:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81708:	7c c5                         	btst	#12, r5
fff8170a:	3a 46 fe                      	beq.w	fff81550 <_Reset_Vector+0xfff81554>
fff8170d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81710:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81716:	66 02                         	mov.l	#0, r2
fff81718:	75 41 2d                      	mov.l	#45, r1
fff8171b:	05 15 f4 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8171f <.LVL24>:
    if (1 == ICU.GRPBL1.BIT.IS14)
fff8171f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81724:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81728:	7c e5                         	btst	#14, r5
fff8172a:	3a 36 fe                      	beq.w	fff81560 <_Reset_Vector+0xfff81564>
fff8172d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_EEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81730:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81736:	66 02                         	mov.l	#0, r2
fff81738:	75 41 2f                      	mov.l	#47, r1
fff8173b:	05 f5 f3 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8173f <.LVL25>:
    if (1 == ICU.GRPBL1.BIT.IS13)
fff8173f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81744:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81748:	7c d5                         	btst	#13, r5
fff8174a:	3a 26 fe                      	beq.w	fff81570 <_Reset_Vector+0xfff81574>
fff8174d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81750:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81756:	66 02                         	mov.l	#0, r2
fff81758:	75 41 2e                      	mov.l	#46, r1
fff8175b:	05 d5 f3 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8175f <.LVL26>:
    if (1 == ICU.GRPBL1.BIT.IS18)
fff8175f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81764:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81768:	7d 25                         	btst	#18, r5
fff8176a:	3a 16 fe                      	beq.w	fff81580 <_Reset_Vector+0xfff81584>
fff8176d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD2_S12CMPAI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81770:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81776:	66 02                         	mov.l	#0, r2
fff81778:	75 41 30                      	mov.l	#48, r1
fff8177b:	05 b5 f3 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8177f <.LVL27>:
    if (1 == ICU.GRPBL1.BIT.IS19)
fff8177f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81784:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81788:	7d 35                         	btst	#19, r5
fff8178a:	3a 06 fe                      	beq.w	fff81590 <_Reset_Vector+0xfff81594>
fff8178d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD2_S12CMPBI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81790:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81796:	66 02                         	mov.l	#0, r2
fff81798:	75 41 31                      	mov.l	#49, r1
fff8179b:	05 95 f3 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8179f <.LVL28>:
    if (1 == ICU.GRPBL1.BIT.IS20)
fff8179f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff817a4:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff817a8:	7d 45                         	btst	#20, r5
fff817aa:	3a f6 fd                      	beq.w	fff815a0 <_Reset_Vector+0xfff815a4>
fff817ad:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff817b0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff817b6:	66 02                         	mov.l	#0, r2
fff817b8:	75 41 32                      	mov.l	#50, r1
fff817bb:	05 75 f3 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff817bf <.LVL29>:
    if (1 == ICU.GRPBL1.BIT.IS21)
fff817bf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff817c4:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff817c8:	7d 55                         	btst	#21, r5
fff817ca:	3a e6 fd                      	beq.w	fff815b0 <_Reset_Vector+0xfff815b4>
fff817cd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff817d0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff817d6:	66 02                         	mov.l	#0, r2
fff817d8:	75 41 33                      	mov.l	#51, r1
fff817db:	05 55 f3 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff817df <.LVL30>:
    if (1 == ICU.GRPBL1.BIT.IS22)
fff817df:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff817e4:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff817e8:	7d 65                         	btst	#22, r5
fff817ea:	3a d6 fd                      	beq.w	fff815c0 <_Reset_Vector+0xfff815c4>
fff817ed:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPAI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff817f0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff817f6:	66 02                         	mov.l	#0, r2
fff817f8:	75 41 34                      	mov.l	#52, r1
fff817fb:	05 35 f3 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff817ff <.LVL31>:
    if (1 == ICU.GRPBL1.BIT.IS23)
fff817ff:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81804:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81808:	7d 75                         	btst	#23, r5
fff8180a:	3a c6 fd                      	beq.w	fff815d0 <_Reset_Vector+0xfff815d4>
fff8180d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPBI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81810:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81816:	66 02                         	mov.l	#0, r2
fff81818:	75 41 35                      	mov.l	#53, r1
fff8181b:	05 15 f3 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8181f <.LVL32>:
    if (1 == ICU.GRPBL1.BIT.IS25)
fff8181f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81824:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81828:	7d 95                         	btst	#25, r5
fff8182a:	3a b6 fd                      	beq.w	fff815e0 <_Reset_Vector+0xfff815e4>
fff8182d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI8_ERI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81830:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81836:	66 02                         	mov.l	#0, r2
fff81838:	75 41 37                      	mov.l	#55, r1
fff8183b:	05 f5 f2 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8183f <.LVL33>:
    if (1 == ICU.GRPBL1.BIT.IS24)
fff8183f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81844:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81848:	7d 85                         	btst	#24, r5
fff8184a:	3a a6 fd                      	beq.w	fff815f0 <_Reset_Vector+0xfff815f4>
fff8184d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI8_TEI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81850:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81856:	66 02                         	mov.l	#0, r2
fff81858:	75 41 36                      	mov.l	#54, r1
fff8185b:	05 d5 f2 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8185f <.LVL34>:
    if (1 == ICU.GRPBL1.BIT.IS27)
fff8185f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81864:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81868:	7d b5                         	btst	#27, r5
fff8186a:	3a 96 fd                      	beq.w	fff81600 <_Reset_Vector+0xfff81604>
fff8186d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI9_ERI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81870:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81876:	66 02                         	mov.l	#0, r2
fff81878:	75 41 39                      	mov.l	#57, r1
fff8187b:	05 b5 f2 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8187f <.LVL35>:
    if (1 == ICU.GRPBL1.BIT.IS26)
fff8187f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81884:	ee 55 8d 01                   	mov.l	1588[r5], r5
fff81888:	7d a5                         	btst	#26, r5
fff8188a:	3a 84 fd                      	beq.w	fff8160e <_Reset_Vector+0xfff81612>
fff8188d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI9_TEI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81890:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81896:	66 02                         	mov.l	#0, r2
fff81898:	75 41 38                      	mov.l	#56, r1
fff8189b:	04 95 f2 ff                   	bra.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8189f <.LFE9>:
fff8189f:	03                            	nop

fff818a0 <__group_al0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_al0_handler_isr, VECT(ICU,GROUPAL0))
fff818a0:	7e a1                         	push.l	r1
fff818a2:	fd 6a 01                      	mvfc	psw, r1
fff818a5:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
fff818aa:	61 81                         	cmp	#8, r1
fff818ac:	22 05                         	bc.b	fff818b1 <_Reset_Vector+0xfff818b5>
fff818ae:	75 70 08                      	mvtipl	#8
fff818b1:	7f a8                         	setpsw	i
fff818b3:	fd 6a 01                      	mvfc	psw, r1
fff818b6:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
fff818bb:	fd 76 c1 00                   	save	r1
fff818bf:	ef 16                         	mov.l	r1, r6
fff818c1:	39 0b 00                      	bsr.w	fff818cc <_Reset_Vector+0xfff818d0>
fff818c4:	fd 76 d6 00                   	rstr	r6
fff818c8:	7e b1                         	pop	r1
fff818ca:	7f 95                         	rte

fff818cc <_group_al0_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_al0_handler_isr (void)
{
    /* AL0 IS13 */
    if (1 == ICU.GRPAL0.BIT.IS13)
fff818cc:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff818d1:	ee 55 0c 02                   	mov.l	2096[r5], r5
fff818d5:	7c d5                         	btst	#13, r5
fff818d7:	21 2f                         	bne.b	fff81906 <_Reset_Vector+0xfff8190a>
        /* BSP_INT_SRC_AL0_SCI11_ERI11 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_ERI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS12 */
    if (1 == ICU.GRPAL0.BIT.IS12)
fff818d9:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff818de:	ee 55 0c 02                   	mov.l	2096[r5], r5
fff818e2:	7c c5                         	btst	#12, r5
fff818e4:	21 3e                         	bne.b	fff81922 <_Reset_Vector+0xfff81926>
fff818e6:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI11_TEI11 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_TEI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS17 */
    if (1 == ICU.GRPAL0.BIT.IS17)
fff818e8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff818ed:	ee 55 0c 02                   	mov.l	2096[r5], r5
fff818f1:	7d 15                         	btst	#17, r5
fff818f3:	21 4d                         	bne.b	fff81940 <_Reset_Vector+0xfff81944>
fff818f5:	fc 13 00                      	nop	; max	r0, r0
        /* BSP_INT_SRC_AL0_RSPI0_SPEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS16 */
    if (1 == ICU.GRPAL0.BIT.IS16)
fff818f8:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff818fd:	ee 55 0c 02                   	mov.l	2096[r5], r5
fff81901:	7d 05                         	btst	#16, r5
fff81903:	21 5d                         	bne.b	fff81960 <_Reset_Vector+0xfff81964>
    {
        /* BSP_INT_SRC_AL0_RSPI0_SPII0 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPII0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_al0_handler_isr() */
fff81905:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_ERI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81906:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff8190c:	66 02                         	mov.l	#0, r2
fff8190e:	75 41 3d                      	mov.l	#61, r1
fff81911:	05 1f f2 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81915 <.LVL37>:
    if (1 == ICU.GRPAL0.BIT.IS12)
fff81915:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff8191a:	ee 55 0c 02                   	mov.l	2096[r5], r5
fff8191e:	7c c5                         	btst	#12, r5
fff81920:	20 c8                         	beq.b	fff818e8 <_Reset_Vector+0xfff818ec>
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_TEI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81922:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81928:	66 02                         	mov.l	#0, r2
fff8192a:	75 41 3c                      	mov.l	#60, r1
fff8192d:	05 03 f2 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff81931 <.LVL38>:
    if (1 == ICU.GRPAL0.BIT.IS17)
fff81931:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81936:	ee 55 0c 02                   	mov.l	2096[r5], r5
fff8193a:	7d 15                         	btst	#17, r5
fff8193c:	20 bc                         	beq.b	fff818f8 <_Reset_Vector+0xfff818fc>
fff8193e:	ef 00                         	nop	; mov.l	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81940:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81946:	66 02                         	mov.l	#0, r2
fff81948:	75 41 3f                      	mov.l	#63, r1
fff8194b:	05 e5 f1 ff                   	bsr.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8194f <.LVL39>:
    if (1 == ICU.GRPAL0.BIT.IS16)
fff8194f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff81954:	ee 55 0c 02                   	mov.l	2096[r5], r5
fff81958:	7d 05                         	btst	#16, r5
fff8195a:	20 ab                         	beq.b	fff81905 <_Reset_Vector+0xfff81909>
fff8195c:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPII0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff81960:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
fff81966:	66 02                         	mov.l	#0, r2
fff81968:	75 41 3e                      	mov.l	#62, r1
fff8196b:	04 c5 f1 ff                   	bra.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff8196f <.LFE10>:
fff8196f:	03                            	nop

fff81970 <__group_be0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_be0_handler_isr, VECT(ICU,GROUPBE0))
fff81970:	7e a1                         	push.l	r1
fff81972:	fd 6a 01                      	mvfc	psw, r1
fff81975:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
fff8197a:	61 81                         	cmp	#8, r1
fff8197c:	22 05                         	bc.b	fff81981 <_Reset_Vector+0xfff81985>
fff8197e:	75 70 08                      	mvtipl	#8
fff81981:	7f a8                         	setpsw	i
fff81983:	fd 6a 01                      	mvfc	psw, r1
fff81986:	fc 5a 11 08 10                	bfmovz	#24, #0, #4, r1, r1
fff8198b:	fd 76 c1 00                   	save	r1
fff8198f:	ef 16                         	mov.l	r1, r6
fff81991:	39 0b 00                      	bsr.w	fff8199c <_Reset_Vector+0xfff819a0>
fff81994:	fd 76 d6 00                   	rstr	r6
fff81998:	7e b1                         	pop	r1
fff8199a:	7f 95                         	rte

fff8199c <_group_be0_handler_isr>:
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_be0_handler_isr (void)
{
    /* BE0 IS0 */
    if (1 == ICU.GRPBE0.BIT.IS0)
fff8199c:	fb 5e 00 70 08                	mov.l	#0x87000, r5
fff819a1:	ee 54 80 01                   	mov.l	1536[r5], r4
fff819a5:	7c 04                         	btst	#0, r4
fff819a7:	21 03                         	bne.b	fff819aa <_Reset_Vector+0xfff819ae>
        ICU.GCRBE0.BIT.CLR0 = 1;

        /* BSP_INT_SRC_BE0_CAN0_ERS0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_be0_handler_isr() */
fff819a9:	02                            	rts
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff819aa:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
        ICU.GCRBE0.BIT.CLR0 = 1;
fff819b0:	ee 54 a0 01                   	mov.l	1664[r5], r4
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff819b4:	66 02                         	mov.l	#0, r2
fff819b6:	75 41 12                      	mov.l	#18, r1
        ICU.GCRBE0.BIT.CLR0 = 1;
fff819b9:	78 04                         	bset	#0, r4
fff819bb:	eb 54 a0 01                   	mov.l	r4, 1664[r5]
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
fff819bf:	04 71 f1 ff                   	bra.a	fff80b30 <_Reset_Vector+0xfff80b34>

fff819c3 <_r_Config_MTU3_MTU4_CrestInterrupt>:
* Description  : This function is TGIA3 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_CrestInterrupt(void)
fff819c3:	7f a8                         	setpsw	i
fff819c5:	fd 76 e0 0f                   	save	#15
fff819c9:	39 09 00                      	bsr.w	fff819d2 <_Reset_Vector+0xfff819d6>
fff819cc:	fd 76 f0 0f                   	rstr	#15
fff819d0:	7f 95                         	rte

fff819d2 <__r_Config_MTU3_MTU4_CrestInterrupt>:
{
    /* Start user code for r_Config_MTU3_MTU4_CrestInterrupt-1. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
    
    CrestFunction();
fff819d2:	04 a6 f7 ff                   	bra.a	fff81178 <_Reset_Vector+0xfff8117c>

fff819d6 <_r_Config_MTU3_MTU4_ad_interrupt>:
* Description  : This function is S12ADI interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_ad_interrupt(void)
fff819d6:	7f a8                         	setpsw	i
fff819d8:	fd 76 e0 0f                   	save	#15
fff819dc:	39 09 00                      	bsr.w	fff819e5 <_Reset_Vector+0xfff819e9>
fff819df:	fd 76 f0 0f                   	rstr	#15
fff819e3:	7f 95                         	rte

fff819e5 <__r_Config_MTU3_MTU4_ad_interrupt>:
{
    /* Start user code for r_Config_MTU3_MTU4_ad_interrupt-1. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
    
    AdFunction();
fff819e5:	04 94 f7 ff                   	bra.a	fff81179 <_Reset_Vector+0xfff8117d>

fff819e9 <.LFE7>:
fff819e9:	00                            	brk
fff819ea:	00                            	brk
fff819eb:	00                            	brk
fff819ec:	00                            	brk
fff819ed:	00                            	brk
	...

fff819f0 <__COM_DIV64u>:
fff819f0:	6e 6c                         	pushm	r6-r12
fff819f2:	61 04                         	cmp	#0, r4
fff819f4:	3b 6e 01                      	bne.w	fff81b62 <_Reset_Vector+0xfff81b66>
fff819f7:	ef 45                         	mov.l	r4, r5
fff819f9:	ef 3f                         	mov.l	r3, r15
fff819fb:	ef 17                         	mov.l	r1, r7
fff819fd:	47 23                         	cmp	r2, r3
fff819ff:	24 05                         	bgtu.b	fff81a04 <_Reset_Vector+0xfff81a08>
fff81a01:	38 b6 00                      	bra.w	fff81ab7 <_Reset_Vector+0xfff81abb>
fff81a04:	ef 2a                         	mov.l	r2, r10
fff81a06:	77 03 ff ff 00                	cmp	#0xffff, r3
fff81a0b:	24 05                         	bgtu.b	fff81a10 <_Reset_Vector+0xfff81a14>
fff81a0d:	38 bd 01                      	bra.w	fff81bca <_Reset_Vector+0xfff81bce>
fff81a10:	74 03 ff ff ff 00             	cmp	#0xffffff, r3
fff81a16:	24 05                         	bgtu.b	fff81a1b <_Reset_Vector+0xfff81a1f>
fff81a18:	38 69 03                      	bra.w	fff81d81 <_Reset_Vector+0xfff81d85>
fff81a1b:	fd 98 36                      	shlr	#24, r3, r6
fff81a1e:	75 45 18                      	mov.l	#24, r5
fff81a21:	fb 42 00 22 f8 ff             	mov.l	#0xfff82200, r4
fff81a27:	fe c6 44                      	movu.b	[r6, r4], r4
fff81a2a:	4b 45                         	add	r4, r5
fff81a2c:	75 46 20                      	mov.l	#32, r6
fff81a2f:	43 56                         	sub	r5, r6
fff81a31:	20 18                         	beq.b	fff81a49 <_Reset_Vector+0xfff81a4d>
fff81a33:	ef 2e                         	mov.l	r2, r14
fff81a35:	fd 62 6e                      	shll	r6, r14
fff81a38:	ef 1a                         	mov.l	r1, r10
fff81a3a:	fd 60 5a                      	shlr	r5, r10
fff81a3d:	ef 3f                         	mov.l	r3, r15
fff81a3f:	fd 62 6f                      	shll	r6, r15
fff81a42:	57 ea                         	or	r14, r10
fff81a44:	ef 17                         	mov.l	r1, r7
fff81a46:	fd 62 67                      	shll	r6, r7
fff81a49:	fd 90 f2                      	shlr	#16, r15, r2
fff81a4c:	fb 6e ff ff 00                	mov.l	#0xffff, r6
fff81a51:	53 f6                         	and	r15, r6
fff81a53:	ef a5                         	mov.l	r10, r5
fff81a55:	fc 27 25                      	divu	r2, r5
fff81a58:	ff 34 25                      	mul 	r2, r5, r4
fff81a5b:	43 4a                         	sub	r4, r10
fff81a5d:	fd d0 a4                      	shll	#16, r10, r4
fff81a60:	fd 90 7a                      	shlr	#16, r7, r10
fff81a63:	ff 33 56                      	mul 	r5, r6, r3
fff81a66:	57 4a                         	or	r4, r10
fff81a68:	47 a3                         	cmp	r10, r3
fff81a6a:	25 14                         	bleu.b	fff81a7e <_Reset_Vector+0xfff81a82>
fff81a6c:	4b fa                         	add	r15, r10
fff81a6e:	71 54 ff                      	add	#-1, r5, r4
fff81a71:	47 af                         	cmp	r10, r15
fff81a73:	24 09                         	bgtu.b	fff81a7c <_Reset_Vector+0xfff81a80>
fff81a75:	47 a3                         	cmp	r10, r3
fff81a77:	25 05                         	bleu.b	fff81a7c <_Reset_Vector+0xfff81a80>
fff81a79:	38 34 03                      	bra.w	fff81dad <_Reset_Vector+0xfff81db1>
fff81a7c:	ef 45                         	mov.l	r4, r5
fff81a7e:	43 3a                         	sub	r3, r10
fff81a80:	77 27 ff ff 00                	and	#0xffff, r7
fff81a85:	ef a1                         	mov.l	r10, r1
fff81a87:	fc 27 21                      	divu	r2, r1
fff81a8a:	4f 12                         	mul	r1, r2
fff81a8c:	43 2a                         	sub	r2, r10
fff81a8e:	ef 13                         	mov.l	r1, r3
fff81a90:	6d 0a                         	shll	#16, r10
fff81a92:	ff 32 16                      	mul 	r1, r6, r2
fff81a95:	57 a7                         	or	r10, r7
fff81a97:	47 72                         	cmp	r7, r2
fff81a99:	25 14                         	bleu.b	fff81aad <_Reset_Vector+0xfff81ab1>
fff81a9b:	4b f7                         	add	r15, r7
fff81a9d:	71 1a ff                      	add	#-1, r1, r10
fff81aa0:	47 7f                         	cmp	r7, r15
fff81aa2:	24 09                         	bgtu.b	fff81aab <_Reset_Vector+0xfff81aaf>
fff81aa4:	47 72                         	cmp	r7, r2
fff81aa6:	25 05                         	bleu.b	fff81aab <_Reset_Vector+0xfff81aaf>
fff81aa8:	38 00 03                      	bra.w	fff81da8 <_Reset_Vector+0xfff81dac>
fff81aab:	ef a3                         	mov.l	r10, r3
fff81aad:	fd d0 51                      	shll	#16, r5, r1
fff81ab0:	66 02                         	mov.l	#0, r2
fff81ab2:	57 31                         	or	r3, r1
fff81ab4:	3f 6c 07                      	rtsd	#28, r6-r12
fff81ab7:	61 03                         	cmp	#0, r3
fff81ab9:	1f                            	bne.s	fff81ac0 <_Reset_Vector+0xfff81ac4>
fff81aba:	66 1f                         	mov.l	#1, r15
fff81abc:	fd 74 9f 00                   	divu	#0, r15
fff81ac0:	77 0f ff ff 00                	cmp	#0xffff, r15
fff81ac5:	24 05                         	bgtu.b	fff81aca <_Reset_Vector+0xfff81ace>
fff81ac7:	38 f3 00                      	bra.w	fff81bba <_Reset_Vector+0xfff81bbe>
fff81aca:	74 0f ff ff ff 00             	cmp	#0xffffff, r15
fff81ad0:	24 05                         	bgtu.b	fff81ad5 <_Reset_Vector+0xfff81ad9>
fff81ad2:	38 a6 02                      	bra.w	fff81d78 <_Reset_Vector+0xfff81d7c>
fff81ad5:	fd 98 f4                      	shlr	#24, r15, r4
fff81ad8:	75 45 18                      	mov.l	#24, r5
fff81adb:	77 10 01 00 00                	nop	; mul	#1, r0
fff81ae0:	fb a2 00 22 f8 ff             	mov.l	#0xfff82200, r10
fff81ae6:	fe c4 a4                      	movu.b	[r4, r10], r4
fff81ae9:	4b 54                         	add	r5, r4
fff81aeb:	75 43 20                      	mov.l	#32, r3
fff81aee:	43 43                         	sub	r4, r3
fff81af0:	3b ea 00                      	bne.w	fff81bda <_Reset_Vector+0xfff81bde>
fff81af3:	ff 0e f2                      	sub	r15, r2, r14
fff81af6:	fd 90 f6                      	shlr	#16, r15, r6
fff81af9:	fb ae ff ff 00                	mov.l	#0xffff, r10
fff81afe:	53 fa                         	and	r15, r10
fff81b00:	66 12                         	mov.l	#1, r2
fff81b02:	ef e5                         	mov.l	r14, r5
fff81b04:	fc 27 65                      	divu	r6, r5
fff81b07:	ff 34 65                      	mul 	r6, r5, r4
fff81b0a:	43 4e                         	sub	r4, r14
fff81b0c:	6d 0e                         	shll	#16, r14
fff81b0e:	fd 90 74                      	shlr	#16, r7, r4
fff81b11:	ff 33 a5                      	mul 	r10, r5, r3
fff81b14:	57 e4                         	or	r14, r4
fff81b16:	47 43                         	cmp	r4, r3
fff81b18:	25 14                         	bleu.b	fff81b2c <_Reset_Vector+0xfff81b30>
fff81b1a:	4b f4                         	add	r15, r4
fff81b1c:	71 51 ff                      	add	#-1, r5, r1
fff81b1f:	47 4f                         	cmp	r4, r15
fff81b21:	24 09                         	bgtu.b	fff81b2a <_Reset_Vector+0xfff81b2e>
fff81b23:	47 43                         	cmp	r4, r3
fff81b25:	25 05                         	bleu.b	fff81b2a <_Reset_Vector+0xfff81b2e>
fff81b27:	38 8d 02                      	bra.w	fff81db4 <_Reset_Vector+0xfff81db8>
fff81b2a:	ef 15                         	mov.l	r1, r5
fff81b2c:	43 34                         	sub	r3, r4
fff81b2e:	77 27 ff ff 00                	and	#0xffff, r7
fff81b33:	ef 41                         	mov.l	r4, r1
fff81b35:	fc 27 61                      	divu	r6, r1
fff81b38:	4f 16                         	mul	r1, r6
fff81b3a:	43 64                         	sub	r6, r4
fff81b3c:	ef 13                         	mov.l	r1, r3
fff81b3e:	6d 04                         	shll	#16, r4
fff81b40:	4f 1a                         	mul	r1, r10
fff81b42:	57 74                         	or	r7, r4
fff81b44:	47 4a                         	cmp	r4, r10
fff81b46:	25 14                         	bleu.b	fff81b5a <_Reset_Vector+0xfff81b5e>
fff81b48:	4b f4                         	add	r15, r4
fff81b4a:	71 17 ff                      	add	#-1, r1, r7
fff81b4d:	47 4f                         	cmp	r4, r15
fff81b4f:	24 09                         	bgtu.b	fff81b58 <_Reset_Vector+0xfff81b5c>
fff81b51:	47 4a                         	cmp	r4, r10
fff81b53:	25 05                         	bleu.b	fff81b58 <_Reset_Vector+0xfff81b5c>
fff81b55:	38 4e 02                      	bra.w	fff81da3 <_Reset_Vector+0xfff81da7>
fff81b58:	ef 73                         	mov.l	r7, r3
fff81b5a:	fd d0 51                      	shll	#16, r5, r1
fff81b5d:	57 31                         	or	r3, r1
fff81b5f:	3f 6c 07                      	rtsd	#28, r6-r12
fff81b62:	47 24                         	cmp	r2, r4
fff81b64:	24 40                         	bgtu.b	fff81ba4 <_Reset_Vector+0xfff81ba8>
fff81b66:	77 04 ff ff 00                	cmp	#0xffff, r4
fff81b6b:	25 40                         	bleu.b	fff81bab <_Reset_Vector+0xfff81baf>
fff81b6d:	74 04 ff ff ff 00             	cmp	#0xffffff, r4
fff81b73:	24 05                         	bgtu.b	fff81b78 <_Reset_Vector+0xfff81b7c>
fff81b75:	38 e7 01                      	bra.w	fff81d5c <_Reset_Vector+0xfff81d60>
fff81b78:	fd 98 45                      	shlr	#24, r4, r5
fff81b7b:	75 4a 18                      	mov.l	#24, r10
fff81b7e:	ef 00                         	nop	; mov.l	r0, r0
fff81b80:	fb 72 00 22 f8 ff             	mov.l	#0xfff82200, r7
fff81b86:	fe c5 75                      	movu.b	[r5, r7], r5
fff81b89:	4b a5                         	add	r10, r5
fff81b8b:	75 4a 20                      	mov.l	#32, r10
fff81b8e:	43 5a                         	sub	r5, r10
fff81b90:	3b dd 00                      	bne.w	fff81c6d <_Reset_Vector+0xfff81c71>
fff81b93:	47 24                         	cmp	r2, r4
fff81b95:	22 05                         	bc.b	fff81b9a <_Reset_Vector+0xfff81b9e>
fff81b97:	38 ce 01                      	bra.w	fff81d65 <_Reset_Vector+0xfff81d69>
fff81b9a:	47 13                         	cmp	r1, r3
fff81b9c:	fc db 15                      	scleu.l	r1
fff81b9f:	66 02                         	mov.l	#0, r2
fff81ba1:	3f 6c 07                      	rtsd	#28, r6-r12
fff81ba4:	66 02                         	mov.l	#0, r2
fff81ba6:	66 01                         	mov.l	#0, r1
fff81ba8:	3f 6c 07                      	rtsd	#28, r6-r12
fff81bab:	75 54 ff                      	cmp	#255, r4
fff81bae:	24 05                         	bgtu.b	fff81bb3 <_Reset_Vector+0xfff81bb7>
fff81bb0:	38 bc 01                      	bra.w	fff81d6c <_Reset_Vector+0xfff81d70>
fff81bb3:	fd 88 45                      	shlr	#8, r4, r5
fff81bb6:	66 8a                         	mov.l	#8, r10
fff81bb8:	2e c8                         	bra.b	fff81b80 <_Reset_Vector+0xfff81b84>
fff81bba:	75 5f ff                      	cmp	#255, r15
fff81bbd:	24 05                         	bgtu.b	fff81bc2 <_Reset_Vector+0xfff81bc6>
fff81bbf:	38 cb 01                      	bra.w	fff81d8a <_Reset_Vector+0xfff81d8e>
fff81bc2:	fd 88 f4                      	shlr	#8, r15, r4
fff81bc5:	66 85                         	mov.l	#8, r5
fff81bc7:	38 19 ff                      	bra.w	fff81ae0 <_Reset_Vector+0xfff81ae4>
fff81bca:	75 53 ff                      	cmp	#255, r3
fff81bcd:	24 05                         	bgtu.b	fff81bd2 <_Reset_Vector+0xfff81bd6>
fff81bcf:	38 a4 01                      	bra.w	fff81d73 <_Reset_Vector+0xfff81d77>
fff81bd2:	fd 88 36                      	shlr	#8, r3, r6
fff81bd5:	66 85                         	mov.l	#8, r5
fff81bd7:	38 4a fe                      	bra.w	fff81a21 <_Reset_Vector+0xfff81a25>
fff81bda:	fd 62 3f                      	shll	r3, r15
fff81bdd:	ef 25                         	mov.l	r2, r5
fff81bdf:	fd 60 45                      	shlr	r4, r5
fff81be2:	fd 90 f6                      	shlr	#16, r15, r6
fff81be5:	ef 2e                         	mov.l	r2, r14
fff81be7:	fd 62 3e                      	shll	r3, r14
fff81bea:	ef 57                         	mov.l	r5, r7
fff81bec:	fc 27 67                      	divu	r6, r7
fff81bef:	ef 12                         	mov.l	r1, r2
fff81bf1:	fd 60 42                      	shlr	r4, r2
fff81bf4:	ff 3b 67                      	mul 	r6, r7, r11
fff81bf7:	57 2e                         	or	r2, r14
fff81bf9:	43 b5                         	sub	r11, r5
fff81bfb:	fb ae ff ff 00                	mov.l	#0xffff, r10
fff81c00:	53 fa                         	and	r15, r10
fff81c02:	ef 74                         	mov.l	r7, r4
fff81c04:	6d 05                         	shll	#16, r5
fff81c06:	fd 90 e7                      	shlr	#16, r14, r7
fff81c09:	ff 32 4a                      	mul 	r4, r10, r2
fff81c0c:	57 75                         	or	r7, r5
fff81c0e:	ef 17                         	mov.l	r1, r7
fff81c10:	fd 62 37                      	shll	r3, r7
fff81c13:	47 52                         	cmp	r5, r2
fff81c15:	25 19                         	bleu.b	fff81c2e <_Reset_Vector+0xfff81c32>
fff81c17:	4b f5                         	add	r15, r5
fff81c19:	71 43 ff                      	add	#-1, r4, r3
fff81c1c:	47 5f                         	cmp	r5, r15
fff81c1e:	25 05                         	bleu.b	fff81c23 <_Reset_Vector+0xfff81c27>
fff81c20:	38 7e 01                      	bra.w	fff81d9e <_Reset_Vector+0xfff81da2>
fff81c23:	47 52                         	cmp	r5, r2
fff81c25:	24 05                         	bgtu.b	fff81c2a <_Reset_Vector+0xfff81c2e>
fff81c27:	38 77 01                      	bra.w	fff81d9e <_Reset_Vector+0xfff81da2>
fff81c2a:	60 24                         	sub	#2, r4
fff81c2c:	4b f5                         	add	r15, r5
fff81c2e:	43 25                         	sub	r2, r5
fff81c30:	fb 3e ff ff 00                	mov.l	#0xffff, r3
fff81c35:	53 e3                         	and	r14, r3
fff81c37:	ef 52                         	mov.l	r5, r2
fff81c39:	fc 27 62                      	divu	r6, r2
fff81c3c:	ff 3e 62                      	mul 	r6, r2, r14
fff81c3f:	43 e5                         	sub	r14, r5
fff81c41:	fd d0 5e                      	shll	#16, r5, r14
fff81c44:	ff 35 2a                      	mul 	r2, r10, r5
fff81c47:	57 3e                         	or	r3, r14
fff81c49:	47 e5                         	cmp	r14, r5
fff81c4b:	25 19                         	bleu.b	fff81c64 <_Reset_Vector+0xfff81c68>
fff81c4d:	4b fe                         	add	r15, r14
fff81c4f:	71 23 ff                      	add	#-1, r2, r3
fff81c52:	47 ef                         	cmp	r14, r15
fff81c54:	25 05                         	bleu.b	fff81c59 <_Reset_Vector+0xfff81c5d>
fff81c56:	38 3e 01                      	bra.w	fff81d94 <_Reset_Vector+0xfff81d98>
fff81c59:	47 e5                         	cmp	r14, r5
fff81c5b:	24 05                         	bgtu.b	fff81c60 <_Reset_Vector+0xfff81c64>
fff81c5d:	38 37 01                      	bra.w	fff81d94 <_Reset_Vector+0xfff81d98>
fff81c60:	60 22                         	sub	#2, r2
fff81c62:	4b fe                         	add	r15, r14
fff81c64:	6d 04                         	shll	#16, r4
fff81c66:	43 5e                         	sub	r5, r14
fff81c68:	57 42                         	or	r4, r2
fff81c6a:	38 98 fe                      	bra.w	fff81b02 <_Reset_Vector+0xfff81b06>
fff81c6d:	fd 62 a4                      	shll	r10, r4
fff81c70:	ef 37                         	mov.l	r3, r7
fff81c72:	fd 60 57                      	shlr	r5, r7
fff81c75:	57 74                         	or	r7, r4
fff81c77:	ef 27                         	mov.l	r2, r7
fff81c79:	fd 60 57                      	shlr	r5, r7
fff81c7c:	fd 90 4f                      	shlr	#16, r4, r15
fff81c7f:	ef 2e                         	mov.l	r2, r14
fff81c81:	fd 62 ae                      	shll	r10, r14
fff81c84:	ef 76                         	mov.l	r7, r6
fff81c86:	fc 27 f6                      	divu	r15, r6
fff81c89:	ef 12                         	mov.l	r1, r2
fff81c8b:	fd 60 52                      	shlr	r5, r2
fff81c8e:	ff 35 f6                      	mul 	r15, r6, r5
fff81c91:	57 e2                         	or	r14, r2
fff81c93:	43 57                         	sub	r5, r7
fff81c95:	fb be ff ff 00                	mov.l	#0xffff, r11
fff81c9a:	53 4b                         	and	r4, r11
fff81c9c:	6d 07                         	shll	#16, r7
fff81c9e:	fd 90 2c                      	shlr	#16, r2, r12
fff81ca1:	ff 35 6b                      	mul 	r6, r11, r5
fff81ca4:	57 c7                         	or	r12, r7
fff81ca6:	ef 3c                         	mov.l	r3, r12
fff81ca8:	fd 62 ac                      	shll	r10, r12
fff81cab:	47 75                         	cmp	r7, r5
fff81cad:	25 19                         	bleu.b	fff81cc6 <_Reset_Vector+0xfff81cca>
fff81caf:	4b 47                         	add	r4, r7
fff81cb1:	71 63 ff                      	add	#-1, r6, r3
fff81cb4:	47 74                         	cmp	r7, r4
fff81cb6:	25 05                         	bleu.b	fff81cbb <_Reset_Vector+0xfff81cbf>
fff81cb8:	38 e1 00                      	bra.w	fff81d99 <_Reset_Vector+0xfff81d9d>
fff81cbb:	47 75                         	cmp	r7, r5
fff81cbd:	24 05                         	bgtu.b	fff81cc2 <_Reset_Vector+0xfff81cc6>
fff81cbf:	38 da 00                      	bra.w	fff81d99 <_Reset_Vector+0xfff81d9d>
fff81cc2:	60 26                         	sub	#2, r6
fff81cc4:	4b 47                         	add	r4, r7
fff81cc6:	43 57                         	sub	r5, r7
fff81cc8:	fb ee ff ff 00                	mov.l	#0xffff, r14
fff81ccd:	53 2e                         	and	r2, r14
fff81ccf:	ef 75                         	mov.l	r7, r5
fff81cd1:	fc 27 f5                      	divu	r15, r5
fff81cd4:	ff 32 f5                      	mul 	r15, r5, r2
fff81cd7:	43 27                         	sub	r2, r7
fff81cd9:	fd d0 72                      	shll	#16, r7, r2
fff81cdc:	4f 5b                         	mul	r5, r11
fff81cde:	57 e2                         	or	r14, r2
fff81ce0:	47 2b                         	cmp	r2, r11
fff81ce2:	25 19                         	bleu.b	fff81cfb <_Reset_Vector+0xfff81cff>
fff81ce4:	4b 42                         	add	r4, r2
fff81ce6:	71 57 ff                      	add	#-1, r5, r7
fff81ce9:	47 24                         	cmp	r2, r4
fff81ceb:	25 05                         	bleu.b	fff81cf0 <_Reset_Vector+0xfff81cf4>
fff81ced:	38 a2 00                      	bra.w	fff81d8f <_Reset_Vector+0xfff81d93>
fff81cf0:	47 2b                         	cmp	r2, r11
fff81cf2:	24 05                         	bgtu.b	fff81cf7 <_Reset_Vector+0xfff81cfb>
fff81cf4:	38 9b 00                      	bra.w	fff81d8f <_Reset_Vector+0xfff81d93>
fff81cf7:	60 25                         	sub	#2, r5
fff81cf9:	4b 42                         	add	r4, r2
fff81cfb:	fd d0 63                      	shll	#16, r6, r3
fff81cfe:	fb 6e ff ff 00                	mov.l	#0xffff, r6
fff81d03:	53 c6                         	and	r12, r6
fff81d05:	57 53                         	or	r5, r3
fff81d07:	fd 90 ce                      	shlr	#16, r12, r14
fff81d0a:	fb 7e ff ff 00                	mov.l	#0xffff, r7
fff81d0f:	53 37                         	and	r3, r7
fff81d11:	fd 90 3c                      	shlr	#16, r3, r12
fff81d14:	ff 34 67                      	mul 	r6, r7, r4
fff81d17:	4f c6                         	mul	r12, r6
fff81d19:	4f e7                         	mul	r14, r7
fff81d1b:	fd 90 45                      	shlr	#16, r4, r5
fff81d1e:	4b 67                         	add	r6, r7
fff81d20:	43 b2                         	sub	r11, r2
fff81d22:	4b 57                         	add	r5, r7
fff81d24:	4f ec                         	mul	r14, r12
fff81d26:	47 76                         	cmp	r7, r6
fff81d28:	25 08                         	bleu.b	fff81d30 <_Reset_Vector+0xfff81d34>
fff81d2a:	73 cc 00 00 01                	add	#0x10000, r12, r12
fff81d2f:	03                            	nop
fff81d30:	fd 90 75                      	shlr	#16, r7, r5
fff81d33:	4b 5c                         	add	r5, r12
fff81d35:	47 c2                         	cmp	r12, r2
fff81d37:	23 1d                         	bnc.b	fff81d54 <_Reset_Vector+0xfff81d58>
fff81d39:	10                            	beq.s	fff81d41 <_Reset_Vector+0xfff81d45>
fff81d3a:	ef 31                         	mov.l	r3, r1
fff81d3c:	66 02                         	mov.l	#0, r2
fff81d3e:	3f 6c 07                      	rtsd	#28, r6-r12
fff81d41:	fd d0 75                      	shll	#16, r7, r5
fff81d44:	77 24 ff ff 00                	and	#0xffff, r4
fff81d49:	ef 17                         	mov.l	r1, r7
fff81d4b:	fd 62 a7                      	shll	r10, r7
fff81d4e:	4b 45                         	add	r4, r5
fff81d50:	47 57                         	cmp	r5, r7
fff81d52:	22 e8                         	bc.b	fff81d3a <_Reset_Vector+0xfff81d3e>
fff81d54:	71 31 ff                      	add	#-1, r3, r1
fff81d57:	66 02                         	mov.l	#0, r2
fff81d59:	3f 6c 07                      	rtsd	#28, r6-r12
fff81d5c:	fd 90 45                      	shlr	#16, r4, r5
fff81d5f:	75 4a 10                      	mov.l	#16, r10
fff81d62:	38 1e fe                      	bra.w	fff81b80 <_Reset_Vector+0xfff81b84>
fff81d65:	66 02                         	mov.l	#0, r2
fff81d67:	66 11                         	mov.l	#1, r1
fff81d69:	3f 6c 07                      	rtsd	#28, r6-r12
fff81d6c:	ef 45                         	mov.l	r4, r5
fff81d6e:	66 0a                         	mov.l	#0, r10
fff81d70:	38 10 fe                      	bra.w	fff81b80 <_Reset_Vector+0xfff81b84>
fff81d73:	ef 36                         	mov.l	r3, r6
fff81d75:	38 ac fc                      	bra.w	fff81a21 <_Reset_Vector+0xfff81a25>
fff81d78:	fd 90 f4                      	shlr	#16, r15, r4
fff81d7b:	75 45 10                      	mov.l	#16, r5
fff81d7e:	38 62 fd                      	bra.w	fff81ae0 <_Reset_Vector+0xfff81ae4>
fff81d81:	fd 90 36                      	shlr	#16, r3, r6
fff81d84:	75 45 10                      	mov.l	#16, r5
fff81d87:	38 9a fc                      	bra.w	fff81a21 <_Reset_Vector+0xfff81a25>
fff81d8a:	ef f4                         	mov.l	r15, r4
fff81d8c:	38 54 fd                      	bra.w	fff81ae0 <_Reset_Vector+0xfff81ae4>
fff81d8f:	ef 75                         	mov.l	r7, r5
fff81d91:	38 6a ff                      	bra.w	fff81cfb <_Reset_Vector+0xfff81cff>
fff81d94:	ef 32                         	mov.l	r3, r2
fff81d96:	38 ce fe                      	bra.w	fff81c64 <_Reset_Vector+0xfff81c68>
fff81d99:	ef 36                         	mov.l	r3, r6
fff81d9b:	38 2b ff                      	bra.w	fff81cc6 <_Reset_Vector+0xfff81cca>
fff81d9e:	ef 34                         	mov.l	r3, r4
fff81da0:	38 8e fe                      	bra.w	fff81c2e <_Reset_Vector+0xfff81c32>
fff81da3:	60 23                         	sub	#2, r3
fff81da5:	38 b5 fd                      	bra.w	fff81b5a <_Reset_Vector+0xfff81b5e>
fff81da8:	60 23                         	sub	#2, r3
fff81daa:	38 03 fd                      	bra.w	fff81aad <_Reset_Vector+0xfff81ab1>
fff81dad:	60 25                         	sub	#2, r5
fff81daf:	4b fa                         	add	r15, r10
fff81db1:	38 cd fc                      	bra.w	fff81a7e <_Reset_Vector+0xfff81a82>
fff81db4:	60 25                         	sub	#2, r5
fff81db6:	4b f4                         	add	r15, r4
fff81db8:	38 74 fd                      	bra.w	fff81b2c <_Reset_Vector+0xfff81b30>
fff81dbb:	77 10 01 00 00                	nop	; mul	#1, r0
