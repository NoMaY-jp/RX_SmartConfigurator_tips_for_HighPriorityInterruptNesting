
RXv2_NestedInterrupt_GCC.elf:     file format elf32-rx-le


Disassembly of section .text:

ffe00000 <_PowerON_Reset>:


_PowerON_Reset_PC :
_PowerON_Reset :
;;initialise user stack pointer
    mvtc    #_ustack,USP
ffe00000:	fd 73 02 80 19 00 00          	mvtc	#0x1980, usp

;;initialise interrupt stack pointer
    mvtc    #_istack,ISP
ffe00007:	fd 73 0a 80 09 00 00          	mvtc	#0x980, isp

;;jump to Power ON Reset main function in RESETPRG.C
    bra     _PowerON_Reset_PC_Prg
ffe0000e:	04 52 3c 00                   	bra.a	ffe03c60 <_Reset_Vector+0xffe03c64>

ffe00012 <__INITSCT>:
    .global __INITSCT
    .type   __INITSCT,@function
__INITSCT:

;;load data section from ROM to RAM
    pushm   r1-r3
ffe00012:	6e 13                         	pushm	r1-r3
    mov     #_mdata,r2      ;;src ROM address of data section in R2
ffe00014:	fb 22 48 67 e0 ff             	mov.l	#0xffe06748, r2
    mov     #_data,r1       ;;dest start RAM address of data section in R1
ffe0001a:	fb 12 04 00 00 00             	mov.l	#4, r1
    mov     #_edata,r3      ;;end RAM address of data section in R3
ffe00020:	fb 32 24 00 00 00             	mov.l	#36, r3
    sub     r1,r3           ;;size of data section in R3 (R3=R3-R1)
ffe00026:	43 13                         	sub	r1, r3
    smovf                   ;;block copy R3 bytes from R2 to R1
ffe00028:	7f 8f                         	smovf

;;bss initialisation : zero out bss
    mov    #00h,r2          ;;load R2 reg with zero
ffe0002a:	66 02                         	mov.l	#0, r2
    mov    #_ebss, r3       ;;store the end address of bss in R3
ffe0002c:	fb 32 25 04 00 00             	mov.l	#0x425, r3
    mov    #_bss, r1        ;;store the start address of bss in R1
ffe00032:	fb 12 24 00 00 00             	mov.l	#36, r1
    sub    r1,r3            ;;size of bss section in R3 (R3=R3-R1)
ffe00038:	43 13                         	sub	r1, r3
    sstr.b
ffe0003a:	7f 88                         	sstr.b
    popm    r1-r3
ffe0003c:	6f 13                         	popm	r1-r3
    rts
ffe0003e:	02                            	rts

ffe0003f <_exit>:

#endif

;;call to exit
_exit:
    bra  _loop_here
ffe0003f:	2e 02                         	bra.b	ffe00041 <_Reset_Vector+0xffe00045>

ffe00041 <_loop_here>:
_loop_here:
    bra _loop_here
ffe00041:	2e 00                         	bra.b	ffe00041 <_Reset_Vector+0xffe00045>

ffe00043 <_sci_iic_int_sci_iic1_tei_isr>:
 * Arguments    : None
 * Return Value : None
 **********************************************************************************************************************/
void sci_iic_int_sci_iic1_tei_isr (void)
{
    r_sci_iic_tei_isr_processing(SCI_IIC_NUM_CH1);
ffe00043:	66 11                         	mov.l	#1, r1
ffe00045:	05 63 0f 00                   	bsr.a	ffe00fa8 <_Reset_Vector+0xffe00fac>

ffe00049 <.LVL0>:

    /* Calls advance function */
    r_sci_iic_advance(g_sci_iic_handles[SCI_IIC_NUM_CH1]->psci_iic_info_ch);
ffe00049:	fb 52 04 00 00 00             	mov.l	#4, r5
ffe0004f:	a9 d1                         	mov.l	24[r5], r1
ffe00051:	04 8f 0d 00                   	bra.a	ffe00de0 <_Reset_Vector+0xffe00de4>

ffe00055 <_riic1_eei_isr>:
 * Arguments    : None
 * Return Value : None
 **********************************************************************************************************************/
void riic1_eei_isr (void * vect)
{
    riic1_eei_sub();
ffe00055:	04 eb 2a 00                   	bra.a	ffe02b40 <_Reset_Vector+0xffe02b44>

ffe00059 <_riic1_tei_isr>:
 * Arguments    : None
 * Return Value : None
 **********************************************************************************************************************/
void riic1_tei_isr (void * vect)
{
    riic1_tei_sub();
ffe00059:	04 ef 2d 00                   	bra.a	ffe02e48 <_Reset_Vector+0xffe02e4c>

ffe0005d <.LFE25>:
ffe0005d:	00                            	brk
	...

ffe00060 <_excep_supervisor_inst_isr>:
* Description  : Supervisor Instruction Violation ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_supervisor_inst_isr(void)
{
ffe00060:	6e ef                         	pushm	r14-r15
ffe00062:	6e 15                         	pushm	r1-r5
ffe00064:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe00067:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe0006a:	7e a1                         	push.l	r1
ffe0006c:	7e a2                         	push.l	r2
ffe0006e:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe00071:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe00074:	7e a1                         	push.l	r1
ffe00076:	7e a2                         	push.l	r2
ffe00078:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe0007b:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe0007e:	7e a1                         	push.l	r1
ffe00080:	7e a2                         	push.l	r2
ffe00082:	60 40                         	sub	#4, r0

ffe00084 <.LBB296>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffe00084:	fb 52 80 00 00 00             	mov.l	#128, r5
ffe0008a:	ec 55                         	mov.l	[r5], r5
ffe0008c:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffe00093:	10                            	beq.s	ffe0009b <_Reset_Vector+0xffe0009f>
                g_bsp_vectors[vector](&cb_args);
ffe00094:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffe00096:	f8 06 00                      	mov.l	#0, [r0]
                g_bsp_vectors[vector](&cb_args);
ffe00099:	7f 15                         	jsr	r5

ffe0009b <.LVL144>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_SUPERVISOR_INSTR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_supervisor_inst_isr() */
ffe0009b:	62 40                         	add	#4, r0
ffe0009d:	7e b2                         	pop	r2
ffe0009f:	7e b1                         	pop	r1
ffe000a1:	fd 17 81                      	mvtachi	r1, a1
ffe000a4:	fd 17 b2                      	mvtacgu	r2, a1
ffe000a7:	7e b2                         	pop	r2
ffe000a9:	7e b1                         	pop	r1
ffe000ab:	fd 17 31                      	mvtacgu	r1, a0
ffe000ae:	fd 17 92                      	mvtaclo	r2, a1
ffe000b1:	7e b2                         	pop	r2
ffe000b3:	7e b1                         	pop	r1
ffe000b5:	fd 17 11                      	mvtaclo	r1, a0
ffe000b8:	fd 17 02                      	mvtachi	r2, a0
ffe000bb:	6f 15                         	popm	r1-r5
ffe000bd:	6f ef                         	popm	r14-r15
ffe000bf:	7f 95                         	rte

ffe000c1 <.LFE11>:
ffe000c1:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe000c8 <_excep_access_isr>:
* Description  : Access exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_access_isr(void)
{
ffe000c8:	6e ef                         	pushm	r14-r15
ffe000ca:	6e 15                         	pushm	r1-r5
ffe000cc:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe000cf:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe000d2:	7e a1                         	push.l	r1
ffe000d4:	7e a2                         	push.l	r2
ffe000d6:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe000d9:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe000dc:	7e a1                         	push.l	r1
ffe000de:	7e a2                         	push.l	r2
ffe000e0:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe000e3:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe000e6:	7e a1                         	push.l	r1
ffe000e8:	7e a2                         	push.l	r2
ffe000ea:	60 40                         	sub	#4, r0

ffe000ec <.LBB300>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffe000ec:	fb 52 80 00 00 00             	mov.l	#128, r5
ffe000f2:	a9 55                         	mov.l	16[r5], r5
ffe000f4:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffe000fb:	10                            	beq.s	ffe00103 <_Reset_Vector+0xffe00107>
                g_bsp_vectors[vector](&cb_args);
ffe000fc:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffe000fe:	f8 06 04                      	mov.l	#4, [r0]
                g_bsp_vectors[vector](&cb_args);
ffe00101:	7f 15                         	jsr	r5

ffe00103 <.LVL146>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_ACCESS, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_access_isr() */
ffe00103:	62 40                         	add	#4, r0
ffe00105:	7e b2                         	pop	r2
ffe00107:	7e b1                         	pop	r1
ffe00109:	fd 17 81                      	mvtachi	r1, a1
ffe0010c:	fd 17 b2                      	mvtacgu	r2, a1
ffe0010f:	7e b2                         	pop	r2
ffe00111:	7e b1                         	pop	r1
ffe00113:	fd 17 31                      	mvtacgu	r1, a0
ffe00116:	fd 17 92                      	mvtaclo	r2, a1
ffe00119:	7e b2                         	pop	r2
ffe0011b:	7e b1                         	pop	r1
ffe0011d:	fd 17 11                      	mvtaclo	r1, a0
ffe00120:	fd 17 02                      	mvtachi	r2, a0
ffe00123:	6f 15                         	popm	r1-r5
ffe00125:	6f ef                         	popm	r14-r15
ffe00127:	7f 95                         	rte

ffe00129 <.LFE12>:
ffe00129:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe00130 <_excep_undefined_inst_isr>:
* Description  : Undefined instruction exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_undefined_inst_isr(void)
{
ffe00130:	6e ef                         	pushm	r14-r15
ffe00132:	6e 15                         	pushm	r1-r5
ffe00134:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe00137:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe0013a:	7e a1                         	push.l	r1
ffe0013c:	7e a2                         	push.l	r2
ffe0013e:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe00141:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe00144:	7e a1                         	push.l	r1
ffe00146:	7e a2                         	push.l	r2
ffe00148:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe0014b:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe0014e:	7e a1                         	push.l	r1
ffe00150:	7e a2                         	push.l	r2
ffe00152:	60 40                         	sub	#4, r0

ffe00154 <.LBB304>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffe00154:	fb 52 80 00 00 00             	mov.l	#128, r5
ffe0015a:	a8 5d                         	mov.l	4[r5], r5
ffe0015c:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffe00163:	10                            	beq.s	ffe0016b <_Reset_Vector+0xffe0016f>
                g_bsp_vectors[vector](&cb_args);
ffe00164:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffe00166:	f8 06 01                      	mov.l	#1, [r0]
                g_bsp_vectors[vector](&cb_args);
ffe00169:	7f 15                         	jsr	r5

ffe0016b <.LVL148>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_UNDEFINED_INSTR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function excep_undefined_inst_isr() */
ffe0016b:	62 40                         	add	#4, r0
ffe0016d:	7e b2                         	pop	r2
ffe0016f:	7e b1                         	pop	r1
ffe00171:	fd 17 81                      	mvtachi	r1, a1
ffe00174:	fd 17 b2                      	mvtacgu	r2, a1
ffe00177:	7e b2                         	pop	r2
ffe00179:	7e b1                         	pop	r1
ffe0017b:	fd 17 31                      	mvtacgu	r1, a0
ffe0017e:	fd 17 92                      	mvtaclo	r2, a1
ffe00181:	7e b2                         	pop	r2
ffe00183:	7e b1                         	pop	r1
ffe00185:	fd 17 11                      	mvtaclo	r1, a0
ffe00188:	fd 17 02                      	mvtachi	r2, a0
ffe0018b:	6f 15                         	popm	r1-r5
ffe0018d:	6f ef                         	popm	r14-r15
ffe0018f:	7f 95                         	rte

ffe00191 <.LFE13>:
ffe00191:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe00198 <_excep_floating_point_isr>:
* Description  : Floating point exception ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void excep_floating_point_isr(void)
{
ffe00198:	6e ef                         	pushm	r14-r15
ffe0019a:	6e 15                         	pushm	r1-r5
ffe0019c:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe0019f:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe001a2:	7e a1                         	push.l	r1
ffe001a4:	7e a2                         	push.l	r2
ffe001a6:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe001a9:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe001ac:	7e a1                         	push.l	r1
ffe001ae:	7e a2                         	push.l	r2
ffe001b0:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe001b3:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe001b6:	7e a1                         	push.l	r1
ffe001b8:	7e a2                         	push.l	r2
ffe001ba:	60 40                         	sub	#4, r0

ffe001bc <.LBB308>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffe001bc:	fb 52 80 00 00 00             	mov.l	#128, r5
ffe001c2:	a8 dd                         	mov.l	12[r5], r5
ffe001c4:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffe001cb:	10                            	beq.s	ffe001d3 <_Reset_Vector+0xffe001d7>
                g_bsp_vectors[vector](&cb_args);
ffe001cc:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffe001ce:	f8 06 03                      	mov.l	#3, [r0]
                g_bsp_vectors[vector](&cb_args);
ffe001d1:	7f 15                         	jsr	r5

ffe001d3 <.LVL150>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_EXC_FPU, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);

#ifdef __FPU
    /* Get current FPSW. */
    tmp_fpsw = (uint32_t)R_BSP_GET_FPSW();
ffe001d3:	fd 6a 35                      	mvfc	fpsw, r5

ffe001d6 <.LVL151>:

    /* Clear only the FPU exception flags. */
    R_BSP_SET_FPSW(tmp_fpsw & ((uint32_t)~BSP_PRV_FPU_CAUSE_FLAGS));
ffe001d6:	76 25 03 ff                   	and	#-253, r5

ffe001da <.LVL152>:
ffe001da:	fd 68 53                      	mvtc	r5, fpsw
#endif
} /* End of function excep_floating_point_isr() */
ffe001dd:	62 40                         	add	#4, r0
ffe001df:	7e b2                         	pop	r2
ffe001e1:	7e b1                         	pop	r1
ffe001e3:	fd 17 81                      	mvtachi	r1, a1
ffe001e6:	fd 17 b2                      	mvtacgu	r2, a1
ffe001e9:	7e b2                         	pop	r2
ffe001eb:	7e b1                         	pop	r1
ffe001ed:	fd 17 31                      	mvtacgu	r1, a0
ffe001f0:	fd 17 92                      	mvtaclo	r2, a1
ffe001f3:	7e b2                         	pop	r2
ffe001f5:	7e b1                         	pop	r1
ffe001f7:	fd 17 11                      	mvtaclo	r1, a0
ffe001fa:	fd 17 02                      	mvtachi	r2, a0
ffe001fd:	6f 15                         	popm	r1-r5
ffe001ff:	6f ef                         	popm	r14-r15
ffe00201:	7f 95                         	rte

ffe00203 <.LFE14>:
ffe00203:	77 10 01 00 00                	nop	; mul	#1, r0

ffe00208 <_non_maskable_isr>:
* Description  : Non-maskable interrupt ISR
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void non_maskable_isr(void)
{
ffe00208:	6e 1f                         	pushm	r1-r15
ffe0020a:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe0020d:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe00210:	6e 12                         	pushm	r1-r2
ffe00212:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe00215:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe00218:	6e 12                         	pushm	r1-r2
ffe0021a:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe0021d:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe00220:	6e 12                         	pushm	r1-r2
    /* Determine what is the cause of this interrupt. */

#ifdef BSP_MCU_NMI_EXC_NMI_PIN
    /* EXC_NMI_PIN */
    if ((1 == ICU.NMISR.BIT.NMIST) && (1 == ICU.NMIER.BIT.NMIEN))
ffe00222:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe00227:	ce 75 80 05                   	mov.b	1408[r7], r5
ffe0022b:	7c 05                         	btst	#0, r5
ffe0022d:	21 63                         	bne.b	ffe00290 <_Reset_Vector+0xffe00294>
ffe0022f:	03                            	nop
    }
#endif

#ifdef BSP_MCU_NMI_OSC_STOP_DETECT
    /* OSC_STOP_DETECT */
    if ((1 == ICU.NMISR.BIT.OSTST) && (1 == ICU.NMIER.BIT.OSTEN))
ffe00230:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe00235:	ce 75 80 05                   	mov.b	1408[r7], r5
ffe00239:	7c 15                         	btst	#1, r5
ffe0023b:	3b e9 00                      	bne.w	ffe00324 <_Reset_Vector+0xffe00328>
ffe0023e:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_WDT_ERROR
    /* WDT_ERROR */
    if ((1 == ICU.NMISR.BIT.WDTST) && (1 == ICU.NMIER.BIT.WDTEN))
ffe00240:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe00245:	ce 75 80 05                   	mov.b	1408[r7], r5
ffe00249:	7c 25                         	btst	#2, r5
ffe0024b:	3b c3 00                      	bne.w	ffe0030e <_Reset_Vector+0xffe00312>
ffe0024e:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_IWDT_ERROR
    /* IWDT_ERROR */
    if ((1 == ICU.NMISR.BIT.IWDTST) && (1 == ICU.NMIER.BIT.IWDTEN))
ffe00250:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe00255:	ce 75 80 05                   	mov.b	1408[r7], r5
ffe00259:	7c 35                         	btst	#3, r5
ffe0025b:	3b 9d 00                      	bne.w	ffe002f8 <_Reset_Vector+0xffe002fc>
ffe0025e:	ef 00                         	nop	; mov.l	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_LVD1
    /* LVD1 */
    if ((1 == ICU.NMISR.BIT.LVD1ST) && (1 == ICU.NMIER.BIT.LVD1EN))
ffe00260:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe00265:	ce 75 80 05                   	mov.b	1408[r7], r5
ffe00269:	7c 45                         	btst	#4, r5
ffe0026b:	21 78                         	bne.b	ffe002e3 <_Reset_Vector+0xffe002e7>
ffe0026d:	fc 13 00                      	nop	; max	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_LVD2
    /* LVD2 */
    if ((1 == ICU.NMISR.BIT.LVD2ST) && (1 == ICU.NMIER.BIT.LVD2EN))
ffe00270:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe00275:	ce 75 80 05                   	mov.b	1408[r7], r5
ffe00279:	7c 55                         	btst	#5, r5
ffe0027b:	21 54                         	bne.b	ffe002cf <_Reset_Vector+0xffe002d3>
ffe0027d:	fc 13 00                      	nop	; max	r0, r0
    }
#endif

#ifdef BSP_MCU_NMI_RAM
    /* RAM */
    if ((1 == ICU.NMISR.BIT.RAMST) && (1 == ICU.NMIER.BIT.RAMEN))
ffe00280:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe00285:	ce 75 80 05                   	mov.b	1408[r7], r5
ffe00289:	7c 65                         	btst	#6, r5
ffe0028b:	21 19                         	bne.b	ffe002a4 <_Reset_Vector+0xffe002a8>
    {
        /* Infinite loop. Return from Non-maskable interrupt handlling routine is prohibited.
           Never use the non-maskable interrupt with an attempt to return to the program that was being executed at 
           the time of interrupt generation after the exception handling routine is ended.
         */
         R_BSP_NOP();
ffe0028d:	03                            	nop
ffe0028e:	2e ff                         	bra.b	ffe0028d <_Reset_Vector+0xffe00291>
    if ((1 == ICU.NMISR.BIT.NMIST) && (1 == ICU.NMIER.BIT.NMIEN))
ffe00290:	ce 75 81 05                   	mov.b	1409[r7], r5
ffe00294:	7c 05                         	btst	#0, r5
ffe00296:	20 9a                         	beq.b	ffe00230 <_Reset_Vector+0xffe00234>
        R_BSP_InterruptControl(BSP_INT_SRC_EXC_NMI_PIN, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe00298:	66 21                         	mov.l	#2, r1
ffe0029a:	05 10 35 00                   	bsr.a	ffe037aa <_Reset_Vector+0xffe037ae>

ffe0029e <.LVL153>:
        ICU.NMICLR.BIT.NMICLR = 1;
ffe0029e:	f2 70 82 05                   	bset	#0, 1410[r7].b
ffe002a2:	2e 8e                         	bra.b	ffe00230 <_Reset_Vector+0xffe00234>
    if ((1 == ICU.NMISR.BIT.RAMST) && (1 == ICU.NMIER.BIT.RAMEN))
ffe002a4:	ce 75 81 05                   	mov.b	1409[r7], r5
ffe002a8:	7c 65                         	btst	#6, r5
ffe002aa:	20 e3                         	beq.b	ffe0028d <_Reset_Vector+0xffe00291>
        if(1 == RAM.RAMSTS.BIT.RAMERR)
ffe002ac:	fb 7e 00 12 08                	mov.l	#0x81200, r7
ffe002b1:	88 7d                         	mov.b	1[r7], r5
ffe002b3:	7c 05                         	btst	#0, r5
ffe002b5:	3b 85 00                      	bne.w	ffe0033a <_Reset_Vector+0xffe0033e>
        if(1 == RAM.EXRAMSTS.BIT.EXRAMERR)
ffe002b8:	fb 7e 00 12 08                	mov.l	#0x81200, r7
ffe002bd:	cd 75 41                      	mov.b	65[r7], r5
ffe002c0:	7c 05                         	btst	#0, r5
ffe002c2:	20 cb                         	beq.b	ffe0028d <_Reset_Vector+0xffe00291>
            R_BSP_InterruptControl(BSP_INT_SRC_EXRAM, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe002c4:	66 d1                         	mov.l	#13, r1
ffe002c6:	05 e4 34 00                   	bsr.a	ffe037aa <_Reset_Vector+0xffe037ae>

ffe002ca <.LVL154>:
            RAM.EXRAMSTS.BIT.EXRAMERR = 0;
ffe002ca:	f1 78 41                      	bclr	#0, 65[r7].b
ffe002cd:	2e c0                         	bra.b	ffe0028d <_Reset_Vector+0xffe00291>
    if ((1 == ICU.NMISR.BIT.LVD2ST) && (1 == ICU.NMIER.BIT.LVD2EN))
ffe002cf:	ce 75 81 05                   	mov.b	1409[r7], r5
ffe002d3:	7c 55                         	btst	#5, r5
ffe002d5:	20 ab                         	beq.b	ffe00280 <_Reset_Vector+0xffe00284>
        R_BSP_InterruptControl(BSP_INT_SRC_LVD2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe002d7:	66 91                         	mov.l	#9, r1
ffe002d9:	05 d1 34 00                   	bsr.a	ffe037aa <_Reset_Vector+0xffe037ae>

ffe002dd <.LVL155>:
        ICU.NMICLR.BIT.LVD2CLR = 1;
ffe002dd:	f2 75 82 05                   	bset	#5, 1410[r7].b
ffe002e1:	2e 9f                         	bra.b	ffe00280 <_Reset_Vector+0xffe00284>
    if ((1 == ICU.NMISR.BIT.LVD1ST) && (1 == ICU.NMIER.BIT.LVD1EN))
ffe002e3:	ce 75 81 05                   	mov.b	1409[r7], r5
ffe002e7:	7c 45                         	btst	#4, r5
ffe002e9:	20 87                         	beq.b	ffe00270 <_Reset_Vector+0xffe00274>
        R_BSP_InterruptControl(BSP_INT_SRC_LVD1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe002eb:	66 81                         	mov.l	#8, r1
ffe002ed:	05 bd 34 00                   	bsr.a	ffe037aa <_Reset_Vector+0xffe037ae>

ffe002f1 <.LVL156>:
        ICU.NMICLR.BIT.LVD1CLR = 1;
ffe002f1:	f2 74 82 05                   	bset	#4, 1410[r7].b
ffe002f5:	38 7b ff                      	bra.w	ffe00270 <_Reset_Vector+0xffe00274>
    if ((1 == ICU.NMISR.BIT.IWDTST) && (1 == ICU.NMIER.BIT.IWDTEN))
ffe002f8:	ce 75 81 05                   	mov.b	1409[r7], r5
ffe002fc:	7c 35                         	btst	#3, r5
ffe002fe:	3a 62 ff                      	beq.w	ffe00260 <_Reset_Vector+0xffe00264>
        R_BSP_InterruptControl(BSP_INT_SRC_IWDT_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe00301:	66 71                         	mov.l	#7, r1
ffe00303:	05 a7 34 00                   	bsr.a	ffe037aa <_Reset_Vector+0xffe037ae>

ffe00307 <.LVL157>:
        ICU.NMICLR.BIT.IWDTCLR = 1;
ffe00307:	f2 73 82 05                   	bset	#3, 1410[r7].b
ffe0030b:	38 55 ff                      	bra.w	ffe00260 <_Reset_Vector+0xffe00264>
    if ((1 == ICU.NMISR.BIT.WDTST) && (1 == ICU.NMIER.BIT.WDTEN))
ffe0030e:	ce 75 81 05                   	mov.b	1409[r7], r5
ffe00312:	7c 25                         	btst	#2, r5
ffe00314:	3a 3c ff                      	beq.w	ffe00250 <_Reset_Vector+0xffe00254>
        R_BSP_InterruptControl(BSP_INT_SRC_WDT_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe00317:	66 61                         	mov.l	#6, r1
ffe00319:	05 91 34 00                   	bsr.a	ffe037aa <_Reset_Vector+0xffe037ae>

ffe0031d <.LVL158>:
        ICU.NMICLR.BIT.WDTCLR = 1;
ffe0031d:	f2 72 82 05                   	bset	#2, 1410[r7].b
ffe00321:	38 2f ff                      	bra.w	ffe00250 <_Reset_Vector+0xffe00254>
    if ((1 == ICU.NMISR.BIT.OSTST) && (1 == ICU.NMIER.BIT.OSTEN))
ffe00324:	ce 75 81 05                   	mov.b	1409[r7], r5
ffe00328:	7c 15                         	btst	#1, r5
ffe0032a:	3a 16 ff                      	beq.w	ffe00240 <_Reset_Vector+0xffe00244>
        R_BSP_InterruptControl(BSP_INT_SRC_OSC_STOP_DETECT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe0032d:	66 51                         	mov.l	#5, r1
ffe0032f:	05 7b 34 00                   	bsr.a	ffe037aa <_Reset_Vector+0xffe037ae>

ffe00333 <.LVL159>:
        ICU.NMICLR.BIT.OSTCLR = 1;
ffe00333:	f2 71 82 05                   	bset	#1, 1410[r7].b
ffe00337:	38 09 ff                      	bra.w	ffe00240 <_Reset_Vector+0xffe00244>
            R_BSP_InterruptControl(BSP_INT_SRC_RAM, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe0033a:	66 c1                         	mov.l	#12, r1
ffe0033c:	05 6e 34 00                   	bsr.a	ffe037aa <_Reset_Vector+0xffe037ae>

ffe00340 <.LVL160>:
            RAM.RAMSTS.BIT.RAMERR = 0;
ffe00340:	f1 78 01                      	bclr	#0, 1[r7].b
ffe00343:	38 75 ff                      	bra.w	ffe002b8 <_Reset_Vector+0xffe002bc>

ffe00346 <.LFE15>:
ffe00346:	ef 00                         	nop	; mov.l	r0, r0

ffe00348 <_undefined_interrupt_source_isr>:
*                Set a breakpoint in this function to determine which source is creating unwanted interrupts.
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void undefined_interrupt_source_isr(void)
{
ffe00348:	6e ef                         	pushm	r14-r15
ffe0034a:	6e 15                         	pushm	r1-r5
ffe0034c:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe0034f:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe00352:	7e a1                         	push.l	r1
ffe00354:	7e a2                         	push.l	r2
ffe00356:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe00359:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe0035c:	7e a1                         	push.l	r1
ffe0035e:	7e a2                         	push.l	r2
ffe00360:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe00363:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe00366:	7e a1                         	push.l	r1
ffe00368:	7e a2                         	push.l	r2
ffe0036a:	60 40                         	sub	#4, r0

ffe0036c <.LBB312>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffe0036c:	fb 52 80 00 00 00             	mov.l	#128, r5
ffe00372:	aa d5                         	mov.l	40[r5], r5
ffe00374:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffe0037b:	10                            	beq.s	ffe00383 <_Reset_Vector+0xffe00387>
                g_bsp_vectors[vector](&cb_args);
ffe0037c:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffe0037e:	f8 06 0a                      	mov.l	#10, [r0]
                g_bsp_vectors[vector](&cb_args);
ffe00381:	7f 15                         	jsr	r5

ffe00383 <.LVL162>:
    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_UNDEFINED_INTERRUPT, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function undefined_interrupt_source_isr() */
ffe00383:	62 40                         	add	#4, r0
ffe00385:	7e b2                         	pop	r2
ffe00387:	7e b1                         	pop	r1
ffe00389:	fd 17 81                      	mvtachi	r1, a1
ffe0038c:	fd 17 b2                      	mvtacgu	r2, a1
ffe0038f:	7e b2                         	pop	r2
ffe00391:	7e b1                         	pop	r1
ffe00393:	fd 17 31                      	mvtacgu	r1, a0
ffe00396:	fd 17 92                      	mvtaclo	r2, a1
ffe00399:	7e b2                         	pop	r2
ffe0039b:	7e b1                         	pop	r1
ffe0039d:	fd 17 11                      	mvtaclo	r1, a0
ffe003a0:	fd 17 02                      	mvtachi	r2, a0
ffe003a3:	6f 15                         	popm	r1-r5
ffe003a5:	6f ef                         	popm	r14-r15
ffe003a7:	7f 95                         	rte

ffe003a9 <.LFE16>:
ffe003a9:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe003b0 <_bus_error_isr>:
*                application.
* Arguments    : none
* Return value : none
***********************************************************************************************************************/
R_BSP_ATTRIB_INTERRUPT void bus_error_isr (void)
{
ffe003b0:	6e ef                         	pushm	r14-r15
ffe003b2:	6e 15                         	pushm	r1-r5
ffe003b4:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe003b7:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe003ba:	7e a1                         	push.l	r1
ffe003bc:	7e a2                         	push.l	r2
ffe003be:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe003c1:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe003c4:	7e a1                         	push.l	r1
ffe003c6:	7e a2                         	push.l	r2
ffe003c8:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe003cb:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe003ce:	7e a1                         	push.l	r1
ffe003d0:	7e a2                         	push.l	r2
ffe003d2:	60 40                         	sub	#4, r0
    /* Clear the bus error */
    BSC.BERCLR.BIT.STSCLR = 1;
ffe003d4:	fb 5e 00 13 08                	mov.l	#0x81300, r5
ffe003d9:	f0 50                         	bset	#0, [r5].b

ffe003db <.LBB316>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffe003db:	fb 52 80 00 00 00             	mov.l	#128, r5
ffe003e1:	aa dd                         	mov.l	44[r5], r5
ffe003e3:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffe003ea:	10                            	beq.s	ffe003f2 <_Reset_Vector+0xffe003f6>
                g_bsp_vectors[vector](&cb_args);
ffe003eb:	ef 01                         	mov.l	r0, r1
                cb_args.vector = vector;
ffe003ed:	f8 06 0b                      	mov.l	#11, [r0]
                g_bsp_vectors[vector](&cb_args);
ffe003f0:	7f 15                         	jsr	r5

ffe003f2 <.LVL164>:
        The upper 13 bits of this register contain the upper 13-bits of the offending address (in 512K byte units)
    */

    /* If user has registered a callback for this exception then call it. */
    R_BSP_InterruptControl(BSP_INT_SRC_BUS_ERROR, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
} /* End of function bus_error_isr() */
ffe003f2:	62 40                         	add	#4, r0
ffe003f4:	7e b2                         	pop	r2
ffe003f6:	7e b1                         	pop	r1
ffe003f8:	fd 17 81                      	mvtachi	r1, a1
ffe003fb:	fd 17 b2                      	mvtacgu	r2, a1
ffe003fe:	7e b2                         	pop	r2
ffe00400:	7e b1                         	pop	r1
ffe00402:	fd 17 31                      	mvtacgu	r1, a0
ffe00405:	fd 17 92                      	mvtaclo	r2, a1
ffe00408:	7e b2                         	pop	r2
ffe0040a:	7e b1                         	pop	r1
ffe0040c:	fd 17 11                      	mvtaclo	r1, a0
ffe0040f:	fd 17 02                      	mvtachi	r2, a0
ffe00412:	6f 15                         	popm	r1-r5
ffe00414:	6f ef                         	popm	r14-r15
ffe00416:	7f 95                         	rte

ffe00418 <_r_Config_SCI0_transmitend_interrupt>:
* Return Value : None
***********************************************************************************************************************/

void r_Config_SCI0_transmitend_interrupt(void)
{
    if (_80_SCI_IIC_START_CYCLE == g_sci0_iic_cycle_flag)
ffe00418:	fb 42 01 04 00 00             	mov.l	#0x401, r4
ffe0041e:	58 45                         	movu.b	[r4], r5
ffe00420:	75 55 80                      	cmp	#128, r5
ffe00423:	20 22                         	beq.b	ffe00445 <_Reset_Vector+0xffe00449>
        SCI0.SIMR3.BIT.IICSTIF = 0U;
        SCI0.SIMR3.BIT.IICSCLS = 0U;
        SCI0.SIMR3.BIT.IICSDAS = 0U;
        SCI0.TDR = g_sci0_slave_address;
    }
    else if (_00_SCI_IIC_STOP_CYCLE == g_sci0_iic_cycle_flag)
ffe00425:	58 45                         	movu.b	[r4], r5
ffe00427:	61 05                         	cmp	#0, r5
ffe00429:	21 1b                         	bne.b	ffe00444 <_Reset_Vector+0xffe00448>
    {
        SCI0.SIMR3.BIT.IICSTIF = 0U;
ffe0042b:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
        SCI0.SIMR3.BYTE |= (_30_SCI_SSDA_HIGH_IMPEDANCE | _C0_SCI_SSCL_HIGH_IMPEDANCE);
        if (_80_SCI_IIC_TRANSMISSION == g_sci0_iic_transmit_receive_flag)
ffe00430:	fb 32 fc 03 00 00             	mov.l	#0x3fc, r3
        SCI0.SIMR3.BIT.IICSTIF = 0U;
ffe00436:	f1 5b 0b                      	bclr	#3, 11[r5].b
        SCI0.SIMR3.BYTE |= (_30_SCI_SSDA_HIGH_IMPEDANCE | _C0_SCI_SSCL_HIGH_IMPEDANCE);
ffe00439:	8a dc                         	mov.b	11[r5], r4
ffe0043b:	75 34 f0                      	or	#-16, r4
ffe0043e:	82 dc                         	mov.b	r4, 11[r5]
        if (_80_SCI_IIC_TRANSMISSION == g_sci0_iic_transmit_receive_flag)
ffe00440:	cc 35                         	mov.b	[r3], r5
        {
            r_Config_SCI0_callback_transmitend();
        }
        if (_00_SCI_IIC_RECEPTION == g_sci0_iic_transmit_receive_flag)
ffe00442:	cc 35                         	mov.b	[r3], r5
    }
    else
    {
        /* Do nothing */
    }
}
ffe00444:	02                            	rts
        SCI0.SIMR3.BIT.IICSTIF = 0U;
ffe00445:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffe0044a:	f1 5b 0b                      	bclr	#3, 11[r5].b
        SCI0.SIMR3.BIT.IICSCLS = 0U;
ffe0044d:	8a dc                         	mov.b	11[r5], r4
ffe0044f:	75 24 3f                      	and	#63, r4
ffe00452:	82 dc                         	mov.b	r4, 11[r5]
        SCI0.SIMR3.BIT.IICSDAS = 0U;
ffe00454:	8a dc                         	mov.b	11[r5], r4
ffe00456:	75 24 cf                      	and	#-49, r4
ffe00459:	82 dc                         	mov.b	r4, 11[r5]
        SCI0.TDR = g_sci0_slave_address;
ffe0045b:	fb 42 00 04 00 00             	mov.l	#0x400, r4
ffe00461:	cc 44                         	mov.b	[r4], r4
ffe00463:	80 dc                         	mov.b	r4, 3[r5]
ffe00465:	02                            	rts

ffe00466 <.LFE6>:
	...

ffe00468 <_r_Config_RIIC0_transmitend_interrupt>:
* Return Value : None
***********************************************************************************************************************/

void r_Config_RIIC0_transmitend_interrupt(void)
{
    if (_06_IIC_MASTER_SENDS_END == g_riic0_state)
ffe00468:	fb 42 24 04 00 00             	mov.l	#0x424, r4
ffe0046e:	58 45                         	movu.b	[r4], r5
ffe00470:	61 65                         	cmp	#6, r5
ffe00472:	20 1b                         	beq.b	ffe0048d <_Reset_Vector+0xffe00491>
        {
            RIIC0.ICSR2.BIT.TEND = 0U;
            r_Config_RIIC0_callback_transmitend();
        }
    }
    else if (_0E_IIC_MASTER_RECEIVES_RESTART == g_riic0_state)
ffe00474:	58 45                         	movu.b	[r4], r5
ffe00476:	61 e5                         	cmp	#14, r5
ffe00478:	20 03                         	beq.b	ffe0047b <_Reset_Vector+0xffe0047f>
    }
    else
    {
        /* Do nothing */
    }
}
ffe0047a:	02                            	rts
        RIIC0.ICSR2.BIT.START = 0U;
ffe0047b:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe00480:	f1 5a 09                      	bclr	#2, 9[r5].b
        RIIC0.ICIER.BIT.STIE = 1U;
ffe00483:	f1 52 07                      	bset	#2, 7[r5].b
        RIIC0.ICCR2.BIT.RS = 1U;    /* Set restart condition flag */
ffe00486:	f1 52 01                      	bset	#2, 1[r5].b
        RIIC0.ICSR2.BIT.TEND = 0U;
ffe00489:	f1 5e 09                      	bclr	#6, 9[r5].b
}
ffe0048c:	02                            	rts
        if (1U == g_riic0_stop_generation)
ffe0048d:	fb 52 14 04 00 00             	mov.l	#0x414, r5
ffe00493:	58 55                         	movu.b	[r5], r5
ffe00495:	61 15                         	cmp	#1, r5
            RIIC0.ICSR2.BIT.STOP = 0U;
ffe00497:	fb 5e 00 83 08                	mov.l	#0x88300, r5
        if (1U == g_riic0_stop_generation)
ffe0049c:	21 ed                         	bne.b	ffe00489 <_Reset_Vector+0xffe0048d>
            RIIC0.ICSR2.BIT.STOP = 0U;
ffe0049e:	f1 5b 09                      	bclr	#3, 9[r5].b
            RIIC0.ICCR2.BIT.SP = 1U;
ffe004a1:	f1 53 01                      	bset	#3, 1[r5].b
            g_riic0_state = _07_IIC_MASTER_SENDS_STOP;
ffe004a4:	f8 44 07                      	mov.b	#7, [r4]
ffe004a7:	02                            	rts

ffe004a8 <_r_Config_RIIC0_error_interrupt>:

void r_Config_RIIC0_error_interrupt(void)
{
    volatile uint8_t dummy;

    if ((1U == RIIC0.ICIER.BIT.ALIE) && (1U == RIIC0.ICSR2.BIT.AL))
ffe004a8:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe004ad:	89 dc                         	mov.b	7[r5], r4
ffe004af:	7c 14                         	btst	#1, r4
ffe004b1:	21 6b                         	bne.b	ffe0051c <_Reset_Vector+0xffe00520>
    {
        r_Config_RIIC0_callback_error(MD_ERROR1);
    }
    else if ((1U == RIIC0.ICIER.BIT.TMOIE) && (1U == RIIC0.ICSR2.BIT.TMOF))
ffe004b3:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe004b8:	89 dc                         	mov.b	7[r5], r4
ffe004ba:	7c 04                         	btst	#0, r4
ffe004bc:	21 6a                         	bne.b	ffe00526 <_Reset_Vector+0xffe0052a>
ffe004be:	ef 00                         	nop	; mov.l	r0, r0
    {
        r_Config_RIIC0_callback_error(MD_ERROR2);
    }
    else if ((1U == RIIC0.ICIER.BIT.NAKIE) && (1U == RIIC0.ICSR2.BIT.NACKF))
ffe004c0:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe004c5:	89 dc                         	mov.b	7[r5], r4
ffe004c7:	7c 44                         	btst	#4, r4
ffe004c9:	21 72                         	bne.b	ffe0053b <_Reset_Vector+0xffe0053f>
ffe004cb:	77 10 01 00 00                	nop	; mul	#1, r0
            /* Do nothing */
        }

        r_Config_RIIC0_callback_error(MD_ERROR3);
    }
    else if (_0D_IIC_MASTER_TRANSMIT == g_riic0_mode_flag)
ffe004d0:	fb 42 10 04 00 00             	mov.l	#0x410, r4
ffe004d6:	58 45                         	movu.b	[r4], r5
ffe004d8:	61 d5                         	cmp	#13, r5
ffe004da:	11                            	beq.s	ffe004e3 <_Reset_Vector+0xffe004e7>
        else
        {
            r_Config_RIIC0_callback_error(MD_ERROR4);
        }
    }
    else if (_0C_IIC_MASTER_RECEIVE == g_riic0_mode_flag)
ffe004db:	58 45                         	movu.b	[r4], r5
ffe004dd:	61 c5                         	cmp	#12, r5
ffe004df:	3a 8f 00                      	beq.w	ffe0056e <_Reset_Vector+0xffe00572>
ffe004e2:	02                            	rts
        if ((_01_IIC_MASTER_SENDS_ADR_7_W == g_riic0_state) || (_02_IIC_MASTER_SENDS_ADR_10A_W == g_riic0_state))
ffe004e3:	fb 42 24 04 00 00             	mov.l	#0x424, r4
ffe004e9:	58 45                         	movu.b	[r4], r5
ffe004eb:	61 15                         	cmp	#1, r5
ffe004ed:	20 20                         	beq.b	ffe0050d <_Reset_Vector+0xffe00511>
ffe004ef:	58 45                         	movu.b	[r4], r5
ffe004f1:	61 25                         	cmp	#2, r5
ffe004f3:	20 1a                         	beq.b	ffe0050d <_Reset_Vector+0xffe00511>
        else if (_07_IIC_MASTER_SENDS_STOP == g_riic0_state)
ffe004f5:	58 45                         	movu.b	[r4], r5
ffe004f7:	61 75                         	cmp	#7, r5
ffe004f9:	21 e9                         	bne.b	ffe004e2 <_Reset_Vector+0xffe004e6>
            RIIC0.ICIER.BIT.STIE = 0U;
            g_riic0_state = _03_IIC_MASTER_SENDS_ADR_10A_R;
        }
        else if (_0B_IIC_MASTER_RECEIVES_STOP == g_riic0_state)
        {
            RIIC0.ICSR2.BIT.NACKF = 0U;
ffe004fb:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe00500:	f1 5c 09                      	bclr	#4, 9[r5].b
            RIIC0.ICSR2.BIT.STOP = 0U;
ffe00503:	f1 5b 09                      	bclr	#3, 9[r5].b
            RIIC0.ICIER.BIT.SPIE = 0U;
ffe00506:	f1 5b 07                      	bclr	#3, 7[r5].b
            RIIC0.ICIER.BIT.STIE = 1U;
ffe00509:	f1 52 07                      	bset	#2, 7[r5].b
    }
    else
    {
        r_Config_RIIC0_callback_error(MD_ERROR4);
    }
}
ffe0050c:	02                            	rts
            RIIC0.ICSR2.BIT.START = 0U;
ffe0050d:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe00512:	f1 5a 09                      	bclr	#2, 9[r5].b
            RIIC0.ICIER.BIT.STIE = 0U;
ffe00515:	f1 5a 07                      	bclr	#2, 7[r5].b
            RIIC0.ICIER.BIT.SPIE = 1U;
ffe00518:	f1 53 07                      	bset	#3, 7[r5].b
ffe0051b:	02                            	rts
    if ((1U == RIIC0.ICIER.BIT.ALIE) && (1U == RIIC0.ICSR2.BIT.AL))
ffe0051c:	8a 5c                         	mov.b	9[r5], r4
ffe0051e:	7c 14                         	btst	#1, r4
ffe00520:	20 93                         	beq.b	ffe004b3 <_Reset_Vector+0xffe004b7>

ffe00522 <.LBB28>:
        case MD_ERROR1:
        {
            /* Start user code for arbitration-lost error. Do not edit comment generated here */
            /* End user code. Do not edit comment generated here */

            RIIC0.ICSR2.BIT.AL = 0U;
ffe00522:	f1 59 09                      	bclr	#1, 9[r5].b
            break;
ffe00525:	02                            	rts

ffe00526 <.LVL1>:
    else if ((1U == RIIC0.ICIER.BIT.TMOIE) && (1U == RIIC0.ICSR2.BIT.TMOF))
ffe00526:	8a 5c                         	mov.b	9[r5], r4
ffe00528:	7c 04                         	btst	#0, r4
ffe0052a:	20 96                         	beq.b	ffe004c0 <_Reset_Vector+0xffe004c4>

ffe0052c <.LBB30>:
        }
        case MD_ERROR2:
        {
            if (1U == RIIC0.ICCR1.BIT.SCLI)
ffe0052c:	cc 54                         	mov.b	[r5], r4
ffe0052e:	7c 14                         	btst	#1, r4
ffe00530:	21 5e                         	bne.b	ffe0058e <_Reset_Vector+0xffe00592>
            }

            /* Start user code for timeout error. Do not edit comment generated here */
            /* End user code. Do not edit comment generated here */

            RIIC0.ICSR2.BIT.TMOF = 0U;
ffe00532:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe00537:	f1 58 09                      	bclr	#0, 9[r5].b
            break;
ffe0053a:	02                            	rts

ffe0053b <.LBE36>:
    else if ((1U == RIIC0.ICIER.BIT.NAKIE) && (1U == RIIC0.ICSR2.BIT.NACKF))
ffe0053b:	8a 5c                         	mov.b	9[r5], r4
ffe0053d:	7c 44                         	btst	#4, r4
ffe0053f:	20 91                         	beq.b	ffe004d0 <_Reset_Vector+0xffe004d4>
        if (_0D_IIC_MASTER_TRANSMIT == g_riic0_mode_flag)
ffe00541:	fb 32 10 04 00 00             	mov.l	#0x410, r3
ffe00547:	58 34                         	movu.b	[r3], r4
ffe00549:	61 d4                         	cmp	#13, r4
ffe0054b:	3a b1 00                      	beq.w	ffe005fc <_Reset_Vector+0xffe00600>
        else if (_0C_IIC_MASTER_RECEIVE == g_riic0_mode_flag)
ffe0054e:	58 34                         	movu.b	[r3], r4
ffe00550:	61 c4                         	cmp	#12, r4
ffe00552:	21 90                         	bne.b	ffe004e2 <_Reset_Vector+0xffe004e6>
{
ffe00554:	60 40                         	sub	#4, r0
            RIIC0.ICSR2.BIT.STOP = 0U;
ffe00556:	f1 5b 09                      	bclr	#3, 9[r5].b
            RIIC0.ICCR2.BIT.SP = 1U;
ffe00559:	f1 53 01                      	bset	#3, 1[r5].b
            dummy = RIIC0.ICDRR;
ffe0055c:	8c dc                         	mov.b	19[r5], r4
ffe0055e:	c3 04                         	mov.b	r4, [r0]
            RIIC0.ICSR2.BIT.NACKF = 0U;
ffe00560:	f1 5c 09                      	bclr	#4, 9[r5].b
            g_riic0_state = _0B_IIC_MASTER_RECEIVES_STOP;
ffe00563:	fb 52 24 04 00 00             	mov.l	#0x424, r5
ffe00569:	f8 54 0b                      	mov.b	#11, [r5]
}
ffe0056c:	67 01                         	rtsd	#4
        if ((_00_IIC_MASTER_SENDS_ADR_7_R == g_riic0_state) || (_02_IIC_MASTER_SENDS_ADR_10A_W == g_riic0_state))
ffe0056e:	fb 42 24 04 00 00             	mov.l	#0x424, r4
ffe00574:	58 45                         	movu.b	[r4], r5
ffe00576:	61 05                         	cmp	#0, r5
ffe00578:	20 95                         	beq.b	ffe0050d <_Reset_Vector+0xffe00511>
ffe0057a:	58 45                         	movu.b	[r4], r5
ffe0057c:	61 25                         	cmp	#2, r5
ffe0057e:	20 8f                         	beq.b	ffe0050d <_Reset_Vector+0xffe00511>
        else if (_0E_IIC_MASTER_RECEIVES_RESTART == g_riic0_state)
ffe00580:	58 45                         	movu.b	[r4], r5
ffe00582:	61 e5                         	cmp	#14, r5
ffe00584:	20 69                         	beq.b	ffe005ed <_Reset_Vector+0xffe005f1>
        else if (_0B_IIC_MASTER_RECEIVES_STOP == g_riic0_state)
ffe00586:	58 45                         	movu.b	[r4], r5
ffe00588:	61 b5                         	cmp	#11, r5
ffe0058a:	3a 71 ff                      	beq.w	ffe004fb <_Reset_Vector+0xffe004ff>
ffe0058d:	02                            	rts

ffe0058e <.LBB33>:
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe0058e:	cc 54                         	mov.b	[r5], r4
ffe00590:	7c 04                         	btst	#0, r4
ffe00592:	21 a0                         	bne.b	ffe00532 <_Reset_Vector+0xffe00536>

ffe00594 <.LVL5>:
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe00594:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe00596:	cc 54                         	mov.b	[r5], r4
ffe00598:	7c 04                         	btst	#0, r4
ffe0059a:	21 98                         	bne.b	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe0059c:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe0059e:	cc 54                         	mov.b	[r5], r4
ffe005a0:	7c 04                         	btst	#0, r4
ffe005a2:	21 90                         	bne.b	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe005a4:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe005a6:	cc 54                         	mov.b	[r5], r4
ffe005a8:	7c 04                         	btst	#0, r4
ffe005aa:	21 88                         	bne.b	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe005ac:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe005ae:	cc 54                         	mov.b	[r5], r4
ffe005b0:	7c 04                         	btst	#0, r4
ffe005b2:	21 80                         	bne.b	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe005b4:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe005b6:	cc 54                         	mov.b	[r5], r4
ffe005b8:	7c 04                         	btst	#0, r4
ffe005ba:	3b 78 ff                      	bne.w	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe005bd:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe005bf:	cc 55                         	mov.b	[r5], r5
ffe005c1:	7c 05                         	btst	#0, r5
ffe005c3:	3b 6f ff                      	bne.w	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe005c6:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe005cb:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe005cd:	cc 54                         	mov.b	[r5], r4
ffe005cf:	7c 04                         	btst	#0, r4
ffe005d1:	3b 61 ff                      	bne.w	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe005d4:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe005d6:	cc 54                         	mov.b	[r5], r4
ffe005d8:	7c 04                         	btst	#0, r4
ffe005da:	3b 58 ff                      	bne.w	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe005dd:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe005df:	cc 54                         	mov.b	[r5], r4
ffe005e1:	7c 04                         	btst	#0, r4
ffe005e3:	3b 4f ff                      	bne.w	ffe00532 <_Reset_Vector+0xffe00536>
                    RIIC0.ICCR1.BIT.CLO = 1U;
ffe005e6:	f0 55                         	bset	#5, [r5].b
                while ((0U == RIIC0.ICCR1.BIT.SDAI) && (count < 0x0AU))
ffe005e8:	cc 55                         	mov.b	[r5], r5
ffe005ea:	38 48 ff                      	bra.w	ffe00532 <_Reset_Vector+0xffe00536>

ffe005ed <.LBE37>:
            RIIC0.ICSR2.BIT.START = 0U;
ffe005ed:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe005f2:	f1 5a 09                      	bclr	#2, 9[r5].b
            RIIC0.ICIER.BIT.STIE = 0U;
ffe005f5:	f1 5a 07                      	bclr	#2, 7[r5].b
            g_riic0_state = _03_IIC_MASTER_SENDS_ADR_10A_R;
ffe005f8:	f8 44 03                      	mov.b	#3, [r4]
ffe005fb:	02                            	rts
            RIIC0.ICSR2.BIT.STOP = 0U;
ffe005fc:	f1 5b 09                      	bclr	#3, 9[r5].b
            RIIC0.ICCR2.BIT.SP = 1U;
ffe005ff:	f1 53 01                      	bset	#3, 1[r5].b
            RIIC0.ICSR2.BIT.NACKF = 0U;
ffe00602:	f1 5c 09                      	bclr	#4, 9[r5].b
            g_riic0_state = _07_IIC_MASTER_SENDS_STOP;
ffe00605:	fb 52 24 04 00 00             	mov.l	#0x424, r5
ffe0060b:	f8 54 07                      	mov.b	#7, [r5]
ffe0060e:	02                            	rts

ffe0060f <.LFE9>:
ffe0060f:	03                            	nop

ffe00610 <_r_sci_iic_init_io_register>:
{
ffe00610:	6e 6c                         	pushm	r6-r12
ffe00612:	60 80                         	sub	#8, r0
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00614:	fb 72 cc 5f e0 ff             	mov.l	#0xffe05fcc, r7
ffe0061a:	59 1a 03                      	movu.b	3[r1], r10
ffe0061d:	fe 6a 7a                      	mov.l	[r10, r7], r10
ffe00620:	ec a3                         	mov.l	[r10], r3
ffe00622:	a8 3d                         	mov.l	4[r3], r5

ffe00624 <.LVL43>:
    pregs->SCR.BYTE = SCI_IIC_SCR_INIT;
ffe00624:	3c 52 00                      	mov.b	#0, 2[r5]
    sci_iic_set_frequency(p_sci_iic_info);
ffe00627:	88 9c                         	mov.b	3[r1], r4

ffe00629 <.LBB4>:
    volatile uint16_t brr_n = 32U; /* default: 64*2^(2*0-1) = 32 */
ffe00629:	3d 02 20                      	mov.w	#32, 4[r0]
    volatile uint8_t cks_value = 0U; /* default: PCLK/1 */
ffe0062c:	3c 06 00                      	mov.b	#0, 6[r0]
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe0062f:	5b 4a                         	movu.b	r4, r10
    if ((SCI_IIC_NUM_CH10 == p_sci_iic_info->ch_no) || (SCI_IIC_NUM_CH11 == p_sci_iic_info->ch_no))
ffe00631:	60 a4                         	sub	#10, r4
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00633:	fe 6a 77                      	mov.l	[r10, r7], r7
    if ((SCI_IIC_NUM_CH10 == p_sci_iic_info->ch_no) || (SCI_IIC_NUM_CH11 == p_sci_iic_info->ch_no))
ffe00636:	5b 44                         	movu.b	r4, r4
    volatile uint32_t brr_value = 0U;
ffe00638:	f8 06 00                      	mov.l	#0, [r0]
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe0063b:	ec 72                         	mov.l	[r7], r2
ffe0063d:	a8 29                         	mov.l	4[r2], r1

ffe0063f <.LVL45>:
        brr_n_tmp = brr_n;
ffe0063f:	98 87                         	mov.w	4[r0], r7
    if ((SCI_IIC_NUM_CH10 == p_sci_iic_info->ch_no) || (SCI_IIC_NUM_CH11 == p_sci_iic_info->ch_no))
ffe00641:	61 14                         	cmp	#1, r4
ffe00643:	24 05                         	bgtu.b	ffe00648 <_Reset_Vector+0xffe0064c>
ffe00645:	38 ff 00                      	bra.w	ffe00744 <_Reset_Vector+0xffe00748>

ffe00648 <.LVL46>:
        brr_value = (uint32_t) ((double) ((double) ((double) BSP_PCLKB_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffe00648:	ac 24                         	mov.l	64[r2], r4
ffe0064a:	fb a2 c0 e1 64 4c             	mov.l	#0x4c64e1c0, r10
ffe00650:	5f 77                         	movu.w	r7, r7

ffe00652 <.LVL47>:
ffe00652:	4f 47                         	mul	r4, r7

ffe00654 <.LVL48>:
ffe00654:	fc 57 77                      	utof	r7, r7
ffe00657:	ef a4                         	mov.l	r10, r4
ffe00659:	fc 93 74                      	fdiv	r7, r4
ffe0065c:	ef 47                         	mov.l	r4, r7
ffe0065e:	fd 72 07 cd cc cc 3d          	fsub	#0x3dcccccd, r7
ffe00665:	fc a7 77                      	ftou	r7, r7
ffe00668:	e3 07                         	mov.l	r7, [r0]
    while (brr_value > 255)
ffe0066a:	ec 07                         	mov.l	[r0], r7
ffe0066c:	75 57 ff                      	cmp	#255, r7
ffe0066f:	25 71                         	bleu.b	ffe006e0 <_Reset_Vector+0xffe006e4>
                brr_n = 512; /* 64*(2^(2*2-1))  */
ffe00671:	fb ea 00 02                   	mov.l	#512, r14
                cks_value = 2; /* clock select: PCLK/16 */
ffe00675:	66 29                         	mov.l	#2, r9
                brr_n = 2048; /* 64*(2^(2*3-1)) */
ffe00677:	fb ca 00 08                   	mov.l	#0x800, r12
                cks_value = 3; /* clock select: PCLK/64 */
ffe0067b:	66 3b                         	mov.l	#3, r11
                brr_n = 128; /* 64*(2^(2*1-1)) */
ffe0067d:	75 46 80                      	mov.l	#128, r6
                cks_value = 1; /* clock select: PCLK/4 */
ffe00680:	66 14                         	mov.l	#1, r4
            brr_value = 255;
ffe00682:	75 4f ff                      	mov.l	#255, r15
ffe00685:	2e 0b                         	bra.b	ffe00690 <_Reset_Vector+0xffe00694>
    while (brr_value > 255)
ffe00687:	ec 07                         	mov.l	[r0], r7
ffe00689:	75 57 ff                      	cmp	#255, r7
ffe0068c:	25 54                         	bleu.b	ffe006e0 <_Reset_Vector+0xffe006e4>
ffe0068e:	ef 00                         	nop	; mov.l	r0, r0
        switch (brr_n)
ffe00690:	b8 87                         	movu.w	4[r0], r7
ffe00692:	75 57 80                      	cmp	#128, r7
ffe00695:	3a a6 00                      	beq.w	ffe0073b <_Reset_Vector+0xffe0073f>
ffe00698:	76 07 00 02                   	cmp	#512, r7
ffe0069c:	3a 96 00                      	beq.w	ffe00732 <_Reset_Vector+0xffe00736>
ffe0069f:	75 57 20                      	cmp	#32, r7
ffe006a2:	3a 89 00                      	beq.w	ffe0072b <_Reset_Vector+0xffe0072f>
ffe006a5:	fc 13 00                      	nop	; max	r0, r0
            brr_n_tmp = brr_n;
ffe006a8:	98 87                         	mov.w	4[r0], r7

ffe006aa <.LVL49>:
            brr_value = (uint32_t) ((double) (((double) BSP_PCLKB_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffe006aa:	ed 28 10                      	mov.l	64[r2], r8
ffe006ad:	5f 77                         	movu.w	r7, r7

ffe006af <.LVL50>:
ffe006af:	4f 87                         	mul	r8, r7

ffe006b1 <.LVL51>:
ffe006b1:	fc 57 77                      	utof	r7, r7
ffe006b4:	ef a8                         	mov.l	r10, r8
ffe006b6:	fc 93 78                      	fdiv	r7, r8
ffe006b9:	ef 87                         	mov.l	r8, r7
ffe006bb:	fd 72 07 cd cc cc 3d          	fsub	#0x3dcccccd, r7
ffe006c2:	fc a7 77                      	ftou	r7, r7
ffe006c5:	e3 07                         	mov.l	r7, [r0]
        if ((3 == cks_value) && (255 < brr_value))
ffe006c7:	b1 87                         	movu.b	6[r0], r7
ffe006c9:	61 37                         	cmp	#3, r7
ffe006cb:	21 bc                         	bne.b	ffe00687 <_Reset_Vector+0xffe0068b>
ffe006cd:	ec 07                         	mov.l	[r0], r7
ffe006cf:	75 57 ff                      	cmp	#255, r7
ffe006d2:	25 b5                         	bleu.b	ffe00687 <_Reset_Vector+0xffe0068b>
            brr_value = 255;
ffe006d4:	e3 0f                         	mov.l	r15, [r0]
    while (brr_value > 255)
ffe006d6:	ec 07                         	mov.l	[r0], r7
ffe006d8:	75 57 ff                      	cmp	#255, r7
ffe006db:	24 b5                         	bgtu.b	ffe00690 <_Reset_Vector+0xffe00694>
ffe006dd:	fc 13 00                      	nop	; max	r0, r0
    cks_value_tmp = cks_value;
ffe006e0:	89 84                         	mov.b	6[r0], r4

ffe006e2 <.LVL52>:
    pregs->SMR.BYTE |= cks_value_tmp; /* Sets SMR */
ffe006e2:	cc 12                         	mov.b	[r1], r2

ffe006e4 <.LVL53>:
ffe006e4:	57 24                         	or	r2, r4

ffe006e6 <.LVL54>:
ffe006e6:	c3 14                         	mov.b	r4, [r1]

ffe006e8 <.LVL55>:
    pregs->BRR = brr_value; /* Sets BRR */
ffe006e8:	ec 07                         	mov.l	[r0], r7
ffe006ea:	80 1f                         	mov.b	r7, 1[r1]

ffe006ec <.LBE4>:
    pregs->SEMR.BIT.NFEN = prom->df_sel;
ffe006ec:	cd 34 44                      	mov.b	68[r3], r4
ffe006ef:	89 df                         	mov.b	7[r5], r7
ffe006f1:	7c 04                         	btst	#0, r4
ffe006f3:	fd e5 17                      	bmne	#5, r7
ffe006f6:	81 df                         	mov.b	r7, 7[r5]
    pregs->SNFR.BIT.NFCS = prom->df_clk;
ffe006f8:	cd 32 45                      	mov.b	69[r3], r2
ffe006fb:	8a 54                         	mov.b	8[r5], r4
ffe006fd:	64 72                         	and	#7, r2
ffe006ff:	75 24 f8                      	and	#-8, r4
ffe00702:	57 24                         	or	r2, r4
ffe00704:	82 54                         	mov.b	r4, 8[r5]
    pregs->SIMR1.BIT.IICM = 0; /* Do not use Simple IIC mode. */
ffe00706:	f1 58 09                      	bclr	#0, 9[r5].b
    pregs->SIMR1.BIT.IICDL = prom->ssda_delay;
ffe00709:	cd 33 3f                      	mov.b	63[r3], r3

ffe0070c <.LVL57>:
ffe0070c:	8a 5c                         	mov.b	9[r5], r4
ffe0070e:	75 23 1f                      	and	#31, r3
ffe00711:	6c 33                         	shll	#3, r3
ffe00713:	64 74                         	and	#7, r4
ffe00715:	57 34                         	or	r3, r4
ffe00717:	82 5c                         	mov.b	r4, 9[r5]
    pregs->SIMR2.BIT.IICACKT = SCI_IIC_NACK_TRANS;
ffe00719:	f1 55 0a                      	bset	#5, 10[r5].b
    pregs->SIMR2.BIT.IICCSC = SCI_IIC_SYNCHRO;
ffe0071c:	f1 51 0a                      	bset	#1, 10[r5].b
    pregs->SIMR2.BIT.IICINTM = SCI_IIC_RCV_TRS_INTERRUPT;
ffe0071f:	f1 50 0a                      	bset	#0, 10[r5].b
    pregs->SISR.BIT.IICACKR = SCI_IIC_ACK_RCV;
ffe00722:	f1 58 0c                      	bclr	#0, 12[r5].b
    pregs->SPMR.BYTE = 0x00;
ffe00725:	3c 5d 00                      	mov.b	#0, 13[r5]
} /* End of function r_sci_iic_init_io_register() */
ffe00728:	3f 6c 09                      	rtsd	#36, r6-r12

ffe0072b <.LBB7>:
                brr_n = 128; /* 64*(2^(2*1-1)) */
ffe0072b:	90 86                         	mov.w	r6, 4[r0]
                cks_value = 1; /* clock select: PCLK/4 */
ffe0072d:	81 84                         	mov.b	r4, 6[r0]
            break;
ffe0072f:	38 79 ff                      	bra.w	ffe006a8 <_Reset_Vector+0xffe006ac>
                brr_n = 2048; /* 64*(2^(2*3-1)) */
ffe00732:	d7 0c 02                      	mov.w	r12, 4[r0]
                cks_value = 3; /* clock select: PCLK/64 */
ffe00735:	c7 0b 06                      	mov.b	r11, 6[r0]
            break;
ffe00738:	38 70 ff                      	bra.w	ffe006a8 <_Reset_Vector+0xffe006ac>
                brr_n = 512; /* 64*(2^(2*2-1))  */
ffe0073b:	d7 0e 02                      	mov.w	r14, 4[r0]
                cks_value = 2; /* clock select: PCLK/16 */
ffe0073e:	c7 09 06                      	mov.b	r9, 6[r0]
            break;
ffe00741:	38 67 ff                      	bra.w	ffe006a8 <_Reset_Vector+0xffe006ac>

ffe00744 <.LVL59>:
        brr_value = (uint32_t) ((double) ((double) ((double) BSP_PCLKA_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffe00744:	ed 2a 10                      	mov.l	64[r2], r10
ffe00747:	fb e2 c0 e1 e4 4c             	mov.l	#0x4ce4e1c0, r14
ffe0074d:	5f 77                         	movu.w	r7, r7

ffe0074f <.LVL60>:
ffe0074f:	4f a7                         	mul	r10, r7

ffe00751 <.LVL61>:
ffe00751:	fc 57 77                      	utof	r7, r7
ffe00754:	ef e4                         	mov.l	r14, r4
ffe00756:	fc 93 74                      	fdiv	r7, r4
ffe00759:	ef 47                         	mov.l	r4, r7
ffe0075b:	fd 72 07 cd cc cc 3d          	fsub	#0x3dcccccd, r7
ffe00762:	fc a7 77                      	ftou	r7, r7
ffe00765:	e3 07                         	mov.l	r7, [r0]
    while (brr_value > 255)
ffe00767:	ec 07                         	mov.l	[r0], r7
ffe00769:	75 57 ff                      	cmp	#255, r7
ffe0076c:	24 05                         	bgtu.b	ffe00771 <_Reset_Vector+0xffe00775>
ffe0076e:	38 72 ff                      	bra.w	ffe006e0 <_Reset_Vector+0xffe006e4>
                brr_n = 512; /* 64*(2^(2*2-1))  */
ffe00771:	fb ca 00 02                   	mov.l	#512, r12
                cks_value = 2; /* clock select: PCLK/16 */
ffe00775:	66 2b                         	mov.l	#2, r11
                brr_n = 2048; /* 64*(2^(2*3-1)) */
ffe00777:	fb 6a 00 08                   	mov.l	#0x800, r6
                cks_value = 3; /* clock select: PCLK/64 */
ffe0077b:	66 3a                         	mov.l	#3, r10
                brr_n = 128; /* 64*(2^(2*1-1)) */
ffe0077d:	75 47 80                      	mov.l	#128, r7
                cks_value = 1; /* clock select: PCLK/4 */
ffe00780:	66 1f                         	mov.l	#1, r15
            brr_value = 255;
ffe00782:	75 49 ff                      	mov.l	#255, r9
ffe00785:	2e 0c                         	bra.b	ffe00791 <_Reset_Vector+0xffe00795>
    while (brr_value > 255)
ffe00787:	ec 04                         	mov.l	[r0], r4
ffe00789:	75 54 ff                      	cmp	#255, r4
ffe0078c:	24 05                         	bgtu.b	ffe00791 <_Reset_Vector+0xffe00795>
ffe0078e:	38 52 ff                      	bra.w	ffe006e0 <_Reset_Vector+0xffe006e4>
        switch (brr_n)
ffe00791:	b8 84                         	movu.w	4[r0], r4
ffe00793:	75 54 80                      	cmp	#128, r4
ffe00796:	20 50                         	beq.b	ffe007e6 <_Reset_Vector+0xffe007ea>
ffe00798:	76 04 00 02                   	cmp	#512, r4
ffe0079c:	20 43                         	beq.b	ffe007df <_Reset_Vector+0xffe007e3>
ffe0079e:	75 54 20                      	cmp	#32, r4
ffe007a1:	20 37                         	beq.b	ffe007d8 <_Reset_Vector+0xffe007dc>
ffe007a3:	77 10 01 00 00                	nop	; mul	#1, r0
            brr_n_tmp = brr_n;
ffe007a8:	98 84                         	mov.w	4[r0], r4

ffe007aa <.LVL62>:
            brr_value = (uint32_t) ((double) (((double) BSP_PCLKA_HZ / (brr_n_tmp * (prom->bitrate)))) - 0.1);
ffe007aa:	ed 28 10                      	mov.l	64[r2], r8
ffe007ad:	5f 44                         	movu.w	r4, r4
ffe007af:	4f 84                         	mul	r8, r4

ffe007b1 <.LVL63>:
ffe007b1:	fc 57 44                      	utof	r4, r4
ffe007b4:	ef e8                         	mov.l	r14, r8
ffe007b6:	fc 93 48                      	fdiv	r4, r8
ffe007b9:	ef 84                         	mov.l	r8, r4
ffe007bb:	fd 72 04 cd cc cc 3d          	fsub	#0x3dcccccd, r4
ffe007c2:	fc a7 44                      	ftou	r4, r4
ffe007c5:	e3 04                         	mov.l	r4, [r0]
        if ((3 == cks_value) && (255 < brr_value))
ffe007c7:	b1 84                         	movu.b	6[r0], r4
ffe007c9:	61 34                         	cmp	#3, r4
ffe007cb:	21 bc                         	bne.b	ffe00787 <_Reset_Vector+0xffe0078b>
ffe007cd:	ec 04                         	mov.l	[r0], r4
ffe007cf:	75 54 ff                      	cmp	#255, r4
ffe007d2:	25 b5                         	bleu.b	ffe00787 <_Reset_Vector+0xffe0078b>
            brr_value = 255;
ffe007d4:	e3 09                         	mov.l	r9, [r0]
ffe007d6:	2e b1                         	bra.b	ffe00787 <_Reset_Vector+0xffe0078b>
                brr_n = 128; /* 64*(2^(2*1-1)) */
ffe007d8:	90 87                         	mov.w	r7, 4[r0]
                cks_value = 1; /* clock select: PCLK/4 */
ffe007da:	c7 0f 06                      	mov.b	r15, 6[r0]
            break;
ffe007dd:	2e cb                         	bra.b	ffe007a8 <_Reset_Vector+0xffe007ac>
                brr_n = 2048; /* 64*(2^(2*3-1)) */
ffe007df:	90 86                         	mov.w	r6, 4[r0]
                cks_value = 3; /* clock select: PCLK/64 */
ffe007e1:	c7 0a 06                      	mov.b	r10, 6[r0]
            break;
ffe007e4:	2e c4                         	bra.b	ffe007a8 <_Reset_Vector+0xffe007ac>
                brr_n = 512; /* 64*(2^(2*2-1))  */
ffe007e6:	d7 0c 02                      	mov.w	r12, 4[r0]
                cks_value = 2; /* clock select: PCLK/16 */
ffe007e9:	c7 0b 06                      	mov.b	r11, 6[r0]
            break;
ffe007ec:	2e bc                         	bra.b	ffe007a8 <_Reset_Vector+0xffe007ac>

ffe007ee <.LBE7>:
ffe007ee:	ef 00                         	nop	; mov.l	r0, r0

ffe007f0 <_r_sci_iic_int_disable>:
{
ffe007f0:	6e 6a                         	pushm	r6-r10
ffe007f2:	60 80                         	sub	#8, r0
ffe007f4:	ef 1a                         	mov.l	r1, r10
    R_BSP_VOLATILE_EVENACCESS const sci_iic_ch_rom_t * prom = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom;
ffe007f6:	fb 62 cc 5f e0 ff             	mov.l	#0xffe05fcc, r6
    R_BSP_InterruptWrite(prom->grp_tei_def, (bsp_int_cb_t) (FIT_NO_FUNC));
ffe007fc:	fb 22 00 00 00 10             	mov.l	#0x10000000, r2
    R_BSP_VOLATILE_EVENACCESS const sci_iic_ch_rom_t * prom = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom;
ffe00802:	b0 9f                         	movu.b	3[r1], r7
ffe00804:	fe 67 67                      	mov.l	[r7, r6], r7
ffe00807:	ec 77                         	mov.l	[r7], r7

ffe00809 <.LVL67>:
    R_BSP_InterruptWrite(prom->grp_tei_def, (bsp_int_cb_t) (FIT_NO_FUNC));
ffe00809:	ab 71                         	mov.l	48[r7], r1

ffe0080b <.LVL68>:
ffe0080b:	05 05 30 00                   	bsr.a	ffe03810 <_Reset_Vector+0xffe03814>

ffe0080f <.LVL69>:
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe0080f:	ef 03                         	mov.l	r0, r3
ffe00811:	66 62                         	mov.l	#6, r2
ffe00813:	75 41 5e                      	mov.l	#94, r1
ffe00816:	05 1a 30 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0081a <.LVL70>:
    icu_txi = (*prom->picu_txi);
ffe0081a:	aa 75                         	mov.l	32[r7], r5
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe0081c:	ef 03                         	mov.l	r0, r3
    icu_txi = (*prom->picu_txi);
ffe0081e:	cc 5e                         	mov.b	[r5], r14

ffe00820 <.LVL71>:
    txi_en_mask = prom->txi_en_mask;
ffe00820:	cd 75 24                      	mov.b	36[r7], r5

ffe00823 <.LVL72>:
    (*prom->picu_txi) = icu_txi & (~txi_en_mask);
ffe00823:	aa 74                         	mov.l	32[r7], r4
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe00825:	66 52                         	mov.l	#5, r2
    (*prom->picu_txi) = icu_txi & (~txi_en_mask);
ffe00827:	7e 05                         	not	r5

ffe00829 <.LVL73>:
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe00829:	75 41 5e                      	mov.l	#94, r1
    (*prom->picu_txi) = icu_txi & (~txi_en_mask);
ffe0082c:	53 e5                         	and	r14, r5
ffe0082e:	c3 45                         	mov.b	r5, [r4]
    icu_tei = (*prom->picu_tei);
ffe00830:	aa f5                         	mov.l	40[r7], r5
ffe00832:	ec 5e                         	mov.l	[r5], r14

ffe00834 <.LVL74>:
    tei_en_mask = prom->tei_en_mask;
ffe00834:	aa fd                         	mov.l	44[r7], r5

ffe00836 <.LVL75>:
    (*prom->picu_tei) = icu_tei & (~tei_en_mask);
ffe00836:	aa f4                         	mov.l	40[r7], r4
ffe00838:	7e 05                         	not	r5

ffe0083a <.LVL76>:
ffe0083a:	53 e5                         	and	r14, r5

ffe0083c <.LVL77>:
ffe0083c:	e3 45                         	mov.l	r5, [r4]
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe0083e:	05 f2 2f 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe00842 <.LVL78>:
    (*prom->pipr) = 0; /* Clears TXI interrupt source priority register. */
ffe00842:	a9 75                         	mov.l	16[r7], r5
ffe00844:	f8 54 00                      	mov.b	#0, [r5]
    if (*prom->pipr)
ffe00847:	a9 75                         	mov.l	16[r7], r5
ffe00849:	58 55                         	movu.b	[r5], r5
ffe0084b:	61 05                         	cmp	#0, r5
ffe0084d:	20 03                         	beq.b	ffe00850 <_Reset_Vector+0xffe00854>
        R_BSP_NOP();
ffe0084f:	03                            	nop
    R_BSP_InterruptControl(prom->grp_tei_def, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &ipl);
ffe00850:	ab 71                         	mov.l	48[r7], r1
ffe00852:	71 03 04                      	add	#4, r0, r3
ffe00855:	66 42                         	mov.l	#4, r2
    ipl = 0; /* Clears TEI interrupt source priority register. */
ffe00857:	3e 01 00                      	mov.l	#0, 4[r0]
    R_BSP_InterruptControl(prom->grp_tei_def, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &ipl);
ffe0085a:	05 d6 2f 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0085e <.LBB10>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe0085e:	59 a7 03                      	movu.b	3[r10], r7

ffe00861 <.LVL80>:
ffe00861:	fe 67 67                      	mov.l	[r7, r6], r7
ffe00864:	ec 75                         	mov.l	[r7], r5

ffe00866 <.LVL81>:
    if (SCI_IIC_IR_SET == (*prom->pir_txi))
ffe00866:	a9 5f                         	mov.l	20[r5], r7
ffe00868:	58 77                         	movu.b	[r7], r7
ffe0086a:	61 17                         	cmp	#1, r7
ffe0086c:	14                            	beq.s	ffe00870 <_Reset_Vector+0xffe00874>

ffe0086d <.LBE10>:
} /* End of function r_sci_iic_int_disable() */
ffe0086d:	3f 6a 07                      	rtsd	#28, r6-r10

ffe00870 <.LBB13>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00870:	a8 5c                         	mov.l	4[r5], r4
        pregs->SCR.BYTE = SCI_IIC_SCR_INIT;
ffe00872:	3c 42 00                      	mov.b	#0, 2[r4]
        while (SCI_IIC_SCR_INIT != pregs->SCR.BYTE)
ffe00875:	fc 13 00                      	nop	; max	r0, r0
ffe00878:	b0 c7                         	movu.b	2[r4], r7
ffe0087a:	61 07                         	cmp	#0, r7
ffe0087c:	21 fc                         	bne.b	ffe00878 <_Reset_Vector+0xffe0087c>
        (*prom->pir_txi) = SCI_IIC_IR_CLR;
ffe0087e:	a9 5f                         	mov.l	20[r5], r7
ffe00880:	f8 74 00                      	mov.b	#0, [r7]

ffe00883 <.LVL83>:
        if (*prom->pir_txi)
ffe00883:	a9 5f                         	mov.l	20[r5], r7
ffe00885:	58 77                         	movu.b	[r7], r7
ffe00887:	61 07                         	cmp	#0, r7
ffe00889:	20 03                         	beq.b	ffe0088c <_Reset_Vector+0xffe00890>
            R_BSP_NOP();
ffe0088b:	03                            	nop
        r_sci_iic_init_io_register(p_sci_iic_info);
ffe0088c:	ef a1                         	mov.l	r10, r1
ffe0088e:	05 82 fd ff                   	bsr.a	ffe00610 <_Reset_Vector+0xffe00614>

ffe00892 <.LBE13>:
} /* End of function r_sci_iic_int_disable() */
ffe00892:	3f 6a 07                      	rtsd	#28, r6-r10

ffe00895 <.LFE9>:
ffe00895:	fc 13 00                      	nop	; max	r0, r0

ffe00898 <_r_sci_iic_mpc_setting>:
{
ffe00898:	6e 6c                         	pushm	r6-r12

ffe0089a <.LVL106>:
                                                           + (uint32_t)((port_gr * 8) + pin_num));
ffe0089a:	5b 11                         	movu.b	r1, r1

ffe0089c <.LVL107>:
ffe0089c:	5b 22                         	movu.b	r2, r2
ffe0089e:	fd c3 17                      	shll	#3, r1, r7
ffe008a1:	4b 27                         	add	r2, r7
    if ((*ppfs) != set_value)
ffe008a3:	5b 3b                         	movu.b	r3, r11
                                                           + (uint32_t)((port_gr * 8) + pin_num));
ffe008a5:	73 77 40 c1 08                	add	#0x8c140, r7, r7

ffe008aa <.LVL108>:
    if ((*ppfs) != set_value)
ffe008aa:	58 7a                         	movu.b	[r7], r10
ffe008ac:	47 ba                         	cmp	r11, r10
ffe008ae:	1d                            	bne.s	ffe008b3 <_Reset_Vector+0xffe008b7>

ffe008af <.LVL109>:
ffe008af:	03                            	nop
} /* End of function r_sci_iic_mpc_setting() */
ffe008b0:	3f 6c 07                      	rtsd	#28, r6-r12

ffe008b3 <.LVL110>:
ffe008b3:	cf 3c                         	mov.b	r3, r12
    R_BSP_VOLATILE_EVENACCESS uint8_t * const ppmr = (uint8_t *)((uint32_t)SCI_IIC_PRV_PMR_BASE_REG + (uint32_t)port_gr);
ffe008b5:	73 1a 60 c0 08                	add	#0x8c060, r1, r10
        (*ppmr) &= (~(1U << pin_num)); /* Uses as a GPIO (Input port). */
ffe008ba:	cc a4                         	mov.b	[r10], r4
ffe008bc:	66 16                         	mov.l	#1, r6
ffe008be:	fd 62 26                      	shll	r2, r6
ffe008c1:	fc 3b 65                      	not	r6, r5
        R_BSP_RegisterProtectDisable(BSP_REG_PROTECT_MPC); /* Enables the PFS register writing. */
ffe008c4:	66 31                         	mov.l	#3, r1

ffe008c6 <.LVL111>:
        (*ppmr) &= (~(1U << pin_num)); /* Uses as a GPIO (Input port). */
ffe008c6:	53 45                         	and	r4, r5
ffe008c8:	c3 a5                         	mov.b	r5, [r10]
        R_BSP_RegisterProtectDisable(BSP_REG_PROTECT_MPC); /* Enables the PFS register writing. */
ffe008ca:	05 46 2e 00                   	bsr.a	ffe03710 <_Reset_Vector+0xffe03714>

ffe008ce <.LVL112>:
        R_BSP_RegisterProtectEnable(BSP_REG_PROTECT_MPC); /* Disables the PFS register writing. */
ffe008ce:	66 31                         	mov.l	#3, r1
        (*ppfs) = set_value; /* Pin function select to "SSCL/SSDA" or "Hi-Z" pin. */
ffe008d0:	c3 7c                         	mov.b	r12, [r7]
        R_BSP_RegisterProtectEnable(BSP_REG_PROTECT_MPC); /* Disables the PFS register writing. */
ffe008d2:	05 b6 2d 00                   	bsr.a	ffe03688 <_Reset_Vector+0xffe0368c>

ffe008d6 <.LVL113>:
        if (SCI_IIC_MPC_SSCL_INIT != set_value)
ffe008d6:	61 0b                         	cmp	#0, r11
ffe008d8:	10                            	beq.s	ffe008e0 <_Reset_Vector+0xffe008e4>
            (*ppmr) |= (1U << pin_num); /* Uses as SCI_IIC (SSCL/SSDA). */
ffe008d9:	cc a5                         	mov.b	[r10], r5
ffe008db:	57 56                         	or	r5, r6
ffe008dd:	c3 a6                         	mov.b	r6, [r10]
ffe008df:	03                            	nop
        if (*ppmr)
ffe008e0:	58 a7                         	movu.b	[r10], r7

ffe008e2 <.LVL114>:
ffe008e2:	61 07                         	cmp	#0, r7
ffe008e4:	20 cc                         	beq.b	ffe008b0 <_Reset_Vector+0xffe008b4>
            R_BSP_NOP();
ffe008e6:	03                            	nop
} /* End of function r_sci_iic_mpc_setting() */
ffe008e7:	3f 6c 07                      	rtsd	#28, r6-r12

ffe008ea <.LFE12>:
ffe008ea:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe008f0 <_sci_iic_generate_start_cond>:
 * Arguments    : sci_iic_info_t * p_sci_iic_info    ; IIC Information
 * Return Value : SCI_IIC_SUCCESS                    ; Successful operation, communication state
 *              : SCI_IIC_ERR_BUS_BUSY               ; None reply error
 **********************************************************************************************************************/
static sci_iic_return_t sci_iic_generate_start_cond (sci_iic_info_t * p_sci_iic_info)
{
ffe008f0:	7e a7                         	push.l	r7
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
    R_BSP_VOLATILE_EVENACCESS uint8_t * const ppidr = SCI_IIC_PRV_PIDR_BASE_REG;
    R_BSP_VOLATILE_EVENACCESS const sci_iic_ch_rom_t * prom = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom;
ffe008f2:	fb e2 cc 5f e0 ff             	mov.l	#0xffe05fcc, r14
ffe008f8:	b0 9f                         	movu.b	3[r1], r7
ffe008fa:	fe 67 e2                      	mov.l	[r7, r14], r2
ffe008fd:	ec 24                         	mov.l	[r2], r4

ffe008ff <.LVL2>:
    uint8_t sscl_port_pin;
    uint8_t ssda_port_gr;
    uint8_t ssda_port_pin;
    
    /* Check Bus busy(SSDA,SSCL pin level) */
    sscl_port_gr = prom->sscl_port_gr;
ffe008ff:	cd 45 39                      	mov.b	57[r4], r5

ffe00902 <.LVL3>:
    sscl_port_pin = prom->sscl_port_pin;
ffe00902:	cd 4f 3a                      	mov.b	58[r4], r15

ffe00905 <.LVL4>:
    ssda_port_gr = prom->ssda_port_gr;
    ssda_port_pin = prom->ssda_port_pin;
    if ((SCI_IIC_LOW == ((*(ppidr + sscl_port_gr)) & (1U << sscl_port_pin)))
ffe00905:	5b 55                         	movu.b	r5, r5
    ssda_port_gr = prom->ssda_port_gr;
ffe00907:	cd 43 3c                      	mov.b	60[r4], r3

ffe0090a <.LVL5>:
    if ((SCI_IIC_LOW == ((*(ppidr + sscl_port_gr)) & (1U << sscl_port_pin)))
ffe0090a:	73 55 40 c0 08                	add	#0x8c040, r5, r5

ffe0090f <.LVL6>:
    ssda_port_pin = prom->ssda_port_pin;
ffe0090f:	cd 47 3d                      	mov.b	61[r4], r7

ffe00912 <.LVL7>:
    if ((SCI_IIC_LOW == ((*(ppidr + sscl_port_gr)) & (1U << sscl_port_pin)))
ffe00912:	cc 55                         	mov.b	[r5], r5

ffe00914 <.LVL8>:
ffe00914:	5b f4                         	movu.b	r15, r4

ffe00916 <.LVL9>:
ffe00916:	5b 55                         	movu.b	r5, r5
ffe00918:	fd 60 45                      	shlr	r4, r5
ffe0091b:	7c 05                         	btst	#0, r5
ffe0091d:	20 38                         	beq.b	ffe00955 <_Reset_Vector+0xffe00959>
            || (SCI_IIC_LOW == ((*(ppidr + ssda_port_gr)) & (1U << ssda_port_pin))))
ffe0091f:	5b 33                         	movu.b	r3, r3
ffe00921:	5b 77                         	movu.b	r7, r7

ffe00923 <.LVL10>:
ffe00923:	73 33 40 c0 08                	add	#0x8c040, r3, r3

ffe00928 <.LVL11>:
ffe00928:	58 35                         	movu.b	[r3], r5
ffe0092a:	fd 60 75                      	shlr	r7, r5
ffe0092d:	7c 05                         	btst	#0, r5
ffe0092f:	20 26                         	beq.b	ffe00955 <_Reset_Vector+0xffe00959>

ffe00931 <.LBB132>:
 * Return Value : None
 **********************************************************************************************************************/
static void sci_iic_set_internal_status (sci_iic_info_t * p_sci_iic_info, sci_iic_api_status_t new_status)
{
    /* Sets the previous status. */
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00931:	e5 22 03 04                   	mov.l	12[r2], 16[r2]

ffe00935 <.LBE132>:
    return ret;
ffe00935:	66 04                         	mov.l	#0, r4

ffe00937 <.LBB135>:

    /* Sets the now status. */
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00937:	3e 23 02                      	mov.l	#2, 12[r2]

ffe0093a <.LBB136>:
 * Arguments    : sci_iic_info_t * p_sci_iic_info     ;   IIC Information
 * Return Value : None
 **********************************************************************************************************************/
static void sci_iic_start_cond_generate (sci_iic_info_t * p_sci_iic_info)
{
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe0093a:	b0 9f                         	movu.b	3[r1], r7

ffe0093c <.LVL14>:
ffe0093c:	fe 67 e5                      	mov.l	[r7, r14], r5
ffe0093f:	ec 57                         	mov.l	[r5], r7
ffe00941:	a8 7f                         	mov.l	4[r7], r7

ffe00943 <.LVL15>:

    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STAREQ; /* mode set start mode.*/
ffe00943:	3c d4 01                      	mov.b	#1, 20[r5]

ffe00946 <.LVL16>:

    /* SCR - Serial Control Register
     b5     TE - Transmit Enable - Serial transmission is enabled
     b4     RE - Transmit Enable - Serial reception is enabled */
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffe00946:	88 f5                         	mov.b	2[r7], r5
ffe00948:	75 35 30                      	or	#48, r5
ffe0094b:	80 f5                         	mov.b	r5, 2[r7]
     b7:b6  IICSCLS - SSCL Output Select - Generate a start, restart, or stop condition.
     b5:b4  IICSDAS - SSDA Output Select - Generate a start, restart, or stop condition.
     b3     IICSTIF - Issuing of Start, Restart, or Stop Condition Completed Flag
     - There are no requests for generating conditions
     b0     IICSTAREQ - Start Condition Generation   - A start condition is not generated. */
    pregs->SIMR3.BYTE = SCI_IIC_ST_CON_GENERATED;
ffe0094d:	3c 7b 51                      	mov.b	#81, 11[r7]

ffe00950 <.LVL17>:
} /* End of function sci_iic_generate_start_cond() */
ffe00950:	ef 41                         	mov.l	r4, r1

ffe00952 <.LVL18>:
ffe00952:	3f 77 01                      	rtsd	#4, r7-r7

ffe00955 <.LVL19>:
        return SCI_IIC_ERR_BUS_BUSY;
ffe00955:	66 54                         	mov.l	#5, r4
} /* End of function sci_iic_generate_start_cond() */
ffe00957:	ef 41                         	mov.l	r4, r1

ffe00959 <.LVL20>:
ffe00959:	3f 77 01                      	rtsd	#4, r7-r7

ffe0095c <.LFE19>:
ffe0095c:	00                            	brk
ffe0095d:	00                            	brk
	...

ffe00960 <_sci_iic_after_gen_start_cond>:
{
ffe00960:	ef 12                         	mov.l	r1, r2
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00962:	fb e2 cc 5f e0 ff             	mov.l	#0xffe05fcc, r14
ffe00968:	b0 9d                         	movu.b	3[r1], r5
ffe0096a:	fe 65 e4                      	mov.l	[r5, r14], r4
ffe0096d:	ec 45                         	mov.l	[r4], r5
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffe0096f:	a8 c3                         	mov.l	8[r4], r3
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00971:	a8 5d                         	mov.l	4[r5], r5

ffe00973 <.LVL22>:
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffe00973:	61 33                         	cmp	#3, r3
ffe00975:	20 50                         	beq.b	ffe009c5 <_Reset_Vector+0xffe009c9>
ffe00977:	61 43                         	cmp	#4, r3
ffe00979:	17                            	beq.s	ffe00980 <_Reset_Vector+0xffe00984>
ffe0097a:	61 23                         	cmp	#2, r3
ffe0097c:	14                            	beq.s	ffe00980 <_Reset_Vector+0xffe00984>
            ret = SCI_IIC_ERR_OTHER;
ffe0097d:	66 61                         	mov.l	#6, r1

ffe0097f <.LVL23>:
} /* End of function sci_iic_after_gen_start_cond() */
ffe0097f:	02                            	rts

ffe00980 <.LVL24>:
            switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status)
ffe00980:	a9 43                         	mov.l	16[r4], r3
ffe00982:	61 13                         	cmp	#1, r3
ffe00984:	20 6c                         	beq.b	ffe009f0 <_Reset_Vector+0xffe009f4>
ffe00986:	61 53                         	cmp	#5, r3
ffe00988:	21 f5                         	bne.b	ffe0097d <_Reset_Vector+0xffe00981>

ffe0098a <.LVL25>:
                    buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffe0098a:	a9 a3                         	mov.l	24[r2], r3
ffe0098c:	cc 33                         	mov.b	[r3], r3

ffe0098e <.LBB138>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe0098e:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffe00992 <.LBE138>:
                    buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffe00992:	4b 33                         	add	r3, r3

ffe00994 <.LBB142>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00994:	3e 43 04                      	mov.l	#4, 12[r4]

ffe00997 <.LBE142>:
                    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffe00997:	f1 5b 0b                      	bclr	#3, 11[r5].b
                    buf_send_data |= SCI_IIC_R_CODE;
ffe0099a:	78 03                         	bset	#0, r3

ffe0099c <.LBB143>:
                    pregs->SIMR3.BIT.IICSCLS = SCI_IIC_CLOCK_OUTPUT;
ffe0099c:	8a dc                         	mov.b	11[r5], r4
ffe0099e:	75 24 3f                      	and	#63, r4
ffe009a1:	82 dc                         	mov.b	r4, 11[r5]
                    pregs->SIMR3.BIT.IICSDAS = SCI_IIC_CLOCK_OUTPUT;
ffe009a3:	8a dc                         	mov.b	11[r5], r4
ffe009a5:	75 24 cf                      	and	#-49, r4
ffe009a8:	82 dc                         	mov.b	r4, 11[r5]
                    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffe009aa:	8a dc                         	mov.b	11[r5], r4
ffe009ac:	7c 34                         	btst	#3, r4
ffe009ae:	21 fc                         	bne.b	ffe009aa <_Reset_Vector+0xffe009ae>

ffe009b0 <.LBB144>:
 *              : uint8_t * p_data                   ;   Transmitted data buffer pointer
 * Return Value : None
 **********************************************************************************************************************/
static void sci_iic_set_sending_data (sci_iic_info_t * p_sci_iic_info, uint8_t * p_data)
{
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe009b0:	b0 ad                         	movu.b	3[r2], r5

ffe009b2 <.LVL30>:
ffe009b2:	fe 65 e5                      	mov.l	[r5, r14], r5
ffe009b5:	ec 55                         	mov.l	[r5], r5
ffe009b7:	a8 5d                         	mov.l	4[r5], r5

ffe009b9 <.LVL31>:

    /* Sets the transmitting data. */
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffe009b9:	80 db                         	mov.b	r3, 3[r5]

    /* dummy read */
    if (pregs->TDR)
ffe009bb:	b0 dd                         	movu.b	3[r5], r5

ffe009bd <.LVL32>:
ffe009bd:	61 05                         	cmp	#0, r5
ffe009bf:	20 03                         	beq.b	ffe009c2 <_Reset_Vector+0xffe009c6>
    {
        R_BSP_NOP();
ffe009c1:	03                            	nop
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffe009c2:	66 01                         	mov.l	#0, r1
ffe009c4:	02                            	rts

ffe009c5 <.LVL33>:
            buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffe009c5:	a9 93                         	mov.l	24[r1], r3
ffe009c7:	cc 33                         	mov.b	[r3], r3

ffe009c9 <.LBB146>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe009c9:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffe009cd <.LBE146>:
            buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffe009cd:	4b 33                         	add	r3, r3

ffe009cf <.LBB150>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe009cf:	3e 43 04                      	mov.l	#4, 12[r4]

ffe009d2 <.LBE150>:
            pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffe009d2:	f1 5b 0b                      	bclr	#3, 11[r5].b
            buf_send_data |= SCI_IIC_R_CODE;
ffe009d5:	78 03                         	bset	#0, r3

ffe009d7 <.LBB151>:
            pregs->SIMR3.BIT.IICSCLS = SCI_IIC_CLOCK_OUTPUT;
ffe009d7:	8a dc                         	mov.b	11[r5], r4
ffe009d9:	75 24 3f                      	and	#63, r4
ffe009dc:	82 dc                         	mov.b	r4, 11[r5]
            pregs->SIMR3.BIT.IICSDAS = SCI_IIC_CLOCK_OUTPUT;
ffe009de:	8a dc                         	mov.b	11[r5], r4
ffe009e0:	75 24 cf                      	and	#-49, r4
ffe009e3:	82 dc                         	mov.b	r4, 11[r5]
            while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffe009e5:	fc 13 00                      	nop	; max	r0, r0
ffe009e8:	8a dc                         	mov.b	11[r5], r4
ffe009ea:	7c 34                         	btst	#3, r4
ffe009ec:	21 fc                         	bne.b	ffe009e8 <_Reset_Vector+0xffe009ec>
ffe009ee:	2e c2                         	bra.b	ffe009b0 <_Reset_Vector+0xffe009b4>

ffe009f0 <.LVL37>:
                    if ((uint8_t *) FIT_NO_PTR == p_sci_iic_info->p_slv_adr) /* Pattern 4 of Master Write  */
ffe009f0:	a9 a3                         	mov.l	24[r2], r3
ffe009f2:	a8 c9                         	mov.l	12[r4], r1

ffe009f4 <.LVL38>:
ffe009f4:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe009fa:	20 26                         	beq.b	ffe00a20 <_Reset_Vector+0xffe00a24>
                    buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffe009fc:	cc 33                         	mov.b	[r3], r3

ffe009fe <.LBB152>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe009fe:	a1 41                         	mov.l	r1, 16[r4]

ffe00a00 <.LBE152>:
                    buf_send_data = (uint8_t) ((*p_sci_iic_info->p_slv_adr) << 1);
ffe00a00:	4b 33                         	add	r3, r3

ffe00a02 <.LBB155>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00a02:	3e 43 03                      	mov.l	#3, 12[r4]

ffe00a05 <.LBE155>:
                    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffe00a05:	f1 5b 0b                      	bclr	#3, 11[r5].b
                    pregs->SIMR3.BIT.IICSCLS = SCI_IIC_CLOCK_OUTPUT;
ffe00a08:	8a dc                         	mov.b	11[r5], r4
ffe00a0a:	75 24 3f                      	and	#63, r4
ffe00a0d:	82 dc                         	mov.b	r4, 11[r5]
                    pregs->SIMR3.BIT.IICSDAS = SCI_IIC_CLOCK_OUTPUT;
ffe00a0f:	8a dc                         	mov.b	11[r5], r4
ffe00a11:	75 24 cf                      	and	#-49, r4
ffe00a14:	82 dc                         	mov.b	r4, 11[r5]
                    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffe00a16:	ef 00                         	nop	; mov.l	r0, r0
ffe00a18:	8a dc                         	mov.b	11[r5], r4
ffe00a1a:	7c 34                         	btst	#3, r4
ffe00a1c:	21 fc                         	bne.b	ffe00a18 <_Reset_Vector+0xffe00a1c>
ffe00a1e:	2e 92                         	bra.b	ffe009b0 <_Reset_Vector+0xffe009b4>

ffe00a20 <.LBB156>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00a20:	a1 41                         	mov.l	r1, 16[r4]

ffe00a22 <.LBE156>:
                        return ret;
ffe00a22:	66 01                         	mov.l	#0, r1

ffe00a24 <.LBB159>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00a24:	3e 43 07                      	mov.l	#7, 12[r4]

ffe00a27 <.LBB160>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00a27:	b0 ad                         	movu.b	3[r2], r5

ffe00a29 <.LVL43>:
ffe00a29:	fe 65 e4                      	mov.l	[r5, r14], r4

ffe00a2c <.LVL44>:
ffe00a2c:	ec 45                         	mov.l	[r4], r5
ffe00a2e:	a8 5d                         	mov.l	4[r5], r5

ffe00a30 <.LVL45>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffe00a30:	3c c4 04                      	mov.b	#4, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffe00a33:	88 d4                         	mov.b	2[r5], r4
ffe00a35:	75 34 30                      	or	#48, r4
ffe00a38:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffe00a3a:	3c 5b 54                      	mov.b	#84, 11[r5]

ffe00a3d <.LVL46>:
                        return ret;
ffe00a3d:	02                            	rts

ffe00a3e <.LFE20>:
ffe00a3e:	ef 00                         	nop	; mov.l	r0, r0

ffe00a40 <_sci_iic_after_send_slvadr>:
{
ffe00a40:	60 40                         	sub	#4, r0
ffe00a42:	ef 15                         	mov.l	r1, r5
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00a44:	fb 22 cc 5f e0 ff             	mov.l	#0xffe05fcc, r2
ffe00a4a:	b0 9c                         	movu.b	3[r1], r4
    volatile uint8_t uctmp = 0U;
ffe00a4c:	f8 04 00                      	mov.b	#0, [r0]
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00a4f:	fe 64 24                      	mov.l	[r4, r2], r4
ffe00a52:	ec 41                         	mov.l	[r4], r1

ffe00a54 <.LVL49>:
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffe00a54:	a8 c3                         	mov.l	8[r4], r3
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00a56:	ed 1e 01                      	mov.l	4[r1], r14

ffe00a59 <.LVL50>:
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffe00a59:	61 33                         	cmp	#3, r3
ffe00a5b:	3a 8d 00                      	beq.w	ffe00ae8 <_Reset_Vector+0xffe00aec>
ffe00a5e:	61 43                         	cmp	#4, r3
ffe00a60:	20 4d                         	beq.b	ffe00aad <_Reset_Vector+0xffe00ab1>
ffe00a62:	61 23                         	cmp	#2, r3
ffe00a64:	15                            	beq.s	ffe00a69 <_Reset_Vector+0xffe00a6d>

ffe00a65 <.LVL51>:
            ret = SCI_IIC_ERR_OTHER;
ffe00a65:	66 61                         	mov.l	#6, r1
} /* End of function sci_iic_after_send_slvadr() */
ffe00a67:	67 01                         	rtsd	#4

ffe00a69 <.LVL52>:
            if (((uint8_t *) FIT_NO_PTR == p_sci_iic_info->p_data1st)
ffe00a69:	a9 5b                         	mov.l	20[r5], r3
ffe00a6b:	a9 51                         	mov.l	16[r5], r1
ffe00a6d:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe00a73:	3a cc 00                      	beq.w	ffe00b3f <_Reset_Vector+0xffe00b43>
                    && ((uint8_t *) FIT_NO_PTR != p_sci_iic_info->p_data2nd))
ffe00a76:	74 01 00 00 00 10             	cmp	#0x10000000, r1
ffe00a7c:	20 e9                         	beq.b	ffe00a65 <_Reset_Vector+0xffe00a69>

ffe00a7e <.LBB162>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00a7e:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffe00a82 <.LBE162>:
                if (0U != p_sci_iic_info->cnt1st)
ffe00a82:	a8 d9                         	mov.l	12[r5], r1

ffe00a84 <.LBB165>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00a84:	3e 43 05                      	mov.l	#5, 12[r4]

ffe00a87 <.LBE165>:
                if (0U != p_sci_iic_info->cnt1st)
ffe00a87:	61 01                         	cmp	#0, r1
ffe00a89:	20 dc                         	beq.b	ffe00a65 <_Reset_Vector+0xffe00a69>

ffe00a8b <.LBB166>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00a8b:	b0 dc                         	movu.b	3[r5], r4
ffe00a8d:	fe 64 24                      	mov.l	[r4, r2], r4
ffe00a90:	ec 44                         	mov.l	[r4], r4
ffe00a92:	a8 4c                         	mov.l	4[r4], r4

ffe00a94 <.LVL56>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffe00a94:	c4 34 03                      	mov.b	[r3], 3[r4]
    if (pregs->TDR)
ffe00a97:	b0 cc                         	movu.b	3[r4], r4

ffe00a99 <.LVL57>:
ffe00a99:	61 04                         	cmp	#0, r4
ffe00a9b:	16                            	beq.s	ffe00aa1 <_Reset_Vector+0xffe00aa5>
        R_BSP_NOP();
ffe00a9c:	03                            	nop
ffe00a9d:	a8 d9                         	mov.l	12[r5], r1
ffe00a9f:	a9 5b                         	mov.l	20[r5], r3

ffe00aa1 <.LVL58>:
                    p_sci_iic_info->cnt1st--;
ffe00aa1:	60 11                         	sub	#1, r1
                    p_sci_iic_info->p_data1st++;
ffe00aa3:	62 13                         	add	#1, r3
                    p_sci_iic_info->cnt1st--;
ffe00aa5:	a0 d9                         	mov.l	r1, 12[r5]
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffe00aa7:	66 01                         	mov.l	#0, r1
                    p_sci_iic_info->p_data1st++;
ffe00aa9:	a1 5b                         	mov.l	r3, 20[r5]
} /* End of function sci_iic_after_send_slvadr() */
ffe00aab:	67 01                         	rtsd	#4

ffe00aad <.LVL59>:
            switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status)
ffe00aad:	a8 cb                         	mov.l	12[r4], r3
ffe00aaf:	61 33                         	cmp	#3, r3
ffe00ab1:	20 65                         	beq.b	ffe00b16 <_Reset_Vector+0xffe00b1a>
ffe00ab3:	61 43                         	cmp	#4, r3
ffe00ab5:	21 b0                         	bne.b	ffe00a65 <_Reset_Vector+0xffe00a69>
                    if (1U >= p_sci_iic_info->cnt2nd)
ffe00ab7:	a8 d4                         	mov.l	8[r5], r4
ffe00ab9:	61 14                         	cmp	#1, r4
ffe00abb:	24 05                         	bgtu.b	ffe00ac0 <_Reset_Vector+0xffe00ac4>
ffe00abd:	38 bd 00                      	bra.w	ffe00b7a <_Reset_Vector+0xffe00b7e>
                        pregs->SIMR2.BIT.IICACKT = SCI_IIC_ACK_TRANS;
ffe00ac0:	f1 ed 0a                      	bclr	#5, 10[r14].b

ffe00ac3 <.LBB168>:
                    p_sci_iic_info->cnt2nd--;
ffe00ac3:	60 14                         	sub	#1, r4
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffe00ac5:	66 01                         	mov.l	#0, r1

ffe00ac7 <.LBB171>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00ac7:	b0 db                         	movu.b	3[r5], r3
ffe00ac9:	fe 63 23                      	mov.l	[r3, r2], r3
ffe00acc:	e5 33 03 04                   	mov.l	12[r3], 16[r3]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00ad0:	3e 33 06                      	mov.l	#6, 12[r3]

ffe00ad3 <.LBB172>:
 * Return Value : Returns received data.
 **********************************************************************************************************************/
static uint8_t sci_iic_get_receiving_data (sci_iic_info_t * p_sci_iic_info)
{
    uint8_t ret;
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00ad3:	b0 db                         	movu.b	3[r5], r3
ffe00ad5:	fe 63 23                      	mov.l	[r3, r2], r3
ffe00ad8:	ec 33                         	mov.l	[r3], r3
ffe00ada:	a8 3b                         	mov.l	4[r3], r3

ffe00adc <.LVL62>:

    ret = pregs->RDR;
ffe00adc:	89 3b                         	mov.b	5[r3], r3

ffe00ade <.LVL63>:
                    p_sci_iic_info->cnt2nd--;
ffe00ade:	a0 d4                         	mov.l	r4, 8[r5]
                    uctmp = sci_iic_get_receiving_data(p_sci_iic_info);
ffe00ae0:	c3 03                         	mov.b	r3, [r0]
                    pregs->TDR = 0xff;
ffe00ae2:	f9 e4 03 ff                   	mov.b	#255, 3[r14]
} /* End of function sci_iic_after_send_slvadr() */
ffe00ae6:	67 01                         	rtsd	#4

ffe00ae8 <.LBB174>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00ae8:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffe00aec <.LBE174>:
            if (1U >= p_sci_iic_info->cnt2nd)
ffe00aec:	a8 d3                         	mov.l	8[r5], r3

ffe00aee <.LBB177>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00aee:	3e 43 06                      	mov.l	#6, 12[r4]

ffe00af1 <.LBE177>:
            if (1U >= p_sci_iic_info->cnt2nd)
ffe00af1:	61 13                         	cmp	#1, r3
ffe00af3:	25 1e                         	bleu.b	ffe00b11 <_Reset_Vector+0xffe00b15>
                pregs->SIMR2.BIT.IICACKT = SCI_IIC_ACK_TRANS;
ffe00af5:	f1 ed 0a                      	bclr	#5, 10[r14].b

ffe00af8 <.LBB178>:
            p_sci_iic_info->cnt2nd--;
ffe00af8:	60 13                         	sub	#1, r3
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffe00afa:	66 01                         	mov.l	#0, r1

ffe00afc <.LBB181>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00afc:	b0 dc                         	movu.b	3[r5], r4
ffe00afe:	fe 64 24                      	mov.l	[r4, r2], r4
ffe00b01:	ec 44                         	mov.l	[r4], r4
ffe00b03:	a8 4c                         	mov.l	4[r4], r4

ffe00b05 <.LVL67>:
    ret = pregs->RDR;
ffe00b05:	89 4c                         	mov.b	5[r4], r4

ffe00b07 <.LBE181>:
            p_sci_iic_info->cnt2nd--;
ffe00b07:	a0 d3                         	mov.l	r3, 8[r5]
            uctmp = sci_iic_get_receiving_data(p_sci_iic_info);
ffe00b09:	c3 04                         	mov.b	r4, [r0]
            pregs->TDR = 0xff;
ffe00b0b:	f9 e4 03 ff                   	mov.b	#255, 3[r14]
} /* End of function sci_iic_after_send_slvadr() */
ffe00b0f:	67 01                         	rtsd	#4

ffe00b11 <.LVL69>:
                pregs->SIMR2.BIT.IICACKT = SCI_IIC_NACK_TRANS;
ffe00b11:	f1 e5 0a                      	bset	#5, 10[r14].b
ffe00b14:	2e e4                         	bra.b	ffe00af8 <_Reset_Vector+0xffe00afc>

ffe00b16 <.LBB182>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00b16:	a1 43                         	mov.l	r3, 16[r4]

ffe00b18 <.LBE182>:
                    sci_iic_set_sending_data(p_sci_iic_info, p_sci_iic_info->p_data1st);
ffe00b18:	a9 5b                         	mov.l	20[r5], r3

ffe00b1a <.LBB185>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00b1a:	3e 43 05                      	mov.l	#5, 12[r4]

ffe00b1d <.LBB186>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00b1d:	b0 dc                         	movu.b	3[r5], r4

ffe00b1f <.LBB188>:
ffe00b1f:	fe 64 24                      	mov.l	[r4, r2], r4
ffe00b22:	ec 44                         	mov.l	[r4], r4
ffe00b24:	a8 4c                         	mov.l	4[r4], r4

ffe00b26 <.LVL73>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffe00b26:	c4 34 03                      	mov.b	[r3], 3[r4]
    if (pregs->TDR)
ffe00b29:	b0 cc                         	movu.b	3[r4], r4

ffe00b2b <.LVL74>:
ffe00b2b:	61 04                         	cmp	#0, r4
ffe00b2d:	14                            	beq.s	ffe00b31 <_Reset_Vector+0xffe00b35>
        R_BSP_NOP();
ffe00b2e:	03                            	nop
ffe00b2f:	a9 5b                         	mov.l	20[r5], r3

ffe00b31 <.LBE188>:
                    p_sci_iic_info->cnt1st--;
ffe00b31:	a8 dc                         	mov.l	12[r5], r4
                    p_sci_iic_info->p_data1st++;
ffe00b33:	62 13                         	add	#1, r3
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffe00b35:	66 01                         	mov.l	#0, r1
                    p_sci_iic_info->p_data1st++;
ffe00b37:	a1 5b                         	mov.l	r3, 20[r5]
                    p_sci_iic_info->cnt1st--;
ffe00b39:	60 14                         	sub	#1, r4
ffe00b3b:	a0 dc                         	mov.l	r4, 12[r5]
} /* End of function sci_iic_after_send_slvadr() */
ffe00b3d:	67 01                         	rtsd	#4

ffe00b3f <.LVL76>:
ffe00b3f:	ed 4e 03                      	mov.l	12[r4], r14

ffe00b42 <.LVL77>:
                    && ((uint8_t *) FIT_NO_PTR == p_sci_iic_info->p_data2nd))
ffe00b42:	74 01 00 00 00 10             	cmp	#0x10000000, r1
ffe00b48:	20 38                         	beq.b	ffe00b80 <_Reset_Vector+0xffe00b84>

ffe00b4a <.LBB189>:
                if (0U != p_sci_iic_info->cnt2nd)
ffe00b4a:	a8 d3                         	mov.l	8[r5], r3

ffe00b4c <.LBB192>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00b4c:	e7 4e 04                      	mov.l	r14, 16[r4]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00b4f:	3e 43 05                      	mov.l	#5, 12[r4]

ffe00b52 <.LBE192>:
                if (0U != p_sci_iic_info->cnt2nd)
ffe00b52:	61 03                         	cmp	#0, r3
ffe00b54:	3a 11 ff                      	beq.w	ffe00a65 <_Reset_Vector+0xffe00a69>

ffe00b57 <.LBB193>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00b57:	b0 dc                         	movu.b	3[r5], r4

ffe00b59 <.LVL81>:
ffe00b59:	fe 64 24                      	mov.l	[r4, r2], r4
ffe00b5c:	ec 44                         	mov.l	[r4], r4
ffe00b5e:	a8 4c                         	mov.l	4[r4], r4

ffe00b60 <.LVL82>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffe00b60:	c4 14 03                      	mov.b	[r1], 3[r4]

ffe00b63 <.LVL83>:
    if (pregs->TDR)
ffe00b63:	b0 cc                         	movu.b	3[r4], r4

ffe00b65 <.LVL84>:
ffe00b65:	61 04                         	cmp	#0, r4
ffe00b67:	16                            	beq.s	ffe00b6d <_Reset_Vector+0xffe00b71>
        R_BSP_NOP();
ffe00b68:	03                            	nop
ffe00b69:	a8 d3                         	mov.l	8[r5], r3
ffe00b6b:	a9 51                         	mov.l	16[r5], r1
                    p_sci_iic_info->cnt2nd--;
ffe00b6d:	60 13                         	sub	#1, r3
                    p_sci_iic_info->p_data2nd++;
ffe00b6f:	71 14 01                      	add	#1, r1, r4
                    p_sci_iic_info->cnt2nd--;
ffe00b72:	a0 d3                         	mov.l	r3, 8[r5]
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffe00b74:	66 01                         	mov.l	#0, r1
                    p_sci_iic_info->p_data2nd++;
ffe00b76:	a1 54                         	mov.l	r4, 16[r5]
} /* End of function sci_iic_after_send_slvadr() */
ffe00b78:	67 01                         	rtsd	#4

ffe00b7a <.LVL85>:
                        pregs->SIMR2.BIT.IICACKT = SCI_IIC_NACK_TRANS;
ffe00b7a:	f1 e5 0a                      	bset	#5, 10[r14].b
ffe00b7d:	38 46 ff                      	bra.w	ffe00ac3 <_Reset_Vector+0xffe00ac7>

ffe00b80 <.LBB195>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00b80:	e7 4e 04                      	mov.l	r14, 16[r4]

ffe00b83 <.LBE195>:
                return ret;
ffe00b83:	66 01                         	mov.l	#0, r1

ffe00b85 <.LBB198>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00b85:	3e 43 07                      	mov.l	#7, 12[r4]

ffe00b88 <.LBB199>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00b88:	b0 dd                         	movu.b	3[r5], r5

ffe00b8a <.LVL88>:
ffe00b8a:	fe 65 24                      	mov.l	[r5, r2], r4

ffe00b8d <.LVL89>:
ffe00b8d:	ec 45                         	mov.l	[r4], r5
ffe00b8f:	a8 5d                         	mov.l	4[r5], r5

ffe00b91 <.LVL90>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffe00b91:	3c c4 04                      	mov.b	#4, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffe00b94:	88 d4                         	mov.b	2[r5], r4
ffe00b96:	75 34 30                      	or	#48, r4
ffe00b99:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffe00b9b:	3c 5b 54                      	mov.b	#84, 11[r5]

ffe00b9e <.LVL91>:
} /* End of function sci_iic_after_send_slvadr() */
ffe00b9e:	67 01                         	rtsd	#4

ffe00ba0 <_sci_iic_write_data_sending>:
{
ffe00ba0:	ef 15                         	mov.l	r1, r5
    switch (g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffe00ba2:	fb 22 cc 5f e0 ff             	mov.l	#0xffe05fcc, r2
ffe00ba8:	b0 9c                         	movu.b	3[r1], r4
ffe00baa:	fe 64 24                      	mov.l	[r4, r2], r4
ffe00bad:	a8 c3                         	mov.l	8[r4], r3
ffe00baf:	61 23                         	cmp	#2, r3
ffe00bb1:	20 2d                         	beq.b	ffe00bde <_Reset_Vector+0xffe00be2>
ffe00bb3:	61 43                         	cmp	#4, r3
ffe00bb5:	21 26                         	bne.b	ffe00bdb <_Reset_Vector+0xffe00bdf>
            if (0U != p_sci_iic_info->cnt1st)
ffe00bb7:	a8 99                         	mov.l	12[r1], r1

ffe00bb9 <.LVL93>:
ffe00bb9:	61 01                         	cmp	#0, r1
ffe00bbb:	21 6e                         	bne.b	ffe00c29 <_Reset_Vector+0xffe00c2d>

ffe00bbd <.LBB201>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00bbd:	e5 44 03 04                   	mov.l	12[r4], 16[r4]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00bc1:	3e 43 02                      	mov.l	#2, 12[r4]

ffe00bc4 <.LBB203>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00bc4:	b0 dd                         	movu.b	3[r5], r5

ffe00bc6 <.LVL96>:
ffe00bc6:	fe 65 24                      	mov.l	[r5, r2], r4
ffe00bc9:	ec 45                         	mov.l	[r4], r5
ffe00bcb:	a8 5d                         	mov.l	4[r5], r5

ffe00bcd <.LVL97>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_RSTAREQ; /* mode set restart mode. */
ffe00bcd:	3c c4 02                      	mov.b	#2, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffe00bd0:	88 d4                         	mov.b	2[r5], r4
ffe00bd2:	75 34 30                      	or	#48, r4
ffe00bd5:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_RST_CON_GENERATED;
ffe00bd7:	3c 5b 52                      	mov.b	#82, 11[r5]
} /* End of function sci_iic_write_data_sending() */
ffe00bda:	02                            	rts

ffe00bdb <.LVL98>:
            ret = SCI_IIC_ERR_OTHER;
ffe00bdb:	66 61                         	mov.l	#6, r1

ffe00bdd <.LVL99>:
ffe00bdd:	02                            	rts

ffe00bde <.LVL100>:
            if ((uint8_t *) FIT_NO_PTR != p_sci_iic_info->p_data1st)
ffe00bde:	a9 1b                         	mov.l	20[r1], r3
ffe00be0:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe00be6:	17                            	beq.s	ffe00bed <_Reset_Vector+0xffe00bf1>
                if (0U != p_sci_iic_info->cnt1st) /* Pattern 1 of Master Write  */
ffe00be7:	a8 99                         	mov.l	12[r1], r1

ffe00be9 <.LVL101>:
ffe00be9:	61 01                         	cmp	#0, r1
ffe00beb:	21 40                         	bne.b	ffe00c2b <_Reset_Vector+0xffe00c2f>
            if ((uint8_t *) FIT_NO_PTR != p_sci_iic_info->p_data2nd)
ffe00bed:	a9 53                         	mov.l	16[r5], r3
ffe00bef:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe00bf5:	17                            	beq.s	ffe00bfc <_Reset_Vector+0xffe00c00>
                if (0U != p_sci_iic_info->cnt2nd) /* Pattern 2 of Master Write */
ffe00bf6:	a8 d1                         	mov.l	8[r5], r1
ffe00bf8:	61 01                         	cmp	#0, r1
ffe00bfa:	21 4d                         	bne.b	ffe00c47 <_Reset_Vector+0xffe00c4b>

ffe00bfc <.LBB205>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00bfc:	e5 44 03 04                   	mov.l	12[r4], 16[r4]

ffe00c00 <.LBE205>:
    sci_iic_return_t ret = SCI_IIC_SUCCESS;
ffe00c00:	66 01                         	mov.l	#0, r1

ffe00c02 <.LBB208>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00c02:	3e 43 07                      	mov.l	#7, 12[r4]

ffe00c05 <.LBB209>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00c05:	b0 dc                         	movu.b	3[r5], r4
ffe00c07:	fe 64 24                      	mov.l	[r4, r2], r4
ffe00c0a:	ec 44                         	mov.l	[r4], r4
ffe00c0c:	a8 4c                         	mov.l	4[r4], r4

ffe00c0e <.LVL104>:
    pregs->SCR.BYTE = New_icier;
ffe00c0e:	f9 44 02 b4                   	mov.b	#180, 2[r4]

ffe00c12 <.LBB211>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00c12:	b0 dd                         	movu.b	3[r5], r5

ffe00c14 <.LVL106>:
ffe00c14:	fe 65 24                      	mov.l	[r5, r2], r4
ffe00c17:	ec 45                         	mov.l	[r4], r5
ffe00c19:	a8 5d                         	mov.l	4[r5], r5

ffe00c1b <.LVL107>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffe00c1b:	3c c4 04                      	mov.b	#4, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffe00c1e:	88 d4                         	mov.b	2[r5], r4
ffe00c20:	75 34 30                      	or	#48, r4
ffe00c23:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffe00c25:	3c 5b 54                      	mov.b	#84, 11[r5]
ffe00c28:	02                            	rts

ffe00c29 <.LVL108>:
                sci_iic_set_sending_data(p_sci_iic_info, p_sci_iic_info->p_data1st);
ffe00c29:	a9 5b                         	mov.l	20[r5], r3

ffe00c2b <.LBB213>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00c2b:	ec 44                         	mov.l	[r4], r4

ffe00c2d <.LBB215>:
ffe00c2d:	a8 4c                         	mov.l	4[r4], r4

ffe00c2f <.LVL110>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffe00c2f:	c4 34 03                      	mov.b	[r3], 3[r4]
    if (pregs->TDR)
ffe00c32:	b0 cc                         	movu.b	3[r4], r4

ffe00c34 <.LVL111>:
ffe00c34:	61 04                         	cmp	#0, r4
ffe00c36:	16                            	beq.s	ffe00c3c <_Reset_Vector+0xffe00c40>
        R_BSP_NOP();
ffe00c37:	03                            	nop
ffe00c38:	a8 d9                         	mov.l	12[r5], r1
ffe00c3a:	a9 5b                         	mov.l	20[r5], r3

ffe00c3c <.LBE215>:
                p_sci_iic_info->cnt1st--;
ffe00c3c:	60 11                         	sub	#1, r1
                p_sci_iic_info->p_data1st++;
ffe00c3e:	62 13                         	add	#1, r3
                p_sci_iic_info->cnt1st--;
ffe00c40:	a0 d9                         	mov.l	r1, 12[r5]
                return ret;
ffe00c42:	66 01                         	mov.l	#0, r1
                p_sci_iic_info->p_data1st++;
ffe00c44:	a1 5b                         	mov.l	r3, 20[r5]
                return ret;
ffe00c46:	02                            	rts

ffe00c47 <.LBB216>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00c47:	ec 44                         	mov.l	[r4], r4

ffe00c49 <.LBB218>:
ffe00c49:	a8 4c                         	mov.l	4[r4], r4

ffe00c4b <.LVL115>:
    pregs->TDR = (*p_data); /* Writes data to SCI_IIC in order to transmit.   */
ffe00c4b:	c4 34 03                      	mov.b	[r3], 3[r4]
    if (pregs->TDR)
ffe00c4e:	b0 cc                         	movu.b	3[r4], r4

ffe00c50 <.LVL116>:
ffe00c50:	61 04                         	cmp	#0, r4
ffe00c52:	16                            	beq.s	ffe00c58 <_Reset_Vector+0xffe00c5c>
        R_BSP_NOP();
ffe00c53:	03                            	nop
ffe00c54:	a8 d1                         	mov.l	8[r5], r1
ffe00c56:	a9 53                         	mov.l	16[r5], r3

ffe00c58 <.LBE218>:
                    p_sci_iic_info->cnt2nd--;
ffe00c58:	60 11                         	sub	#1, r1
                    p_sci_iic_info->p_data2nd++;
ffe00c5a:	62 13                         	add	#1, r3
                    p_sci_iic_info->cnt2nd--;
ffe00c5c:	a0 d1                         	mov.l	r1, 8[r5]
                    return ret;
ffe00c5e:	66 01                         	mov.l	#0, r1
                    p_sci_iic_info->p_data2nd++;
ffe00c60:	a1 53                         	mov.l	r3, 16[r5]
                    return ret;
ffe00c62:	02                            	rts

ffe00c63 <.LFE22>:
ffe00c63:	77 10 01 00 00                	nop	; mul	#1, r0

ffe00c68 <_sci_iic_release>:
{
ffe00c68:	7e a7                         	push.l	r7
ffe00c6a:	ef 15                         	mov.l	r1, r5

ffe00c6c <.LBB219>:
} /* End of function sci_iic_release() */
ffe00c6c:	66 01                         	mov.l	#0, r1

ffe00c6e <.LBB222>:
    g_sci_iic_ChStatus[p_sci_iic_info->ch_no] = status;
ffe00c6e:	b0 dc                         	movu.b	3[r5], r4
ffe00c70:	fb 32 fc 01 00 00             	mov.l	#508, r3
ffe00c76:	66 27                         	mov.l	#2, r7
ffe00c78:	fe 04 37                      	mov.b	r7, [r4, r3]
    p_sci_iic_info->dev_sts = status;
ffe00c7b:	80 d7                         	mov.b	r7, 2[r5]

ffe00c7d <.LBE222>:
} /* End of function sci_iic_release() */
ffe00c7d:	3f 77 01                      	rtsd	#4, r7-r7

ffe00c80 <_sci_iic_nack>:
{
ffe00c80:	7e a7                         	push.l	r7
ffe00c82:	60 40                         	sub	#4, r0
ffe00c84:	ef 15                         	mov.l	r1, r5

ffe00c86 <.LBB223>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00c86:	fb 42 cc 5f e0 ff             	mov.l	#0xffe05fcc, r4
ffe00c8c:	b0 9b                         	movu.b	3[r1], r3

ffe00c8e <.LBE223>:
    volatile uint8_t uctmp = 0U;
ffe00c8e:	f8 04 00                      	mov.b	#0, [r0]

ffe00c91 <.LBB226>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00c91:	fe 63 43                      	mov.l	[r3, r4], r3
ffe00c94:	e5 33 03 04                   	mov.l	12[r3], 16[r3]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00c98:	3e 33 07                      	mov.l	#7, 12[r3]

ffe00c9b <.LBB227>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00c9b:	b0 9b                         	movu.b	3[r1], r3
ffe00c9d:	fe 63 43                      	mov.l	[r3, r4], r3
ffe00ca0:	ec 33                         	mov.l	[r3], r3
ffe00ca2:	a8 3b                         	mov.l	4[r3], r3

ffe00ca4 <.LVL127>:
    pregs->SCR.BYTE = New_icier;
ffe00ca4:	f9 34 02 b4                   	mov.b	#180, 2[r3]

ffe00ca8 <.LBB229>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00ca8:	b0 9b                         	movu.b	3[r1], r3
ffe00caa:	fe 63 41                      	mov.l	[r3, r4], r1

ffe00cad <.LVL129>:
ffe00cad:	ec 12                         	mov.l	[r1], r2

ffe00caf <.LBE229>:
            || (SCI_IIC_MODE_SEND_RECEIVE == g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode))
ffe00caf:	a8 93                         	mov.l	8[r1], r3

ffe00cb1 <.LBB233>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00cb1:	a8 2a                         	mov.l	4[r2], r2

ffe00cb3 <.LVL130>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffe00cb3:	3c 94 04                      	mov.b	#4, 20[r1]

ffe00cb6 <.LBE233>:
            || (SCI_IIC_MODE_SEND_RECEIVE == g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode))
ffe00cb6:	60 33                         	sub	#3, r3

ffe00cb8 <.LBB234>:
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffe00cb8:	88 a1                         	mov.b	2[r2], r1
ffe00cba:	75 31 30                      	or	#48, r1
ffe00cbd:	80 a1                         	mov.b	r1, 2[r2]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffe00cbf:	3c 2b 54                      	mov.b	#84, 11[r2]

ffe00cc2 <.LBE234>:
    if ((SCI_IIC_MODE_RECEIVE == g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffe00cc2:	61 13                         	cmp	#1, r3

ffe00cc4 <.LBB235>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00cc4:	b0 db                         	movu.b	3[r5], r3

ffe00cc6 <.LBE235>:
    if ((SCI_IIC_MODE_RECEIVE == g_sci_iic_handles[p_sci_iic_info->ch_no]->api_mode)
ffe00cc6:	24 0d                         	bgtu.b	ffe00cd3 <_Reset_Vector+0xffe00cd7>

ffe00cc8 <.LBB238>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00cc8:	fe 63 44                      	mov.l	[r3, r4], r4
ffe00ccb:	ec 44                         	mov.l	[r4], r4
ffe00ccd:	a8 4c                         	mov.l	4[r4], r4

ffe00ccf <.LVL133>:
    ret = pregs->RDR;
ffe00ccf:	89 4c                         	mov.b	5[r4], r4

ffe00cd1 <.LBE238>:
        uctmp = sci_iic_get_receiving_data(p_sci_iic_info);
ffe00cd1:	c3 04                         	mov.b	r4, [r0]

ffe00cd3 <.LBB239>:
} /* End of function sci_iic_nack() */
ffe00cd3:	66 01                         	mov.l	#0, r1

ffe00cd5 <.LBB242>:
    g_sci_iic_ChStatus[p_sci_iic_info->ch_no] = status;
ffe00cd5:	fb 42 fc 01 00 00             	mov.l	#508, r4
ffe00cdb:	66 37                         	mov.l	#3, r7
ffe00cdd:	fe 03 47                      	mov.b	r7, [r3, r4]
    p_sci_iic_info->dev_sts = status;
ffe00ce0:	80 d7                         	mov.b	r7, 2[r5]

ffe00ce2 <.LBE242>:
} /* End of function sci_iic_nack() */
ffe00ce2:	3f 77 02                      	rtsd	#8, r7-r7

ffe00ce5 <.LFE25>:
ffe00ce5:	fc 13 00                      	nop	; max	r0, r0

ffe00ce8 <_sci_iic_init_driver>:
{
ffe00ce8:	7e a7                         	push.l	r7
ffe00cea:	ef 17                         	mov.l	r1, r7
    r_sci_iic_init_io_register(p_sci_iic_info);
ffe00cec:	05 24 f9 ff                   	bsr.a	ffe00610 <_Reset_Vector+0xffe00614>

ffe00cf0 <.LBB245>:
} /* End of function sci_iic_init_driver() */
ffe00cf0:	66 01                         	mov.l	#0, r1

ffe00cf2 <.LBB248>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00cf2:	b0 fc                         	movu.b	3[r7], r4
ffe00cf4:	fb 52 cc 5f e0 ff             	mov.l	#0xffe05fcc, r5
ffe00cfa:	fe 64 55                      	mov.l	[r4, r5], r5
ffe00cfd:	e5 55 03 04                   	mov.l	12[r5], 16[r5]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00d01:	3e 53 01                      	mov.l	#1, 12[r5]

ffe00d04 <.LBE248>:
} /* End of function sci_iic_init_driver() */
ffe00d04:	3f 77 01                      	rtsd	#4, r7-r7

ffe00d07 <.LFE18>:
	...

ffe00d08 <_sci_iic_read_data_receiving>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00d08:	fb 52 cc 5f e0 ff             	mov.l	#0xffe05fcc, r5
    if (1U >= p_sci_iic_info->cnt2nd)
ffe00d0e:	a8 93                         	mov.l	8[r1], r3
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00d10:	b0 9c                         	movu.b	3[r1], r4
ffe00d12:	a9 12                         	mov.l	16[r1], r2
ffe00d14:	fe 64 54                      	mov.l	[r4, r5], r4
ffe00d17:	ec 44                         	mov.l	[r4], r4
ffe00d19:	a8 4c                         	mov.l	4[r4], r4

ffe00d1b <.LVL141>:
    if (1U >= p_sci_iic_info->cnt2nd)
ffe00d1b:	61 13                         	cmp	#1, r3
ffe00d1d:	25 1b                         	bleu.b	ffe00d38 <_Reset_Vector+0xffe00d3c>
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00d1f:	ef 45                         	mov.l	r4, r5

ffe00d21 <.LBB261>:
    ret = pregs->RDR;
ffe00d21:	89 5d                         	mov.b	5[r5], r5

ffe00d23 <.LVL143>:
        (*p_sci_iic_info->p_data2nd) = sci_iic_get_receiving_data(p_sci_iic_info);
ffe00d23:	c3 25                         	mov.b	r5, [r2]
        p_sci_iic_info->cnt2nd--; /* Decreases the receiving data counter.  */
ffe00d25:	a8 93                         	mov.l	8[r1], r3
        p_sci_iic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffe00d27:	a9 15                         	mov.l	16[r1], r5
        p_sci_iic_info->cnt2nd--; /* Decreases the receiving data counter.  */
ffe00d29:	60 13                         	sub	#1, r3
        p_sci_iic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffe00d2b:	62 15                         	add	#1, r5
        p_sci_iic_info->cnt2nd--; /* Decreases the receiving data counter.  */
ffe00d2d:	a0 93                         	mov.l	r3, 8[r1]
        p_sci_iic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffe00d2f:	a1 15                         	mov.l	r5, 16[r1]
        pregs->TDR = 0xff;
ffe00d31:	f9 44 03 ff                   	mov.b	#255, 3[r4]
} /* End of function sci_iic_read_data_receiving() */
ffe00d35:	66 01                         	mov.l	#0, r1

ffe00d37 <.LVL144>:
ffe00d37:	02                            	rts

ffe00d38 <.LVL145>:
        pregs->SIMR2.BIT.IICACKT = SCI_IIC_NACK_TRANS;
ffe00d38:	f1 45 0a                      	bset	#5, 10[r4].b
    if (0U >= p_sci_iic_info->cnt2nd)
ffe00d3b:	61 03                         	cmp	#0, r3
ffe00d3d:	21 34                         	bne.b	ffe00d71 <_Reset_Vector+0xffe00d75>

ffe00d3f <.LBB263>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00d3f:	b0 9c                         	movu.b	3[r1], r4

ffe00d41 <.LVL147>:
ffe00d41:	fe 64 54                      	mov.l	[r4, r5], r4
ffe00d44:	ec 44                         	mov.l	[r4], r4
ffe00d46:	a8 4c                         	mov.l	4[r4], r4

ffe00d48 <.LVL148>:
    ret = pregs->RDR;
ffe00d48:	89 4c                         	mov.b	5[r4], r4

ffe00d4a <.LVL149>:
        (*p_sci_iic_info->p_data2nd) = sci_iic_get_receiving_data(p_sci_iic_info);
ffe00d4a:	c3 24                         	mov.b	r4, [r2]

ffe00d4c <.LBB267>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00d4c:	b0 9c                         	movu.b	3[r1], r4
ffe00d4e:	fe 64 54                      	mov.l	[r4, r5], r4
ffe00d51:	e5 44 03 04                   	mov.l	12[r4], 16[r4]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00d55:	3e 43 07                      	mov.l	#7, 12[r4]

ffe00d58 <.LBB269>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00d58:	b0 9c                         	movu.b	3[r1], r4
ffe00d5a:	fe 64 54                      	mov.l	[r4, r5], r4
ffe00d5d:	ec 45                         	mov.l	[r4], r5
ffe00d5f:	a8 5d                         	mov.l	4[r5], r5

ffe00d61 <.LVL152>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->mode = SCI_IIC_STPREQ; /* mode set stop mode. */
ffe00d61:	3c c4 04                      	mov.b	#4, 20[r4]
    pregs->SCR.BYTE |= SCI_IIC_SCR_TE_RE;
ffe00d64:	88 d4                         	mov.b	2[r5], r4
ffe00d66:	75 34 30                      	or	#48, r4
ffe00d69:	80 d4                         	mov.b	r4, 2[r5]
    pregs->SIMR3.BYTE = SCI_IIC_SP_CON_GENERATED;
ffe00d6b:	3c 5b 54                      	mov.b	#84, 11[r5]
} /* End of function sci_iic_read_data_receiving() */
ffe00d6e:	66 01                         	mov.l	#0, r1

ffe00d70 <.LVL153>:
ffe00d70:	02                            	rts

ffe00d71 <.LVL154>:
ffe00d71:	b0 9b                         	movu.b	3[r1], r3
ffe00d73:	fe 63 55                      	mov.l	[r3, r5], r5
ffe00d76:	ec 55                         	mov.l	[r5], r5
ffe00d78:	a8 5d                         	mov.l	4[r5], r5
ffe00d7a:	2e a7                         	bra.b	ffe00d21 <_Reset_Vector+0xffe00d25>

ffe00d7c <.LFE23>:
ffe00d7c:	76 10 01 00                   	nop	; mul	#1, r0

ffe00d80 <_sci_iic_disable>:
{
ffe00d80:	6e 6b                         	pushm	r6-r11
ffe00d82:	ef 16                         	mov.l	r1, r6

ffe00d84 <.LBB277>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00d84:	fb b2 cc 5f e0 ff             	mov.l	#0xffe05fcc, r11

ffe00d8a <.LBB280>:
#if SCI_IIC_CFG_PORT_SETTING_PROCESSING
    /* Disables SCI_IIC multi-function pin controller after setting SCL and SDA to Hi-z by Reset. */
    /* Includes I/O register read operation at the end of the following function. */
    sscl_port_gr = prom->sscl_port_gr;
    sscl_port_pin = prom->sscl_port_pin;
    r_sci_iic_mpc_setting(sscl_port_gr, sscl_port_pin, SCI_IIC_MPC_SSCL_INIT);
ffe00d8a:	66 03                         	mov.l	#0, r3

ffe00d8c <.LBB283>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00d8c:	b0 9f                         	movu.b	3[r1], r7
ffe00d8e:	fe 67 b7                      	mov.l	[r7, r11], r7
ffe00d91:	ec 77                         	mov.l	[r7], r7
ffe00d93:	a8 7f                         	mov.l	4[r7], r7

ffe00d95 <.LVL157>:
    pregs->SCR.BYTE = New_icier;
ffe00d95:	3c 72 00                      	mov.b	#0, 2[r7]

ffe00d98 <.LBB284>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00d98:	b0 9f                         	movu.b	3[r1], r7
ffe00d9a:	fe 67 b7                      	mov.l	[r7, r11], r7
ffe00d9d:	ec 7a                         	mov.l	[r7], r10
    sscl_port_gr = prom->sscl_port_gr;
ffe00d9f:	cd a1 39                      	mov.b	57[r10], r1

ffe00da2 <.LVL159>:
    sscl_port_pin = prom->sscl_port_pin;
ffe00da2:	cd a2 3a                      	mov.b	58[r10], r2
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00da5:	ed a7 01                      	mov.l	4[r10], r7

ffe00da8 <.LVL160>:
    r_sci_iic_mpc_setting(sscl_port_gr, sscl_port_pin, SCI_IIC_MPC_SSCL_INIT);
ffe00da8:	05 f0 fa ff                   	bsr.a	ffe00898 <_Reset_Vector+0xffe0089c>

ffe00dac <.LVL161>:
    ssda_port_gr = prom->ssda_port_gr;
ffe00dac:	cd a1 3c                      	mov.b	60[r10], r1

ffe00daf <.LVL162>:
    ssda_port_pin = prom->ssda_port_pin;
ffe00daf:	cd a2 3d                      	mov.b	61[r10], r2

ffe00db2 <.LVL163>:
    r_sci_iic_mpc_setting(ssda_port_gr, ssda_port_pin, SCI_IIC_MPC_SSDA_INIT);
ffe00db2:	66 03                         	mov.l	#0, r3
ffe00db4:	05 e4 fa ff                   	bsr.a	ffe00898 <_Reset_Vector+0xffe0089c>

ffe00db8 <.LVL164>:
#endif

    /* Resets SCI_IIC registers. */
    pregs->SCMR.BIT.SMIF = 0;
ffe00db8:	f1 78 06                      	bclr	#0, 6[r7].b
    pregs->SIMR1.BIT.IICM = 0;
ffe00dbb:	f1 78 09                      	bclr	#0, 9[r7].b

    /* dummy read */
    if (pregs->SCMR.BYTE)
ffe00dbe:	b1 f7                         	movu.b	6[r7], r7

ffe00dc0 <.LVL165>:
ffe00dc0:	61 07                         	cmp	#0, r7
ffe00dc2:	20 03                         	beq.b	ffe00dc5 <_Reset_Vector+0xffe00dc9>
    {
        R_BSP_NOP();
ffe00dc4:	03                            	nop

ffe00dc5 <.LBE284>:
    r_sci_iic_int_disable(p_sci_iic_info);
ffe00dc5:	ef 61                         	mov.l	r6, r1
ffe00dc7:	05 29 fa ff                   	bsr.a	ffe007f0 <_Reset_Vector+0xffe007f4>

ffe00dcb <.LBB285>:
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_b_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00dcb:	b0 ef                         	movu.b	3[r6], r7
ffe00dcd:	fe 67 b7                      	mov.l	[r7, r11], r7
ffe00dd0:	e5 77 03 04                   	mov.l	12[r7], 16[r7]
    g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status = new_status;
ffe00dd4:	3e 73 01                      	mov.l	#1, 12[r7]

ffe00dd7 <.LVL167>:
} /* End of function sci_iic_disable() */
ffe00dd7:	3f 6b 06                      	rtsd	#24, r6-r11

ffe00dda <.LFE31>:
ffe00dda:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe00de0 <_r_sci_iic_advance>:
{
ffe00de0:	6e 6c                         	pushm	r6-r12
ffe00de2:	60 40                         	sub	#4, r0
    if (NULL == p_sci_iic_info)
ffe00de4:	61 01                         	cmp	#0, r1
ffe00de6:	20 7e                         	beq.b	ffe00e64 <_Reset_Vector+0xffe00e68>

ffe00de8 <.LBB487>:
    switch (g_sci_iic_ChStatus[p_sci_iic_info->ch_no])
ffe00de8:	fb 62 fc 01 00 00             	mov.l	#508, r6

ffe00dee <.LBE489>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00dee:	b0 9f                         	movu.b	3[r1], r7

ffe00df0 <.LBB495>:
    switch (g_sci_iic_ChStatus[p_sci_iic_info->ch_no])
ffe00df0:	fe c7 65                      	movu.b	[r7, r6], r5
ffe00df3:	61 05                         	cmp	#0, r5
ffe00df5:	20 76                         	beq.b	ffe00e6b <_Reset_Vector+0xffe00e6f>
ffe00df7:	61 45                         	cmp	#4, r5
ffe00df9:	10                            	beq.s	ffe00e01 <_Reset_Vector+0xffe00e05>

ffe00dfa <.LVL338>:
            ret = SCI_IIC_ERR_OTHER;
ffe00dfa:	66 6a                         	mov.l	#6, r10

ffe00dfc <.LBE487>:
} /* End of function r_sci_iic_advance() */
ffe00dfc:	ef a1                         	mov.l	r10, r1
ffe00dfe:	3f 6c 08                      	rtsd	#32, r6-r12

ffe00e01 <.LBB496>:
            else if (SCI_IIC_COMMUNICATION == p_sci_iic_info->dev_sts)
ffe00e01:	59 1a 02                      	movu.b	2[r1], r10
ffe00e04:	61 4a                         	cmp	#4, r10
ffe00e06:	21 f4                         	bne.b	ffe00dfa <_Reset_Vector+0xffe00dfe>

ffe00e08 <.LBE496>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00e08:	fb b2 cc 5f e0 ff             	mov.l	#0xffe05fcc, r11
ffe00e0e:	fe 67 ba                      	mov.l	[r7, r11], r10

ffe00e11 <.LBB497>:
    if (SCI_IIC_EV_INIT != g_sci_iic_handles[p_sci_iic_info->ch_no]->api_event)
ffe00e11:	ed a5 01                      	mov.l	4[r10], r5
ffe00e14:	61 05                         	cmp	#0, r5
ffe00e16:	20 e4                         	beq.b	ffe00dfa <_Reset_Vector+0xffe00dfe>

ffe00e18 <.LBB498>:
    n_status = g_sci_iic_handles[p_sci_iic_info->ch_no]->api_n_status;
ffe00e18:	ed a7 03                      	mov.l	12[r10], r7

ffe00e1b <.LVL343>:
    if ((SCI_IIC_STS_MAX > n_status) && (SCI_IIC_EV_MAX > event))
ffe00e1b:	61 77                         	cmp	#7, r7
ffe00e1d:	24 dd                         	bgtu.b	ffe00dfa <_Reset_Vector+0xffe00dfe>
ffe00e1f:	61 65                         	cmp	#6, r5
ffe00e21:	24 d9                         	bgtu.b	ffe00dfa <_Reset_Vector+0xffe00dfe>
        if (NULL != gc_sci_iic_mtx_tbl[n_status][event].proc)
ffe00e23:	63 77                         	mul	#7, r7

ffe00e25 <.LVL344>:
ffe00e25:	4b 57                         	add	r5, r7
ffe00e27:	6c 37                         	shll	#3, r7
ffe00e29:	70 77 48 60 e0 ff             	add	#0xffe06048, r7, r7
ffe00e2f:	a8 7d                         	mov.l	4[r7], r5

ffe00e31 <.LVL345>:
ffe00e31:	61 05                         	cmp	#0, r5
ffe00e33:	20 c7                         	beq.b	ffe00dfa <_Reset_Vector+0xffe00dfe>
ffe00e35:	ef 17                         	mov.l	r1, r7

ffe00e37 <.LBE498>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00e37:	ec a4                         	mov.l	[r10], r4
ffe00e39:	ed 4c 01                      	mov.l	4[r4], r12

ffe00e3c <.LBB501>:
            g_sci_iic_handles[p_sci_iic_info->ch_no]->api_event = SCI_IIC_EV_INIT;
ffe00e3c:	f9 a6 01 00                   	mov.l	#0, 4[r10]

ffe00e40 <.LVL347>:
            ret = (*pFunc)(p_sci_iic_info);
ffe00e40:	7f 15                         	jsr	r5

ffe00e42 <.LBE501>:
        if (SCI_IIC_SUCCESS == ret)
ffe00e42:	71 1a 00                      	add	#0, r1, r10
ffe00e45:	21 b5                         	bne.b	ffe00dfa <_Reset_Vector+0xffe00dfe>
            switch (g_sci_iic_ChStatus[p_sci_iic_info->ch_no])
ffe00e47:	b0 fc                         	movu.b	3[r7], r4
ffe00e49:	fe c4 65                      	movu.b	[r4, r6], r5
ffe00e4c:	61 35                         	cmp	#3, r5
ffe00e4e:	20 24                         	beq.b	ffe00e72 <_Reset_Vector+0xffe00e76>
ffe00e50:	61 45                         	cmp	#4, r5
ffe00e52:	20 aa                         	beq.b	ffe00dfc <_Reset_Vector+0xffe00e00>
ffe00e54:	61 25                         	cmp	#2, r5
ffe00e56:	3a 8b 00                      	beq.w	ffe00ee1 <_Reset_Vector+0xffe00ee5>
                    if (NULL != g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc)
ffe00e59:	fe 64 b7                      	mov.l	[r4, r11], r7

ffe00e5c <.LVL349>:
ffe00e5c:	a9 f7                         	mov.l	24[r7], r7
ffe00e5e:	a8 7f                         	mov.l	4[r7], r7
ffe00e60:	61 07                         	cmp	#0, r7
ffe00e62:	21 7a                         	bne.b	ffe00edc <_Reset_Vector+0xffe00ee0>

ffe00e64 <.LBE524>:
        ret = SCI_IIC_ERR_INVALID_ARG;
ffe00e64:	66 3a                         	mov.l	#3, r10
} /* End of function r_sci_iic_advance() */
ffe00e66:	ef a1                         	mov.l	r10, r1
ffe00e68:	3f 6c 08                      	rtsd	#32, r6-r12

ffe00e6b <.LBB502>:
            ret = SCI_IIC_ERR_NO_INIT;
ffe00e6b:	66 4a                         	mov.l	#4, r10

ffe00e6d <.LBE502>:
} /* End of function r_sci_iic_advance() */
ffe00e6d:	ef a1                         	mov.l	r10, r1

ffe00e6f <.LVL352>:
ffe00e6f:	3f 6c 08                      	rtsd	#32, r6-r12

ffe00e72 <.LBB503>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00e72:	fe 64 b5                      	mov.l	[r4, r11], r5

ffe00e75 <.LBE505>:
    cnt = SCI_IIC_STOP_COND_WAIT;
ffe00e75:	f8 09 e8 03                   	mov.w	#0x3e8, [r0]

ffe00e79 <.LBB511>:
    sci_regs_t pregs = g_sci_iic_handles[p_sci_iic_info->ch_no]->prom->regs;
ffe00e79:	ec 54                         	mov.l	[r5], r4
ffe00e7b:	b5 55                         	movu.b	20[r5], r5
ffe00e7d:	a8 4c                         	mov.l	4[r4], r4
ffe00e7f:	61 45                         	cmp	#4, r5
ffe00e81:	3a a7 00                      	beq.w	ffe00f28 <_Reset_Vector+0xffe00f2c>
ffe00e84:	76 10 01 00                   	nop	; mul	#1, r0

ffe00e88 <.LBB512>:
        cnt--;
ffe00e88:	dc 05                         	mov.w	[r0], r5
ffe00e8a:	60 15                         	sub	#1, r5
ffe00e8c:	d3 05                         	mov.w	r5, [r0]
    } while (0U != cnt);/* WAIT_LOOP */
ffe00e8e:	5c 05                         	movu.w	[r0], r5
ffe00e90:	61 05                         	cmp	#0, r5
ffe00e92:	21 f6                         	bne.b	ffe00e88 <_Reset_Vector+0xffe00e8c>
    if (0U == cnt)
ffe00e94:	5c 09                         	movu.w	[r0], r9
ffe00e96:	61 09                         	cmp	#0, r9
ffe00e98:	fc db 91                      	scne.l	r9

ffe00e9b <.LBE503>:
                    sci_iic_disable(p_sci_iic_info);
ffe00e9b:	ef 71                         	mov.l	r7, r1
ffe00e9d:	05 e3 fe ff                   	bsr.a	ffe00d80 <_Reset_Vector+0xffe00d84>

ffe00ea1 <.LVL356>:
                    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffe00ea1:	f1 cb 0b                      	bclr	#3, 11[r12].b
                    pregs->SIMR3.BIT.IICSCLS = SCI_IIC_HI_Z_OUTPUT;
ffe00ea4:	cd c5 0b                      	mov.b	11[r12], r5
ffe00ea7:	75 35 c0                      	or	#-64, r5
ffe00eaa:	c7 c5 0b                      	mov.b	r5, 11[r12]
                    pregs->SIMR3.BIT.IICSDAS = SCI_IIC_HI_Z_OUTPUT;
ffe00ead:	cd c5 0b                      	mov.b	11[r12], r5
ffe00eb0:	75 35 30                      	or	#48, r5
ffe00eb3:	c7 c5 0b                      	mov.b	r5, 11[r12]
                    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffe00eb6:	ef 00                         	nop	; mov.l	r0, r0
ffe00eb8:	cd c5 0b                      	mov.b	11[r12], r5
ffe00ebb:	7c 35                         	btst	#3, r5
ffe00ebd:	21 fb                         	bne.b	ffe00eb8 <_Reset_Vector+0xffe00ebc>
                    if (SCI_IIC_TRUE == boolret)
ffe00ebf:	5b 99                         	movu.b	r9, r9
ffe00ec1:	b0 fd                         	movu.b	3[r7], r5
ffe00ec3:	61 09                         	cmp	#0, r9
ffe00ec5:	21 0c                         	bne.b	ffe00ed1 <_Reset_Vector+0xffe00ed5>

ffe00ec7 <.LBB516>:
    g_sci_iic_ChStatus[p_sci_iic_info->ch_no] = status;
ffe00ec7:	66 5a                         	mov.l	#5, r10
ffe00ec9:	fe 05 6a                      	mov.b	r10, [r5, r6]

ffe00ecc <.LBE516>:
                        ret = SCI_IIC_ERR_BUS_BUSY;
ffe00ecc:	66 5a                         	mov.l	#5, r10

ffe00ece <.LBB519>:
    p_sci_iic_info->dev_sts = status;
ffe00ece:	3c 72 05                      	mov.b	#5, 2[r7]

ffe00ed1 <.LBE519>:
                    if (NULL != g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc)
ffe00ed1:	fe 65 b7                      	mov.l	[r5, r11], r7

ffe00ed4 <.LVL359>:
ffe00ed4:	a9 f7                         	mov.l	24[r7], r7
ffe00ed6:	a8 7f                         	mov.l	4[r7], r7
ffe00ed8:	61 07                         	cmp	#0, r7
ffe00eda:	20 8a                         	beq.b	ffe00e64 <_Reset_Vector+0xffe00e68>

ffe00edc <.LVL360>:
                        g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc();
ffe00edc:	7f 17                         	jsr	r7
                break;
ffe00ede:	38 1e ff                      	bra.w	ffe00dfc <_Reset_Vector+0xffe00e00>

ffe00ee1 <.LVL362>:
                    sci_iic_disable(p_sci_iic_info);
ffe00ee1:	ef 71                         	mov.l	r7, r1
ffe00ee3:	05 9d fe ff                   	bsr.a	ffe00d80 <_Reset_Vector+0xffe00d84>

ffe00ee7 <.LVL363>:
                    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffe00ee7:	f1 cb 0b                      	bclr	#3, 11[r12].b
                    pregs->SIMR3.BIT.IICSCLS = SCI_IIC_HI_Z_OUTPUT;
ffe00eea:	cd c5 0b                      	mov.b	11[r12], r5
ffe00eed:	75 35 c0                      	or	#-64, r5
ffe00ef0:	c7 c5 0b                      	mov.b	r5, 11[r12]
                    pregs->SIMR3.BIT.IICSDAS = SCI_IIC_HI_Z_OUTPUT;
ffe00ef3:	cd c5 0b                      	mov.b	11[r12], r5
ffe00ef6:	75 35 30                      	or	#48, r5
ffe00ef9:	c7 c5 0b                      	mov.b	r5, 11[r12]
                    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffe00efc:	76 10 01 00                   	nop	; mul	#1, r0
ffe00f00:	cd c5 0b                      	mov.b	11[r12], r5
ffe00f03:	7c 35                         	btst	#3, r5
ffe00f05:	21 fb                         	bne.b	ffe00f00 <_Reset_Vector+0xffe00f04>
                    if (NULL != g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc)
ffe00f07:	b0 ff                         	movu.b	3[r7], r7

ffe00f09 <.LVL364>:
ffe00f09:	fe 67 b7                      	mov.l	[r7, r11], r7
ffe00f0c:	a9 f7                         	mov.l	24[r7], r7
ffe00f0e:	a8 7f                         	mov.l	4[r7], r7
ffe00f10:	61 07                         	cmp	#0, r7
ffe00f12:	3a 52 ff                      	beq.w	ffe00e64 <_Reset_Vector+0xffe00e68>
                        g_sci_iic_handles[p_sci_iic_info->ch_no]->psci_iic_info_ch->callbackfunc();
ffe00f15:	7f 17                         	jsr	r7

ffe00f17 <.LVL365>:
                break;
ffe00f17:	38 e5 fe                      	bra.w	ffe00dfc <_Reset_Vector+0xffe00e00>

ffe00f1a <.LBB520>:
        cnt--;
ffe00f1a:	dc 05                         	mov.w	[r0], r5
ffe00f1c:	60 15                         	sub	#1, r5
ffe00f1e:	d3 05                         	mov.w	r5, [r0]
    } while (0U != cnt);/* WAIT_LOOP */
ffe00f20:	5c 05                         	movu.w	[r0], r5
ffe00f22:	61 05                         	cmp	#0, r5
ffe00f24:	3a 70 ff                      	beq.w	ffe00e94 <_Reset_Vector+0xffe00e98>

ffe00f27 <.LVL367>:
ffe00f27:	03                            	nop

ffe00f28 <.LBB513>:
    if ((SCI_IIC_STPREQ == g_sci_iic_handles[p_sci_iic_info->ch_no]->mode) && (1 == pregs->SIMR3.BIT.IICSTIF))
ffe00f28:	8a cd                         	mov.b	11[r4], r5
ffe00f2a:	68 35                         	shlr	#3, r5
ffe00f2c:	64 15                         	and	#1, r5
ffe00f2e:	cf 59                         	mov.b	r5, r9
ffe00f30:	20 ea                         	beq.b	ffe00f1a <_Reset_Vector+0xffe00f1e>
ffe00f32:	38 69 ff                      	bra.w	ffe00e9b <_Reset_Vector+0xffe00e9f>

ffe00f35 <.LBE514>:
ffe00f35:	fc 13 00                      	nop	; max	r0, r0

ffe00f38 <_r_sci_iic_txi_isr_processing>:
 * Arguments    : uint8_t ch_no    ; number of channel
 * Return Value : None
 **********************************************************************************************************************/
void r_sci_iic_txi_isr_processing (uint8_t ch_no)
{
    sci_regs_t pregs = g_sci_iic_handles[ch_no]->prom->regs;
ffe00f38:	5b 11                         	movu.b	r1, r1
ffe00f3a:	fb 52 cc 5f e0 ff             	mov.l	#0xffe05fcc, r5
ffe00f40:	fe 61 55                      	mov.l	[r1, r5], r5
ffe00f43:	ec 54                         	mov.l	[r5], r4

    /* ---- Checks NACK reception. ---- */
    if ((((SCI_IIC_MODE_SEND == g_sci_iic_handles[ch_no]->api_mode)
ffe00f45:	a8 d3                         	mov.l	8[r5], r3
    sci_regs_t pregs = g_sci_iic_handles[ch_no]->prom->regs;
ffe00f47:	a8 4a                         	mov.l	4[r4], r2

ffe00f49 <.LVL369>:
    if ((((SCI_IIC_MODE_SEND == g_sci_iic_handles[ch_no]->api_mode)
ffe00f49:	61 23                         	cmp	#2, r3
ffe00f4b:	20 32                         	beq.b	ffe00f7d <_Reset_Vector+0xffe00f81>
            || (SCI_IIC_STS_SEND_SLVADR_R_WAIT == g_sci_iic_handles[ch_no]->api_n_status))
ffe00f4d:	a8 dc                         	mov.l	12[r5], r4
ffe00f4f:	61 44                         	cmp	#4, r4
ffe00f51:	20 0e                         	beq.b	ffe00f5f <_Reset_Vector+0xffe00f63>
            || ((SCI_IIC_MODE_SEND_RECEIVE == g_sci_iic_handles[ch_no]->api_mode)
ffe00f53:	61 43                         	cmp	#4, r3
ffe00f55:	20 17                         	beq.b	ffe00f6c <_Reset_Vector+0xffe00f70>
    }
    else
    {
        /* ---- Receive ACK reception ---- */
        /* Sets event. */
        switch (g_sci_iic_handles[ch_no]->api_n_status)
ffe00f57:	61 54                         	cmp	#5, r4
ffe00f59:	21 1b                         	bne.b	ffe00f74 <_Reset_Vector+0xffe00f78>
            break;

            case SCI_IIC_STS_SEND_DATA_WAIT :

                /* Sets interrupted data sending. */
                g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_SEND;
ffe00f5b:	3e 51 04                      	mov.l	#4, 4[r5]
            break;
        }

    }

} /* End of function r_sci_iic_txi_isr_processing() */
ffe00f5e:	02                            	rts
        if (0U != pregs->SISR.BIT.IICACKR)
ffe00f5f:	8b 24                         	mov.b	12[r2], r4
ffe00f61:	7c 04                         	btst	#0, r4
ffe00f63:	20 2d                         	beq.b	ffe00f90 <_Reset_Vector+0xffe00f94>
ffe00f65:	fc 13 00                      	nop	; max	r0, r0
            g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_NACK;
ffe00f68:	3e 51 06                      	mov.l	#6, 4[r5]
ffe00f6b:	02                            	rts
                    && (SCI_IIC_STS_SEND_SLVADR_W_WAIT == g_sci_iic_handles[ch_no]->api_n_status)))
ffe00f6c:	61 34                         	cmp	#3, r4
ffe00f6e:	20 f1                         	beq.b	ffe00f5f <_Reset_Vector+0xffe00f63>
                    && (SCI_IIC_STS_SEND_DATA_WAIT == g_sci_iic_handles[ch_no]->api_n_status)))
ffe00f70:	61 54                         	cmp	#5, r4
ffe00f72:	20 27                         	beq.b	ffe00f99 <_Reset_Vector+0xffe00f9d>
        switch (g_sci_iic_handles[ch_no]->api_n_status)
ffe00f74:	61 64                         	cmp	#6, r4
ffe00f76:	20 1a                         	beq.b	ffe00f90 <_Reset_Vector+0xffe00f94>
ffe00f78:	61 34                         	cmp	#3, r4
ffe00f7a:	20 16                         	beq.b	ffe00f90 <_Reset_Vector+0xffe00f94>
} /* End of function r_sci_iic_txi_isr_processing() */
ffe00f7c:	02                            	rts
        if (0U != pregs->SISR.BIT.IICACKR)
ffe00f7d:	8b 24                         	mov.b	12[r2], r4
ffe00f7f:	7c 04                         	btst	#0, r4
ffe00f81:	21 e7                         	bne.b	ffe00f68 <_Reset_Vector+0xffe00f6c>
            switch (g_sci_iic_handles[ch_no]->api_n_status)
ffe00f83:	a8 dc                         	mov.l	12[r5], r4
ffe00f85:	61 54                         	cmp	#5, r4
ffe00f87:	20 d4                         	beq.b	ffe00f5b <_Reset_Vector+0xffe00f5f>
ffe00f89:	24 0b                         	bgtu.b	ffe00f94 <_Reset_Vector+0xffe00f98>
ffe00f8b:	61 34                         	cmp	#3, r4
ffe00f8d:	23 ef                         	bnc.b	ffe00f7c <_Reset_Vector+0xffe00f80>
ffe00f8f:	03                            	nop
                g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_ADD;
ffe00f90:	3e 51 03                      	mov.l	#3, 4[r5]
            break;
ffe00f93:	02                            	rts
            switch (g_sci_iic_handles[ch_no]->api_n_status)
ffe00f94:	61 64                         	cmp	#6, r4
ffe00f96:	20 fa                         	beq.b	ffe00f90 <_Reset_Vector+0xffe00f94>
} /* End of function r_sci_iic_txi_isr_processing() */
ffe00f98:	02                            	rts
        if (0U != pregs->SISR.BIT.IICACKR)
ffe00f99:	8b 24                         	mov.b	12[r2], r4
ffe00f9b:	7c 04                         	btst	#0, r4
ffe00f9d:	21 cb                         	bne.b	ffe00f68 <_Reset_Vector+0xffe00f6c>
ffe00f9f:	2e bc                         	bra.b	ffe00f5b <_Reset_Vector+0xffe00f5f>

ffe00fa1 <.LFE45>:
ffe00fa1:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe00fa8 <_r_sci_iic_tei_isr_processing>:
 * Arguments    : uint8_t ch_no    ; number of channel
 * Return Value : None
 **********************************************************************************************************************/
void r_sci_iic_tei_isr_processing (uint8_t ch_no)
{
    sci_regs_t pregs = g_sci_iic_handles[ch_no]->prom->regs;
ffe00fa8:	5b 11                         	movu.b	r1, r1
ffe00faa:	fb 52 cc 5f e0 ff             	mov.l	#0xffe05fcc, r5
ffe00fb0:	fe 61 51                      	mov.l	[r1, r5], r1

ffe00fb3 <.LVL371>:
ffe00fb3:	ec 13                         	mov.l	[r1], r3
ffe00fb5:	a8 3c                         	mov.l	4[r3], r4

ffe00fb7 <.LVL372>:

    /* Clear IR flag */
    pregs->SIMR3.BIT.IICSTIF = SCI_IIC_IICSTIF_CLEAR;
ffe00fb7:	f1 4b 0b                      	bclr	#3, 11[r4].b

    /* WAIT_LOOP */
    while (SCI_IIC_IICSTIF_CLEAR != pregs->SIMR3.BIT.IICSTIF)
ffe00fba:	8a cd                         	mov.b	11[r4], r5
ffe00fbc:	7c 35                         	btst	#3, r5
ffe00fbe:	21 fc                         	bne.b	ffe00fba <_Reset_Vector+0xffe00fbe>
    {
        /* nothing to do */
    }

    /* WAIT_LOOP */
    while (0 != ((*g_sci_iic_handles[ch_no]->prom->pir_tei) & (g_sci_iic_handles[ch_no]->prom->tei_ir_mask)))
ffe00fc0:	a9 b2                         	mov.l	24[r3], r2
ffe00fc2:	a9 bb                         	mov.l	28[r3], r3
ffe00fc4:	ec 25                         	mov.l	[r2], r5
ffe00fc6:	fc 33 35                      	tst	r3, r5
ffe00fc9:	21 fb                         	bne.b	ffe00fc4 <_Reset_Vector+0xffe00fc8>
    {
        /* nothing to do */
    }

    /* ---- Checks NACK reception. ---- */
    if (0U != pregs->SISR.BIT.IICACKR)
ffe00fcb:	8b 45                         	mov.b	12[r4], r5
ffe00fcd:	7c 05                         	btst	#0, r5
ffe00fcf:	21 16                         	bne.b	ffe00fe5 <_Reset_Vector+0xffe00fe9>
    {
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_NACK;
    }

    /* ---- Checks start condition detection. ---- */
    if ((SCI_IIC_STAREQ == g_sci_iic_handles[ch_no]->mode) || (SCI_IIC_RSTAREQ == g_sci_iic_handles[ch_no]->mode))
ffe00fd1:	8d 14                         	mov.b	20[r1], r4

ffe00fd3 <.LVL373>:
ffe00fd3:	71 45 ff                      	add	#-1, r4, r5
ffe00fd6:	5b 55                         	movu.b	r5, r5
ffe00fd8:	61 15                         	cmp	#1, r5
ffe00fda:	25 19                         	bleu.b	ffe00ff3 <_Reset_Vector+0xffe00ff7>
        /* Sets event flag. */
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_START;
    }

    /* ---- Checks stop condition detection. ---- */
    if (SCI_IIC_STPREQ == g_sci_iic_handles[ch_no]->mode)
ffe00fdc:	5b 44                         	movu.b	r4, r4
ffe00fde:	61 44                         	cmp	#4, r4
ffe00fe0:	1c                            	bne.s	ffe00fe4 <_Reset_Vector+0xffe00fe8>
    {
        /* Sets event flag. */
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_STOP;
ffe00fe1:	3e 11 05                      	mov.l	#5, 4[r1]
    }
} /* End of function r_sci_iic_tei_isr_processing() */
ffe00fe4:	02                            	rts

ffe00fe5 <.LVL374>:
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_NACK;
ffe00fe5:	3e 11 06                      	mov.l	#6, 4[r1]
    if ((SCI_IIC_STAREQ == g_sci_iic_handles[ch_no]->mode) || (SCI_IIC_RSTAREQ == g_sci_iic_handles[ch_no]->mode))
ffe00fe8:	8d 14                         	mov.b	20[r1], r4

ffe00fea <.LVL375>:
ffe00fea:	71 45 ff                      	add	#-1, r4, r5
ffe00fed:	5b 55                         	movu.b	r5, r5
ffe00fef:	61 15                         	cmp	#1, r5
ffe00ff1:	24 eb                         	bgtu.b	ffe00fdc <_Reset_Vector+0xffe00fe0>
        g_sci_iic_handles[ch_no]->mode = 0;
ffe00ff3:	3c 94 00                      	mov.b	#0, 20[r1]

ffe00ff6 <.LVL376>:
        g_sci_iic_handles[ch_no]->api_event = SCI_IIC_EV_INT_START;
ffe00ff6:	3e 11 02                      	mov.l	#2, 4[r1]
    if (SCI_IIC_STPREQ == g_sci_iic_handles[ch_no]->mode)
ffe00ff9:	02                            	rts

ffe00ffa <.LFE46>:
ffe00ffa:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe01000 <_riic_mcu_check_ir_txi>:
    switch (channel)
ffe01000:	5b 11                         	movu.b	r1, r1
ffe01002:	61 11                         	cmp	#1, r1
ffe01004:	16                            	beq.s	ffe0100a <_Reset_Vector+0xffe0100e>
    uint8_t ret = RIIC_IR_CLR;
ffe01005:	66 01                         	mov.l	#0, r1

ffe01007 <.LVL30>:
} /* End of function riic_mcu_check_ir_txi() */
ffe01007:	64 11                         	and	#1, r1

ffe01009 <.LVL31>:
ffe01009:	02                            	rts
            ret = RIIC_IR_TXI1;
ffe0100a:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe0100f:	cd 51 33                      	mov.b	51[r5], r1
ffe01012:	64 11                         	and	#1, r1

ffe01014 <.LVL32>:
} /* End of function riic_mcu_check_ir_txi() */
ffe01014:	64 11                         	and	#1, r1

ffe01016 <.LVL33>:
ffe01016:	02                            	rts

ffe01017 <_riic_mcu_check_ir_rxi>:
    switch (channel)
ffe01017:	5b 11                         	movu.b	r1, r1
ffe01019:	61 11                         	cmp	#1, r1
ffe0101b:	16                            	beq.s	ffe01021 <_Reset_Vector+0xffe01025>
    uint8_t ret = RIIC_IR_CLR;
ffe0101c:	66 01                         	mov.l	#0, r1

ffe0101e <.LVL35>:
} /* End of function riic_mcu_check_ir_rxi() */
ffe0101e:	64 11                         	and	#1, r1

ffe01020 <.LVL36>:
ffe01020:	02                            	rts
            ret = RIIC_IR_RXI1;
ffe01021:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe01026:	cd 51 32                      	mov.b	50[r5], r1
ffe01029:	64 11                         	and	#1, r1

ffe0102b <.LVL37>:
} /* End of function riic_mcu_check_ir_rxi() */
ffe0102b:	64 11                         	and	#1, r1

ffe0102d <.LVL38>:
ffe0102d:	02                            	rts

ffe0102e <_riic_mcu_clear_ir_txi>:
    switch (channel)
ffe0102e:	5b 11                         	movu.b	r1, r1
ffe01030:	61 11                         	cmp	#1, r1
ffe01032:	20 03                         	beq.b	ffe01035 <_Reset_Vector+0xffe01039>
} /* End of function riic_mcu_clear_ir_txi() */
ffe01034:	02                            	rts
            RIIC_IR_TXI1 = RIIC_IR_CLR; /* Clears TXI interrupt request register. */
ffe01035:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe0103a:	f1 58 33                      	bclr	#0, 51[r5].b
            if (RIIC_IR_CLR == RIIC_IR_TXI1)
ffe0103d:	cd 55 33                      	mov.b	51[r5], r5
} /* End of function riic_mcu_clear_ir_txi() */
ffe01040:	02                            	rts

ffe01041 <_riic_mcu_clear_ir_rxi>:
    switch (channel)
ffe01041:	5b 11                         	movu.b	r1, r1
ffe01043:	61 11                         	cmp	#1, r1
ffe01045:	20 03                         	beq.b	ffe01048 <_Reset_Vector+0xffe0104c>
} /* End of function riic_mcu_clear_ir_rxi() */
ffe01047:	02                            	rts
            RIIC_IR_RXI1 = RIIC_IR_CLR; /* Clears TXI interrupt request register. */
ffe01048:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe0104d:	f1 58 32                      	bclr	#0, 50[r5].b
            if (RIIC_IR_CLR == RIIC_IR_RXI1)
ffe01050:	cd 55 32                      	mov.b	50[r5], r5
} /* End of function riic_mcu_clear_ir_rxi() */
ffe01053:	02                            	rts

ffe01054 <_riic_mcu_int_icier_setting>:
{
ffe01054:	60 40                         	sub	#4, r0
    switch (channel)
ffe01056:	5b 11                         	movu.b	r1, r1
    volatile uint8_t uctmp = 0x00;
ffe01058:	f8 04 00                      	mov.b	#0, [r0]
    switch (channel)
ffe0105b:	61 11                         	cmp	#1, r1
ffe0105d:	13                            	beq.s	ffe01060 <_Reset_Vector+0xffe01064>
} /* End of function riic_mcu_int_icier_setting() */
ffe0105e:	67 01                         	rtsd	#4
            RIIC1.ICIER.BYTE = (New_icier | RIIC_ICIER_TMO);
ffe01060:	78 02                         	bset	#0, r2

ffe01062 <.LVL66>:
ffe01062:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffe01067:	81 da                         	mov.b	r2, 7[r5]
            uctmp = RIIC1.ICIER.BYTE; /* Reads ICIER. */
ffe01069:	89 dd                         	mov.b	7[r5], r5
ffe0106b:	c3 05                         	mov.b	r5, [r0]
} /* End of function riic_mcu_int_icier_setting() */
ffe0106d:	67 01                         	rtsd	#4

ffe0106f <.LFE16>:
	...

ffe01070 <_riic_mcu_int_enable>:
{
ffe01070:	7e a7                         	push.l	r7
ffe01072:	60 c0                         	sub	#12, r0
ffe01074:	cf 17                         	mov.b	r1, r7
    volatile uint8_t uctmp = 0x00;
ffe01076:	3c 08 00                      	mov.b	#0, 8[r0]
    group_priority.ipl = 0x00000000;
ffe01079:	3e 01 00                      	mov.l	#0, 4[r0]
    if (group_priority.ipl < RIIC_IPR_CH1_EEI_SET)
ffe0107c:	a8 0d                         	mov.l	4[r0], r5
ffe0107e:	61 25                         	cmp	#2, r5
ffe01080:	24 05                         	bgtu.b	ffe01085 <_Reset_Vector+0xffe01089>
        group_priority.ipl = (uint32_t) RIIC_IPR_CH1_EEI_SET;
ffe01082:	3e 01 03                      	mov.l	#3, 4[r0]
    if (group_priority.ipl < RIIC_IPR_CH1_TEI_SET)
ffe01085:	a8 0d                         	mov.l	4[r0], r5
ffe01087:	61 25                         	cmp	#2, r5
ffe01089:	24 07                         	bgtu.b	ffe01090 <_Reset_Vector+0xffe01094>
        group_priority.ipl = (uint32_t) RIIC_IPR_CH1_TEI_SET;
ffe0108b:	3e 01 03                      	mov.l	#3, 4[r0]
ffe0108e:	ef 00                         	nop	; mov.l	r0, r0
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_ENABLE, (void *) &group_priority);
ffe01090:	71 03 04                      	add	#4, r0, r3
ffe01093:	66 32                         	mov.l	#3, r2
ffe01095:	75 41 3c                      	mov.l	#60, r1

ffe01098 <.LVL68>:
ffe01098:	05 98 27 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0109c <.LVL69>:
    switch (channel)
ffe0109c:	5b 77                         	movu.b	r7, r7

ffe0109e <.LVL70>:
ffe0109e:	61 17                         	cmp	#1, r7
ffe010a0:	14                            	beq.s	ffe010a4 <_Reset_Vector+0xffe010a8>
} /* End of function riic_mcu_int_enable() */
ffe010a1:	3f 77 04                      	rtsd	#16, r7-r7

ffe010a4 <.LVL71>:
            RIIC_IER_EEI1_GPBL1 = RIIC_IER_ENABLE; /* Enables EEI1 groupBL1 interrupt request enable register. */
ffe010a4:	fb 7e 00 70 08                	mov.l	#0x87000, r7
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe010a9:	ef 03                         	mov.l	r0, r3
ffe010ab:	66 62                         	mov.l	#6, r2
ffe010ad:	75 41 5e                      	mov.l	#94, r1
ffe010b0:	05 80 27 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe010b4 <.LVL72>:
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe010b4:	ef 03                         	mov.l	r0, r3
ffe010b6:	66 52                         	mov.l	#5, r2
ffe010b8:	75 41 5e                      	mov.l	#94, r1
            RIIC_IER_EEI1_GPBL1 = RIIC_IER_ENABLE; /* Enables EEI1 groupBL1 interrupt request enable register. */
ffe010bb:	ee 75 9d 01                   	mov.l	1652[r7], r5
ffe010bf:	79 d5                         	bset	#29, r5
ffe010c1:	eb 75 9d 01                   	mov.l	r5, 1652[r7]
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe010c5:	05 6b 27 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe010c9 <.LVL73>:
            RIIC_IER_RXI1 = RIIC_IER_ENABLE; /* Enables RXI1 interrupt request enable register. */
ffe010c9:	f2 72 06 02                   	bset	#2, 518[r7].b
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe010cd:	ef 03                         	mov.l	r0, r3
            RIIC_IER_TXI1 = RIIC_IER_ENABLE; /* Enables TXI1 interrupt request enable register. */
ffe010cf:	f2 73 06 02                   	bset	#3, 518[r7].b
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe010d3:	66 62                         	mov.l	#6, r2
ffe010d5:	75 41 5e                      	mov.l	#94, r1
ffe010d8:	05 58 27 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe010dc <.LVL74>:
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe010dc:	ef 03                         	mov.l	r0, r3
ffe010de:	66 52                         	mov.l	#5, r2
ffe010e0:	75 41 5e                      	mov.l	#94, r1
            RIIC_IER_TEI1_GPBL1 = RIIC_IER_ENABLE; /* Enables TEI1 groupBL1 interrupt request enable register. */
ffe010e3:	ee 75 9d 01                   	mov.l	1652[r7], r5
ffe010e7:	79 c5                         	bset	#28, r5
ffe010e9:	eb 75 9d 01                   	mov.l	r5, 1652[r7]
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe010ed:	05 43 27 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe010f1 <.LVL75>:
            RIIC_IPR_RXI1 = RIIC_IPR_CH1_RXI_SET; /* Sets RXI1 interrupt source priority register. */
ffe010f1:	fa 74 32 03 02                	mov.b	#2, 818[r7]
            RIIC_IPR_TXI1 = RIIC_IPR_CH1_TXI_SET; /* Sets TXI1 interrupt source priority register. */
ffe010f6:	fa 74 33 03 02                	mov.b	#2, 819[r7]
            uctmp = RIIC_IPR_TXI1; /* Reads IPR. */
ffe010fb:	ce 77 33 03                   	mov.b	819[r7], r7
ffe010ff:	82 07                         	mov.b	r7, 8[r0]
} /* End of function riic_mcu_int_enable() */
ffe01101:	3f 77 04                      	rtsd	#16, r7-r7

ffe01104 <.LFE17>:
ffe01104:	76 10 01 00                   	nop	; mul	#1, r0

ffe01108 <_riic_mcu_int_disable>:
{
ffe01108:	7e a7                         	push.l	r7
ffe0110a:	60 c0                         	sub	#12, r0
    switch (channel)
ffe0110c:	5b 11                         	movu.b	r1, r1
    volatile uint8_t uctmp = 0x00;
ffe0110e:	3c 08 00                      	mov.b	#0, 8[r0]
    switch (channel)
ffe01111:	61 11                         	cmp	#1, r1
ffe01113:	20 14                         	beq.b	ffe01127 <_Reset_Vector+0xffe0112b>
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &group_priority);
ffe01115:	71 03 04                      	add	#4, r0, r3
ffe01118:	66 42                         	mov.l	#4, r2
ffe0111a:	75 41 3c                      	mov.l	#60, r1

ffe0111d <.LVL77>:
    group_priority.ipl = 0x00000000;
ffe0111d:	3e 01 00                      	mov.l	#0, 4[r0]
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &group_priority);
ffe01120:	05 10 27 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe01124 <.LVL78>:
} /* End of function riic_mcu_int_disable() */
ffe01124:	3f 77 04                      	rtsd	#16, r7-r7
            RIIC_IER_EEI1_GPBL1 = RIIC_IER_DISABLE; /* Disables TEI1 groupBL1 interrupt request enable register. */
ffe01127:	fb 7e 00 70 08                	mov.l	#0x87000, r7
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe0112c:	ef 03                         	mov.l	r0, r3
ffe0112e:	66 62                         	mov.l	#6, r2
ffe01130:	75 41 5e                      	mov.l	#94, r1
ffe01133:	05 fd 26 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe01137 <.LVL79>:
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe01137:	ef 03                         	mov.l	r0, r3
ffe01139:	66 52                         	mov.l	#5, r2
ffe0113b:	75 41 5e                      	mov.l	#94, r1
            RIIC_IER_EEI1_GPBL1 = RIIC_IER_DISABLE; /* Disables TEI1 groupBL1 interrupt request enable register. */
ffe0113e:	ee 75 9d 01                   	mov.l	1652[r7], r5
ffe01142:	7b d5                         	bclr	#29, r5
ffe01144:	eb 75 9d 01                   	mov.l	r5, 1652[r7]
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe01148:	05 e8 26 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0114c <.LVL80>:
            RIIC_IER_RXI1 = RIIC_IER_DISABLE; /* Disables RXI1 interrupt request enable register. */
ffe0114c:	f2 7a 06 02                   	bclr	#2, 518[r7].b
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe01150:	ef 03                         	mov.l	r0, r3
            RIIC_IER_TXI1 = RIIC_IER_DISABLE; /* Disables TXI1 interrupt request enable register. */
ffe01152:	f2 7b 06 02                   	bclr	#3, 518[r7].b
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe01156:	66 62                         	mov.l	#6, r2
ffe01158:	75 41 5e                      	mov.l	#94, r1
ffe0115b:	05 d5 26 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0115f <.LVL81>:
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe0115f:	ef 03                         	mov.l	r0, r3
ffe01161:	66 52                         	mov.l	#5, r2
ffe01163:	75 41 5e                      	mov.l	#94, r1
            RIIC_IER_TEI1_GPBL1 = RIIC_IER_DISABLE; /* Disables TEI1 groupBL1 interrupt request enable register. */
ffe01166:	ee 75 9d 01                   	mov.l	1652[r7], r5
ffe0116a:	7b c5                         	bclr	#28, r5
ffe0116c:	eb 75 9d 01                   	mov.l	r5, 1652[r7]
            R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe01170:	05 c0 26 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe01174 <.LVL82>:
            RIIC_IPR_RXI1 = RIIC_IPR_CH1_RXI_INIT; /* Sets RXI1 interrupt source priority register. */
ffe01174:	fa 74 32 03 00                	mov.b	#0, 818[r7]
            RIIC_IPR_TXI1 = RIIC_IPR_CH1_TXI_INIT; /* Sets TXI1 interrupt source priority register. */
ffe01179:	fa 74 33 03 00                	mov.b	#0, 819[r7]
            uctmp = RIIC_IPR_TXI1; /* Reads IPR. */
ffe0117e:	ce 77 33 03                   	mov.b	819[r7], r7
ffe01182:	82 07                         	mov.b	r7, 8[r0]
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &group_priority);
ffe01184:	71 03 04                      	add	#4, r0, r3
ffe01187:	66 42                         	mov.l	#4, r2
ffe01189:	75 41 3c                      	mov.l	#60, r1
    group_priority.ipl = 0x00000000;
ffe0118c:	3e 01 00                      	mov.l	#0, 4[r0]
    R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_GROUP_INTERRUPT_DISABLE, (void *) &group_priority);
ffe0118f:	05 a1 26 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe01193 <.LVL83>:
} /* End of function riic_mcu_int_disable() */
ffe01193:	3f 77 04                      	rtsd	#16, r7-r7

ffe01196 <_riic_mcu_check_freq>:
} /* End of function riic_mcu_check_freq() */
ffe01196:	fb 12 c0 e1 64 4c             	mov.l	#0x4c64e1c0, r1
ffe0119c:	02                            	rts

ffe0119d <_riic_time_out>:
 *              : riic_api_status_t new_status  ; New status
 * Return Value : None
 **********************************************************************************************************************/
static void riic_api_status_set (riic_info_t * p_riic_info, riic_api_status_t new_status)
{
    uint8_t ch_no = p_riic_info->ch_no;
ffe0119d:	88 9d                         	mov.b	3[r1], r5

ffe0119f <.LBE320>:
} /* End of function riic_time_out() */
ffe0119f:	66 01                         	mov.l	#0, r1

ffe011a1 <.LBB323>:
    
    /* Sets the previous status. */
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe011a1:	5b 55                         	movu.b	r5, r5
ffe011a3:	6c 45                         	shll	#4, r5

ffe011a5 <.LVL3>:
ffe011a5:	70 55 24 00 00 00             	add	#36, r5, r5
ffe011ab:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

    /* Sets the now status. */
    riic_api_info[ch_no].N_status = new_status;
ffe011af:	3e 52 0a                      	mov.l	#10, 8[r5]

ffe011b2 <.LBE323>:
} /* End of function riic_time_out() */
ffe011b2:	02                            	rts

ffe011b3 <.LFE31>:
ffe011b3:	00                            	brk
ffe011b4:	00                            	brk
ffe011b5:	00                            	brk
	...

ffe011b8 <_riic_enable_slave_transfer>:
{
ffe011b8:	6e 6b                         	pushm	r6-r11
ffe011ba:	60 40                         	sub	#4, r0
ffe011bc:	ef 15                         	mov.l	r1, r5

ffe011be <.LBB332>:
 * Arguments    : riic_info_t * p_riic_info      ; IIC Information
 * Return Value : None
 **********************************************************************************************************************/
static void riic_slv_addr_match_int_enable (riic_info_t * p_riic_info)
{
    volatile uint8_t uctmp = 0x00;
ffe011be:	3c 02 00                      	mov.b	#0, 2[r0]

    /* Creates the register pointer for the specified RIIC channel. */
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffe011c1:	88 9e                         	mov.b	3[r1], r6
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffe011c3:	cd 1e 03                      	mov.b	3[r1], r14
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffe011c6:	cd 1f 03                      	mov.b	3[r1], r15
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffe011c9:	88 99                         	mov.b	3[r1], r1

ffe011cb <.LVL18>:
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffe011cb:	88 da                         	mov.b	3[r5], r2
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffe011cd:	cd 5b 03                      	mov.b	3[r5], r11
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe011d0:	88 dc                         	mov.b	3[r5], r4

ffe011d2 <.LBB334>:
 * Arguments    : riic_info_t * p_riic_info      ; IIC Information
 * Return Value : None
 **********************************************************************************************************************/
static void riic_reset_set (riic_info_t * p_riic_info)
{
    volatile uint8_t uctmp = 0x00;
ffe011d2:	f8 04 00                      	mov.b	#0, [r0]

    /* Creates the register pointer for the specified RIIC channel. */
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe011d5:	88 db                         	mov.b	3[r5], r3

ffe011d7 <.LBE334>:
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffe011d7:	fb a2 1a 62 e0 ff             	mov.l	#0xffe0621a, r10
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffe011dd:	5b 66                         	movu.b	r6, r6
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffe011df:	5b ee                         	movu.b	r14, r14

ffe011e1 <.LBB342>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe011e1:	5b 33                         	movu.b	r3, r3

ffe011e3 <.LBE342>:
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffe011e3:	5b ff                         	movu.b	r15, r15

ffe011e5 <.LBB343>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe011e5:	6c 53                         	shll	#5, r3

ffe011e7 <.LBE343>:
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffe011e7:	5b 11                         	movu.b	r1, r1

ffe011e9 <.LBB344>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe011e9:	73 33 00 83 08                	add	#0x88300, r3, r3

ffe011ee <.LBE344>:
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffe011ee:	5b 22                         	movu.b	r2, r2

ffe011f0 <.LBB345>:

    /* Resets RIIC registers. */
    (*piccr1_reg) |= RIIC_ICCR1_RIIC_RESET; /* Sets ICCR1.IICRST bit. */
ffe011f0:	f0 36                         	bset	#6, [r3].b
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffe011f2:	cc 37                         	mov.b	[r3], r7

ffe011f4 <.LBE345>:
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffe011f4:	5b b3                         	movu.b	r11, r3

ffe011f6 <.LBB346>:
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffe011f6:	c3 07                         	mov.b	r7, [r0]

ffe011f8 <.LBE346>:
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe011f8:	5b 44                         	movu.b	r4, r4
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffe011fa:	88 df                         	mov.b	3[r5], r7
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffe011fc:	6c 56                         	shll	#5, r6
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffe011fe:	6c 5e                         	shll	#5, r14
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffe01200:	6c 5f                         	shll	#5, r15
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffe01202:	5b 77                         	movu.b	r7, r7
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffe01204:	6c 51                         	shll	#5, r1
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffe01206:	6c 52                         	shll	#5, r2
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffe01208:	fe c7 a7                      	movu.b	[r7, r10], r7
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffe0120b:	6c 53                         	shll	#5, r3
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe0120d:	6c 54                         	shll	#5, r4
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffe0120f:	73 66 0a 83 08                	add	#0x8830a, r6, r6

ffe01214 <.LVL19>:
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffe01214:	73 ee 0b 83 08                	add	#0x8830b, r14, r14

ffe01219 <.LVL20>:
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffe01219:	73 ff 0c 83 08                	add	#0x8830c, r15, r15

ffe0121e <.LVL21>:
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffe0121e:	73 11 0d 83 08                	add	#0x8830d, r1, r1

ffe01223 <.LVL22>:
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffe01223:	73 22 0e 83 08                	add	#0x8830e, r2, r2

ffe01228 <.LVL23>:
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffe01228:	73 33 0f 83 08                	add	#0x8830f, r3, r3

ffe0122d <.LVL24>:
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe0122d:	73 44 06 83 08                	add	#0x88306, r4, r4

ffe01232 <.LBB347>:
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffe01232:	61 17                         	cmp	#1, r7
        *psarl0_reg = g_riic_slv_ad0_val[p_riic_info->ch_no] << 1;
ffe01234:	b0 df                         	movu.b	3[r5], r7
    if (1U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffe01236:	3a 13 01                      	beq.w	ffe01349 <_Reset_Vector+0xffe0134d>
    else if (2U == g_riic_slv_ad0_format[p_riic_info->ch_no])
ffe01239:	fe c7 a7                      	movu.b	[r7, r10], r7
ffe0123c:	61 27                         	cmp	#2, r7
ffe0123e:	3a 88 00                      	beq.w	ffe012c6 <_Reset_Vector+0xffe012ca>
        (*picser_reg) &= RIIC_ICSER_SAR0E_CLR;
ffe01241:	f0 48                         	bclr	#0, [r4].b
ffe01243:	77 10 01 00 00                	nop	; mul	#1, r0
    if (1U == g_riic_slv_ad1_format[p_riic_info->ch_no])
ffe01248:	cd 5e 03                      	mov.b	3[r5], r14

ffe0124b <.LVL26>:
ffe0124b:	fb 72 17 62 e0 ff             	mov.l	#0xffe06217, r7
ffe01251:	5b ee                         	movu.b	r14, r14
ffe01253:	fe ce 7a                      	movu.b	[r14, r7], r10
ffe01256:	61 1a                         	cmp	#1, r10
ffe01258:	3a a0 00                      	beq.w	ffe012f8 <_Reset_Vector+0xffe012fc>
    else if (2U == g_riic_slv_ad1_format[p_riic_info->ch_no])
ffe0125b:	59 5a 03                      	movu.b	3[r5], r10
ffe0125e:	fe ca 77                      	movu.b	[r10, r7], r7
ffe01261:	61 27                         	cmp	#2, r7
ffe01263:	3a 1c 01                      	beq.w	ffe0137f <_Reset_Vector+0xffe01383>
        (*picser_reg) &= RIIC_ICSER_SAR1E_CLR;
ffe01266:	f0 49                         	bclr	#1, [r4].b
    if (1U == g_riic_slv_ad2_format[p_riic_info->ch_no])
ffe01268:	88 d9                         	mov.b	3[r5], r1

ffe0126a <.LVL27>:
ffe0126a:	fb 72 14 62 e0 ff             	mov.l	#0xffe06214, r7
ffe01270:	5b 11                         	movu.b	r1, r1
ffe01272:	fe c1 7a                      	movu.b	[r1, r7], r10
ffe01275:	61 1a                         	cmp	#1, r10
ffe01277:	3a a9 00                      	beq.w	ffe01320 <_Reset_Vector+0xffe01324>

ffe0127a <.LVL28>:
    else if (2 == g_riic_slv_ad2_format[p_riic_info->ch_no])
ffe0127a:	59 5a 03                      	movu.b	3[r5], r10
ffe0127d:	fe ca 77                      	movu.b	[r10, r7], r7
ffe01280:	61 27                         	cmp	#2, r7
ffe01282:	3a dc 00                      	beq.w	ffe0135e <_Reset_Vector+0xffe01362>
        (*picser_reg) &= RIIC_ICSER_SAR2E_CLR;
ffe01285:	f0 4a                         	bclr	#2, [r4].b
ffe01287:	03                            	nop
    if (1U == g_riic_gca_enable[p_riic_info->ch_no])
ffe01288:	b0 db                         	movu.b	3[r5], r3

ffe0128a <.LVL29>:
ffe0128a:	fb 72 11 62 e0 ff             	mov.l	#0xffe06211, r7
ffe01290:	fe c3 77                      	movu.b	[r3, r7], r7
ffe01293:	61 17                         	cmp	#1, r7
ffe01295:	3a af 00                      	beq.w	ffe01344 <_Reset_Vector+0xffe01348>
        (*picser_reg) &= RIIC_ICSER_GCAE_CLR;
ffe01298:	f0 4b                         	bclr	#3, [r4].b
    uctmp = *picser_reg; /* Reads ICSER. */
ffe0129a:	cc 47                         	mov.b	[r4], r7

ffe0129c <.LBE332>:
} /* End of function riic_enable_slave_transfer() */
ffe0129c:	66 01                         	mov.l	#0, r1

ffe0129e <.LBB352>:
    uctmp = *picser_reg; /* Reads ICSER. */
ffe0129e:	80 87                         	mov.b	r7, 2[r0]

ffe012a0 <.LBB348>:
    volatile uint8_t uctmp = 0x00;
ffe012a0:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe012a3:	b0 dc                         	movu.b	3[r5], r4

ffe012a5 <.LVL31>:
ffe012a5:	6c 54                         	shll	#5, r4
ffe012a7:	73 44 00 83 08                	add	#0x88300, r4, r4

ffe012ac <.LVL32>:
    (*piccr1_reg) &= RIIC_ICCR1_ENABLE; /* Clears ICCR1.IICRST bit. */
ffe012ac:	f0 4e                         	bclr	#6, [r4].b
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffe012ae:	cc 47                         	mov.b	[r4], r7
ffe012b0:	80 0f                         	mov.b	r7, 1[r0]

ffe012b2 <.LBB353>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe012b2:	b0 dd                         	movu.b	3[r5], r5

ffe012b4 <.LVL34>:
ffe012b4:	6c 45                         	shll	#4, r5
ffe012b6:	70 55 24 00 00 00             	add	#36, r5, r5
ffe012bc:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe012c0:	3e 52 02                      	mov.l	#2, 8[r5]

ffe012c3 <.LVL35>:
} /* End of function riic_enable_slave_transfer() */
ffe012c3:	3f 6b 07                      	rtsd	#28, r6-r11

ffe012c6 <.LBB355>:
        *psarl0_reg = (uint8_t) (g_riic_slv_ad0_val[p_riic_info->ch_no] & RIIC_SARL_MASK);
ffe012c6:	88 df                         	mov.b	3[r5], r7
ffe012c8:	fb a2 2a 62 e0 ff             	mov.l	#0xffe0622a, r10
ffe012ce:	5b 77                         	movu.b	r7, r7
ffe012d0:	fe 57 a7                      	mov.w	[r7, r10], r7
ffe012d3:	c3 67                         	mov.b	r7, [r6]
        *psaru0_reg = (uint8_t) (((g_riic_slv_ad0_val[p_riic_info->ch_no] & RIIC_SARU_MASK) >> 7) |
ffe012d5:	b0 df                         	movu.b	3[r5], r7
ffe012d7:	fe d7 a7                      	movu.w	[r7, r10], r7
ffe012da:	6a 77                         	shar	#7, r7
ffe012dc:	64 67                         	and	#6, r7
ffe012de:	78 07                         	bset	#0, r7
ffe012e0:	c3 e7                         	mov.b	r7, [r14]
        (*picser_reg) |= RIIC_ICSER_SAR0E_SET;
ffe012e2:	f0 40                         	bset	#0, [r4].b
    if (1U == g_riic_slv_ad1_format[p_riic_info->ch_no])
ffe012e4:	cd 5e 03                      	mov.b	3[r5], r14

ffe012e7 <.LVL37>:
ffe012e7:	fb 72 17 62 e0 ff             	mov.l	#0xffe06217, r7
ffe012ed:	5b ee                         	movu.b	r14, r14
ffe012ef:	fe ce 7a                      	movu.b	[r14, r7], r10
ffe012f2:	61 1a                         	cmp	#1, r10
ffe012f4:	3b 67 ff                      	bne.w	ffe0125b <_Reset_Vector+0xffe0125f>
ffe012f7:	03                            	nop
        *psarl1_reg = (uint8_t) (g_riic_slv_ad1_val[p_riic_info->ch_no] << 1);
ffe012f8:	b0 df                         	movu.b	3[r5], r7
ffe012fa:	fb a2 24 62 e0 ff             	mov.l	#0xffe06224, r10
ffe01300:	fe 57 a6                      	mov.w	[r7, r10], r6

ffe01303 <.LVL38>:
ffe01303:	6c 16                         	shll	#1, r6
ffe01305:	c3 f6                         	mov.b	r6, [r15]
        *psaru1_reg = 0x00;
ffe01307:	f8 14 00                      	mov.b	#0, [r1]
        (*picser_reg) |= RIIC_ICSER_SAR1E_SET;
ffe0130a:	f0 41                         	bset	#1, [r4].b
    if (1U == g_riic_slv_ad2_format[p_riic_info->ch_no])
ffe0130c:	88 d9                         	mov.b	3[r5], r1

ffe0130e <.LVL39>:
ffe0130e:	fb 72 14 62 e0 ff             	mov.l	#0xffe06214, r7
ffe01314:	5b 11                         	movu.b	r1, r1
ffe01316:	fe c1 7a                      	movu.b	[r1, r7], r10
ffe01319:	61 1a                         	cmp	#1, r10
ffe0131b:	3b 5f ff                      	bne.w	ffe0127a <_Reset_Vector+0xffe0127e>
ffe0131e:	ef 00                         	nop	; mov.l	r0, r0
        *psarl2_reg = (uint8_t) (g_riic_slv_ad2_val[p_riic_info->ch_no] << 1);
ffe01320:	b0 df                         	movu.b	3[r5], r7
ffe01322:	fb a2 1e 62 e0 ff             	mov.l	#0xffe0621e, r10
ffe01328:	fe 57 a1                      	mov.w	[r7, r10], r1
ffe0132b:	6c 11                         	shll	#1, r1
ffe0132d:	c3 21                         	mov.b	r1, [r2]
        *psaru2_reg = 0x00;
ffe0132f:	f8 34 00                      	mov.b	#0, [r3]
        (*picser_reg) |= RIIC_ICSER_SAR2E_SET;
ffe01332:	f0 42                         	bset	#2, [r4].b
    if (1U == g_riic_gca_enable[p_riic_info->ch_no])
ffe01334:	b0 db                         	movu.b	3[r5], r3

ffe01336 <.LVL40>:
ffe01336:	fb 72 11 62 e0 ff             	mov.l	#0xffe06211, r7
ffe0133c:	fe c3 77                      	movu.b	[r3, r7], r7
ffe0133f:	61 17                         	cmp	#1, r7
ffe01341:	3b 57 ff                      	bne.w	ffe01298 <_Reset_Vector+0xffe0129c>
        (*picser_reg) |= RIIC_ICSER_GCAE_SET;
ffe01344:	f0 43                         	bset	#3, [r4].b
ffe01346:	38 54 ff                      	bra.w	ffe0129a <_Reset_Vector+0xffe0129e>

ffe01349 <.LVL41>:
        *psarl0_reg = g_riic_slv_ad0_val[p_riic_info->ch_no] << 1;
ffe01349:	fb a2 2a 62 e0 ff             	mov.l	#0xffe0622a, r10
ffe0134f:	fe 57 ab                      	mov.w	[r7, r10], r11
ffe01352:	6c 1b                         	shll	#1, r11
ffe01354:	c3 6b                         	mov.b	r11, [r6]
        *psaru0_reg = 0x00;
ffe01356:	f8 e4 00                      	mov.b	#0, [r14]
        (*picser_reg) |= RIIC_ICSER_SAR0E_SET;
ffe01359:	f0 40                         	bset	#0, [r4].b
ffe0135b:	38 ed fe                      	bra.w	ffe01248 <_Reset_Vector+0xffe0124c>

ffe0135e <.LVL42>:
        *psarl2_reg = (uint8_t) (g_riic_slv_ad2_val[p_riic_info->ch_no] & RIIC_SARL_MASK);
ffe0135e:	88 df                         	mov.b	3[r5], r7
ffe01360:	fb a2 1e 62 e0 ff             	mov.l	#0xffe0621e, r10
ffe01366:	5b 77                         	movu.b	r7, r7
ffe01368:	fe 57 a7                      	mov.w	[r7, r10], r7
ffe0136b:	c3 27                         	mov.b	r7, [r2]
        *psaru2_reg = (uint8_t) (((g_riic_slv_ad2_val[p_riic_info->ch_no] & RIIC_SARU_MASK) >> 7) |
ffe0136d:	b0 df                         	movu.b	3[r5], r7
ffe0136f:	fe d7 a7                      	movu.w	[r7, r10], r7
ffe01372:	6a 77                         	shar	#7, r7
ffe01374:	64 67                         	and	#6, r7
ffe01376:	78 07                         	bset	#0, r7
ffe01378:	c3 37                         	mov.b	r7, [r3]
        (*picser_reg) |= RIIC_ICSER_SAR2E_SET;
ffe0137a:	f0 42                         	bset	#2, [r4].b
ffe0137c:	38 0c ff                      	bra.w	ffe01288 <_Reset_Vector+0xffe0128c>

ffe0137f <.LVL43>:
        *psarl1_reg = (uint8_t) (g_riic_slv_ad1_val[p_riic_info->ch_no] & RIIC_SARL_MASK);
ffe0137f:	88 df                         	mov.b	3[r5], r7
ffe01381:	fb a2 24 62 e0 ff             	mov.l	#0xffe06224, r10
ffe01387:	5b 77                         	movu.b	r7, r7
ffe01389:	fe 57 a7                      	mov.w	[r7, r10], r7
ffe0138c:	c3 f7                         	mov.b	r7, [r15]
        *psaru1_reg = (uint8_t) (((g_riic_slv_ad1_val[p_riic_info->ch_no] & RIIC_SARU_MASK) >> 7) |
ffe0138e:	b0 df                         	movu.b	3[r5], r7
ffe01390:	fe d7 a7                      	movu.w	[r7, r10], r7
ffe01393:	6a 77                         	shar	#7, r7
ffe01395:	64 67                         	and	#6, r7
ffe01397:	78 07                         	bset	#0, r7
ffe01399:	c3 17                         	mov.b	r7, [r1]
        (*picser_reg) |= RIIC_ICSER_SAR1E_SET;
ffe0139b:	f0 41                         	bset	#1, [r4].b
ffe0139d:	38 cb fe                      	bra.w	ffe01268 <_Reset_Vector+0xffe0126c>

ffe013a0 <_riic_arbitration_lost>:
    if (((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe013a0:	b0 9d                         	movu.b	3[r1], r5
ffe013a2:	6c 45                         	shll	#4, r5
ffe013a4:	70 55 24 00 00 00             	add	#36, r5, r5
ffe013aa:	ec 55                         	mov.l	[r5], r5
ffe013ac:	61 15                         	cmp	#1, r5
ffe013ae:	20 36                         	beq.b	ffe013e4 <_Reset_Vector+0xffe013e8>
            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe013b0:	b0 9d                         	movu.b	3[r1], r5
ffe013b2:	6c 45                         	shll	#4, r5
ffe013b4:	70 55 24 00 00 00             	add	#36, r5, r5
ffe013ba:	ec 55                         	mov.l	[r5], r5
ffe013bc:	61 25                         	cmp	#2, r5
ffe013be:	20 26                         	beq.b	ffe013e4 <_Reset_Vector+0xffe013e8>
            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe013c0:	b0 9d                         	movu.b	3[r1], r5
ffe013c2:	6c 45                         	shll	#4, r5
ffe013c4:	70 55 24 00 00 00             	add	#36, r5, r5
ffe013ca:	ec 55                         	mov.l	[r5], r5
ffe013cc:	61 35                         	cmp	#3, r5
ffe013ce:	20 16                         	beq.b	ffe013e4 <_Reset_Vector+0xffe013e8>
    else if ((RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe013d0:	b0 9d                         	movu.b	3[r1], r5
ffe013d2:	6c 45                         	shll	#4, r5
ffe013d4:	70 55 24 00 00 00             	add	#36, r5, r5
ffe013da:	ec 55                         	mov.l	[r5], r5
ffe013dc:	61 55                         	cmp	#5, r5
ffe013de:	13                            	beq.s	ffe013e1 <_Reset_Vector+0xffe013e5>
            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe013df:	88 9d                         	mov.b	3[r1], r5
} /* End of function riic_arbitration_lost() */
ffe013e1:	66 01                         	mov.l	#0, r1

ffe013e3 <.LVL45>:
ffe013e3:	02                            	rts

ffe013e4 <.LVL46>:
{
ffe013e4:	6e 7a                         	pushm	r7-r10
        if ((((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe013e6:	b0 9d                         	movu.b	3[r1], r5
ffe013e8:	6c 45                         	shll	#4, r5
ffe013ea:	70 55 24 00 00 00             	add	#36, r5, r5
ffe013f0:	a8 5d                         	mov.l	4[r5], r5
ffe013f2:	61 15                         	cmp	#1, r5
ffe013f4:	20 34                         	beq.b	ffe01428 <_Reset_Vector+0xffe0142c>
                || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe013f6:	b0 9d                         	movu.b	3[r1], r5
ffe013f8:	6c 45                         	shll	#4, r5
ffe013fa:	70 55 24 00 00 00             	add	#36, r5, r5
ffe01400:	a8 5d                         	mov.l	4[r5], r5
ffe01402:	61 25                         	cmp	#2, r5
ffe01404:	20 24                         	beq.b	ffe01428 <_Reset_Vector+0xffe0142c>
                || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe01406:	b0 9d                         	movu.b	3[r1], r5
ffe01408:	6c 45                         	shll	#4, r5
ffe0140a:	70 55 24 00 00 00             	add	#36, r5, r5
ffe01410:	a8 5d                         	mov.l	4[r5], r5
ffe01412:	61 35                         	cmp	#3, r5
ffe01414:	20 14                         	beq.b	ffe01428 <_Reset_Vector+0xffe0142c>
                || (RIIC_MODE_NONE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe01416:	b0 9d                         	movu.b	3[r1], r5
ffe01418:	6c 45                         	shll	#4, r5
ffe0141a:	70 55 24 00 00 00             	add	#36, r5, r5
ffe01420:	a8 5d                         	mov.l	4[r5], r5
ffe01422:	61 05                         	cmp	#0, r5
ffe01424:	21 24                         	bne.b	ffe01448 <_Reset_Vector+0xffe0144c>
ffe01426:	ef 00                         	nop	; mov.l	r0, r0

ffe01428 <.LBB356>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe01428:	88 9d                         	mov.b	3[r1], r5

ffe0142a <.LBB359>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0142a:	88 99                         	mov.b	3[r1], r1

ffe0142c <.LVL49>:
ffe0142c:	66 82                         	mov.l	#8, r2

ffe0142e <.LBB362>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe0142e:	5b 55                         	movu.b	r5, r5
ffe01430:	6c 45                         	shll	#4, r5

ffe01432 <.LVL50>:
ffe01432:	70 55 24 00 00 00             	add	#36, r5, r5
ffe01438:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe0143c:	3e 52 08                      	mov.l	#8, 8[r5]

ffe0143f <.LBB363>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0143f:	05 15 fc ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01443 <.LBE363>:
} /* End of function riic_arbitration_lost() */
ffe01443:	66 01                         	mov.l	#0, r1
ffe01445:	3f 7a 04                      	rtsd	#16, r7-r10

ffe01448 <.LVL53>:
        else if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01448:	b0 9d                         	movu.b	3[r1], r5
ffe0144a:	6c 45                         	shll	#4, r5
ffe0144c:	70 55 24 00 00 00             	add	#36, r5, r5
ffe01452:	a8 5b                         	mov.l	4[r5], r3
ffe01454:	61 43                         	cmp	#4, r3
ffe01456:	21 ed                         	bne.b	ffe01443 <_Reset_Vector+0xffe01447>
            riic_api_mode_event_init(priic_info_s[p_riic_info->ch_no], RIIC_MODE_S_READY);
ffe01458:	88 9d                         	mov.b	3[r1], r5
ffe0145a:	fb 42 60 00 00 00             	mov.l	#96, r4
ffe01460:	5b 55                         	movu.b	r5, r5
ffe01462:	fe 65 47                      	mov.l	[r5, r4], r7

ffe01465 <.LBB364>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe01465:	cd 7e 03                      	mov.b	3[r7], r14

ffe01468 <.LBE364>:
            riic_api_status_set(priic_info_s[p_riic_info->ch_no], RIIC_STS_AL);
ffe01468:	88 9d                         	mov.b	3[r1], r5

ffe0146a <.LBB370>:
    riic_api_event[ch_no] = RIIC_EV_INIT;
ffe0146a:	5b ee                         	movu.b	r14, r14

ffe0146c <.LBE370>:
            riic_api_status_set(priic_info_s[p_riic_info->ch_no], RIIC_STS_AL);
ffe0146c:	5b 55                         	movu.b	r5, r5

ffe0146e <.LBB371>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe0146e:	fd c4 e2                      	shll	#4, r14, r2
ffe01471:	70 22 24 00 00 00             	add	#36, r2, r2

ffe01477 <.LBE371>:
            riic_api_status_set(priic_info_s[p_riic_info->ch_no], RIIC_STS_AL);
ffe01477:	fe 65 47                      	mov.l	[r5, r4], r7

ffe0147a <.LBB372>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe0147a:	e4 22 01                      	mov.l	[r2], 4[r2]

ffe0147d <.LBB373>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe0147d:	88 fd                         	mov.b	3[r7], r5

ffe0147f <.LBE373>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe0147f:	cd 1f 03                      	mov.b	3[r1], r15

ffe01482 <.LBB379>:
    riic_api_event[ch_no] = RIIC_EV_INIT;
ffe01482:	fb 72 54 00 00 00             	mov.l	#84, r7
ffe01488:	66 0a                         	mov.l	#0, r10
ffe0148a:	fe 2e 7a                      	mov.l	r10, [r14, r7]
    riic_api_info[ch_no].N_Mode = new_mode;
ffe0148d:	e3 23                         	mov.l	r3, [r2]

ffe0148f <.LBB380>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe0148f:	5b f3                         	movu.b	r15, r3

ffe01491 <.LBB381>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01491:	5b 55                         	movu.b	r5, r5
ffe01493:	6c 45                         	shll	#4, r5

ffe01495 <.LBE381>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01495:	fe 63 43                      	mov.l	[r3, r4], r3

ffe01498 <.LBB382>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01498:	70 55 24 00 00 00             	add	#36, r5, r5
ffe0149e:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

ffe014a2 <.LBE382>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe014a2:	a9 3b                         	mov.l	20[r3], r3

ffe014a4 <.LBB383>:
    riic_api_info[ch_no].N_status = new_status;
ffe014a4:	3e 52 09                      	mov.l	#9, 8[r5]

ffe014a7 <.LBE383>:
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe014a7:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe014ad:	20 24                         	beq.b	ffe014d1 <_Reset_Vector+0xffe014d5>
                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe014af:	b0 9d                         	movu.b	3[r1], r5
ffe014b1:	fe 65 47                      	mov.l	[r5, r4], r7
ffe014b4:	a9 77                         	mov.l	16[r7], r7
ffe014b6:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffe014bc:	20 15                         	beq.b	ffe014d1 <_Reset_Vector+0xffe014d5>
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_RX_SP_NAK);
ffe014be:	88 9f                         	mov.b	3[r1], r7

ffe014c0 <.LBB384>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe014c0:	fb 26 b8                      	mov.l	#-72, r2

ffe014c3 <.LBE384>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_RX_SP_NAK);
ffe014c3:	5b 77                         	movu.b	r7, r7
ffe014c5:	fe 67 47                      	mov.l	[r7, r4], r7

ffe014c8 <.LBB387>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe014c8:	88 f9                         	mov.b	3[r7], r1

ffe014ca <.LVL61>:
ffe014ca:	05 8a fb ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe014ce <.LVL62>:
ffe014ce:	38 75 ff                      	bra.w	ffe01443 <_Reset_Vector+0xffe01447>

ffe014d1 <.LBE387>:
            else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe014d1:	b0 9d                         	movu.b	3[r1], r5
ffe014d3:	fe 65 47                      	mov.l	[r5, r4], r7
ffe014d6:	a9 7f                         	mov.l	20[r7], r7
ffe014d8:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffe014de:	20 12                         	beq.b	ffe014f0 <_Reset_Vector+0xffe014f4>
                    && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe014e0:	b0 9f                         	movu.b	3[r1], r7
ffe014e2:	fe 67 47                      	mov.l	[r7, r4], r7
ffe014e5:	a9 77                         	mov.l	16[r7], r7
ffe014e7:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffe014ed:	20 36                         	beq.b	ffe01523 <_Reset_Vector+0xffe01527>
ffe014ef:	03                            	nop
            else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe014f0:	b0 9d                         	movu.b	3[r1], r5
ffe014f2:	fe 65 47                      	mov.l	[r5, r4], r7
ffe014f5:	a9 7f                         	mov.l	20[r7], r7
ffe014f7:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffe014fd:	3b 46 ff                      	bne.w	ffe01443 <_Reset_Vector+0xffe01447>
                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01500:	b0 9f                         	movu.b	3[r1], r7
ffe01502:	fe 67 47                      	mov.l	[r7, r4], r7
ffe01505:	a9 77                         	mov.l	16[r7], r7
ffe01507:	74 07 00 00 00 10             	cmp	#0x10000000, r7
ffe0150d:	3a 36 ff                      	beq.w	ffe01443 <_Reset_Vector+0xffe01447>
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_SP);
ffe01510:	88 9f                         	mov.b	3[r1], r7

ffe01512 <.LBB388>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01512:	75 42 28                      	mov.l	#40, r2

ffe01515 <.LBE388>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_SP);
ffe01515:	5b 77                         	movu.b	r7, r7
ffe01517:	fe 67 47                      	mov.l	[r7, r4], r7

ffe0151a <.LBB391>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0151a:	88 f9                         	mov.b	3[r7], r1

ffe0151c <.LVL65>:
ffe0151c:	05 38 fb ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01520 <.LVL66>:
ffe01520:	38 23 ff                      	bra.w	ffe01443 <_Reset_Vector+0xffe01447>

ffe01523 <.LBE391>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_SP_NAK);
ffe01523:	88 9f                         	mov.b	3[r1], r7

ffe01525 <.LBB392>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01525:	fb 26 98                      	mov.l	#-104, r2

ffe01528 <.LBE392>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_SP_NAK);
ffe01528:	5b 77                         	movu.b	r7, r7
ffe0152a:	fe 67 47                      	mov.l	[r7, r4], r7

ffe0152d <.LBB395>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0152d:	88 f9                         	mov.b	3[r7], r1

ffe0152f <.LVL69>:
ffe0152f:	05 25 fb ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01533 <.LVL70>:
ffe01533:	38 10 ff                      	bra.w	ffe01443 <_Reset_Vector+0xffe01447>

ffe01536 <.LBE395>:
ffe01536:	ef 00                         	nop	; mov.l	r0, r0

ffe01538 <_riic_advance>:
{
ffe01538:	6e 6b                         	pushm	r6-r11
ffe0153a:	60 40                         	sub	#4, r0

ffe0153c <.LBB430>:
    switch (g_riic_ChStatus[p_riic_info->ch_no])
ffe0153c:	fb a2 0c 02 00 00             	mov.l	#524, r10

ffe01542 <.LBE430>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe01542:	88 9e                         	mov.b	3[r1], r6

ffe01544 <.LVL72>:
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffe01544:	cd 1b 03                      	mov.b	3[r1], r11

ffe01547 <.LBB437>:
    switch (g_riic_ChStatus[p_riic_info->ch_no])
ffe01547:	b0 9f                         	movu.b	3[r1], r7
ffe01549:	fe c7 a5                      	movu.b	[r7, r10], r5
ffe0154c:	61 45                         	cmp	#4, r5
ffe0154e:	20 26                         	beq.b	ffe01574 <_Reset_Vector+0xffe01578>
ffe01550:	25 13                         	bleu.b	ffe01563 <_Reset_Vector+0xffe01567>
ffe01552:	61 55                         	cmp	#5, r5
ffe01554:	20 1c                         	beq.b	ffe01570 <_Reset_Vector+0xffe01574>
            ret = RIIC_ERR_OTHER;
ffe01556:	61 65                         	cmp	#6, r5
ffe01558:	66 85                         	mov.l	#8, r5
ffe0155a:	fd 74 e5 07                   	stz	#7, r5

ffe0155e <.LBE437>:
} /* End of function riic_advance() */
ffe0155e:	ef 51                         	mov.l	r5, r1
ffe01560:	3f 6b 07                      	rtsd	#28, r6-r11

ffe01563 <.LBB438>:
            ret = RIIC_ERR_OTHER;
ffe01563:	61 05                         	cmp	#0, r5
ffe01565:	66 85                         	mov.l	#8, r5
ffe01567:	fd 74 e5 04                   	stz	#4, r5

ffe0156b <.LBE438>:
} /* End of function riic_advance() */
ffe0156b:	ef 51                         	mov.l	r5, r1

ffe0156d <.LVL76>:
ffe0156d:	3f 6b 07                      	rtsd	#28, r6-r11

ffe01570 <.LBB439>:
            ret = RIIC_ERR_AL;
ffe01570:	66 65                         	mov.l	#6, r5
ffe01572:	2e ec                         	bra.b	ffe0155e <_Reset_Vector+0xffe01562>
            if ((((RIIC_NO_INIT == p_riic_info->dev_sts) || (RIIC_IDLE == p_riic_info->dev_sts))
ffe01574:	b0 97                         	movu.b	2[r1], r7
ffe01576:	61 07                         	cmp	#0, r7
ffe01578:	3a 17 02                      	beq.w	ffe0178f <_Reset_Vector+0xffe01793>
ffe0157b:	b0 97                         	movu.b	2[r1], r7
ffe0157d:	61 17                         	cmp	#1, r7
ffe0157f:	3a 10 02                      	beq.w	ffe0178f <_Reset_Vector+0xffe01793>
                    || (RIIC_FINISH == p_riic_info->dev_sts)) || (RIIC_NACK == p_riic_info->dev_sts))
ffe01582:	b0 97                         	movu.b	2[r1], r7
ffe01584:	61 27                         	cmp	#2, r7
ffe01586:	3a 09 02                      	beq.w	ffe0178f <_Reset_Vector+0xffe01793>
ffe01589:	b0 97                         	movu.b	2[r1], r7
ffe0158b:	61 37                         	cmp	#3, r7
ffe0158d:	3a 02 02                      	beq.w	ffe0178f <_Reset_Vector+0xffe01793>
            else if (RIIC_COMMUNICATION == p_riic_info->dev_sts)
ffe01590:	b0 97                         	movu.b	2[r1], r7
ffe01592:	61 47                         	cmp	#4, r7
ffe01594:	20 15                         	beq.b	ffe015a9 <_Reset_Vector+0xffe015ad>
            else if (RIIC_TMO == p_riic_info->dev_sts)
ffe01596:	b0 97                         	movu.b	2[r1], r7
ffe01598:	61 67                         	cmp	#6, r7
ffe0159a:	3a e7 02                      	beq.w	ffe01881 <_Reset_Vector+0xffe01885>
            else if (RIIC_AL == p_riic_info->dev_sts)
ffe0159d:	b0 95                         	movu.b	2[r1], r5
                ret = RIIC_ERR_AL;
ffe0159f:	61 55                         	cmp	#5, r5
ffe015a1:	66 65                         	mov.l	#6, r5
ffe015a3:	fd 74 f5 08                   	stnz	#8, r5
ffe015a7:	2e b7                         	bra.b	ffe0155e <_Reset_Vector+0xffe01562>

ffe015a9 <.LBE439>:
    if (RIIC_EV_INIT != riic_api_event[p_riic_info->ch_no])
ffe015a9:	88 9f                         	mov.b	3[r1], r7
ffe015ab:	fb 42 54 00 00 00             	mov.l	#84, r4
ffe015b1:	5b 77                         	movu.b	r7, r7
ffe015b3:	fe 67 47                      	mov.l	[r7, r4], r7
ffe015b6:	61 07                         	cmp	#0, r7
ffe015b8:	3a d7 01                      	beq.w	ffe0178f <_Reset_Vector+0xffe01793>
ffe015bb:	ef 17                         	mov.l	r1, r7
        ret = riic_func_table(riic_api_event[p_riic_info->ch_no], p_riic_info);
ffe015bd:	88 9b                         	mov.b	3[r1], r3

ffe015bf <.LBB440>:
    n_status = riic_api_info[p_riic_info->ch_no].N_status;
ffe015bf:	b0 9d                         	movu.b	3[r1], r5
ffe015c1:	6c 45                         	shll	#4, r5
ffe015c3:	70 55 24 00 00 00             	add	#36, r5, r5
ffe015c9:	a8 d5                         	mov.l	8[r5], r5

ffe015cb <.LVL80>:
    if ((RIIC_STS_MAX > n_status) && (RIIC_EV_MAX > event))
ffe015cb:	61 a5                         	cmp	#10, r5
ffe015cd:	25 05                         	bleu.b	ffe015d2 <_Reset_Vector+0xffe015d6>
ffe015cf:	38 b2 01                      	bra.w	ffe01781 <_Reset_Vector+0xffe01785>

ffe015d2 <.LBE440>:
        ret = riic_func_table(riic_api_event[p_riic_info->ch_no], p_riic_info);
ffe015d2:	5b 33                         	movu.b	r3, r3

ffe015d4 <.LVL82>:
ffe015d4:	fe 63 43                      	mov.l	[r3, r4], r3

ffe015d7 <.LBB444>:
    if ((RIIC_STS_MAX > n_status) && (RIIC_EV_MAX > event))
ffe015d7:	61 a3                         	cmp	#10, r3
ffe015d9:	25 05                         	bleu.b	ffe015de <_Reset_Vector+0xffe015e2>
ffe015db:	38 a6 01                      	bra.w	ffe01781 <_Reset_Vector+0xffe01785>
        if (NULL != gc_riic_mtx_tbl[n_status][event].proc)
ffe015de:	63 b5                         	mul	#11, r5

ffe015e0 <.LVL84>:
ffe015e0:	4b 35                         	add	r3, r5
ffe015e2:	6c 35                         	shll	#3, r5
ffe015e4:	70 55 38 62 e0 ff             	add	#0xffe06238, r5, r5
ffe015ea:	a8 5b                         	mov.l	4[r5], r3
ffe015ec:	61 03                         	cmp	#0, r3
ffe015ee:	3a 93 01                      	beq.w	ffe01781 <_Reset_Vector+0xffe01785>

ffe015f1 <.LVL85>:
            riic_api_event[p_riic_info->ch_no] = RIIC_EV_INIT;
ffe015f1:	88 9d                         	mov.b	3[r1], r5
ffe015f3:	5b 55                         	movu.b	r5, r5
ffe015f5:	66 02                         	mov.l	#0, r2
ffe015f7:	fe 25 42                      	mov.l	r2, [r5, r4]
            ret = (*pFunc)(p_riic_info);
ffe015fa:	7f 13                         	jsr	r3

ffe015fc <.LBE444>:
        switch (ret)
ffe015fc:	71 15 00                      	add	#0, r1, r5
ffe015ff:	3b 84 01                      	bne.w	ffe01783 <_Reset_Vector+0xffe01787>
                if (RIIC_STS_TMO == riic_api_info[p_riic_info->ch_no].N_status)
ffe01602:	b0 fc                         	movu.b	3[r7], r4
ffe01604:	6c 44                         	shll	#4, r4
ffe01606:	70 44 24 00 00 00             	add	#36, r4, r4
ffe0160c:	a8 c4                         	mov.l	8[r4], r4
ffe0160e:	61 a4                         	cmp	#10, r4
                    if ((((((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe01610:	b0 fc                         	movu.b	3[r7], r4
                if (RIIC_STS_TMO == riic_api_info[p_riic_info->ch_no].N_status)
ffe01612:	3a 82 01                      	beq.w	ffe01794 <_Reset_Vector+0xffe01798>
                else if (((RIIC_STS_SP_COND_WAIT != riic_api_info[p_riic_info->ch_no].N_status)
ffe01615:	6c 44                         	shll	#4, r4
ffe01617:	70 44 24 00 00 00             	add	#36, r4, r4
ffe0161d:	a8 c4                         	mov.l	8[r4], r4
ffe0161f:	61 84                         	cmp	#8, r4
ffe01621:	3b 3d ff                      	bne.w	ffe0155e <_Reset_Vector+0xffe01562>
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe01624:	5b 64                         	movu.b	r6, r4
ffe01626:	6c 54                         	shll	#5, r4
ffe01628:	73 44 09 83 08                	add	#0x88309, r4, r4
                        || (0x00 != ((*picsr2_reg) & RIIC_ICSR2_STOP))) || (0x00 != ((*picier_reg) & RIIC_ICIER_SP)))
ffe0162d:	cc 43                         	mov.b	[r4], r3
ffe0162f:	7c 33                         	btst	#3, r3
ffe01631:	3b 2d ff                      	bne.w	ffe0155e <_Reset_Vector+0xffe01562>
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffe01634:	5b b6                         	movu.b	r11, r6

ffe01636 <.LVL87>:
ffe01636:	6c 56                         	shll	#5, r6
ffe01638:	73 66 07 83 08                	add	#0x88307, r6, r6
                        || (0x00 != ((*picsr2_reg) & RIIC_ICSR2_STOP))) || (0x00 != ((*picier_reg) & RIIC_ICIER_SP)))
ffe0163d:	cc 63                         	mov.b	[r6], r3
ffe0163f:	7c 33                         	btst	#3, r3
ffe01641:	3b 1d ff                      	bne.w	ffe0155e <_Reset_Vector+0xffe01562>
                    if (RIIC_ICSR2_AL == ((*picsr2_reg) & RIIC_ICSR2_AL))
ffe01644:	cc 43                         	mov.b	[r4], r3
ffe01646:	7c 13                         	btst	#1, r3
ffe01648:	3a fa 02                      	beq.w	ffe01942 <_Reset_Vector+0xffe01946>
                        if (((RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe0164b:	b0 fc                         	movu.b	3[r7], r4
ffe0164d:	6c 44                         	shll	#4, r4
ffe0164f:	70 44 24 00 00 00             	add	#36, r4, r4
ffe01655:	ec 44                         	mov.l	[r4], r4
ffe01657:	61 44                         	cmp	#4, r4
ffe01659:	3a 4b 03                      	beq.w	ffe019a4 <_Reset_Vector+0xffe019a8>
                                || (RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe0165c:	b0 fc                         	movu.b	3[r7], r4
ffe0165e:	6c 44                         	shll	#4, r4
ffe01660:	70 44 24 00 00 00             	add	#36, r4, r4
ffe01666:	ec 44                         	mov.l	[r4], r4
ffe01668:	61 54                         	cmp	#5, r4
ffe0166a:	3a 3a 03                      	beq.w	ffe019a4 <_Reset_Vector+0xffe019a8>
                                || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe0166d:	b0 fc                         	movu.b	3[r7], r4
ffe0166f:	6c 44                         	shll	#4, r4
ffe01671:	70 44 24 00 00 00             	add	#36, r4, r4
ffe01677:	ec 44                         	mov.l	[r4], r4
ffe01679:	61 64                         	cmp	#6, r4
ffe0167b:	3a 29 03                      	beq.w	ffe019a4 <_Reset_Vector+0xffe019a8>
ffe0167e:	ef 00                         	nop	; mov.l	r0, r0
                        riic_set_ch_status(priic_info_m[p_riic_info->ch_no], RIIC_AL);
ffe01680:	b0 fc                         	movu.b	3[r7], r4
ffe01682:	fb 32 6c 00 00 00             	mov.l	#108, r3
ffe01688:	fe 64 33                      	mov.l	[r4, r3], r3

ffe0168b <.LBB445>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe0168b:	b0 bc                         	movu.b	3[r3], r4
ffe0168d:	66 51                         	mov.l	#5, r1
ffe0168f:	fe 04 a1                      	mov.b	r1, [r4, r10]
    p_riic_info->dev_sts = status;
ffe01692:	80 b1                         	mov.b	r1, 2[r3]

ffe01694 <.LVL89>:
                    if ((((((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe01694:	59 7a 03                      	movu.b	3[r7], r10
ffe01697:	6c 4a                         	shll	#4, r10
ffe01699:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe0169f:	ec aa                         	mov.l	[r10], r10
ffe016a1:	61 1a                         	cmp	#1, r10
ffe016a3:	3a e3 01                      	beq.w	ffe01886 <_Reset_Vector+0xffe0188a>
                            || (RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe016a6:	59 7a 03                      	movu.b	3[r7], r10
ffe016a9:	6c 4a                         	shll	#4, r10
ffe016ab:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe016b1:	ed aa 01                      	mov.l	4[r10], r10
ffe016b4:	61 1a                         	cmp	#1, r10
ffe016b6:	3a d0 01                      	beq.w	ffe01886 <_Reset_Vector+0xffe0188a>
                            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe016b9:	59 7a 03                      	movu.b	3[r7], r10
ffe016bc:	6c 4a                         	shll	#4, r10
ffe016be:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe016c4:	ec aa                         	mov.l	[r10], r10
ffe016c6:	61 2a                         	cmp	#2, r10
ffe016c8:	3a be 01                      	beq.w	ffe01886 <_Reset_Vector+0xffe0188a>
                            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe016cb:	59 7a 03                      	movu.b	3[r7], r10
ffe016ce:	6c 4a                         	shll	#4, r10
ffe016d0:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe016d6:	ed aa 01                      	mov.l	4[r10], r10
ffe016d9:	61 2a                         	cmp	#2, r10
ffe016db:	3a ab 01                      	beq.w	ffe01886 <_Reset_Vector+0xffe0188a>
                            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe016de:	59 7a 03                      	movu.b	3[r7], r10
ffe016e1:	6c 4a                         	shll	#4, r10
ffe016e3:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe016e9:	ec aa                         	mov.l	[r10], r10
ffe016eb:	61 3a                         	cmp	#3, r10
ffe016ed:	3a 99 01                      	beq.w	ffe01886 <_Reset_Vector+0xffe0188a>
                            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe016f0:	59 7a 03                      	movu.b	3[r7], r10
ffe016f3:	6c 4a                         	shll	#4, r10
ffe016f5:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe016fb:	ed aa 01                      	mov.l	4[r10], r10
ffe016fe:	61 3a                         	cmp	#3, r10
ffe01700:	3a 86 01                      	beq.w	ffe01886 <_Reset_Vector+0xffe0188a>
                    if ((RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe01703:	59 7a 03                      	movu.b	3[r7], r10
ffe01706:	6c 4a                         	shll	#4, r10
ffe01708:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe0170e:	ec aa                         	mov.l	[r10], r10
ffe01710:	61 5a                         	cmp	#5, r10
ffe01712:	3a 0e 02                      	beq.w	ffe01920 <_Reset_Vector+0xffe01924>
                            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe01715:	59 7a 03                      	movu.b	3[r7], r10
ffe01718:	6c 4a                         	shll	#4, r10
ffe0171a:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe01720:	ec aa                         	mov.l	[r10], r10
ffe01722:	61 6a                         	cmp	#6, r10
ffe01724:	3a fc 01                      	beq.w	ffe01920 <_Reset_Vector+0xffe01924>
ffe01727:	03                            	nop
                    if ((RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe01728:	59 7a 03                      	movu.b	3[r7], r10
ffe0172b:	6c 4a                         	shll	#4, r10
ffe0172d:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe01733:	ec aa                         	mov.l	[r10], r10
ffe01735:	61 4a                         	cmp	#4, r10
ffe01737:	3a 71 01                      	beq.w	ffe018a8 <_Reset_Vector+0xffe018ac>
                            || (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe0173a:	59 7a 03                      	movu.b	3[r7], r10
ffe0173d:	6c 4a                         	shll	#4, r10
ffe0173f:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe01745:	ed aa 01                      	mov.l	4[r10], r10
ffe01748:	61 4a                         	cmp	#4, r10
ffe0174a:	3a 5e 01                      	beq.w	ffe018a8 <_Reset_Vector+0xffe018ac>

ffe0174d <.LBB447>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe0174d:	cd 7a 03                      	mov.b	3[r7], r10

ffe01750 <.LBB453>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe01750:	88 ff                         	mov.b	3[r7], r7

ffe01752 <.LBB459>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe01752:	5b aa                         	movu.b	r10, r10

ffe01754 <.LBE459>:
                        *picier_reg = RIIC_ICIER_INIT;
ffe01754:	f8 64 00                      	mov.b	#0, [r6]

ffe01757 <.LBB460>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01757:	5b 77                         	movu.b	r7, r7

ffe01759 <.LBB461>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe01759:	6c 4a                         	shll	#4, r10

ffe0175b <.LBB462>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe0175b:	6c 47                         	shll	#4, r7

ffe0175d <.LBB463>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe0175d:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe01763:	e4 aa 01                      	mov.l	[r10], 4[r10]

ffe01766 <.LBB464>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01766:	70 77 24 00 00 00             	add	#36, r7, r7

ffe0176c <.LBB465>:
    riic_api_info[ch_no].N_Mode = new_mode;
ffe0176c:	f8 a6 00                      	mov.l	#0, [r10]

ffe0176f <.LBB466>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe0176f:	e5 77 02 03                   	mov.l	8[r7], 12[r7]
    riic_api_info[ch_no].N_status = new_status;
ffe01773:	3e 72 01                      	mov.l	#1, 8[r7]

ffe01776 <.LBE466>:
                        while (RIIC_ICIER_INIT != (*picier_reg))
ffe01776:	ef 00                         	nop	; mov.l	r0, r0
ffe01778:	58 67                         	movu.b	[r6], r7
ffe0177a:	61 07                         	cmp	#0, r7
ffe0177c:	21 fc                         	bne.b	ffe01778 <_Reset_Vector+0xffe0177c>
ffe0177e:	38 e0 fd                      	bra.w	ffe0155e <_Reset_Vector+0xffe01562>

ffe01781 <.LBB467>:
        ret = RIIC_ERR_OTHER;
ffe01781:	66 85                         	mov.l	#8, r5

ffe01783 <.LBB468>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe01783:	b0 fc                         	movu.b	3[r7], r4
ffe01785:	66 71                         	mov.l	#7, r1
ffe01787:	fe 04 a1                      	mov.b	r1, [r4, r10]
    p_riic_info->dev_sts = status;
ffe0178a:	80 f1                         	mov.b	r1, 2[r7]
ffe0178c:	38 d2 fd                      	bra.w	ffe0155e <_Reset_Vector+0xffe01562>

ffe0178f <.LBB470>:
                ret = RIIC_ERR_OTHER;
ffe0178f:	66 85                         	mov.l	#8, r5
ffe01791:	38 cd fd                      	bra.w	ffe0155e <_Reset_Vector+0xffe01562>

ffe01794 <.LBE470>:
                    if ((((((RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe01794:	6c 44                         	shll	#4, r4
ffe01796:	70 44 24 00 00 00             	add	#36, r4, r4
ffe0179c:	ec 44                         	mov.l	[r4], r4
ffe0179e:	61 14                         	cmp	#1, r4
ffe017a0:	3a ae 00                      	beq.w	ffe0184e <_Reset_Vector+0xffe01852>
                            || (RIIC_MODE_M_SEND == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe017a3:	b0 fc                         	movu.b	3[r7], r4
ffe017a5:	6c 44                         	shll	#4, r4
ffe017a7:	70 44 24 00 00 00             	add	#36, r4, r4
ffe017ad:	a8 4c                         	mov.l	4[r4], r4
ffe017af:	61 14                         	cmp	#1, r4
ffe017b1:	3a 9d 00                      	beq.w	ffe0184e <_Reset_Vector+0xffe01852>
                            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe017b4:	b0 fc                         	movu.b	3[r7], r4
ffe017b6:	6c 44                         	shll	#4, r4
ffe017b8:	70 44 24 00 00 00             	add	#36, r4, r4
ffe017be:	ec 44                         	mov.l	[r4], r4
ffe017c0:	61 24                         	cmp	#2, r4
ffe017c2:	3a 8c 00                      	beq.w	ffe0184e <_Reset_Vector+0xffe01852>
                            || (RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe017c5:	b0 fc                         	movu.b	3[r7], r4
ffe017c7:	6c 44                         	shll	#4, r4
ffe017c9:	70 44 24 00 00 00             	add	#36, r4, r4
ffe017cf:	a8 4c                         	mov.l	4[r4], r4
ffe017d1:	61 24                         	cmp	#2, r4
ffe017d3:	20 7b                         	beq.b	ffe0184e <_Reset_Vector+0xffe01852>
                            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe017d5:	b0 fc                         	movu.b	3[r7], r4
ffe017d7:	6c 44                         	shll	#4, r4
ffe017d9:	70 44 24 00 00 00             	add	#36, r4, r4
ffe017df:	ec 44                         	mov.l	[r4], r4
ffe017e1:	61 34                         	cmp	#3, r4
ffe017e3:	20 6b                         	beq.b	ffe0184e <_Reset_Vector+0xffe01852>
                            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].B_Mode))
ffe017e5:	b0 fc                         	movu.b	3[r7], r4
ffe017e7:	6c 44                         	shll	#4, r4
ffe017e9:	70 44 24 00 00 00             	add	#36, r4, r4
ffe017ef:	a8 4c                         	mov.l	4[r4], r4
ffe017f1:	61 34                         	cmp	#3, r4
ffe017f3:	20 5b                         	beq.b	ffe0184e <_Reset_Vector+0xffe01852>
ffe017f5:	fc 13 00                      	nop	; max	r0, r0
                    if ((RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe017f8:	b0 fc                         	movu.b	3[r7], r4
ffe017fa:	6c 44                         	shll	#4, r4
ffe017fc:	70 44 24 00 00 00             	add	#36, r4, r4
ffe01802:	ec 44                         	mov.l	[r4], r4
ffe01804:	61 54                         	cmp	#5, r4
ffe01806:	20 13                         	beq.b	ffe01819 <_Reset_Vector+0xffe0181d>
                            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe01808:	b0 fc                         	movu.b	3[r7], r4
ffe0180a:	6c 44                         	shll	#4, r4
ffe0180c:	70 44 24 00 00 00             	add	#36, r4, r4
ffe01812:	ec 44                         	mov.l	[r4], r4
ffe01814:	61 64                         	cmp	#6, r4
ffe01816:	3b 48 fd                      	bne.w	ffe0155e <_Reset_Vector+0xffe01562>
                        riic_set_ch_status(priic_info_s[p_riic_info->ch_no], RIIC_TMO);
ffe01819:	88 fc                         	mov.b	3[r7], r4
                        if (NULL != g_riic_callbackfunc_s[p_riic_info->ch_no])
ffe0181b:	fb 22 1c 02 00 00             	mov.l	#540, r2
                        riic_set_ch_status(priic_info_s[p_riic_info->ch_no], RIIC_TMO);
ffe01821:	5b 44                         	movu.b	r4, r4
ffe01823:	fb 32 60 00 00 00             	mov.l	#96, r3
ffe01829:	fe 64 33                      	mov.l	[r4, r3], r3

ffe0182c <.LBB471>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe0182c:	b0 bc                         	movu.b	3[r3], r4
ffe0182e:	66 61                         	mov.l	#6, r1
ffe01830:	fe 04 a1                      	mov.b	r1, [r4, r10]
    p_riic_info->dev_sts = status;
ffe01833:	80 b1                         	mov.b	r1, 2[r3]

ffe01835 <.LVL101>:
                        if (NULL != g_riic_callbackfunc_s[p_riic_info->ch_no])
ffe01835:	59 7a 03                      	movu.b	3[r7], r10
ffe01838:	fe 6a 2a                      	mov.l	[r10, r2], r10
ffe0183b:	61 0a                         	cmp	#0, r10
ffe0183d:	3a 21 fd                      	beq.w	ffe0155e <_Reset_Vector+0xffe01562>
                            g_riic_callbackfunc_s[p_riic_info->ch_no]();
ffe01840:	b0 ff                         	movu.b	3[r7], r7

ffe01842 <.LVL102>:
ffe01842:	fe 67 27                      	mov.l	[r7, r2], r7
ffe01845:	e3 05                         	mov.l	r5, [r0]
ffe01847:	7f 17                         	jsr	r7
ffe01849:	ec 05                         	mov.l	[r0], r5
ffe0184b:	38 13 fd                      	bra.w	ffe0155e <_Reset_Vector+0xffe01562>

ffe0184e <.LVL104>:
                        riic_set_ch_status(priic_info_m[p_riic_info->ch_no], RIIC_TMO);
ffe0184e:	88 fc                         	mov.b	3[r7], r4
                        if (NULL != g_riic_callbackfunc_m[p_riic_info->ch_no])
ffe01850:	fb 22 10 02 00 00             	mov.l	#528, r2
                        riic_set_ch_status(priic_info_m[p_riic_info->ch_no], RIIC_TMO);
ffe01856:	5b 44                         	movu.b	r4, r4
ffe01858:	fb 32 6c 00 00 00             	mov.l	#108, r3
ffe0185e:	fe 64 33                      	mov.l	[r4, r3], r3

ffe01861 <.LBB473>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe01861:	b0 bc                         	movu.b	3[r3], r4
ffe01863:	66 61                         	mov.l	#6, r1
ffe01865:	fe 04 a1                      	mov.b	r1, [r4, r10]
    p_riic_info->dev_sts = status;
ffe01868:	80 b1                         	mov.b	r1, 2[r3]

ffe0186a <.LVL106>:
                        if (NULL != g_riic_callbackfunc_m[p_riic_info->ch_no])
ffe0186a:	b0 fc                         	movu.b	3[r7], r4
ffe0186c:	fe 64 24                      	mov.l	[r4, r2], r4
ffe0186f:	61 04                         	cmp	#0, r4
ffe01871:	20 87                         	beq.b	ffe017f8 <_Reset_Vector+0xffe017fc>
                            g_riic_callbackfunc_m[p_riic_info->ch_no]();
ffe01873:	b0 fc                         	movu.b	3[r7], r4
ffe01875:	fe 64 24                      	mov.l	[r4, r2], r4
ffe01878:	e3 05                         	mov.l	r5, [r0]
ffe0187a:	7f 14                         	jsr	r4
ffe0187c:	ec 05                         	mov.l	[r0], r5
ffe0187e:	38 7a ff                      	bra.w	ffe017f8 <_Reset_Vector+0xffe017fc>

ffe01881 <.LBB475>:
                ret = RIIC_ERR_TMO;
ffe01881:	66 75                         	mov.l	#7, r5
ffe01883:	38 db fc                      	bra.w	ffe0155e <_Reset_Vector+0xffe01562>

ffe01886 <.LBE475>:
                        if (NULL != g_riic_callbackfunc_m[p_riic_info->ch_no])
ffe01886:	cd 7a 03                      	mov.b	3[r7], r10
ffe01889:	fb 42 10 02 00 00             	mov.l	#528, r4
ffe0188f:	5b aa                         	movu.b	r10, r10
ffe01891:	fe 6a 4a                      	mov.l	[r10, r4], r10
ffe01894:	61 0a                         	cmp	#0, r10
ffe01896:	3a 6d fe                      	beq.w	ffe01703 <_Reset_Vector+0xffe01707>
                            g_riic_callbackfunc_m[p_riic_info->ch_no]();
ffe01899:	59 7a 03                      	movu.b	3[r7], r10
ffe0189c:	fe 6a 4a                      	mov.l	[r10, r4], r10
ffe0189f:	e3 05                         	mov.l	r5, [r0]
ffe018a1:	7f 1a                         	jsr	r10
ffe018a3:	ec 05                         	mov.l	[r0], r5
ffe018a5:	38 5e fe                      	bra.w	ffe01703 <_Reset_Vector+0xffe01707>

ffe018a8 <.LBB476>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe018a8:	88 fb                         	mov.b	3[r7], r3

ffe018aa <.LBB483>:
ffe018aa:	88 fc                         	mov.b	3[r7], r4

ffe018ac <.LBB491>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe018ac:	cd 7a 03                      	mov.b	3[r7], r10

ffe018af <.LBE491>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe018af:	88 fa                         	mov.b	3[r7], r2

ffe018b1 <.LBB498>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe018b1:	5b 33                         	movu.b	r3, r3

ffe018b3 <.LBE498>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe018b3:	fb 12 60 00 00 00             	mov.l	#96, r1
ffe018b9:	5b 22                         	movu.b	r2, r2

ffe018bb <.LBB499>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe018bb:	6c 43                         	shll	#4, r3

ffe018bd <.LBB500>:
ffe018bd:	5b 44                         	movu.b	r4, r4

ffe018bf <.LBB501>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe018bf:	5b aa                         	movu.b	r10, r10

ffe018c1 <.LBB502>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe018c1:	70 33 24 00 00 00             	add	#36, r3, r3

ffe018c7 <.LBE502>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe018c7:	fe 62 12                      	mov.l	[r2, r1], r2

ffe018ca <.LBB503>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe018ca:	6c 44                         	shll	#4, r4

ffe018cc <.LBB504>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe018cc:	6c 4a                         	shll	#4, r10

ffe018ce <.LBB505>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe018ce:	e4 33 01                      	mov.l	[r3], 4[r3]

ffe018d1 <.LBB506>:
ffe018d1:	70 44 24 00 00 00             	add	#36, r4, r4

ffe018d7 <.LBB507>:
    riic_api_info[ch_no].N_Mode = new_mode;
ffe018d7:	f8 36 00                      	mov.l	#0, [r3]

ffe018da <.LBB508>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe018da:	70 aa 24 00 00 00             	add	#36, r10, r10

ffe018e0 <.LBE509>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe018e0:	a9 2b                         	mov.l	20[r2], r3

ffe018e2 <.LBB510>:
    riic_api_info[ch_no].B_Mode = riic_api_info[ch_no].N_Mode;
ffe018e2:	e4 44 01                      	mov.l	[r4], 4[r4]

ffe018e5 <.LBB511>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe018e5:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]

ffe018e9 <.LBB512>:
    riic_api_info[ch_no].N_Mode = new_mode;
ffe018e9:	f8 46 04                      	mov.l	#4, [r4]

ffe018ec <.LBB513>:
    riic_api_info[ch_no].N_status = new_status;
ffe018ec:	f9 a6 02 02                   	mov.l	#2, 8[r10]

ffe018f0 <.LBE513>:
                        if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe018f0:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe018f6:	20 5e                         	beq.b	ffe01954 <_Reset_Vector+0xffe01958>
                                && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe018f8:	59 7a 03                      	movu.b	3[r7], r10
ffe018fb:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffe018fe:	ed aa 04                      	mov.l	16[r10], r10
ffe01901:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01907:	20 4d                         	beq.b	ffe01954 <_Reset_Vector+0xffe01958>
                            riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX_RX);
ffe01909:	88 ff                         	mov.b	3[r7], r7

ffe0190b <.LBB514>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0190b:	fb 26 a0                      	mov.l	#-96, r2
                            riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX);
ffe0190e:	5b 77                         	movu.b	r7, r7
ffe01910:	fe 67 17                      	mov.l	[r7, r1], r7

ffe01913 <.LBB516>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01913:	88 f9                         	mov.b	3[r7], r1
ffe01915:	e3 05                         	mov.l	r5, [r0]
ffe01917:	05 3d f7 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe0191b <.LVL119>:
ffe0191b:	ec 05                         	mov.l	[r0], r5
ffe0191d:	38 41 fc                      	bra.w	ffe0155e <_Reset_Vector+0xffe01562>

ffe01920 <.LBE516>:
                        if (NULL != g_riic_callbackfunc_s[p_riic_info->ch_no])
ffe01920:	cd 7a 03                      	mov.b	3[r7], r10
ffe01923:	fb 42 1c 02 00 00             	mov.l	#540, r4
ffe01929:	5b aa                         	movu.b	r10, r10
ffe0192b:	fe 6a 4a                      	mov.l	[r10, r4], r10
ffe0192e:	61 0a                         	cmp	#0, r10
ffe01930:	3a f8 fd                      	beq.w	ffe01728 <_Reset_Vector+0xffe0172c>
                            g_riic_callbackfunc_s[p_riic_info->ch_no]();
ffe01933:	59 7a 03                      	movu.b	3[r7], r10
ffe01936:	fe 6a 4a                      	mov.l	[r10, r4], r10
ffe01939:	e3 05                         	mov.l	r5, [r0]
ffe0193b:	7f 1a                         	jsr	r10
ffe0193d:	ec 05                         	mov.l	[r0], r5
ffe0193f:	38 e9 fd                      	bra.w	ffe01728 <_Reset_Vector+0xffe0172c>
                    else if (RIIC_ICSR2_NACKF == ((*picsr2_reg) & RIIC_ICSR2_NACKF))
ffe01942:	cc 44                         	mov.b	[r4], r4
ffe01944:	7c 44                         	btst	#4, r4

ffe01946 <.LBB519>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe01946:	b0 fc                         	movu.b	3[r7], r4

ffe01948 <.LBE519>:
                    else if (RIIC_ICSR2_NACKF == ((*picsr2_reg) & RIIC_ICSR2_NACKF))
ffe01948:	20 73                         	beq.b	ffe019bb <_Reset_Vector+0xffe019bf>

ffe0194a <.LBB522>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe0194a:	66 32                         	mov.l	#3, r2
ffe0194c:	fe 04 a2                      	mov.b	r2, [r4, r10]
    p_riic_info->dev_sts = status;
ffe0194f:	80 f2                         	mov.b	r2, 2[r7]
ffe01951:	38 43 fd                      	bra.w	ffe01694 <_Reset_Vector+0xffe01698>

ffe01954 <.LBE522>:
                        else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01954:	59 7a 03                      	movu.b	3[r7], r10
ffe01957:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffe0195a:	ed aa 05                      	mov.l	20[r10], r10
ffe0195d:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01963:	20 15                         	beq.b	ffe01978 <_Reset_Vector+0xffe0197c>
                                && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01965:	59 7a 03                      	movu.b	3[r7], r10
ffe01968:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffe0196b:	ed aa 04                      	mov.l	16[r10], r10
ffe0196e:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01974:	20 51                         	beq.b	ffe019c5 <_Reset_Vector+0xffe019c9>
ffe01976:	ef 00                         	nop	; mov.l	r0, r0
                        else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01978:	59 7a 03                      	movu.b	3[r7], r10
ffe0197b:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffe0197e:	ed aa 05                      	mov.l	20[r10], r10
ffe01981:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01987:	3b d7 fb                      	bne.w	ffe0155e <_Reset_Vector+0xffe01562>
                                && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe0198a:	59 7a 03                      	movu.b	3[r7], r10
ffe0198d:	fe 6a 1a                      	mov.l	[r10, r1], r10
ffe01990:	ed aa 04                      	mov.l	16[r10], r10
ffe01993:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01999:	3a c5 fb                      	beq.w	ffe0155e <_Reset_Vector+0xffe01562>
                            riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX);
ffe0199c:	88 ff                         	mov.b	3[r7], r7

ffe0199e <.LBB523>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0199e:	75 42 20                      	mov.l	#32, r2
ffe019a1:	38 6d ff                      	bra.w	ffe0190e <_Reset_Vector+0xffe01912>

ffe019a4 <.LVL125>:
                            riic_set_ch_status(priic_info_s[p_riic_info->ch_no], RIIC_FINISH);
ffe019a4:	b0 fc                         	movu.b	3[r7], r4
ffe019a6:	fb 32 60 00 00 00             	mov.l	#96, r3
ffe019ac:	fe 64 33                      	mov.l	[r4, r3], r3

ffe019af <.LBB525>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe019af:	b0 bc                         	movu.b	3[r3], r4
ffe019b1:	66 22                         	mov.l	#2, r2
ffe019b3:	fe 04 a2                      	mov.b	r2, [r4, r10]
    p_riic_info->dev_sts = status;
ffe019b6:	80 b2                         	mov.b	r2, 2[r3]
ffe019b8:	38 c8 fc                      	bra.w	ffe01680 <_Reset_Vector+0xffe01684>

ffe019bb <.LBB527>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe019bb:	66 23                         	mov.l	#2, r3
ffe019bd:	fe 04 a3                      	mov.b	r3, [r4, r10]
    p_riic_info->dev_sts = status;
ffe019c0:	80 f3                         	mov.b	r3, 2[r7]
ffe019c2:	38 d2 fc                      	bra.w	ffe01694 <_Reset_Vector+0xffe01698>

ffe019c5 <.LVL128>:
                            riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TX);
ffe019c5:	88 ff                         	mov.b	3[r7], r7

ffe019c7 <.LBB529>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe019c7:	fb 26 80                      	mov.l	#-128, r2
ffe019ca:	38 44 ff                      	bra.w	ffe0190e <_Reset_Vector+0xffe01912>

ffe019cd <.LBE529>:
ffe019cd:	fc 13 00                      	nop	; max	r0, r0

ffe019d0 <_riic_after_gen_start_cond>:
{
ffe019d0:	6e 6a                         	pushm	r6-r10
ffe019d2:	60 80                         	sub	#8, r0
ffe019d4:	ef 17                         	mov.l	r1, r7
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe019d6:	cd 1a 03                      	mov.b	3[r1], r10

ffe019d9 <.LVL132>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe019d9:	88 9d                         	mov.b	3[r1], r5
    switch (riic_api_info[p_riic_info->ch_no].N_Mode)
ffe019db:	b0 9d                         	movu.b	3[r1], r5
ffe019dd:	6c 45                         	shll	#4, r5
ffe019df:	70 55 24 00 00 00             	add	#36, r5, r5
ffe019e5:	ec 55                         	mov.l	[r5], r5
ffe019e7:	61 25                         	cmp	#2, r5
ffe019e9:	20 6f                         	beq.b	ffe01a58 <_Reset_Vector+0xffe01a5c>
ffe019eb:	61 35                         	cmp	#3, r5
ffe019ed:	11                            	beq.s	ffe019f6 <_Reset_Vector+0xffe019fa>
ffe019ee:	61 15                         	cmp	#1, r5
ffe019f0:	16                            	beq.s	ffe019f6 <_Reset_Vector+0xffe019fa>

ffe019f1 <.LVL134>:
            ret = RIIC_ERR_OTHER;
ffe019f1:	66 81                         	mov.l	#8, r1

ffe019f3 <.LVL135>:
} /* End of function riic_after_gen_start_cond() */
ffe019f3:	3f 6a 07                      	rtsd	#28, r6-r10

ffe019f6 <.LVL136>:
            switch (riic_api_info[p_riic_info->ch_no].B_status)
ffe019f6:	b0 fd                         	movu.b	3[r7], r5
ffe019f8:	6c 45                         	shll	#4, r5
ffe019fa:	70 55 24 00 00 00             	add	#36, r5, r5
ffe01a00:	a8 dd                         	mov.l	12[r5], r5
ffe01a02:	61 05                         	cmp	#0, r5
ffe01a04:	20 ed                         	beq.b	ffe019f1 <_Reset_Vector+0xffe019f5>
ffe01a06:	61 25                         	cmp	#2, r5
ffe01a08:	24 05                         	bgtu.b	ffe01a0d <_Reset_Vector+0xffe01a11>
ffe01a0a:	38 e0 00                      	bra.w	ffe01aea <_Reset_Vector+0xffe01aee>
ffe01a0d:	61 65                         	cmp	#6, r5
ffe01a0f:	21 e2                         	bne.b	ffe019f1 <_Reset_Vector+0xffe019f5>
                    buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01a11:	a9 f5                         	mov.l	24[r7], r5

ffe01a13 <.LBB572>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe01a13:	cd 7a 03                      	mov.b	3[r7], r10

ffe01a16 <.LBB576>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01a16:	88 f9                         	mov.b	3[r7], r1

ffe01a18 <.LVL139>:
ffe01a18:	75 42 32                      	mov.l	#50, r2

ffe01a1b <.LBE576>:
                    buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01a1b:	cc 55                         	mov.b	[r5], r5

ffe01a1d <.LBB579>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01a1d:	5b aa                         	movu.b	r10, r10
ffe01a1f:	6c 4a                         	shll	#4, r10
ffe01a21:	70 aa 24 00 00 00             	add	#36, r10, r10

ffe01a27 <.LBE579>:
                    buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01a27:	ff 26 55                      	add	r5, r5, r6
                    buf_send_data |= R_CODE;
ffe01a2a:	78 06                         	bset	#0, r6

ffe01a2c <.LBB580>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01a2c:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffe01a30:	f9 a6 02 05                   	mov.l	#5, 8[r10]

ffe01a34 <.LBB581>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01a34:	05 20 f6 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01a38 <.LBB582>:
    volatile uint8_t uctmp = 0x00;
ffe01a38:	3c 06 00                      	mov.b	#0, 6[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe01a3b:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe01a3e:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe01a40:	5b a7                         	movu.b	r10, r7

ffe01a42 <.LVL144>:
ffe01a42:	6c 57                         	shll	#5, r7
ffe01a44:	73 77 12 83 08                	add	#0x88312, r7, r7

ffe01a49 <.LVL145>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe01a49:	05 e5 f5 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe01a4d <.LVL146>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe01a4d:	c3 76                         	mov.b	r6, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe01a4f:	cc 77                         	mov.b	[r7], r7

ffe01a51 <.LBE582>:
    riic_return_t ret = RIIC_SUCCESS;
ffe01a51:	66 01                         	mov.l	#0, r1

ffe01a53 <.LBB585>:
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe01a53:	81 87                         	mov.b	r7, 6[r0]

ffe01a55 <.LBE585>:
} /* End of function riic_after_gen_start_cond() */
ffe01a55:	3f 6a 07                      	rtsd	#28, r6-r10

ffe01a58 <.LVL148>:
            buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01a58:	ed 1a 06                      	mov.l	24[r1], r10

ffe01a5b <.LBB586>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe01a5b:	88 9d                         	mov.b	3[r1], r5

ffe01a5d <.LBE586>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01a5d:	88 9c                         	mov.b	3[r1], r4
            buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01a5f:	cc a3                         	mov.b	[r10], r3

ffe01a61 <.LBB594>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01a61:	5b 55                         	movu.b	r5, r5

ffe01a63 <.LBE594>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01a63:	5b 44                         	movu.b	r4, r4

ffe01a65 <.LBB595>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01a65:	6c 45                         	shll	#4, r5

ffe01a67 <.LBE595>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01a67:	6c 44                         	shll	#4, r4

ffe01a69 <.LBB596>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01a69:	70 55 24 00 00 00             	add	#36, r5, r5

ffe01a6f <.LBE596>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01a6f:	70 44 24 00 00 00             	add	#36, r4, r4
            buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01a75:	ff 2a 33                      	add	r3, r3, r10

ffe01a78 <.LBB597>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01a78:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

ffe01a7c <.LBE597>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01a7c:	a8 4c                         	mov.l	4[r4], r4

ffe01a7e <.LBB598>:
    riic_api_info[ch_no].N_status = new_status;
ffe01a7e:	3e 52 05                      	mov.l	#5, 8[r5]

ffe01a81 <.LBE598>:
            buf_send_data |= R_CODE;
ffe01a81:	78 0a                         	bset	#0, r10

ffe01a83 <.LBB599>:
            if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01a83:	61 44                         	cmp	#4, r4
ffe01a85:	21 5a                         	bne.b	ffe01adf <_Reset_Vector+0xffe01ae3>
                if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01a87:	88 9c                         	mov.b	3[r1], r4
ffe01a89:	fb 52 60 00 00 00             	mov.l	#96, r5
ffe01a8f:	5b 44                         	movu.b	r4, r4
ffe01a91:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01a94:	a9 4c                         	mov.l	20[r4], r4
ffe01a96:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01a9c:	3a e7 00                      	beq.w	ffe01b83 <_Reset_Vector+0xffe01b87>
                        && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01a9f:	b0 9c                         	movu.b	3[r1], r4
ffe01aa1:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01aa4:	a9 44                         	mov.l	16[r4], r4
ffe01aa6:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01aac:	3a d7 00                      	beq.w	ffe01b83 <_Reset_Vector+0xffe01b87>
ffe01aaf:	03                            	nop
                    riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_NAK_AL | RIIC_ICIER_TX);
ffe01ab0:	88 fc                         	mov.b	3[r7], r4

ffe01ab2 <.LBB600>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01ab2:	fb 26 b2                      	mov.l	#-78, r2

ffe01ab5 <.LBE600>:
                    riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_NAK_AL | RIIC_ICIER_TX);
ffe01ab5:	5b 44                         	movu.b	r4, r4
ffe01ab7:	fe 64 55                      	mov.l	[r4, r5], r5

ffe01aba <.LBB603>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01aba:	88 d9                         	mov.b	3[r5], r1

ffe01abc <.LVL153>:
ffe01abc:	05 98 f5 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01ac0 <.LBB604>:
    volatile uint8_t uctmp = 0x00;
ffe01ac0:	3c 05 00                      	mov.b	#0, 5[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe01ac3:	88 fd                         	mov.b	3[r7], r5
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe01ac5:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe01ac7:	5b 57                         	movu.b	r5, r7

ffe01ac9 <.LVL155>:
ffe01ac9:	6c 57                         	shll	#5, r7
ffe01acb:	73 77 12 83 08                	add	#0x88312, r7, r7

ffe01ad0 <.LVL156>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe01ad0:	05 5e f5 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe01ad4 <.LVL157>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe01ad4:	c3 7a                         	mov.b	r10, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe01ad6:	cc 77                         	mov.b	[r7], r7

ffe01ad8 <.LBE604>:
    riic_return_t ret = RIIC_SUCCESS;
ffe01ad8:	66 01                         	mov.l	#0, r1

ffe01ada <.LBB607>:
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe01ada:	81 0f                         	mov.b	r7, 5[r0]

ffe01adc <.LBE607>:
} /* End of function riic_after_gen_start_cond() */
ffe01adc:	3f 6a 07                      	rtsd	#28, r6-r10

ffe01adf <.LBB608>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01adf:	88 99                         	mov.b	3[r1], r1

ffe01ae1 <.LVL160>:
ffe01ae1:	75 42 32                      	mov.l	#50, r2
ffe01ae4:	05 70 f5 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01ae8 <.LVL161>:
ffe01ae8:	2e d8                         	bra.b	ffe01ac0 <_Reset_Vector+0xffe01ac4>

ffe01aea <.LVL162>:
                    if ((uint8_t *) FIT_NO_PTR == p_riic_info->p_slv_adr) /* Pattern 4 of Master Write */
ffe01aea:	a9 f5                         	mov.l	24[r7], r5
ffe01aec:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffe01af2:	3a ee 00                      	beq.w	ffe01be0 <_Reset_Vector+0xffe01be4>
                        buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01af5:	a9 f4                         	mov.l	24[r7], r4

ffe01af7 <.LBB610>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe01af7:	cd 7a 03                      	mov.b	3[r7], r10

ffe01afa <.LBE610>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01afa:	88 fd                         	mov.b	3[r7], r5
                        buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01afc:	cc 44                         	mov.b	[r4], r4

ffe01afe <.LBB617>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01afe:	5b aa                         	movu.b	r10, r10

ffe01b00 <.LBE617>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01b00:	5b 55                         	movu.b	r5, r5

ffe01b02 <.LBB618>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01b02:	6c 4a                         	shll	#4, r10

ffe01b04 <.LBE618>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01b04:	6c 45                         	shll	#4, r5

ffe01b06 <.LBB619>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01b06:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe01b0c:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]

ffe01b10 <.LBE619>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01b10:	70 55 24 00 00 00             	add	#36, r5, r5

ffe01b16 <.LBB620>:
    riic_api_info[ch_no].N_status = new_status;
ffe01b16:	f9 a6 02 04                   	mov.l	#4, 8[r10]

ffe01b1a <.LBE620>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01b1a:	ed 5a 01                      	mov.l	4[r5], r10
                        buf_send_data = (uint8_t) ((*(p_riic_info->p_slv_adr)) << 1U);
ffe01b1d:	ff 26 44                      	add	r4, r4, r6

ffe01b20 <.LBB621>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01b20:	61 4a                         	cmp	#4, r10
ffe01b22:	3b b3 00                      	bne.w	ffe01bd5 <_Reset_Vector+0xffe01bd9>
                            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01b25:	cd 7a 03                      	mov.b	3[r7], r10
ffe01b28:	fb 52 60 00 00 00             	mov.l	#96, r5
ffe01b2e:	5b aa                         	movu.b	r10, r10
ffe01b30:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffe01b33:	ed aa 05                      	mov.l	20[r10], r10
ffe01b36:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01b3c:	3a 65 01                      	beq.w	ffe01ca1 <_Reset_Vector+0xffe01ca5>
                                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01b3f:	59 7a 03                      	movu.b	3[r7], r10
ffe01b42:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffe01b45:	ed aa 04                      	mov.l	16[r10], r10
ffe01b48:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01b4e:	3a 53 01                      	beq.w	ffe01ca1 <_Reset_Vector+0xffe01ca5>
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffe01b51:	cd 7a 03                      	mov.b	3[r7], r10

ffe01b54 <.LBB622>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01b54:	fb 26 f2                      	mov.l	#-14, r2

ffe01b57 <.LBE622>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffe01b57:	5b aa                         	movu.b	r10, r10
ffe01b59:	fe 6a 5a                      	mov.l	[r10, r5], r10

ffe01b5c <.LBB625>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01b5c:	cd a1 03                      	mov.b	3[r10], r1

ffe01b5f <.LVL166>:
ffe01b5f:	05 f5 f4 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01b63 <.LBB626>:
    volatile uint8_t uctmp = 0x00;
ffe01b63:	3c 07 00                      	mov.b	#0, 7[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe01b66:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe01b69:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe01b6b:	5b a7                         	movu.b	r10, r7

ffe01b6d <.LVL168>:
ffe01b6d:	6c 57                         	shll	#5, r7
ffe01b6f:	73 77 12 83 08                	add	#0x88312, r7, r7

ffe01b74 <.LVL169>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe01b74:	05 ba f4 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe01b78 <.LVL170>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe01b78:	c3 76                         	mov.b	r6, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe01b7a:	cc 77                         	mov.b	[r7], r7

ffe01b7c <.LBE626>:
    riic_return_t ret = RIIC_SUCCESS;
ffe01b7c:	66 01                         	mov.l	#0, r1

ffe01b7e <.LBB629>:
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe01b7e:	81 8f                         	mov.b	r7, 7[r0]

ffe01b80 <.LBE629>:
} /* End of function riic_after_gen_start_cond() */
ffe01b80:	3f 6a 07                      	rtsd	#28, r6-r10

ffe01b83 <.LVL172>:
                else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01b83:	b0 fc                         	movu.b	3[r7], r4
ffe01b85:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01b88:	a9 4c                         	mov.l	20[r4], r4
ffe01b8a:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01b90:	20 12                         	beq.b	ffe01ba2 <_Reset_Vector+0xffe01ba6>
                        && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01b92:	b0 fc                         	movu.b	3[r7], r4
ffe01b94:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01b97:	a9 44                         	mov.l	16[r4], r4
ffe01b99:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01b9f:	3a 11 ff                      	beq.w	ffe01ab0 <_Reset_Vector+0xffe01ab4>
                else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01ba2:	b0 fc                         	movu.b	3[r7], r4
ffe01ba4:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01ba7:	a9 4c                         	mov.l	20[r4], r4
ffe01ba9:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01baf:	3b 11 ff                      	bne.w	ffe01ac0 <_Reset_Vector+0xffe01ac4>
                        && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01bb2:	b0 fc                         	movu.b	3[r7], r4
ffe01bb4:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01bb7:	a9 44                         	mov.l	16[r4], r4
ffe01bb9:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01bbf:	3a 01 ff                      	beq.w	ffe01ac0 <_Reset_Vector+0xffe01ac4>
                    riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_NAK_AL | RIIC_ICIER_RX);
ffe01bc2:	88 fc                         	mov.b	3[r7], r4

ffe01bc4 <.LBB630>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01bc4:	75 42 32                      	mov.l	#50, r2

ffe01bc7 <.LBE630>:
                    riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_RX_NAK_AL | RIIC_ICIER_RX);
ffe01bc7:	5b 44                         	movu.b	r4, r4
ffe01bc9:	fe 64 55                      	mov.l	[r4, r5], r5

ffe01bcc <.LBB633>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01bcc:	88 d9                         	mov.b	3[r5], r1

ffe01bce <.LVL174>:
ffe01bce:	05 86 f4 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01bd2 <.LVL175>:
ffe01bd2:	38 ee fe                      	bra.w	ffe01ac0 <_Reset_Vector+0xffe01ac4>

ffe01bd5 <.LBB634>:
ffe01bd5:	88 f9                         	mov.b	3[r7], r1

ffe01bd7 <.LVL177>:
ffe01bd7:	75 42 52                      	mov.l	#82, r2
ffe01bda:	05 7a f4 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01bde <.LVL178>:
ffe01bde:	2e 85                         	bra.b	ffe01b63 <_Reset_Vector+0xffe01b67>

ffe01be0 <.LBB636>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe01be0:	88 fd                         	mov.b	3[r7], r5

ffe01be2 <.LBE636>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01be2:	88 fc                         	mov.b	3[r7], r4

ffe01be4 <.LBB642>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01be4:	5b 55                         	movu.b	r5, r5

ffe01be6 <.LBE642>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01be6:	5b 44                         	movu.b	r4, r4

ffe01be8 <.LBB643>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01be8:	6c 45                         	shll	#4, r5

ffe01bea <.LBE643>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01bea:	6c 44                         	shll	#4, r4

ffe01bec <.LBB644>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe01bec:	70 55 24 00 00 00             	add	#36, r5, r5
ffe01bf2:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

ffe01bf6 <.LBE644>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01bf6:	70 44 24 00 00 00             	add	#36, r4, r4

ffe01bfc <.LBB645>:
    riic_api_info[ch_no].N_status = new_status;
ffe01bfc:	3e 52 08                      	mov.l	#8, 8[r5]

ffe01bff <.LBE645>:
                        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe01bff:	a8 4d                         	mov.l	4[r4], r5
ffe01c01:	61 45                         	cmp	#4, r5
ffe01c03:	3b fa 00                      	bne.w	ffe01cfd <_Reset_Vector+0xffe01d01>
                            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01c06:	88 fc                         	mov.b	3[r7], r4
ffe01c08:	fb 52 60 00 00 00             	mov.l	#96, r5
ffe01c0e:	5b 44                         	movu.b	r4, r4
ffe01c10:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01c13:	a9 4c                         	mov.l	20[r4], r4
ffe01c15:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01c1b:	3a ee 00                      	beq.w	ffe01d09 <_Reset_Vector+0xffe01d0d>
                                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01c1e:	b0 fc                         	movu.b	3[r7], r4
ffe01c20:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01c23:	a9 44                         	mov.l	16[r4], r4
ffe01c25:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01c2b:	3a de 00                      	beq.w	ffe01d09 <_Reset_Vector+0xffe01d0d>
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffe01c2e:	88 fc                         	mov.b	3[r7], r4

ffe01c30 <.LBB646>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01c30:	fb 26 ba                      	mov.l	#-70, r2

ffe01c33 <.LBE646>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffe01c33:	5b 44                         	movu.b	r4, r4
ffe01c35:	fe 64 55                      	mov.l	[r4, r5], r5

ffe01c38 <.LBB649>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01c38:	88 d9                         	mov.b	3[r5], r1

ffe01c3a <.LVL184>:
ffe01c3a:	05 1a f4 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01c3e <.LVL185>:
ffe01c3e:	ef 00                         	nop	; mov.l	r0, r0

ffe01c40 <.LBE649>:
                        for (cnt = RIIC_CFG_SCL_CHECK_COUNTER; (false == scl_low_chk) && (cnt > 0x00000000); cnt--)
ffe01c40:	f8 0a e8 03                   	mov.l	#0x3e8, [r0]
ffe01c44:	ec 05                         	mov.l	[r0], r5
ffe01c46:	61 05                         	cmp	#0, r5
ffe01c48:	3a a9 fd                      	beq.w	ffe019f1 <_Reset_Vector+0xffe019f5>
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe01c4b:	5b aa                         	movu.b	r10, r10
ffe01c4d:	6c 5a                         	shll	#5, r10

ffe01c4f <.LVL186>:
ffe01c4f:	73 aa 00 83 08                	add	#0x88300, r10, r10
ffe01c54:	76 10 01 00                   	nop	; mul	#1, r0
                            if (RIIC_ICCR1_SCLI_SET != ((*piccr1_reg) & RIIC_ICCR1_SCLI)) /* SCL low ? */
ffe01c58:	cc a5                         	mov.b	[r10], r5
ffe01c5a:	7c 15                         	btst	#1, r5
ffe01c5c:	21 34                         	bne.b	ffe01c90 <_Reset_Vector+0xffe01c94>

ffe01c5e <.LVL187>:
                        for (cnt = RIIC_CFG_SCL_CHECK_COUNTER; (false == scl_low_chk) && (cnt > 0x00000000); cnt--)
ffe01c5e:	ec 0a                         	mov.l	[r0], r10
ffe01c60:	60 1a                         	sub	#1, r10
ffe01c62:	e3 0a                         	mov.l	r10, [r0]

ffe01c64 <.LBB650>:
    volatile uint8_t uctmp = 0x00;
ffe01c64:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe01c67:	cd 7a 03                      	mov.b	3[r7], r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe01c6a:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe01c6c:	5b a7                         	movu.b	r10, r7

ffe01c6e <.LVL189>:
ffe01c6e:	6c 57                         	shll	#5, r7
ffe01c70:	73 77 09 83 08                	add	#0x88309, r7, r7

ffe01c75 <.LVL190>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe01c75:	cc 74                         	mov.b	[r7], r4
ffe01c77:	7c 34                         	btst	#3, r4
ffe01c79:	13                            	beq.s	ffe01c7c <_Reset_Vector+0xffe01c80>
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffe01c7a:	f0 7b                         	bclr	#3, [r7].b
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe01c7c:	5b 57                         	movu.b	r5, r7

ffe01c7e <.LVL191>:
ffe01c7e:	6c 57                         	shll	#5, r7
ffe01c80:	73 77 01 83 08                	add	#0x88301, r7, r7

ffe01c85 <.LBE650>:
    riic_return_t ret = RIIC_SUCCESS;
ffe01c85:	66 01                         	mov.l	#0, r1

ffe01c87 <.LBB653>:
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffe01c87:	f0 73                         	bset	#3, [r7].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe01c89:	cc 77                         	mov.b	[r7], r7
ffe01c8b:	81 07                         	mov.b	r7, 4[r0]

ffe01c8d <.LBE653>:
} /* End of function riic_after_gen_start_cond() */
ffe01c8d:	3f 6a 07                      	rtsd	#28, r6-r10

ffe01c90 <.LVL192>:
                        for (cnt = RIIC_CFG_SCL_CHECK_COUNTER; (false == scl_low_chk) && (cnt > 0x00000000); cnt--)
ffe01c90:	ec 05                         	mov.l	[r0], r5
ffe01c92:	60 15                         	sub	#1, r5
ffe01c94:	e3 05                         	mov.l	r5, [r0]
ffe01c96:	ec 05                         	mov.l	[r0], r5
ffe01c98:	61 05                         	cmp	#0, r5
ffe01c9a:	21 be                         	bne.b	ffe01c58 <_Reset_Vector+0xffe01c5c>
            ret = RIIC_ERR_OTHER;
ffe01c9c:	66 81                         	mov.l	#8, r1
ffe01c9e:	38 55 fd                      	bra.w	ffe019f3 <_Reset_Vector+0xffe019f7>

ffe01ca1 <.LVL193>:
                            else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01ca1:	59 7a 03                      	movu.b	3[r7], r10
ffe01ca4:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffe01ca7:	ed aa 05                      	mov.l	20[r10], r10
ffe01caa:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01cb0:	20 14                         	beq.b	ffe01cc4 <_Reset_Vector+0xffe01cc8>
                                    && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01cb2:	59 7a 03                      	movu.b	3[r7], r10
ffe01cb5:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffe01cb8:	ed aa 04                      	mov.l	16[r10], r10
ffe01cbb:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01cc1:	3a 9a 00                      	beq.w	ffe01d5b <_Reset_Vector+0xffe01d5f>
                            else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01cc4:	59 7a 03                      	movu.b	3[r7], r10
ffe01cc7:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffe01cca:	ed aa 05                      	mov.l	20[r10], r10
ffe01ccd:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01cd3:	3b 90 fe                      	bne.w	ffe01b63 <_Reset_Vector+0xffe01b67>
                                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01cd6:	59 7a 03                      	movu.b	3[r7], r10
ffe01cd9:	fe 6a 5a                      	mov.l	[r10, r5], r10
ffe01cdc:	ed aa 04                      	mov.l	16[r10], r10
ffe01cdf:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe01ce5:	3a 7e fe                      	beq.w	ffe01b63 <_Reset_Vector+0xffe01b67>
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffe01ce8:	cd 7a 03                      	mov.b	3[r7], r10

ffe01ceb <.LBB654>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01ceb:	75 42 72                      	mov.l	#114, r2

ffe01cee <.LBE654>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffe01cee:	5b aa                         	movu.b	r10, r10
ffe01cf0:	fe 6a 5a                      	mov.l	[r10, r5], r10

ffe01cf3 <.LBB657>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01cf3:	cd a1 03                      	mov.b	3[r10], r1

ffe01cf6 <.LVL195>:
ffe01cf6:	05 5e f3 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01cfa <.LVL196>:
ffe01cfa:	38 69 fe                      	bra.w	ffe01b63 <_Reset_Vector+0xffe01b67>

ffe01cfd <.LBB658>:
ffe01cfd:	88 f9                         	mov.b	3[r7], r1

ffe01cff <.LVL198>:
ffe01cff:	75 42 1a                      	mov.l	#26, r2
ffe01d02:	05 52 f3 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01d06 <.LVL199>:
ffe01d06:	38 3a ff                      	bra.w	ffe01c40 <_Reset_Vector+0xffe01c44>

ffe01d09 <.LVL200>:
                            else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01d09:	b0 fc                         	movu.b	3[r7], r4
ffe01d0b:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01d0e:	a9 4c                         	mov.l	20[r4], r4
ffe01d10:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01d16:	20 12                         	beq.b	ffe01d28 <_Reset_Vector+0xffe01d2c>
                                    && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01d18:	b0 fc                         	movu.b	3[r7], r4
ffe01d1a:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01d1d:	a9 44                         	mov.l	16[r4], r4
ffe01d1f:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01d25:	20 4b                         	beq.b	ffe01d70 <_Reset_Vector+0xffe01d74>
ffe01d27:	03                            	nop
                            else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe01d28:	b0 fc                         	movu.b	3[r7], r4
ffe01d2a:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01d2d:	a9 4c                         	mov.l	20[r4], r4
ffe01d2f:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01d35:	3b 0b ff                      	bne.w	ffe01c40 <_Reset_Vector+0xffe01c44>
                                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe01d38:	b0 fc                         	movu.b	3[r7], r4
ffe01d3a:	fe 64 54                      	mov.l	[r4, r5], r4
ffe01d3d:	a9 44                         	mov.l	16[r4], r4
ffe01d3f:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe01d45:	3a fb fe                      	beq.w	ffe01c40 <_Reset_Vector+0xffe01c44>
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffe01d48:	88 fc                         	mov.b	3[r7], r4

ffe01d4a <.LBB660>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01d4a:	75 42 3a                      	mov.l	#58, r2

ffe01d4d <.LBE660>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffe01d4d:	5b 44                         	movu.b	r4, r4
ffe01d4f:	fe 64 55                      	mov.l	[r4, r5], r5

ffe01d52 <.LBB663>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01d52:	88 d9                         	mov.b	3[r5], r1

ffe01d54 <.LVL202>:
ffe01d54:	05 00 f3 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01d58 <.LVL203>:
ffe01d58:	38 e8 fe                      	bra.w	ffe01c40 <_Reset_Vector+0xffe01c44>

ffe01d5b <.LBE663>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffe01d5b:	cd 7a 03                      	mov.b	3[r7], r10

ffe01d5e <.LBB664>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01d5e:	fb 26 d2                      	mov.l	#-46, r2

ffe01d61 <.LBE664>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_TEND_NAK_AL |
ffe01d61:	5b aa                         	movu.b	r10, r10
ffe01d63:	fe 6a 5a                      	mov.l	[r10, r5], r10

ffe01d66 <.LBB667>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01d66:	cd a1 03                      	mov.b	3[r10], r1

ffe01d69 <.LVL206>:
ffe01d69:	05 eb f2 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01d6d <.LVL207>:
ffe01d6d:	38 f6 fd                      	bra.w	ffe01b63 <_Reset_Vector+0xffe01b67>

ffe01d70 <.LBE667>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffe01d70:	88 fc                         	mov.b	3[r7], r4

ffe01d72 <.LBB668>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01d72:	fb 26 9a                      	mov.l	#-102, r2

ffe01d75 <.LBE668>:
                                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_SP_NAK_AL |
ffe01d75:	5b 44                         	movu.b	r4, r4
ffe01d77:	fe 64 55                      	mov.l	[r4, r5], r5

ffe01d7a <.LBB671>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe01d7a:	88 d9                         	mov.b	3[r5], r1

ffe01d7c <.LVL210>:
ffe01d7c:	05 d8 f2 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe01d80 <.LVL211>:
ffe01d80:	38 c0 fe                      	bra.w	ffe01c40 <_Reset_Vector+0xffe01c44>

ffe01d83 <.LBE671>:
ffe01d83:	77 10 01 00 00                	nop	; mul	#1, r0

ffe01d88 <_riic_init_io_register>:
{
ffe01d88:	6e 6d                         	pushm	r6-r13
ffe01d8a:	71 00 e4                      	add	#-28, r0, r0
ffe01d8d:	ef 17                         	mov.l	r1, r7
    volatile uint8_t uctmp = 0x00;
ffe01d8f:	3c 8b 00                      	mov.b	#0, 27[r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe01d92:	88 99                         	mov.b	3[r1], r1

ffe01d94 <.LVL213>:
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffe01d94:	cd 7e 03                      	mov.b	3[r7], r14
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffe01d97:	cd 78 03                      	mov.b	3[r7], r8
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffe01d9a:	cd 79 03                      	mov.b	3[r7], r9
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffe01d9d:	cd 7c 03                      	mov.b	3[r7], r12
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffe01da0:	88 fb                         	mov.b	3[r7], r3
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffe01da2:	88 fc                         	mov.b	3[r7], r4
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe01da4:	88 fa                         	mov.b	3[r7], r2
    volatile uint8_t * const picmr2_reg = RIIC_ICMR2_ADR(p_riic_info->ch_no);
ffe01da6:	88 fe                         	mov.b	3[r7], r6
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe01da8:	cd 7b 03                      	mov.b	3[r7], r11
    volatile uint8_t * const picfer_reg = RIIC_ICFER_ADR(p_riic_info->ch_no);
ffe01dab:	cd 7a 03                      	mov.b	3[r7], r10

ffe01dae <.LBB678>:
 * Arguments    : riic_info_t * p_riic_info      ; IIC Information
 * Return Value : None
 **********************************************************************************************************************/
static void riic_all_reset (riic_info_t * p_riic_info)
{
    volatile uint8_t uctmp = 0x00;
ffe01dae:	3c 8a 00                      	mov.b	#0, 26[r0]

    /* Creates the register pointer for the specified RIIC channel. */
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe01db1:	88 fd                         	mov.b	3[r7], r5

ffe01db3 <.LBE678>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe01db3:	5b 11                         	movu.b	r1, r1
ffe01db5:	6c 51                         	shll	#5, r1
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffe01db7:	5b ee                         	movu.b	r14, r14

ffe01db9 <.LBB689>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe01db9:	5b 55                         	movu.b	r5, r5

ffe01dbb <.LBE689>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe01dbb:	73 11 00 83 08                	add	#0x88300, r1, r1

ffe01dc0 <.LBB690>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe01dc0:	6c 55                         	shll	#5, r5

ffe01dc2 <.LBE690>:
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffe01dc2:	6c 5e                         	shll	#5, r14

ffe01dc4 <.LBB691>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe01dc4:	73 55 00 83 08                	add	#0x88300, r5, r5

ffe01dc9 <.LBE691>:
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffe01dc9:	5b 88                         	movu.b	r8, r8

ffe01dcb <.LBB692>:

    /* Resets RIIC registers. */
    (*piccr1_reg) &= RIIC_ICCR1_ICE_CLR; /* Clears ICCR1.ICE bit to 0. */
ffe01dcb:	cc 5f                         	mov.b	[r5], r15

ffe01dcd <.LBE692>:
    volatile uint8_t * const psarl0_reg = RIIC_SARL0_ADR(p_riic_info->ch_no);
ffe01dcd:	73 ee 0a 83 08                	add	#0x8830a, r14, r14

ffe01dd2 <.LVL215>:
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffe01dd2:	6c 58                         	shll	#5, r8
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffe01dd4:	5b 99                         	movu.b	r9, r9

ffe01dd6 <.LBB693>:
    (*piccr1_reg) &= RIIC_ICCR1_ICE_CLR; /* Clears ICCR1.ICE bit to 0. */
ffe01dd6:	75 2f 7f                      	and	#127, r15

ffe01dd9 <.LBE693>:
    volatile uint8_t * const psaru0_reg = RIIC_SARU0_ADR(p_riic_info->ch_no);
ffe01dd9:	73 88 0b 83 08                	add	#0x8830b, r8, r8

ffe01dde <.LBB694>:
    (*piccr1_reg) &= RIIC_ICCR1_ICE_CLR; /* Clears ICCR1.ICE bit to 0. */
ffe01dde:	c3 5f                         	mov.b	r15, [r5]

ffe01de0 <.LBE694>:
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffe01de0:	6c 59                         	shll	#5, r9

ffe01de2 <.LBB695>:
    (*piccr1_reg) |= RIIC_ICCR1_RIIC_RESET; /* Sets ICCR1.IICRST bit to 1. */
ffe01de2:	f0 56                         	bset	#6, [r5].b

    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffe01de4:	cc 55                         	mov.b	[r5], r5

ffe01de6 <.LBE695>:
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffe01de6:	5b cc                         	movu.b	r12, r12
    volatile uint8_t * const psarl1_reg = RIIC_SARL1_ADR(p_riic_info->ch_no);
ffe01de8:	73 99 0c 83 08                	add	#0x8830c, r9, r9

ffe01ded <.LBB696>:
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffe01ded:	86 85                         	mov.b	r5, 26[r0]

ffe01def <.LBE696>:
    (*piccr1_reg) |= RIIC_ICCR1_ICE_SET; /* Sets ICCR1.ICE bit to 1. */
ffe01def:	cc 15                         	mov.b	[r1], r5
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffe01df1:	6c 5c                         	shll	#5, r12
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffe01df3:	5b 33                         	movu.b	r3, r3
    volatile uint8_t * const psaru1_reg = RIIC_SARU1_ADR(p_riic_info->ch_no);
ffe01df5:	73 cc 0d 83 08                	add	#0x8830d, r12, r12

ffe01dfa <.LVL218>:
    (*piccr1_reg) |= RIIC_ICCR1_ICE_SET; /* Sets ICCR1.ICE bit to 1. */
ffe01dfa:	75 35 80                      	or	#-128, r5
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffe01dfd:	6c 53                         	shll	#5, r3
    (*piccr1_reg) |= RIIC_ICCR1_ICE_SET; /* Sets ICCR1.ICE bit to 1. */
ffe01dff:	c3 15                         	mov.b	r5, [r1]
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffe01e01:	5b 44                         	movu.b	r4, r4
    volatile uint8_t * const psarl2_reg = RIIC_SARL2_ADR(p_riic_info->ch_no);
ffe01e03:	73 33 0e 83 08                	add	#0x8830e, r3, r3

ffe01e08 <.LVL219>:
    *psarl0_reg = RIIC_SARL0_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffe01e08:	f8 e4 00                      	mov.b	#0, [r14]
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffe01e0b:	6c 54                         	shll	#5, r4
    *psaru0_reg = RIIC_SARU0_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffe01e0d:	f8 84 00                      	mov.b	#0, [r8]
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe01e10:	5b 25                         	movu.b	r2, r5
    *psarl1_reg = RIIC_SARL1_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffe01e12:	f8 94 00                      	mov.b	#0, [r9]
    volatile uint8_t * const psaru2_reg = RIIC_SARU2_ADR(p_riic_info->ch_no);
ffe01e15:	73 44 0f 83 08                	add	#0x8830f, r4, r4

ffe01e1a <.LVL220>:
    *psaru1_reg = RIIC_SARU1_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffe01e1a:	f8 c4 00                      	mov.b	#0, [r12]
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe01e1d:	6c 55                         	shll	#5, r5
    *psarl2_reg = RIIC_SARL2_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffe01e1f:	f8 34 00                      	mov.b	#0, [r3]
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe01e22:	73 55 06 83 08                	add	#0x88306, r5, r5

ffe01e27 <.LVL221>:
    *psaru2_reg = RIIC_SARU2_INIT; /* Sets SARLy and SARUy.(y=0,1,2) */
ffe01e27:	f8 44 00                      	mov.b	#0, [r4]
    *picser_reg = RIIC_ICSER_INIT; /* Sets ICSER register. */
ffe01e2a:	f8 54 00                      	mov.b	#0, [r5]
    uctmp = *picser_reg; /* Reads ICSER. */
ffe01e2d:	cc 55                         	mov.b	[r5], r5

ffe01e2f <.LVL222>:
    volatile uint8_t * const picmr2_reg = RIIC_ICMR2_ADR(p_riic_info->ch_no);
ffe01e2f:	5b 66                         	movu.b	r6, r6
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe01e31:	5b bb                         	movu.b	r11, r11
    volatile uint8_t * const picfer_reg = RIIC_ICFER_ADR(p_riic_info->ch_no);
ffe01e33:	5b aa                         	movu.b	r10, r10
    volatile uint8_t * const picmr2_reg = RIIC_ICMR2_ADR(p_riic_info->ch_no);
ffe01e35:	6c 56                         	shll	#5, r6
    uctmp = *picser_reg; /* Reads ICSER. */
ffe01e37:	86 8d                         	mov.b	r5, 27[r0]

ffe01e39 <.LBB697>:
    riic_bps_calc(p_riic_info, g_riic_bps[p_riic_info->ch_no]); /* Set BPS */
ffe01e39:	88 fd                         	mov.b	3[r7], r5

ffe01e3b <.LBB699>:
 *              : RIIC_ERR_OTHER                 ; Other error
 **********************************************************************************************************************/
static riic_return_t riic_bps_calc (riic_info_t * p_riic_info, uint16_t kbps)
{
    volatile uint8_t uctmp;
    volatile uint8_t * const picmr1_reg = RIIC_ICMR1_ADR(p_riic_info->ch_no);
ffe01e3b:	cd 7c 03                      	mov.b	3[r7], r12

ffe01e3e <.LBE697>:
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe01e3e:	6c 5b                         	shll	#5, r11
    volatile uint8_t * const picfer_reg = RIIC_ICFER_ADR(p_riic_info->ch_no);
ffe01e40:	6c 5a                         	shll	#5, r10

ffe01e42 <.LBB716>:
    riic_bps_calc(p_riic_info, g_riic_bps[p_riic_info->ch_no]); /* Set BPS */
ffe01e42:	5b 55                         	movu.b	r5, r5

ffe01e44 <.LBB706>:
    volatile uint8_t * const picbrl_reg = RIIC_ICBRL_ADR(p_riic_info->ch_no);
ffe01e44:	cd 78 03                      	mov.b	3[r7], r8

ffe01e47 <.LBE706>:
    volatile uint8_t * const picmr2_reg = RIIC_ICMR2_ADR(p_riic_info->ch_no);
ffe01e47:	73 66 03 83 08                	add	#0x88303, r6, r6

ffe01e4c <.LBB707>:

    const uint8_t d_cks[RIIC_MAX_DIV] =
    { 1, 2, 4, 8, 16, 32, 64, 128 }; /* divider array of RIIC clock  */
    double pclk_val;

    volatile double bps = (double) (kbps * 1000);
ffe01e4c:	fb 42 30 62 e0 ff             	mov.l	#0xffe06230, r4

ffe01e52 <.LVL226>:
ffe01e52:	fe d5 4d                      	movu.w	[r5, r4], r13
    volatile uint8_t * const picbrh_reg = RIIC_ICBRH_ADR(p_riic_info->ch_no);
ffe01e55:	cd 79 03                      	mov.b	3[r7], r9

ffe01e58 <.LBE707>:
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe01e58:	73 bb 04 83 08                	add	#0x88304, r11, r11

ffe01e5d <.LBB708>:
    volatile double bps = (double) (kbps * 1000);
ffe01e5d:	fb 5a e8 03                   	mov.l	#0x3e8, r5
ffe01e61:	4f d5                         	mul	r13, r5

ffe01e63 <.LBE708>:
    volatile uint8_t * const picfer_reg = RIIC_ICFER_ADR(p_riic_info->ch_no);
ffe01e63:	73 aa 05 83 08                	add	#0x88305, r10, r10

ffe01e68 <.LBB709>:
    const uint8_t d_cks[RIIC_MAX_DIV] =
ffe01e68:	f8 02 01 02 04 08             	mov.l	#0x8040201, [r0]
    volatile double bps = (double) (kbps * 1000);
ffe01e6e:	fc 47 55                      	itof	r5, r5
    const uint8_t d_cks[RIIC_MAX_DIV] =
ffe01e71:	f9 02 01 10 20 40 80          	mov.l	#0x80402010, 4[r0]
    volatile double bps = (double) (kbps * 1000);
ffe01e78:	a1 0d                         	mov.l	r5, 20[r0]

    double scl_up_time;
    double scl_down_time;
    volatile uint8_t cnt;

    pclk_val = riic_mcu_check_freq(); /* Store pclk frequency */
ffe01e7a:	05 1c f3 ff                   	bsr.a	ffe01196 <_Reset_Vector+0xffe0119a>

ffe01e7e <.LVL230>:

    /* Set Rise up time and down time */
    if (kbps > RIIC_FAST_SPPED_MAX)
ffe01e7e:	76 0d 90 01                   	cmp	#400, r13
ffe01e82:	24 51                         	bgtu.b	ffe01ed3 <_Reset_Vector+0xffe01ed7>
    {
        /* When bps more than 400Kbps[Fast mode plus] */
        scl_up_time = scl1m_up_time;
        scl_down_time = scl1m_down_time;
    }
    else if (kbps > RIIC_STAD_SPPED_MAX)
ffe01e84:	75 5d 64                      	cmp	#100, r13
ffe01e87:	24 05                         	bgtu.b	ffe01e8c <_Reset_Vector+0xffe01e90>
ffe01e89:	38 2f 01                      	bra.w	ffe01fb8 <_Reset_Vector+0xffe01fbc>

ffe01e8c <.LVL231>:
    }

    /* Calculation for ICBRH and ICBRL registers value */

    /* Calculation L width time */
    L_time = (1 / (2 * bps)); /* Harf period of frequency */
ffe01e8c:	a9 0c                         	mov.l	20[r0], r4
ffe01e8e:	fb 52 00 00 80 3f             	mov.l	#0x3f800000, r5
ffe01e94:	fc 8b 44                      	fadd	r4, r4
ffe01e97:	ef 53                         	mov.l	r5, r3
ffe01e99:	fc 93 43                      	fdiv	r4, r3
ffe01e9c:	a1 03                         	mov.l	r3, 16[r0]
    H_time = L_time;
ffe01e9e:	a9 04                         	mov.l	16[r0], r4
ffe01ea0:	a0 8c                         	mov.l	r4, 12[r0]
    }
    else if (kbps > RIIC_STAD_SPPED_MAX)
    {
        /* 100kbps over */
        /* Check L width */
        if (L_time < 1.3E-6)
ffe01ea2:	a9 04                         	mov.l	16[r0], r4
ffe01ea4:	fd 72 14 a9 7b ae 35          	fcmp	#0x35ae7ba9, r4
ffe01eab:	27 05                         	bn.b	ffe01eb0 <_Reset_Vector+0xffe01eb4>
ffe01ead:	38 cd 01                      	bra.w	ffe0207a <_Reset_Vector+0xffe0207e>
        {
            /* Wnen L width less than 1.3us */
            /* Subtract Rise up and down time for SCL from H/L width */
            L_time = 1.3E-6;
ffe01eb0:	f9 02 04 a9 7b ae 35          	mov.l	#0x35ae7ba9, 16[r0]
            bps_tmp = bps;
ffe01eb7:	a9 0b                         	mov.l	20[r0], r3

ffe01eb9 <.LVL232>:
            H_time = (((1 / bps_tmp) - L_time) - scl_up_time) - scl_down_time;
ffe01eb9:	a9 04                         	mov.l	16[r0], r4
ffe01ebb:	fc 93 35                      	fdiv	r3, r5
ffe01ebe:	fc 83 45                      	fsub	r4, r5
ffe01ec1:	fd 72 05 b0 0f a1 34          	fsub	#0x34a10fb0, r5
ffe01ec8:	fd 72 05 b0 0f a1 34          	fsub	#0x34a10fb0, r5
ffe01ecf:	a0 8d                         	mov.l	r5, 12[r0]
ffe01ed1:	2e 3f                         	bra.b	ffe01f10 <_Reset_Vector+0xffe01f14>

ffe01ed3 <.LVL233>:
    L_time = (1 / (2 * bps)); /* Harf period of frequency */
ffe01ed3:	a9 0c                         	mov.l	20[r0], r4
ffe01ed5:	fb 52 00 00 80 3f             	mov.l	#0x3f800000, r5
ffe01edb:	fc 8b 44                      	fadd	r4, r4
ffe01ede:	ef 53                         	mov.l	r5, r3
ffe01ee0:	fc 93 43                      	fdiv	r4, r3
ffe01ee3:	a1 03                         	mov.l	r3, 16[r0]
    H_time = L_time;
ffe01ee5:	a9 04                         	mov.l	16[r0], r4
ffe01ee7:	a0 8c                         	mov.l	r4, 12[r0]
        if (L_time < 0.5E-6)
ffe01ee9:	a9 04                         	mov.l	16[r0], r4
ffe01eeb:	fd 72 14 bd 37 06 35          	fcmp	#0x350637bd, r4
ffe01ef2:	26 05                         	bpz.b	ffe01ef7 <_Reset_Vector+0xffe01efb>
ffe01ef4:	38 a0 00                      	bra.w	ffe01f94 <_Reset_Vector+0xffe01f98>
            L_time -= scl_down_time;
ffe01ef7:	a9 05                         	mov.l	16[r0], r5
ffe01ef9:	fd 72 05 59 d9 00 34          	fsub	#0x3400d959, r5
ffe01f00:	a1 05                         	mov.l	r5, 16[r0]
            H_time -= scl_up_time;
ffe01f02:	a8 8d                         	mov.l	12[r0], r5
ffe01f04:	fd 72 05 59 d9 00 34          	fsub	#0x3400d959, r5
ffe01f0b:	a0 8d                         	mov.l	r5, 12[r0]

ffe01f0d <.LVL234>:
ffe01f0d:	fc 13 00                      	nop	; max	r0, r0
    }

    /*************** Calculation ICBRL value ***********************/
    /* Calculating until calc_val is less than 32 */
    /* WAIT_LOOP */
    for (calc_val = 0xFF, cnt = 0; RIIC_ICBR_MAX < calc_val; cnt++)
ffe01f10:	fb 42 00 00 00 42             	mov.l	#0x42000000, r4
ffe01f16:	f9 02 02 00 00 7f 43          	mov.l	#0x437f0000, 8[r0]
ffe01f1d:	3c 88 00                      	mov.b	#0, 24[r0]
ffe01f20:	fc 85 04 02                   	fcmp	8[r0].l, r4
ffe01f24:	27 31                         	bn.b	ffe01f55 <_Reset_Vector+0xffe01f59>
ffe01f26:	38 bf 00                      	bra.w	ffe01fe5 <_Reset_Vector+0xffe01fe9>
        {
            /* Cannot set bps */
            return RIIC_ERR_OTHER;
        }

        calc_val_tmp = calc_val;
ffe01f29:	a8 83                         	mov.l	8[r0], r3

ffe01f2b <.LVL235>:
        calc_val = (calc_val_tmp / (d_cks[cnt] / pclk_val));/* Calculattion ICBRL value */
ffe01f2b:	b6 05                         	movu.b	24[r0], r5
ffe01f2d:	fe c5 05                      	movu.b	[r5, r0], r5
ffe01f30:	fc 47 55                      	itof	r5, r5
ffe01f33:	fc 93 15                      	fdiv	r1, r5
ffe01f36:	fc 93 53                      	fdiv	r5, r3

ffe01f39 <.LVL236>:
ffe01f39:	a0 83                         	mov.l	r3, 8[r0]
        calc_val = calc_val + 0.5; /* round off */
ffe01f3b:	a8 85                         	mov.l	8[r0], r5
ffe01f3d:	fd 72 25 00 00 00 3f          	fadd	#0x3f000000, r5
ffe01f44:	a0 85                         	mov.l	r5, 8[r0]
    for (calc_val = 0xFF, cnt = 0; RIIC_ICBR_MAX < calc_val; cnt++)
ffe01f46:	8e 05                         	mov.b	24[r0], r5
ffe01f48:	62 15                         	add	#1, r5
ffe01f4a:	86 05                         	mov.b	r5, 24[r0]
ffe01f4c:	fc 85 04 02                   	fcmp	8[r0].l, r4
ffe01f50:	27 05                         	bn.b	ffe01f55 <_Reset_Vector+0xffe01f59>
ffe01f52:	38 93 00                      	bra.w	ffe01fe5 <_Reset_Vector+0xffe01fe9>
        calc_val = L_time; /* Set L width time */
ffe01f55:	a9 05                         	mov.l	16[r0], r5
ffe01f57:	a0 85                         	mov.l	r5, 8[r0]
        if (cnt >= RIIC_MAX_DIV)
ffe01f59:	b6 05                         	movu.b	24[r0], r5
ffe01f5b:	61 75                         	cmp	#7, r5
ffe01f5d:	25 cc                         	bleu.b	ffe01f29 <_Reset_Vector+0xffe01f2d>

ffe01f5f <.LVL237>:
ffe01f5f:	03                            	nop

ffe01f60 <.LBE709>:
    *picmr2_reg = g_riic_icmr2_init[p_riic_info->ch_no];
ffe01f60:	b0 fd                         	movu.b	3[r7], r5
ffe01f62:	fb 42 0e 62 e0 ff             	mov.l	#0xffe0620e, r4
ffe01f68:	fe 45 45                      	mov.b	[r5, r4], r5
ffe01f6b:	c3 65                         	mov.b	r5, [r6]
    *picmr3_reg = g_riic_icmr3_init[p_riic_info->ch_no];
ffe01f6d:	b0 fd                         	movu.b	3[r7], r5
ffe01f6f:	fb 42 0b 62 e0 ff             	mov.l	#0xffe0620b, r4
ffe01f75:	fe 45 45                      	mov.b	[r5, r4], r5
ffe01f78:	c3 b5                         	mov.b	r5, [r11]
    riic_mcu_int_disable(p_riic_info->ch_no);
ffe01f7a:	88 f9                         	mov.b	3[r7], r1
ffe01f7c:	05 8c f1 ff                   	bsr.a	ffe01108 <_Reset_Vector+0xffe0110c>

ffe01f80 <.LVL238>:
    *picfer_reg = g_riic_icfer_init[p_riic_info->ch_no];
ffe01f80:	b0 ff                         	movu.b	3[r7], r7

ffe01f82 <.LVL239>:
ffe01f82:	fb 52 08 62 e0 ff             	mov.l	#0xffe06208, r5
ffe01f88:	fe 47 57                      	mov.b	[r7, r5], r7
ffe01f8b:	c3 a7                         	mov.b	r7, [r10]
    uctmp = *picfer_reg; /* Reads ICFER. */
ffe01f8d:	cc a7                         	mov.b	[r10], r7
ffe01f8f:	86 8f                         	mov.b	r7, 27[r0]
} /* End of function riic_init_io_register() */
ffe01f91:	3f 6d 0f                      	rtsd	#60, r6-r13

ffe01f94 <.LBB710>:
            L_time = 0.5E-6;
ffe01f94:	f9 02 04 bd 37 06 35          	mov.l	#0x350637bd, 16[r0]
            bps_tmp = bps;
ffe01f9b:	a9 0b                         	mov.l	20[r0], r3

ffe01f9d <.LVL241>:
            H_time = (((1 / bps_tmp) - L_time) - scl_up_time) - scl_down_time;
ffe01f9d:	a9 04                         	mov.l	16[r0], r4
ffe01f9f:	fc 93 35                      	fdiv	r3, r5
ffe01fa2:	fc 83 45                      	fsub	r4, r5
ffe01fa5:	fd 72 05 59 d9 00 34          	fsub	#0x3400d959, r5
ffe01fac:	fd 72 05 59 d9 00 34          	fsub	#0x3400d959, r5
ffe01fb3:	a0 8d                         	mov.l	r5, 12[r0]
ffe01fb5:	38 5b ff                      	bra.w	ffe01f10 <_Reset_Vector+0xffe01f14>

ffe01fb8 <.LVL242>:
    L_time = (1 / (2 * bps)); /* Harf period of frequency */
ffe01fb8:	a9 0d                         	mov.l	20[r0], r5
ffe01fba:	fc 8b 55                      	fadd	r5, r5
ffe01fbd:	fb 42 00 00 80 3f             	mov.l	#0x3f800000, r4
ffe01fc3:	fc 93 54                      	fdiv	r5, r4
ffe01fc6:	a1 04                         	mov.l	r4, 16[r0]
    H_time = L_time;
ffe01fc8:	a9 05                         	mov.l	16[r0], r5
ffe01fca:	a0 8d                         	mov.l	r5, 12[r0]
        L_time -= scl_down_time;
ffe01fcc:	a9 05                         	mov.l	16[r0], r5
ffe01fce:	fd 72 05 b0 0f a1 34          	fsub	#0x34a10fb0, r5
ffe01fd5:	a1 05                         	mov.l	r5, 16[r0]
        H_time -= scl_up_time;
ffe01fd7:	a8 8d                         	mov.l	12[r0], r5
ffe01fd9:	fd 72 05 bd 37 86 35          	fsub	#0x358637bd, r5
ffe01fe0:	a0 8d                         	mov.l	r5, 12[r0]
ffe01fe2:	38 2e ff                      	bra.w	ffe01f10 <_Reset_Vector+0xffe01f14>

ffe01fe5 <.LVL243>:
    volatile uint8_t * const picmr1_reg = RIIC_ICMR1_ADR(p_riic_info->ch_no);
ffe01fe5:	5b cc                         	movu.b	r12, r12
    volatile uint8_t * const picbrl_reg = RIIC_ICBRL_ADR(p_riic_info->ch_no);
ffe01fe7:	5b 88                         	movu.b	r8, r8
    volatile uint8_t * const picmr1_reg = RIIC_ICMR1_ADR(p_riic_info->ch_no);
ffe01fe9:	6c 5c                         	shll	#5, r12

ffe01feb <.LVL244>:
    volatile uint8_t * const picbrl_reg = RIIC_ICBRL_ADR(p_riic_info->ch_no);
ffe01feb:	6c 58                         	shll	#5, r8

ffe01fed <.LVL245>:
    volatile uint8_t * const picmr1_reg = RIIC_ICMR1_ADR(p_riic_info->ch_no);
ffe01fed:	73 cc 02 83 08                	add	#0x88302, r12, r12
    volatile uint8_t * const picbrl_reg = RIIC_ICBRL_ADR(p_riic_info->ch_no);
ffe01ff2:	73 88 10 83 08                	add	#0x88310, r8, r8
    }

     /* store ICMR1 value to avoid CKS bit. */
    uctmp = (uint8_t) ((uint8_t) (*picmr1_reg) & (((~BIT4) & (~BIT5)) & (~BIT6)));
ffe01ff7:	cc c5                         	mov.b	[r12], r5
    *picbrl_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRL register */

    /*************** Calculation ICBRH value ***********************/
    calc_val = H_time; /* Set H width */
    calc_val_tmp = calc_val;
    calc_val = (calc_val_tmp / (d_cks[cnt - 1] / pclk_val)); /* Calculattion ICBRH value */
ffe01ff9:	71 04 ff                      	add	#-1, r0, r4
    uctmp = (uint8_t) ((uint8_t) (*picmr1_reg) & (((~BIT4) & (~BIT5)) & (~BIT6)));
ffe01ffc:	75 25 8f                      	and	#-113, r5
ffe01fff:	86 0d                         	mov.b	r5, 25[r0]
    uctmp_tmp = uctmp;
ffe02001:	8e 0b                         	mov.b	25[r0], r3

ffe02003 <.LVL246>:
    *picmr1_reg = (uint8_t) ((uctmp_tmp) | ((cnt - 1) << 4)); /* Set ICMR1.CKS bits.*/
ffe02003:	b6 05                         	movu.b	24[r0], r5
ffe02005:	60 15                         	sub	#1, r5
ffe02007:	6c 45                         	shll	#4, r5
ffe02009:	57 35                         	or	r3, r5
ffe0200b:	c3 c5                         	mov.b	r5, [r12]
    *picbrl_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRL register */
ffe0200d:	a8 85                         	mov.l	8[r0], r5
ffe0200f:	fd 72 05 00 00 80 3f          	fsub	#0x3f800000, r5
ffe02016:	fc a7 55                      	ftou	r5, r5
ffe02019:	75 35 e0                      	or	#-32, r5
ffe0201c:	c3 85                         	mov.b	r5, [r8]
    calc_val = H_time; /* Set H width */
ffe0201e:	a8 8d                         	mov.l	12[r0], r5
ffe02020:	a0 85                         	mov.l	r5, 8[r0]
    calc_val_tmp = calc_val;
ffe02022:	a8 83                         	mov.l	8[r0], r3

ffe02024 <.LVL247>:
    calc_val = (calc_val_tmp / (d_cks[cnt - 1] / pclk_val)); /* Calculattion ICBRH value */
ffe02024:	b6 05                         	movu.b	24[r0], r5
ffe02026:	fe c5 45                      	movu.b	[r5, r4], r5
ffe02029:	fc 47 55                      	itof	r5, r5
ffe0202c:	fc 93 15                      	fdiv	r1, r5
ffe0202f:	fc 93 53                      	fdiv	r5, r3

ffe02032 <.LVL248>:
ffe02032:	a0 83                         	mov.l	r3, 8[r0]
    calc_val = (uint8_t) (calc_val + 0.5); /* round off */
ffe02034:	a8 85                         	mov.l	8[r0], r5
ffe02036:	fd 72 25 00 00 00 3f          	fadd	#0x3f000000, r5
ffe0203d:	fc a7 55                      	ftou	r5, r5
ffe02040:	5b 55                         	movu.b	r5, r5
ffe02042:	fc 57 55                      	utof	r5, r5
ffe02045:	a0 85                         	mov.l	r5, 8[r0]

    /* If the calculated value is less than 1, it rounded up to 1. */
    if (1 > calc_val)
ffe02047:	a8 85                         	mov.l	8[r0], r5
ffe02049:	fd 72 15 00 00 80 3f          	fcmp	#0x3f800000, r5
ffe02050:	26 09                         	bpz.b	ffe02059 <_Reset_Vector+0xffe0205d>
    {
        calc_val = 1;
ffe02052:	f9 02 02 00 00 80 3f          	mov.l	#0x3f800000, 8[r0]
    }

    *picbrh_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRH register */
ffe02059:	a8 85                         	mov.l	8[r0], r5
    volatile uint8_t * const picbrh_reg = RIIC_ICBRH_ADR(p_riic_info->ch_no);
ffe0205b:	5b 99                         	movu.b	r9, r9
ffe0205d:	6c 59                         	shll	#5, r9

ffe0205f <.LVL249>:
ffe0205f:	73 99 11 83 08                	add	#0x88311, r9, r9
    *picbrh_reg = (uint8_t) ((((uint8_t) (calc_val - 1) | BIT7) | BIT6) | BIT5); /* Set value to ICBRH register */
ffe02064:	fd 72 05 00 00 80 3f          	fsub	#0x3f800000, r5
ffe0206b:	fc a7 55                      	ftou	r5, r5
ffe0206e:	75 35 e0                      	or	#-32, r5
ffe02071:	c3 95                         	mov.b	r5, [r9]

    uctmp = *picbrh_reg; /* dummy read */
ffe02073:	cc 95                         	mov.b	[r9], r5
ffe02075:	86 0d                         	mov.b	r5, 25[r0]

    return RIIC_SUCCESS;
ffe02077:	38 e9 fe                      	bra.w	ffe01f60 <_Reset_Vector+0xffe01f64>

ffe0207a <.LVL250>:
            L_time -= scl_down_time;
ffe0207a:	a9 05                         	mov.l	16[r0], r5
ffe0207c:	fd 72 05 b0 0f a1 34          	fsub	#0x34a10fb0, r5
ffe02083:	a1 05                         	mov.l	r5, 16[r0]
            H_time -= scl_up_time;
ffe02085:	a8 8d                         	mov.l	12[r0], r5
ffe02087:	fd 72 05 b0 0f a1 34          	fsub	#0x34a10fb0, r5
ffe0208e:	a0 8d                         	mov.l	r5, 12[r0]
ffe02090:	38 80 fe                      	bra.w	ffe01f10 <_Reset_Vector+0xffe01f14>

ffe02093 <.LBE710>:
ffe02093:	77 10 01 00 00                	nop	; mul	#1, r0

ffe02098 <_riic_clear_ir_flag>:
{
ffe02098:	6e 6a                         	pushm	r6-r10
ffe0209a:	60 40                         	sub	#4, r0

ffe0209c <.LVL252>:
ffe0209c:	ef 16                         	mov.l	r1, r6
    volatile uint8_t uctmp = 0x00;
ffe0209e:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe020a1:	cd 1a 03                      	mov.b	3[r1], r10

ffe020a4 <.LVL253>:
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffe020a4:	88 9f                         	mov.b	3[r1], r7

ffe020a6 <.LVL254>:
    if ((RIIC_IR_SET == riic_mcu_check_ir_txi(p_riic_info->ch_no))
ffe020a6:	88 99                         	mov.b	3[r1], r1

ffe020a8 <.LVL255>:
ffe020a8:	05 58 ef ff                   	bsr.a	ffe01000 <_Reset_Vector+0xffe01004>

ffe020ac <.LVL256>:
ffe020ac:	61 11                         	cmp	#1, r1
ffe020ae:	21 5c                         	bne.b	ffe0210a <_Reset_Vector+0xffe0210e>
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe020b0:	5b a5                         	movu.b	r10, r5
ffe020b2:	6c 55                         	shll	#5, r5
ffe020b4:	73 55 00 83 08                	add	#0x88300, r5, r5
        if (RIIC_ICCR1_ICE_SET == ((*piccr1_reg) & RIIC_ICCR1_ICE)) /* ICCR1.ICE = 1 */
ffe020b9:	cc 54                         	mov.b	[r5], r4
ffe020bb:	7c 74                         	btst	#7, r4
ffe020bd:	21 2e                         	bne.b	ffe020eb <_Reset_Vector+0xffe020ef>
    uint8_t internal_flag = 0x00; /* Determines whether reinitialization is necessary. */
ffe020bf:	66 0a                         	mov.l	#0, r10

ffe020c1 <.LVL257>:
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffe020c1:	5b 74                         	movu.b	r7, r4
ffe020c3:	6c 54                         	shll	#5, r4
ffe020c5:	73 44 07 83 08                	add	#0x88307, r4, r4

ffe020ca <.LVL258>:
        *picier_reg = RIIC_ICIER_INIT;
ffe020ca:	f8 44 00                      	mov.b	#0, [r4]
        while (RIIC_ICIER_INIT != (*picier_reg))
ffe020cd:	fc 13 00                      	nop	; max	r0, r0
ffe020d0:	58 45                         	movu.b	[r4], r5
ffe020d2:	61 05                         	cmp	#0, r5
ffe020d4:	21 fc                         	bne.b	ffe020d0 <_Reset_Vector+0xffe020d4>
        riic_mcu_clear_ir_rxi(p_riic_info->ch_no); /* Clears RXI interrupt request register. */
ffe020d6:	88 e9                         	mov.b	3[r6], r1
ffe020d8:	05 69 ef ff                   	bsr.a	ffe01041 <_Reset_Vector+0xffe01045>

ffe020dc <.LVL259>:
        riic_mcu_clear_ir_txi(p_riic_info->ch_no); /* Clears TXI interrupt request register. */
ffe020dc:	88 e9                         	mov.b	3[r6], r1
ffe020de:	05 50 ef ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe020e2 <.LVL260>:
        if (0x01 == internal_flag)
ffe020e2:	5b a7                         	movu.b	r10, r7

ffe020e4 <.LVL261>:
ffe020e4:	61 17                         	cmp	#1, r7
ffe020e6:	20 31                         	beq.b	ffe02117 <_Reset_Vector+0xffe0211b>
} /* End of function riic_clear_ir_flag() */
ffe020e8:	3f 6a 06                      	rtsd	#24, r6-r10

ffe020eb <.LVL262>:
            (*piccr1_reg) |= RIIC_ICCR1_RIIC_RESET;
ffe020eb:	f0 56                         	bset	#6, [r5].b
            while (RIIC_ICCR1_RIIC_RESET != ((*piccr1_reg) & RIIC_ICCR1_RIIC_RESET))
ffe020ed:	fc 13 00                      	nop	; max	r0, r0
ffe020f0:	cc 54                         	mov.b	[r5], r4
ffe020f2:	7c 64                         	btst	#6, r4
ffe020f4:	20 fc                         	beq.b	ffe020f0 <_Reset_Vector+0xffe020f4>
            (*piccr1_reg) &= RIIC_ICCR1_ICE_CLR;
ffe020f6:	cc 54                         	mov.b	[r5], r4
ffe020f8:	75 24 7f                      	and	#127, r4
ffe020fb:	c3 54                         	mov.b	r4, [r5]
            while (RIIC_ICCR1_NOT_DRIVEN != ((*piccr1_reg) & RIIC_ICCR1_ICE))
ffe020fd:	fc 13 00                      	nop	; max	r0, r0
ffe02100:	cc 54                         	mov.b	[r5], r4
ffe02102:	7c 74                         	btst	#7, r4
ffe02104:	21 fc                         	bne.b	ffe02100 <_Reset_Vector+0xffe02104>
            internal_flag = 0x01;
ffe02106:	66 1a                         	mov.l	#1, r10

ffe02108 <.LVL263>:
ffe02108:	2e b9                         	bra.b	ffe020c1 <_Reset_Vector+0xffe020c5>

ffe0210a <.LVL264>:
            || (RIIC_IR_SET == riic_mcu_check_ir_rxi(p_riic_info->ch_no)))
ffe0210a:	88 e9                         	mov.b	3[r6], r1
ffe0210c:	05 0b ef ff                   	bsr.a	ffe01017 <_Reset_Vector+0xffe0101b>

ffe02110 <.LVL265>:
ffe02110:	61 11                         	cmp	#1, r1
ffe02112:	20 9e                         	beq.b	ffe020b0 <_Reset_Vector+0xffe020b4>
} /* End of function riic_clear_ir_flag() */
ffe02114:	3f 6a 06                      	rtsd	#24, r6-r10

ffe02117 <.LVL266>:
            riic_init_io_register(p_riic_info);
ffe02117:	ef 61                         	mov.l	r6, r1
} /* End of function riic_clear_ir_flag() */
ffe02119:	62 40                         	add	#4, r0
ffe0211b:	6f 6a                         	popm	r6-r10

ffe0211d <.LVL267>:
            riic_init_io_register(p_riic_info);
ffe0211d:	04 6b fc ff                   	bra.a	ffe01d88 <_Reset_Vector+0xffe01d8c>

ffe02121 <.LFE60>:
ffe02121:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe02128 <_riic_after_dtct_stop_cond>:
{
ffe02128:	60 40                         	sub	#4, r0

ffe0212a <.LVL270>:
ffe0212a:	ef 13                         	mov.l	r1, r3
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe0212c:	88 9a                         	mov.b	3[r1], r2

ffe0212e <.LBB724>:
    volatile uint32_t cnt = 0x00000000;
ffe0212e:	f8 06 00                      	mov.l	#0, [r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe02131:	88 9c                         	mov.b	3[r1], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02133:	88 9d                         	mov.b	3[r1], r5
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe02135:	5b 44                         	movu.b	r4, r4
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffe02137:	f8 0a e8 03                   	mov.l	#0x3e8, [r0]
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0213b:	5b 55                         	movu.b	r5, r5
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffe0213d:	ec 01                         	mov.l	[r0], r1

ffe0213f <.LVL272>:
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe0213f:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02141:	6c 55                         	shll	#5, r5
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe02143:	73 44 00 83 08                	add	#0x88300, r4, r4

ffe02148 <.LVL273>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02148:	73 55 01 83 08                	add	#0x88301, r5, r5

ffe0214d <.LVL274>:
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffe0214d:	61 01                         	cmp	#0, r1
ffe0214f:	20 1b                         	beq.b	ffe0216a <_Reset_Vector+0xffe0216e>
        if ((RIIC_MSK_BBSY != ((*piccr2_reg) & RIIC_MSK_BBSY)) && /* ICCR2.BBSY = 0 */
ffe02151:	cc 51                         	mov.b	[r5], r1
ffe02153:	7c 71                         	btst	#7, r1
ffe02155:	19                            	bne.s	ffe0215e <_Reset_Vector+0xffe02162>
        (RIIC_MSK_SCLSDA == ((*piccr1_reg) & RIIC_MSK_SCLSDA))) /* ICCR1.SCLI = 1, ICCR1.SDAI = 1 */
ffe02156:	cc 41                         	mov.b	[r4], r1
        if ((RIIC_MSK_BBSY != ((*piccr2_reg) & RIIC_MSK_BBSY)) && /* ICCR2.BBSY = 0 */
ffe02158:	64 31                         	and	#3, r1
ffe0215a:	61 31                         	cmp	#3, r1
ffe0215c:	20 43                         	beq.b	ffe0219f <_Reset_Vector+0xffe021a3>
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffe0215e:	ec 01                         	mov.l	[r0], r1
ffe02160:	60 11                         	sub	#1, r1
ffe02162:	e3 01                         	mov.l	r1, [r0]
ffe02164:	ec 01                         	mov.l	[r0], r1
ffe02166:	61 01                         	cmp	#0, r1
ffe02168:	21 e9                         	bne.b	ffe02151 <_Reset_Vector+0xffe02155>
        ret = RIIC_ERR_BUS_BUSY;
ffe0216a:	66 51                         	mov.l	#5, r1

ffe0216c <.LVL275>:
    if ((RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe0216c:	b0 bd                         	movu.b	3[r3], r5
ffe0216e:	6c 45                         	shll	#4, r5
ffe02170:	70 55 24 00 00 00             	add	#36, r5, r5
ffe02176:	ec 55                         	mov.l	[r5], r5
ffe02178:	61 55                         	cmp	#5, r5
ffe0217a:	20 13                         	beq.b	ffe0218d <_Reset_Vector+0xffe02191>
            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe0217c:	b0 bd                         	movu.b	3[r3], r5
ffe0217e:	6c 45                         	shll	#4, r5
ffe02180:	70 55 24 00 00 00             	add	#36, r5, r5
ffe02186:	ec 55                         	mov.l	[r5], r5
ffe02188:	61 65                         	cmp	#6, r5
ffe0218a:	13                            	beq.s	ffe0218d <_Reset_Vector+0xffe02191>
} /* End of function riic_after_dtct_stop_cond() */
ffe0218b:	67 01                         	rtsd	#4
    volatile uint8_t * const picser_reg = RIIC_ICSER_ADR(p_riic_info->ch_no);
ffe0218d:	5b 22                         	movu.b	r2, r2
ffe0218f:	6c 52                         	shll	#5, r2

ffe02191 <.LVL276>:
ffe02191:	73 22 06 83 08                	add	#0x88306, r2, r2
        (*picser_reg) &= RIIC_ICSER_SAR_DASABLE;
ffe02196:	cc 25                         	mov.b	[r2], r5
ffe02198:	75 25 f8                      	and	#-8, r5
ffe0219b:	c3 25                         	mov.b	r5, [r2]
} /* End of function riic_after_dtct_stop_cond() */
ffe0219d:	67 01                         	rtsd	#4

ffe0219f <.LVL277>:
        if (RIIC_TMO == g_riic_ChStatus[p_riic_info->ch_no])
ffe0219f:	88 bc                         	mov.b	3[r3], r4
        if (RIIC_AL == g_riic_ChStatus[p_riic_info->ch_no])
ffe021a1:	88 bd                         	mov.b	3[r3], r5
        if (RIIC_TMO == g_riic_ChStatus[p_riic_info->ch_no])
ffe021a3:	fb e2 0c 02 00 00             	mov.l	#524, r14
ffe021a9:	5b 44                         	movu.b	r4, r4
        if (RIIC_AL == g_riic_ChStatus[p_riic_info->ch_no])
ffe021ab:	5b 55                         	movu.b	r5, r5
        if (RIIC_TMO == g_riic_ChStatus[p_riic_info->ch_no])
ffe021ad:	fe c4 e1                      	movu.b	[r4, r14], r1
        if (RIIC_AL == g_riic_ChStatus[p_riic_info->ch_no])
ffe021b0:	fe c5 e5                      	movu.b	[r5, r14], r5
    riic_return_t ret = RIIC_SUCCESS;
ffe021b3:	61 61                         	cmp	#6, r1
ffe021b5:	66 01                         	mov.l	#0, r1
ffe021b7:	fd 74 e1 07                   	stz	#7, r1

ffe021bb <.LVL278>:
            ret = RIIC_ERR_AL;
ffe021bb:	61 55                         	cmp	#5, r5
ffe021bd:	fd 74 e1 06                   	stz	#6, r1

ffe021c1 <.LVL279>:
ffe021c1:	2e ab                         	bra.b	ffe0216c <_Reset_Vector+0xffe02170>

ffe021c3 <.LFE29>:
ffe021c3:	77 10 01 00 00                	nop	; mul	#1, r0

ffe021c8 <_riic_init_driver>:
{
ffe021c8:	7e a7                         	push.l	r7
ffe021ca:	60 40                         	sub	#4, r0
ffe021cc:	ef 17                         	mov.l	r1, r7

ffe021ce <.LBB734>:
    riic_init_io_register(p_riic_info);
ffe021ce:	05 ba fb ff                   	bsr.a	ffe01d88 <_Reset_Vector+0xffe01d8c>

ffe021d2 <.LVL282>:
    riic_clear_ir_flag(p_riic_info);
ffe021d2:	ef 71                         	mov.l	r7, r1
ffe021d4:	05 c4 fe ff                   	bsr.a	ffe02098 <_Reset_Vector+0xffe0209c>

ffe021d8 <.LBB736>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe021d8:	88 fd                         	mov.b	3[r7], r5

ffe021da <.LBB739>:
    riic_clear_ir_flag(p_riic_info);
ffe021da:	ef 71                         	mov.l	r7, r1

ffe021dc <.LBB742>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe021dc:	5b 55                         	movu.b	r5, r5
ffe021de:	6c 45                         	shll	#4, r5

ffe021e0 <.LVL285>:
ffe021e0:	70 55 24 00 00 00             	add	#36, r5, r5
ffe021e6:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe021ea:	3e 52 01                      	mov.l	#1, 8[r5]

ffe021ed <.LBB743>:
    riic_clear_ir_flag(p_riic_info);
ffe021ed:	05 ab fe ff                   	bsr.a	ffe02098 <_Reset_Vector+0xffe0209c>

ffe021f1 <.LVL287>:
    riic_mcu_int_enable(p_riic_info->ch_no);
ffe021f1:	88 f9                         	mov.b	3[r7], r1
ffe021f3:	05 7d ee ff                   	bsr.a	ffe01070 <_Reset_Vector+0xffe01074>

ffe021f7 <.LBB744>:
} /* End of function riic_init_driver() */
ffe021f7:	66 01                         	mov.l	#0, r1

ffe021f9 <.LBB747>:
    volatile uint8_t uctmp = 0x00;
ffe021f9:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe021fc:	b0 fd                         	movu.b	3[r7], r5
ffe021fe:	6c 55                         	shll	#5, r5
ffe02200:	73 55 00 83 08                	add	#0x88300, r5, r5

ffe02205 <.LVL289>:
    (*piccr1_reg) &= RIIC_ICCR1_ENABLE; /* Clears ICCR1.IICRST bit. */
ffe02205:	f0 5e                         	bclr	#6, [r5].b
    uctmp = *piccr1_reg; /* Reads ICCR1. */
ffe02207:	cc 57                         	mov.b	[r5], r7

ffe02209 <.LVL290>:
ffe02209:	c3 07                         	mov.b	r7, [r0]

ffe0220b <.LBE747>:
} /* End of function riic_init_driver() */
ffe0220b:	3f 77 02                      	rtsd	#8, r7-r7

ffe0220e <.LFE22>:
	...

ffe02210 <_riic_generate_start_cond>:
{
ffe02210:	7e a7                         	push.l	r7
ffe02212:	60 80                         	sub	#8, r0
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffe02214:	88 9a                         	mov.b	3[r1], r2

ffe02216 <.LVL293>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02216:	88 9d                         	mov.b	3[r1], r5

ffe02218 <.LBB764>:
    volatile uint32_t cnt = 0x00000000;
ffe02218:	f8 06 00                      	mov.l	#0, [r0]
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe0221b:	cd 1e 03                      	mov.b	3[r1], r14
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0221e:	88 9b                         	mov.b	3[r1], r3
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe02220:	5b ee                         	movu.b	r14, r14
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffe02222:	f8 0a e8 03                   	mov.l	#0x3e8, [r0]
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02226:	5b 33                         	movu.b	r3, r3
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffe02228:	ec 07                         	mov.l	[r0], r7
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe0222a:	6c 5e                         	shll	#5, r14
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0222c:	6c 53                         	shll	#5, r3
    volatile uint8_t * const piccr1_reg = RIIC_ICCR1_ADR(p_riic_info->ch_no);
ffe0222e:	73 ee 00 83 08                	add	#0x88300, r14, r14

ffe02233 <.LVL295>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02233:	73 33 01 83 08                	add	#0x88301, r3, r3

ffe02238 <.LVL296>:
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffe02238:	61 07                         	cmp	#0, r7
ffe0223a:	20 1f                         	beq.b	ffe02259 <_Reset_Vector+0xffe0225d>
ffe0223c:	76 10 01 00                   	nop	; mul	#1, r0
        if ((RIIC_MSK_BBSY != ((*piccr2_reg) & RIIC_MSK_BBSY)) && /* ICCR2.BBSY = 0 */
ffe02240:	cc 34                         	mov.b	[r3], r4
ffe02242:	7c 74                         	btst	#7, r4
ffe02244:	19                            	bne.s	ffe0224d <_Reset_Vector+0xffe02251>
        (RIIC_MSK_SCLSDA == ((*piccr1_reg) & RIIC_MSK_SCLSDA))) /* ICCR1.SCLI = 1, ICCR1.SDAI = 1 */
ffe02245:	cc e4                         	mov.b	[r14], r4
        if ((RIIC_MSK_BBSY != ((*piccr2_reg) & RIIC_MSK_BBSY)) && /* ICCR2.BBSY = 0 */
ffe02247:	64 34                         	and	#3, r4
ffe02249:	61 34                         	cmp	#3, r4
ffe0224b:	20 13                         	beq.b	ffe0225e <_Reset_Vector+0xffe02262>
    for (cnt = RIIC_CFG_BUS_CHECK_COUNTER; cnt > 0x00000000; cnt--)
ffe0224d:	ec 04                         	mov.l	[r0], r4
ffe0224f:	60 14                         	sub	#1, r4
ffe02251:	e3 04                         	mov.l	r4, [r0]
ffe02253:	ec 04                         	mov.l	[r0], r4
ffe02255:	61 04                         	cmp	#0, r4
ffe02257:	21 e9                         	bne.b	ffe02240 <_Reset_Vector+0xffe02244>
        ret = RIIC_ERR_BUS_BUSY; /* Bus busy */
ffe02259:	66 51                         	mov.l	#5, r1

ffe0225b <.LVL297>:
} /* End of function riic_generate_start_cond() */
ffe0225b:	3f 77 03                      	rtsd	#12, r7-r7

ffe0225e <.LVL298>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe0225e:	5b 54                         	movu.b	r5, r4
ffe02260:	6c 54                         	shll	#5, r4
ffe02262:	73 44 09 83 08                	add	#0x88309, r4, r4

ffe02267 <.LVL299>:
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffe02267:	f0 4b                         	bclr	#3, [r4].b

ffe02269 <.LVL300>:
        while (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START) || ((*picsr2_reg) & RIIC_ICSR2_STOP)))
ffe02269:	cc 45                         	mov.b	[r4], r5
ffe0226b:	7c 25                         	btst	#2, r5
ffe0226d:	21 fc                         	bne.b	ffe02269 <_Reset_Vector+0xffe0226d>
ffe0226f:	cc 45                         	mov.b	[r4], r5
ffe02271:	7c 35                         	btst	#3, r5
ffe02273:	21 f6                         	bne.b	ffe02269 <_Reset_Vector+0xffe0226d>
ffe02275:	ef 17                         	mov.l	r1, r7
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffe02277:	5b 24                         	movu.b	r2, r4

ffe02279 <.LBB766>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe02279:	88 9d                         	mov.b	3[r1], r5

ffe0227b <.LBE766>:
    volatile uint8_t * const picier_reg = RIIC_ICIER_ADR(p_riic_info->ch_no);
ffe0227b:	6c 54                         	shll	#5, r4
ffe0227d:	73 44 07 83 08                	add	#0x88307, r4, r4

ffe02282 <.LBB772>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02282:	5b 55                         	movu.b	r5, r5

ffe02284 <.LBE772>:
        (*picier_reg) &= (~RIIC_ICIER_AL);
ffe02284:	f0 49                         	bclr	#1, [r4].b
        uctmp = *picier_reg; /* Reads ICIER. */
ffe02286:	cc 44                         	mov.b	[r4], r4

ffe02288 <.LBB773>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02288:	6c 45                         	shll	#4, r5

ffe0228a <.LVL302>:
ffe0228a:	70 55 24 00 00 00             	add	#36, r5, r5

ffe02290 <.LBE773>:
        uctmp = *picier_reg; /* Reads ICIER. */
ffe02290:	81 0c                         	mov.b	r4, 5[r0]

ffe02292 <.LBB774>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02292:	e5 55 02 03                   	mov.l	8[r5], 12[r5]

ffe02296 <.LBE774>:
        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe02296:	88 9c                         	mov.b	3[r1], r4

ffe02298 <.LBB775>:
    riic_api_info[ch_no].N_status = new_status;
ffe02298:	3e 52 03                      	mov.l	#3, 8[r5]

ffe0229b <.LBE775>:
        if (RIIC_MODE_S_READY == riic_api_info[p_riic_info->ch_no].B_Mode)
ffe0229b:	5b 45                         	movu.b	r4, r5
ffe0229d:	6c 45                         	shll	#4, r5
ffe0229f:	70 55 24 00 00 00             	add	#36, r5, r5
ffe022a5:	a8 5d                         	mov.l	4[r5], r5
ffe022a7:	61 45                         	cmp	#4, r5
ffe022a9:	21 3a                         	bne.b	ffe022e3 <_Reset_Vector+0xffe022e7>
            if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe022ab:	88 9c                         	mov.b	3[r1], r4
ffe022ad:	fb 52 60 00 00 00             	mov.l	#96, r5
ffe022b3:	5b 44                         	movu.b	r4, r4
ffe022b5:	fe 64 54                      	mov.l	[r4, r5], r4
ffe022b8:	a9 4c                         	mov.l	20[r4], r4
ffe022ba:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe022c0:	20 5b                         	beq.b	ffe0231b <_Reset_Vector+0xffe0231f>
                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe022c2:	b0 9c                         	movu.b	3[r1], r4
ffe022c4:	fe 64 54                      	mov.l	[r4, r5], r4
ffe022c7:	a9 44                         	mov.l	16[r4], r4
ffe022c9:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe022cf:	20 4c                         	beq.b	ffe0231b <_Reset_Vector+0xffe0231f>
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_TX_RX);
ffe022d1:	88 9c                         	mov.b	3[r1], r4

ffe022d3 <.LBB776>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe022d3:	fb 26 b6                      	mov.l	#-74, r2

ffe022d6 <.LBE776>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_TX_RX);
ffe022d6:	5b 44                         	movu.b	r4, r4
ffe022d8:	fe 64 55                      	mov.l	[r4, r5], r5

ffe022db <.LBB779>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe022db:	88 d9                         	mov.b	3[r5], r1

ffe022dd <.LVL306>:
ffe022dd:	05 77 ed ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe022e1 <.LVL307>:
ffe022e1:	2e 0f                         	bra.b	ffe022f0 <_Reset_Vector+0xffe022f4>

ffe022e3 <.LBB780>:
ffe022e3:	88 99                         	mov.b	3[r1], r1

ffe022e5 <.LVL309>:
ffe022e5:	75 42 16                      	mov.l	#22, r2

ffe022e8 <.LVL310>:
ffe022e8:	05 6c ed ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe022ec <.LVL311>:
ffe022ec:	76 10 01 00                   	nop	; mul	#1, r0

ffe022f0 <.LBB782>:
    volatile uint8_t uctmp = 0x00;
ffe022f0:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe022f3:	88 fc                         	mov.b	3[r7], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe022f5:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe022f7:	5b 44                         	movu.b	r4, r4
ffe022f9:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe022fb:	5b 55                         	movu.b	r5, r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe022fd:	73 44 09 83 08                	add	#0x88309, r4, r4

ffe02302 <.LVL312>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02302:	6c 55                         	shll	#5, r5
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START_SET) >> 2U))
ffe02304:	cc 43                         	mov.b	[r4], r3
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02306:	73 55 01 83 08                	add	#0x88301, r5, r5

ffe0230b <.LVL313>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START_SET) >> 2U))
ffe0230b:	7c 23                         	btst	#2, r3
ffe0230d:	13                            	beq.s	ffe02310 <_Reset_Vector+0xffe02314>
        (*picsr2_reg) &= RIIC_ICSR2_START_CLR;
ffe0230e:	f0 4a                         	bclr	#2, [r4].b
    (*piccr2_reg) |= RIIC_ICCR2_ST; /* Sets ICCR2.ST bit. */
ffe02310:	f0 51                         	bset	#1, [r5].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe02312:	cc 57                         	mov.b	[r5], r7

ffe02314 <.LBE782>:
        ret = RIIC_SUCCESS;
ffe02314:	66 01                         	mov.l	#0, r1

ffe02316 <.LBB785>:
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe02316:	81 07                         	mov.b	r7, 4[r0]

ffe02318 <.LBE785>:
} /* End of function riic_generate_start_cond() */
ffe02318:	3f 77 03                      	rtsd	#12, r7-r7

ffe0231b <.LVL316>:
            else if (((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe0231b:	b0 fc                         	movu.b	3[r7], r4
ffe0231d:	fe 64 54                      	mov.l	[r4, r5], r4
ffe02320:	a9 4c                         	mov.l	20[r4], r4
ffe02322:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe02328:	20 11                         	beq.b	ffe02339 <_Reset_Vector+0xffe0233d>
                    && ((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe0232a:	b0 fc                         	movu.b	3[r7], r4
ffe0232c:	fe 64 54                      	mov.l	[r4, r5], r4
ffe0232f:	a9 44                         	mov.l	16[r4], r4
ffe02331:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe02337:	20 32                         	beq.b	ffe02369 <_Reset_Vector+0xffe0236d>
            else if (((uint8_t *) FIT_NO_PTR == priic_info_s[p_riic_info->ch_no]->p_data1st)
ffe02339:	b0 fc                         	movu.b	3[r7], r4
ffe0233b:	fe 64 54                      	mov.l	[r4, r5], r4
ffe0233e:	a9 4c                         	mov.l	20[r4], r4
ffe02340:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe02346:	21 aa                         	bne.b	ffe022f0 <_Reset_Vector+0xffe022f4>
                    && ((uint8_t *) FIT_NO_PTR != priic_info_s[p_riic_info->ch_no]->p_data2nd))
ffe02348:	b0 fc                         	movu.b	3[r7], r4
ffe0234a:	fe 64 54                      	mov.l	[r4, r5], r4
ffe0234d:	a9 44                         	mov.l	16[r4], r4
ffe0234f:	74 04 00 00 00 10             	cmp	#0x10000000, r4
ffe02355:	20 9b                         	beq.b	ffe022f0 <_Reset_Vector+0xffe022f4>
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_RX);
ffe02357:	88 fc                         	mov.b	3[r7], r4

ffe02359 <.LBB786>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02359:	75 42 36                      	mov.l	#54, r2

ffe0235c <.LBE786>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_RX);
ffe0235c:	5b 44                         	movu.b	r4, r4
ffe0235e:	fe 64 55                      	mov.l	[r4, r5], r5

ffe02361 <.LBB789>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02361:	88 d9                         	mov.b	3[r5], r1

ffe02363 <.LVL319>:
ffe02363:	05 f1 ec ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02367 <.LVL320>:
ffe02367:	2e 89                         	bra.b	ffe022f0 <_Reset_Vector+0xffe022f4>

ffe02369 <.LBE789>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_TX);
ffe02369:	88 fc                         	mov.b	3[r7], r4

ffe0236b <.LBB790>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0236b:	fb 26 96                      	mov.l	#-106, r2

ffe0236e <.LBE790>:
                riic_int_icier_setting(priic_info_s[p_riic_info->ch_no], RIIC_ICIER_ST_NAK_AL | RIIC_ICIER_TX);
ffe0236e:	5b 44                         	movu.b	r4, r4
ffe02370:	fe 64 55                      	mov.l	[r4, r5], r5

ffe02373 <.LBB793>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02373:	88 d9                         	mov.b	3[r5], r1

ffe02375 <.LVL324>:
ffe02375:	05 df ec ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02379 <.LVL325>:
ffe02379:	38 77 ff                      	bra.w	ffe022f0 <_Reset_Vector+0xffe022f4>

ffe0237c <.LBE793>:
ffe0237c:	76 10 01 00                   	nop	; mul	#1, r0

ffe02380 <_riic_nack>:
{
ffe02380:	7e a7                         	push.l	r7
ffe02382:	60 40                         	sub	#4, r0
ffe02384:	ef 17                         	mov.l	r1, r7
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02386:	88 9c                         	mov.b	3[r1], r4
    volatile uint8_t uctmp = 0x00;
ffe02388:	3c 01 00                      	mov.b	#0, 1[r0]

ffe0238b <.LBB804>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe0238b:	88 9d                         	mov.b	3[r1], r5

ffe0238d <.LBE804>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0238d:	5b 44                         	movu.b	r4, r4
ffe0238f:	6c 54                         	shll	#5, r4

ffe02391 <.LBB809>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02391:	5b 55                         	movu.b	r5, r5

ffe02393 <.LBE809>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02393:	73 44 01 83 08                	add	#0x88301, r4, r4

ffe02398 <.LBB810>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02398:	6c 45                         	shll	#4, r5

ffe0239a <.LBE810>:
    if (RIIC_ICCR2_MST_SET == ((*piccr2_reg) & RIIC_ICCR2_MST))
ffe0239a:	cc 44                         	mov.b	[r4], r4

ffe0239c <.LBB811>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe0239c:	70 55 24 00 00 00             	add	#36, r5, r5
ffe023a2:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe023a6:	3e 52 08                      	mov.l	#8, 8[r5]

ffe023a9 <.LBB812>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe023a9:	88 99                         	mov.b	3[r1], r1

ffe023ab <.LBE812>:
    if (RIIC_ICCR2_MST_SET == ((*piccr2_reg) & RIIC_ICCR2_MST))
ffe023ab:	7c 64                         	btst	#6, r4
ffe023ad:	3a 88 00                      	beq.w	ffe02435 <_Reset_Vector+0xffe02439>

ffe023b0 <.LBB815>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe023b0:	66 a2                         	mov.l	#10, r2
ffe023b2:	05 a2 ec ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe023b6 <.LBB816>:
    volatile uint8_t uctmp = 0x00;
ffe023b6:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe023b9:	88 fc                         	mov.b	3[r7], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe023bb:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe023bd:	5b 44                         	movu.b	r4, r4
ffe023bf:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe023c1:	5b 55                         	movu.b	r5, r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe023c3:	73 44 09 83 08                	add	#0x88309, r4, r4

ffe023c8 <.LVL334>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe023c8:	6c 55                         	shll	#5, r5
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe023ca:	cc 43                         	mov.b	[r4], r3
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe023cc:	73 55 01 83 08                	add	#0x88301, r5, r5

ffe023d1 <.LVL335>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe023d1:	7c 33                         	btst	#3, r3
ffe023d3:	21 4c                         	bne.b	ffe0241f <_Reset_Vector+0xffe02423>
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffe023d5:	f0 53                         	bset	#3, [r5].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe023d7:	cc 55                         	mov.b	[r5], r5

ffe023d9 <.LVL336>:
ffe023d9:	c3 05                         	mov.b	r5, [r0]

ffe023db <.LBE816>:
    if ((((RIIC_MODE_M_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode)
ffe023db:	b0 fd                         	movu.b	3[r7], r5
ffe023dd:	6c 45                         	shll	#4, r5
ffe023df:	70 55 24 00 00 00             	add	#36, r5, r5
ffe023e5:	ec 55                         	mov.l	[r5], r5
ffe023e7:	61 25                         	cmp	#2, r5
ffe023e9:	20 3a                         	beq.b	ffe02423 <_Reset_Vector+0xffe02427>
            || (RIIC_MODE_M_SEND_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe023eb:	b0 fd                         	movu.b	3[r7], r5
ffe023ed:	6c 45                         	shll	#4, r5
ffe023ef:	70 55 24 00 00 00             	add	#36, r5, r5
ffe023f5:	ec 55                         	mov.l	[r5], r5
ffe023f7:	61 35                         	cmp	#3, r5
ffe023f9:	20 2a                         	beq.b	ffe02423 <_Reset_Vector+0xffe02427>
            || (RIIC_MODE_S_SEND == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe023fb:	b0 fd                         	movu.b	3[r7], r5
ffe023fd:	6c 45                         	shll	#4, r5
ffe023ff:	70 55 24 00 00 00             	add	#36, r5, r5
ffe02405:	ec 55                         	mov.l	[r5], r5
ffe02407:	61 55                         	cmp	#5, r5
ffe02409:	20 1a                         	beq.b	ffe02423 <_Reset_Vector+0xffe02427>
            || (RIIC_MODE_S_RECEIVE == riic_api_info[p_riic_info->ch_no].N_Mode))
ffe0240b:	b0 fd                         	movu.b	3[r7], r5
ffe0240d:	6c 45                         	shll	#4, r5
ffe0240f:	70 55 24 00 00 00             	add	#36, r5, r5
ffe02415:	ec 55                         	mov.l	[r5], r5
ffe02417:	61 65                         	cmp	#6, r5
ffe02419:	12                            	beq.s	ffe02423 <_Reset_Vector+0xffe02427>
} /* End of function riic_nack() */
ffe0241a:	66 01                         	mov.l	#0, r1
ffe0241c:	3f 77 02                      	rtsd	#8, r7-r7

ffe0241f <.LBB819>:
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffe0241f:	f0 4b                         	bclr	#3, [r4].b
ffe02421:	2e b4                         	bra.b	ffe023d5 <_Reset_Vector+0xffe023d9>

ffe02423 <.LBB820>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe02423:	b0 ff                         	movu.b	3[r7], r7

ffe02425 <.LVL340>:
ffe02425:	6c 57                         	shll	#5, r7
ffe02427:	73 77 13 83 08                	add	#0x88313, r7, r7

ffe0242c <.LVL341>:
    return *picdrr_reg;
ffe0242c:	cc 77                         	mov.b	[r7], r7

ffe0242e <.LVL342>:
        uctmp = riic_get_receiving_data(p_riic_info);
ffe0242e:	80 0f                         	mov.b	r7, 1[r0]
} /* End of function riic_nack() */
ffe02430:	66 01                         	mov.l	#0, r1
ffe02432:	3f 77 02                      	rtsd	#8, r7-r7

ffe02435 <.LBB822>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02435:	66 82                         	mov.l	#8, r2
ffe02437:	05 1d ec ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe0243b <.LVL344>:
ffe0243b:	2e a0                         	bra.b	ffe023db <_Reset_Vector+0xffe023df>

ffe0243d <.LFE32>:
ffe0243d:	fc 13 00                      	nop	; max	r0, r0

ffe02440 <_riic_after_receive_slvadr>:
{
ffe02440:	6e 6b                         	pushm	r6-r11
ffe02442:	60 80                         	sub	#8, r0
ffe02444:	ef 17                         	mov.l	r1, r7
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02446:	88 9c                         	mov.b	3[r1], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02448:	cd 1a 03                      	mov.b	3[r1], r10
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe0244b:	5b 44                         	movu.b	r4, r4
    volatile uint8_t uctmp = 0x00;
ffe0244d:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02450:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02452:	5b aa                         	movu.b	r10, r10
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02454:	73 44 09 83 08                	add	#0x88309, r4, r4

ffe02459 <.LVL346>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02459:	6c 5a                         	shll	#5, r10
    (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffe0245b:	f0 4b                         	bclr	#3, [r4].b
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0245d:	73 aa 01 83 08                	add	#0x88301, r10, r10

ffe02462 <.LVL347>:
    while (0x00 != ((*picsr2_reg) & RIIC_ICSR2_STOP))
ffe02462:	cc 45                         	mov.b	[r4], r5
ffe02464:	7c 35                         	btst	#3, r5
ffe02466:	21 fc                         	bne.b	ffe02462 <_Reset_Vector+0xffe02466>
    if (((uint8_t *) FIT_NO_PTR != p_riic_info->p_data1st) && ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data2nd))
ffe02468:	a9 7d                         	mov.l	20[r7], r5
ffe0246a:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffe02470:	20 6e                         	beq.b	ffe024de <_Reset_Vector+0xffe024e2>
ffe02472:	a9 75                         	mov.l	16[r7], r5
ffe02474:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffe0247a:	20 64                         	beq.b	ffe024de <_Reset_Vector+0xffe024e2>

ffe0247c <.LBB844>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0247c:	88 f9                         	mov.b	3[r7], r1

ffe0247e <.LVL349>:
ffe0247e:	fb 26 b8                      	mov.l	#-72, r2
ffe02481:	05 d3 eb ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02485 <.LVL350>:
ffe02485:	fc 13 00                      	nop	; max	r0, r0
    if (0x00 == ((*piccr2_reg) & RIIC_ICCR2_TRS))
ffe02488:	cc a5                         	mov.b	[r10], r5

ffe0248a <.LBB846>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe0248a:	cd 7a 03                      	mov.b	3[r7], r10

ffe0248d <.LBE846>:
    if (0x00 == ((*piccr2_reg) & RIIC_ICCR2_TRS))
ffe0248d:	7c 55                         	btst	#5, r5
ffe0248f:	3b 83 00                      	bne.w	ffe02512 <_Reset_Vector+0xffe02516>

ffe02492 <.LBB850>:
        if (0x00000002 >= p_riic_info->cnt2nd)
ffe02492:	a8 f5                         	mov.l	8[r7], r5

ffe02494 <.LBB851>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02494:	5b aa                         	movu.b	r10, r10
ffe02496:	6c 4a                         	shll	#4, r10

ffe02498 <.LVL353>:
ffe02498:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe0249e:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffe024a2:	f9 a6 02 07                   	mov.l	#7, 8[r10]

ffe024a6 <.LBE851>:
        if (0x00000002 >= p_riic_info->cnt2nd)
ffe024a6:	61 25                         	cmp	#2, r5
ffe024a8:	24 16                         	bgtu.b	ffe024be <_Reset_Vector+0xffe024c2>

ffe024aa <.LBB852>:
    volatile uint8_t uctmp = 0x00;
ffe024aa:	3c 03 00                      	mov.b	#0, 3[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe024ad:	59 7a 03                      	movu.b	3[r7], r10
ffe024b0:	6c 5a                         	shll	#5, r10
ffe024b2:	73 aa 04 83 08                	add	#0x88304, r10, r10

ffe024b7 <.LVL356>:
    (*picmr3_reg) |= RIIC_ICMR3_WAIT_SET;
ffe024b7:	f0 a6                         	bset	#6, [r10].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffe024b9:	cc aa                         	mov.b	[r10], r10

ffe024bb <.LVL357>:
ffe024bb:	c7 0a 03                      	mov.b	r10, 3[r0]

ffe024be <.LVL358>:
        if (0x00000001 >= p_riic_info->cnt2nd)
ffe024be:	ed 7a 02                      	mov.l	8[r7], r10
ffe024c1:	61 1a                         	cmp	#1, r10
ffe024c3:	24 05                         	bgtu.b	ffe024c8 <_Reset_Vector+0xffe024cc>
ffe024c5:	38 d6 00                      	bra.w	ffe0259b <_Reset_Vector+0xffe0259f>

ffe024c8 <.LBB854>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe024c8:	88 ff                         	mov.b	3[r7], r7

ffe024ca <.LBE854>:
    return RIIC_SUCCESS;
ffe024ca:	66 06                         	mov.l	#0, r6

ffe024cc <.LBB857>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe024cc:	5b 77                         	movu.b	r7, r7
ffe024ce:	6c 57                         	shll	#5, r7
ffe024d0:	73 77 13 83 08                	add	#0x88313, r7, r7

ffe024d5 <.LVL361>:
    return *picdrr_reg;
ffe024d5:	cc 77                         	mov.b	[r7], r7

ffe024d7 <.LBE857>:
        uctmp = riic_get_receiving_data(p_riic_info);
ffe024d7:	81 07                         	mov.b	r7, 4[r0]
} /* End of function riic_after_receive_slvadr() */
ffe024d9:	ef 61                         	mov.l	r6, r1
ffe024db:	3f 6b 08                      	rtsd	#32, r6-r11

ffe024de <.LVL363>:
    else if (((uint8_t *) FIT_NO_PTR != p_riic_info->p_data1st) && ((uint8_t *) FIT_NO_PTR == p_riic_info->p_data2nd))
ffe024de:	a9 7d                         	mov.l	20[r7], r5
ffe024e0:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffe024e6:	20 0c                         	beq.b	ffe024f2 <_Reset_Vector+0xffe024f6>
ffe024e8:	a9 75                         	mov.l	16[r7], r5
ffe024ea:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffe024f0:	20 7e                         	beq.b	ffe0256e <_Reset_Vector+0xffe02572>
    else if (((uint8_t *) FIT_NO_PTR == p_riic_info->p_data1st) && ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data2nd))
ffe024f2:	a9 7d                         	mov.l	20[r7], r5
ffe024f4:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffe024fa:	21 8e                         	bne.b	ffe02488 <_Reset_Vector+0xffe0248c>
ffe024fc:	a9 75                         	mov.l	16[r7], r5
ffe024fe:	74 05 00 00 00 10             	cmp	#0x10000000, r5
ffe02504:	20 84                         	beq.b	ffe02488 <_Reset_Vector+0xffe0248c>

ffe02506 <.LBB858>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02506:	88 f9                         	mov.b	3[r7], r1

ffe02508 <.LVL365>:
ffe02508:	75 42 28                      	mov.l	#40, r2
ffe0250b:	05 49 eb ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe0250f <.LVL366>:
ffe0250f:	38 79 ff                      	bra.w	ffe02488 <_Reset_Vector+0xffe0248c>

ffe02512 <.LBB860>:
        if (0x00000000 != p_riic_info->cnt1st)
ffe02512:	a8 fe                         	mov.l	12[r7], r6

ffe02514 <.LBB863>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02514:	5b aa                         	movu.b	r10, r10
ffe02516:	6c 4a                         	shll	#4, r10

ffe02518 <.LVL368>:
ffe02518:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe0251e:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffe02522:	f9 a6 02 06                   	mov.l	#6, 8[r10]

ffe02526 <.LBE863>:
        if (0x00000000 != p_riic_info->cnt1st)
ffe02526:	61 06                         	cmp	#0, r6
ffe02528:	20 52                         	beq.b	ffe0257a <_Reset_Vector+0xffe0257e>
            if ((uint8_t *) FIT_NO_PTR == p_riic_info->p_data1st)
ffe0252a:	ed 7a 05                      	mov.l	20[r7], r10
ffe0252d:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe02533:	3a 84 00                      	beq.w	ffe025b7 <_Reset_Vector+0xffe025bb>
            riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffe02536:	ed 7b 05                      	mov.l	20[r7], r11

ffe02539 <.LBB864>:
    volatile uint8_t uctmp = 0x00;
ffe02539:	3c 02 00                      	mov.b	#0, 2[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe0253c:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe0253f:	88 f9                         	mov.b	3[r7], r1

ffe02541 <.LBE864>:
    return RIIC_SUCCESS;
ffe02541:	66 06                         	mov.l	#0, r6

ffe02543 <.LBB867>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02543:	5b aa                         	movu.b	r10, r10
ffe02545:	6c 5a                         	shll	#5, r10
ffe02547:	73 aa 12 83 08                	add	#0x88312, r10, r10

ffe0254c <.LVL371>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe0254c:	05 e2 ea ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe02550 <.LVL372>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02550:	cc b5                         	mov.b	[r11], r5
ffe02552:	c3 a5                         	mov.b	r5, [r10]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe02554:	cc aa                         	mov.b	[r10], r10

ffe02556 <.LVL373>:
ffe02556:	c7 0a 02                      	mov.b	r10, 2[r0]

ffe02559 <.LBE867>:
            p_riic_info->cnt1st--;
ffe02559:	ed 7a 03                      	mov.l	12[r7], r10
ffe0255c:	60 1a                         	sub	#1, r10
ffe0255e:	e7 7a 03                      	mov.l	r10, 12[r7]
            p_riic_info->p_data1st++;
ffe02561:	ed 7a 05                      	mov.l	20[r7], r10
ffe02564:	62 1a                         	add	#1, r10
ffe02566:	e7 7a 05                      	mov.l	r10, 20[r7]

ffe02569 <.LVL375>:
} /* End of function riic_after_receive_slvadr() */
ffe02569:	ef 61                         	mov.l	r6, r1
ffe0256b:	3f 6b 08                      	rtsd	#32, r6-r11

ffe0256e <.LBB868>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0256e:	88 f9                         	mov.b	3[r7], r1

ffe02570 <.LVL377>:
ffe02570:	fb 26 98                      	mov.l	#-104, r2
ffe02573:	05 e1 ea ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02577 <.LVL378>:
ffe02577:	38 11 ff                      	bra.w	ffe02488 <_Reset_Vector+0xffe0248c>

ffe0257a <.LBB870>:
    volatile uint8_t uctmp = 0x00;
ffe0257a:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe0257d:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02580:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02582:	5b a7                         	movu.b	r10, r7

ffe02584 <.LVL380>:
ffe02584:	6c 57                         	shll	#5, r7
ffe02586:	73 77 12 83 08                	add	#0x88312, r7, r7

ffe0258b <.LVL381>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe0258b:	05 a3 ea ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe0258f <.LVL382>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe0258f:	f8 74 ff                      	mov.b	#255, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe02592:	cc 77                         	mov.b	[r7], r7

ffe02594 <.LVL383>:
ffe02594:	80 0f                         	mov.b	r7, 1[r0]
} /* End of function riic_after_receive_slvadr() */
ffe02596:	ef 61                         	mov.l	r6, r1
ffe02598:	3f 6b 08                      	rtsd	#32, r6-r11

ffe0259b <.LBB872>:
    volatile uint8_t uctmp = 0x00;
ffe0259b:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe0259e:	59 7a 03                      	movu.b	3[r7], r10
ffe025a1:	6c 5a                         	shll	#5, r10
ffe025a3:	73 aa 04 83 08                	add	#0x88304, r10, r10

ffe025a8 <.LVL385>:
    (*picmr3_reg) |= RIIC_ICMR3_RDRFS_SET;
ffe025a8:	f0 a5                         	bset	#5, [r10].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled.                */
ffe025aa:	f0 a4                         	bset	#4, [r10].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET; /* A 1 is sent as the acknowledge bit (NACK transmission).  */
ffe025ac:	f0 a3                         	bset	#3, [r10].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled.               */
ffe025ae:	f0 ac                         	bclr	#4, [r10].b
    uctmp = *picmr3_reg; /* Reads ICMR3.                                             */
ffe025b0:	cc aa                         	mov.b	[r10], r10

ffe025b2 <.LVL386>:
ffe025b2:	c3 0a                         	mov.b	r10, [r0]
ffe025b4:	38 14 ff                      	bra.w	ffe024c8 <_Reset_Vector+0xffe024cc>

ffe025b7 <.LVL387>:
                return RIIC_ERR_OTHER;
ffe025b7:	66 86                         	mov.l	#8, r6

ffe025b9 <.LVL388>:
ffe025b9:	2e b0                         	bra.b	ffe02569 <_Reset_Vector+0xffe0256d>

ffe025bb <.LFE26>:
ffe025bb:	77 10 01 00 00                	nop	; mul	#1, r0

ffe025c0 <_riic_read_data_receiving>:
{
ffe025c0:	7e a7                         	push.l	r7
ffe025c2:	60 80                         	sub	#8, r0
    volatile uint8_t uctmp = 0x00;
ffe025c4:	3c 04 00                      	mov.b	#0, 4[r0]
    if (0x00000003 >= p_riic_info->cnt2nd)
ffe025c7:	a8 97                         	mov.l	8[r1], r7
ffe025c9:	61 37                         	cmp	#3, r7
ffe025cb:	24 15                         	bgtu.b	ffe025e0 <_Reset_Vector+0xffe025e4>

ffe025cd <.LBB892>:
    volatile uint8_t uctmp = 0x00;
ffe025cd:	3c 03 00                      	mov.b	#0, 3[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe025d0:	b0 9d                         	movu.b	3[r1], r5
ffe025d2:	6c 55                         	shll	#5, r5
ffe025d4:	73 55 04 83 08                	add	#0x88304, r5, r5

ffe025d9 <.LVL391>:
    (*picmr3_reg) |= RIIC_ICMR3_WAIT_SET;
ffe025d9:	f0 56                         	bset	#6, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffe025db:	cc 57                         	mov.b	[r5], r7
ffe025dd:	80 8f                         	mov.b	r7, 3[r0]

ffe025df <.LVL392>:
ffe025df:	03                            	nop
    if (0x00000002 >= p_riic_info->cnt2nd)
ffe025e0:	a8 97                         	mov.l	8[r1], r7
ffe025e2:	61 27                         	cmp	#2, r7
ffe025e4:	24 05                         	bgtu.b	ffe025e9 <_Reset_Vector+0xffe025ed>
ffe025e6:	38 ba 00                      	bra.w	ffe026a0 <_Reset_Vector+0xffe026a4>
    if (0x00000001 >= p_riic_info->cnt2nd)
ffe025e9:	a8 97                         	mov.l	8[r1], r7
ffe025eb:	61 17                         	cmp	#1, r7
ffe025ed:	25 22                         	bleu.b	ffe0260f <_Reset_Vector+0xffe02613>
        *p_riic_info->p_data2nd = riic_get_receiving_data(p_riic_info);
ffe025ef:	a9 17                         	mov.l	16[r1], r7

ffe025f1 <.LBB894>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe025f1:	b0 9d                         	movu.b	3[r1], r5
ffe025f3:	6c 55                         	shll	#5, r5
ffe025f5:	73 55 13 83 08                	add	#0x88313, r5, r5

ffe025fa <.LVL394>:
    return *picdrr_reg;
ffe025fa:	cc 55                         	mov.b	[r5], r5

ffe025fc <.LVL395>:
        *p_riic_info->p_data2nd = riic_get_receiving_data(p_riic_info);
ffe025fc:	c3 75                         	mov.b	r5, [r7]
        p_riic_info->cnt2nd--; /* Decreases the receiving data counter. */
ffe025fe:	a8 97                         	mov.l	8[r1], r7
ffe02600:	60 17                         	sub	#1, r7
ffe02602:	a0 97                         	mov.l	r7, 8[r1]
        p_riic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffe02604:	a9 17                         	mov.l	16[r1], r7
ffe02606:	62 17                         	add	#1, r7
ffe02608:	a1 17                         	mov.l	r7, 16[r1]
} /* End of function riic_read_data_receiving() */
ffe0260a:	66 01                         	mov.l	#0, r1

ffe0260c <.LVL396>:
ffe0260c:	3f 77 03                      	rtsd	#12, r7-r7

ffe0260f <.LVL397>:
ffe0260f:	ef 17                         	mov.l	r1, r7
        if (RIIC_MODE_S_RECEIVE != riic_api_info[p_riic_info->ch_no].N_Mode)
ffe02611:	b0 9d                         	movu.b	3[r1], r5
ffe02613:	6c 45                         	shll	#4, r5
ffe02615:	70 55 24 00 00 00             	add	#36, r5, r5
ffe0261b:	ec 55                         	mov.l	[r5], r5
ffe0261d:	61 65                         	cmp	#6, r5
ffe0261f:	20 43                         	beq.b	ffe02662 <_Reset_Vector+0xffe02666>

ffe02621 <.LBB896>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe02621:	88 9d                         	mov.b	3[r1], r5

ffe02623 <.LBB899>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02623:	88 99                         	mov.b	3[r1], r1

ffe02625 <.LVL400>:
ffe02625:	75 42 1a                      	mov.l	#26, r2

ffe02628 <.LBB902>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02628:	5b 55                         	movu.b	r5, r5
ffe0262a:	6c 45                         	shll	#4, r5

ffe0262c <.LVL401>:
ffe0262c:	70 55 24 00 00 00             	add	#36, r5, r5
ffe02632:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe02636:	3e 52 08                      	mov.l	#8, 8[r5]

ffe02639 <.LBB903>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02639:	05 1b ea ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe0263d <.LBB904>:
    volatile uint8_t uctmp = 0x00;
ffe0263d:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02640:	88 fc                         	mov.b	3[r7], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02642:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02644:	5b 44                         	movu.b	r4, r4
ffe02646:	6c 54                         	shll	#5, r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02648:	5b 55                         	movu.b	r5, r5
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe0264a:	73 44 09 83 08                	add	#0x88309, r4, r4

ffe0264f <.LVL404>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0264f:	6c 55                         	shll	#5, r5
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe02651:	cc 43                         	mov.b	[r4], r3
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02653:	73 55 01 83 08                	add	#0x88301, r5, r5

ffe02658 <.LVL405>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe02658:	7c 33                         	btst	#3, r3
ffe0265a:	21 70                         	bne.b	ffe026ca <_Reset_Vector+0xffe026ce>
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffe0265c:	f0 53                         	bset	#3, [r5].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe0265e:	cc 55                         	mov.b	[r5], r5

ffe02660 <.LVL406>:
ffe02660:	80 0d                         	mov.b	r5, 1[r0]

ffe02662 <.LBE904>:
        if (0x00000000 != p_riic_info->cnt2nd)
ffe02662:	a8 f5                         	mov.l	8[r7], r5
ffe02664:	61 05                         	cmp	#0, r5
ffe02666:	20 55                         	beq.b	ffe026bb <_Reset_Vector+0xffe026bf>
            *p_riic_info->p_data2nd = riic_get_receiving_data(p_riic_info);
ffe02668:	a9 74                         	mov.l	16[r7], r4

ffe0266a <.LBB907>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe0266a:	b0 fd                         	movu.b	3[r7], r5
ffe0266c:	6c 55                         	shll	#5, r5
ffe0266e:	73 55 13 83 08                	add	#0x88313, r5, r5

ffe02673 <.LVL409>:
    return *picdrr_reg;
ffe02673:	cc 55                         	mov.b	[r5], r5

ffe02675 <.LVL410>:
            *p_riic_info->p_data2nd = riic_get_receiving_data(p_riic_info);
ffe02675:	c3 45                         	mov.b	r5, [r4]
            p_riic_info->cnt2nd--; /* Decreases the receiving data counter. */
ffe02677:	a8 f5                         	mov.l	8[r7], r5
ffe02679:	60 15                         	sub	#1, r5
ffe0267b:	a0 f5                         	mov.l	r5, 8[r7]
            p_riic_info->p_data2nd++; /* Increases the receiving data buffer pointer. */
ffe0267d:	a9 75                         	mov.l	16[r7], r5
ffe0267f:	62 15                         	add	#1, r5
ffe02681:	a1 75                         	mov.l	r5, 16[r7]

ffe02683 <.LBB909>:
    volatile uint8_t uctmp = 0x00;
ffe02683:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe02686:	b0 fd                         	movu.b	3[r7], r5
ffe02688:	6c 55                         	shll	#5, r5
ffe0268a:	73 55 04 83 08                	add	#0x88304, r5, r5

ffe0268f <.LVL412>:
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled. */
ffe0268f:	f0 54                         	bset	#4, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET;
ffe02691:	f0 53                         	bset	#3, [r5].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled. */
ffe02693:	f0 5c                         	bclr	#4, [r5].b
    (*picmr3_reg) &= RIIC_ICMR3_WAIT_CLR;
ffe02695:	f0 5e                         	bclr	#6, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffe02697:	cc 57                         	mov.b	[r5], r7

ffe02699 <.LVL413>:
ffe02699:	c3 07                         	mov.b	r7, [r0]
} /* End of function riic_read_data_receiving() */
ffe0269b:	66 01                         	mov.l	#0, r1
ffe0269d:	3f 77 03                      	rtsd	#12, r7-r7

ffe026a0 <.LBB911>:
    volatile uint8_t uctmp = 0x00;
ffe026a0:	3c 02 00                      	mov.b	#0, 2[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe026a3:	b0 9d                         	movu.b	3[r1], r5
ffe026a5:	6c 55                         	shll	#5, r5
ffe026a7:	73 55 04 83 08                	add	#0x88304, r5, r5

ffe026ac <.LVL415>:
    (*picmr3_reg) |= RIIC_ICMR3_RDRFS_SET;
ffe026ac:	f0 55                         	bset	#5, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled.                */
ffe026ae:	f0 54                         	bset	#4, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET; /* A 1 is sent as the acknowledge bit (NACK transmission).  */
ffe026b0:	f0 53                         	bset	#3, [r5].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled.               */
ffe026b2:	f0 5c                         	bclr	#4, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3.                                             */
ffe026b4:	cc 57                         	mov.b	[r5], r7
ffe026b6:	80 87                         	mov.b	r7, 2[r0]
ffe026b8:	38 31 ff                      	bra.w	ffe025e9 <_Reset_Vector+0xffe025ed>

ffe026bb <.LBB913>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe026bb:	b0 fd                         	movu.b	3[r7], r5
ffe026bd:	6c 55                         	shll	#5, r5
ffe026bf:	73 55 13 83 08                	add	#0x88313, r5, r5

ffe026c4 <.LVL417>:
    return *picdrr_reg;
ffe026c4:	cc 55                         	mov.b	[r5], r5

ffe026c6 <.LVL418>:
            uctmp = riic_get_receiving_data(p_riic_info);
ffe026c6:	81 05                         	mov.b	r5, 4[r0]
ffe026c8:	2e bb                         	bra.b	ffe02683 <_Reset_Vector+0xffe02687>

ffe026ca <.LBB915>:
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffe026ca:	f0 4b                         	bclr	#3, [r4].b
ffe026cc:	2e 90                         	bra.b	ffe0265c <_Reset_Vector+0xffe02660>

ffe026ce <.LBE915>:
ffe026ce:	ef 00                         	nop	; mov.l	r0, r0

ffe026d0 <_riic_write_data_sending>:
{
ffe026d0:	6e 6b                         	pushm	r6-r11
ffe026d2:	60 80                         	sub	#8, r0

ffe026d4 <.LVL421>:
ffe026d4:	ef 17                         	mov.l	r1, r7
    switch (riic_api_info[p_riic_info->ch_no].N_Mode)
ffe026d6:	b0 9d                         	movu.b	3[r1], r5
ffe026d8:	6c 45                         	shll	#4, r5
ffe026da:	70 55 24 00 00 00             	add	#36, r5, r5
ffe026e0:	ec 55                         	mov.l	[r5], r5
ffe026e2:	61 35                         	cmp	#3, r5
ffe026e4:	20 12                         	beq.b	ffe026f6 <_Reset_Vector+0xffe026fa>
ffe026e6:	61 55                         	cmp	#5, r5
ffe026e8:	3a cd 00                      	beq.w	ffe027b5 <_Reset_Vector+0xffe027b9>
ffe026eb:	61 15                         	cmp	#1, r5
ffe026ed:	20 57                         	beq.b	ffe02744 <_Reset_Vector+0xffe02748>
            ret = RIIC_ERR_OTHER;
ffe026ef:	66 8a                         	mov.l	#8, r10

ffe026f1 <.LVL422>:
} /* End of function riic_write_data_sending() */
ffe026f1:	ef a1                         	mov.l	r10, r1
ffe026f3:	3f 6b 08                      	rtsd	#32, r6-r11

ffe026f6 <.LVL423>:
            if (0x00000000 != p_riic_info->cnt1st)
ffe026f6:	ed 1a 03                      	mov.l	12[r1], r10
ffe026f9:	61 0a                         	cmp	#0, r10
ffe026fb:	3b f0 00                      	bne.w	ffe027eb <_Reset_Vector+0xffe027ef>

ffe026fe <.LBB940>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe026fe:	88 9c                         	mov.b	3[r1], r4

ffe02700 <.LBB943>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02700:	88 99                         	mov.b	3[r1], r1

ffe02702 <.LVL426>:
ffe02702:	75 42 16                      	mov.l	#22, r2

ffe02705 <.LBB946>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02705:	5b 44                         	movu.b	r4, r4
ffe02707:	6c 44                         	shll	#4, r4

ffe02709 <.LVL427>:
ffe02709:	70 44 24 00 00 00             	add	#36, r4, r4
ffe0270f:	e5 44 02 03                   	mov.l	8[r4], 12[r4]
    riic_api_info[ch_no].N_status = new_status;
ffe02713:	a0 c5                         	mov.l	r5, 8[r4]

ffe02715 <.LBB947>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02715:	05 3f e9 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02719 <.LBB948>:
    volatile uint8_t uctmp = 0x00;
ffe02719:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe0271c:	88 fd                         	mov.b	3[r7], r5
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0271e:	88 ff                         	mov.b	3[r7], r7

ffe02720 <.LVL430>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02720:	5b 55                         	movu.b	r5, r5
ffe02722:	6c 55                         	shll	#5, r5
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02724:	5b 77                         	movu.b	r7, r7
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02726:	73 55 09 83 08                	add	#0x88309, r5, r5

ffe0272b <.LVL431>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0272b:	6c 57                         	shll	#5, r7
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START_SET) >> 2U))
ffe0272d:	cc 54                         	mov.b	[r5], r4
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0272f:	73 77 01 83 08                	add	#0x88301, r7, r7

ffe02734 <.LVL432>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_START_SET) >> 2U))
ffe02734:	7c 24                         	btst	#2, r4
ffe02736:	13                            	beq.s	ffe02739 <_Reset_Vector+0xffe0273d>
        (*picsr2_reg) &= RIIC_ICSR2_START_CLR;
ffe02737:	f0 5a                         	bclr	#2, [r5].b
    (*piccr2_reg) |= RIIC_ICCR2_RS; /* Sets ICCR2.RS bit. */
ffe02739:	f0 72                         	bset	#2, [r7].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe0273b:	cc 77                         	mov.b	[r7], r7

ffe0273d <.LVL433>:
ffe0273d:	c3 07                         	mov.b	r7, [r0]
} /* End of function riic_write_data_sending() */
ffe0273f:	ef a1                         	mov.l	r10, r1
ffe02741:	3f 6b 08                      	rtsd	#32, r6-r11

ffe02744 <.LVL434>:
            if ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data1st)
ffe02744:	ed 1a 05                      	mov.l	20[r1], r10
ffe02747:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe0274d:	11                            	beq.s	ffe02756 <_Reset_Vector+0xffe0275a>
                if (0x00000000 != p_riic_info->cnt1st) /* Pattern 1 of Master Write */
ffe0274e:	ed 1a 03                      	mov.l	12[r1], r10
ffe02751:	61 0a                         	cmp	#0, r10
ffe02753:	3b ea 00                      	bne.w	ffe0283d <_Reset_Vector+0xffe02841>
            if ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data2nd)
ffe02756:	ed 7a 04                      	mov.l	16[r7], r10
ffe02759:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe0275f:	11                            	beq.s	ffe02768 <_Reset_Vector+0xffe0276c>
                if (0x00000000 != p_riic_info->cnt2nd) /* Pattern 2 of Master Write */
ffe02760:	ed 7a 02                      	mov.l	8[r7], r10
ffe02763:	61 0a                         	cmp	#0, r10
ffe02765:	3b fb 00                      	bne.w	ffe02860 <_Reset_Vector+0xffe02864>

ffe02768 <.LBB950>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe02768:	cd 7a 03                      	mov.b	3[r7], r10

ffe0276b <.LBB953>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0276b:	88 f9                         	mov.b	3[r7], r1

ffe0276d <.LVL437>:
ffe0276d:	75 42 1a                      	mov.l	#26, r2

ffe02770 <.LBB956>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02770:	5b aa                         	movu.b	r10, r10
ffe02772:	6c 4a                         	shll	#4, r10

ffe02774 <.LVL438>:
ffe02774:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe0277a:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffe0277e:	f9 a6 02 08                   	mov.l	#8, 8[r10]

ffe02782 <.LBB957>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02782:	05 d2 e8 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02786 <.LBB958>:
    volatile uint8_t uctmp = 0x00;
ffe02786:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02789:	cd 7a 03                      	mov.b	3[r7], r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0278c:	88 ff                         	mov.b	3[r7], r7

ffe0278e <.LVL441>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe0278e:	5b aa                         	movu.b	r10, r10
ffe02790:	6c 5a                         	shll	#5, r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02792:	5b 77                         	movu.b	r7, r7
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02794:	73 aa 09 83 08                	add	#0x88309, r10, r10

ffe02799 <.LVL442>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02799:	6c 57                         	shll	#5, r7
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe0279b:	cc a5                         	mov.b	[r10], r5
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe0279d:	73 77 01 83 08                	add	#0x88301, r7, r7

ffe027a2 <.LVL443>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe027a2:	7c 35                         	btst	#3, r5
ffe027a4:	14                            	beq.s	ffe027a8 <_Reset_Vector+0xffe027ac>
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffe027a5:	f0 ab                         	bclr	#3, [r10].b
ffe027a7:	03                            	nop
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffe027a8:	f0 73                         	bset	#3, [r7].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe027aa:	cc 77                         	mov.b	[r7], r7

ffe027ac <.LBE958>:
    riic_return_t ret = RIIC_SUCCESS;
ffe027ac:	66 0a                         	mov.l	#0, r10

ffe027ae <.LBB961>:
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe027ae:	80 0f                         	mov.b	r7, 1[r0]

ffe027b0 <.LBE961>:
} /* End of function riic_write_data_sending() */
ffe027b0:	ef a1                         	mov.l	r10, r1
ffe027b2:	3f 6b 08                      	rtsd	#32, r6-r11

ffe027b5 <.LVL446>:
            if ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data1st)
ffe027b5:	ed 1a 05                      	mov.l	20[r1], r10
ffe027b8:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe027be:	3a d2 00                      	beq.w	ffe02890 <_Reset_Vector+0xffe02894>
                if (0x00000000 != p_riic_info->cnt1st)
ffe027c1:	ed 1a 03                      	mov.l	12[r1], r10
ffe027c4:	61 0a                         	cmp	#0, r10
ffe027c6:	20 57                         	beq.b	ffe0281d <_Reset_Vector+0xffe02821>
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffe027c8:	ed 1b 05                      	mov.l	20[r1], r11

ffe027cb <.LBB962>:
    volatile uint8_t uctmp = 0x00;
ffe027cb:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe027ce:	88 9e                         	mov.b	3[r1], r6
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe027d0:	88 99                         	mov.b	3[r1], r1

ffe027d2 <.LBE962>:
    riic_return_t ret = RIIC_SUCCESS;
ffe027d2:	66 0a                         	mov.l	#0, r10

ffe027d4 <.LBB965>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe027d4:	5b 66                         	movu.b	r6, r6
ffe027d6:	6c 56                         	shll	#5, r6
ffe027d8:	73 66 12 83 08                	add	#0x88312, r6, r6

ffe027dd <.LVL449>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe027dd:	05 51 e8 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe027e1 <.LVL450>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe027e1:	cc b5                         	mov.b	[r11], r5
ffe027e3:	c3 65                         	mov.b	r5, [r6]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe027e5:	cc 65                         	mov.b	[r6], r5
ffe027e7:	81 05                         	mov.b	r5, 4[r0]

ffe027e9 <.LBE965>:
                    p_riic_info->cnt1st--;
ffe027e9:	2e 23                         	bra.b	ffe0280c <_Reset_Vector+0xffe02810>

ffe027eb <.LVL452>:
                riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffe027eb:	ed 1b 05                      	mov.l	20[r1], r11

ffe027ee <.LBB966>:
    volatile uint8_t uctmp = 0x00;
ffe027ee:	3c 05 00                      	mov.b	#0, 5[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe027f1:	88 9e                         	mov.b	3[r1], r6
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe027f3:	88 99                         	mov.b	3[r1], r1

ffe027f5 <.LBE966>:
    riic_return_t ret = RIIC_SUCCESS;
ffe027f5:	66 0a                         	mov.l	#0, r10

ffe027f7 <.LBB969>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe027f7:	5b 66                         	movu.b	r6, r6
ffe027f9:	6c 56                         	shll	#5, r6
ffe027fb:	73 66 12 83 08                	add	#0x88312, r6, r6

ffe02800 <.LVL455>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02800:	05 2e e8 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe02804 <.LVL456>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02804:	cc b5                         	mov.b	[r11], r5
ffe02806:	c3 65                         	mov.b	r5, [r6]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe02808:	cc 65                         	mov.b	[r6], r5
ffe0280a:	81 0d                         	mov.b	r5, 5[r0]

ffe0280c <.LBE969>:
                p_riic_info->cnt1st--;
ffe0280c:	a8 fd                         	mov.l	12[r7], r5
ffe0280e:	60 15                         	sub	#1, r5
ffe02810:	a0 fd                         	mov.l	r5, 12[r7]
                p_riic_info->p_data1st++;
ffe02812:	a9 7d                         	mov.l	20[r7], r5
ffe02814:	62 15                         	add	#1, r5
ffe02816:	a1 7d                         	mov.l	r5, 20[r7]
} /* End of function riic_write_data_sending() */
ffe02818:	ef a1                         	mov.l	r10, r1
ffe0281a:	3f 6b 08                      	rtsd	#32, r6-r11

ffe0281d <.LBB970>:
    volatile uint8_t uctmp = 0x00;
ffe0281d:	3c 03 00                      	mov.b	#0, 3[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02820:	88 9d                         	mov.b	3[r1], r5
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02822:	88 99                         	mov.b	3[r1], r1

ffe02824 <.LVL459>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02824:	5b 57                         	movu.b	r5, r7

ffe02826 <.LVL460>:
ffe02826:	6c 57                         	shll	#5, r7
ffe02828:	73 77 12 83 08                	add	#0x88312, r7, r7

ffe0282d <.LVL461>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe0282d:	05 01 e8 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe02831 <.LVL462>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02831:	f8 74 ff                      	mov.b	#255, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe02834:	cc 77                         	mov.b	[r7], r7

ffe02836 <.LVL463>:
ffe02836:	80 8f                         	mov.b	r7, 3[r0]
} /* End of function riic_write_data_sending() */
ffe02838:	ef a1                         	mov.l	r10, r1
ffe0283a:	3f 6b 08                      	rtsd	#32, r6-r11

ffe0283d <.LVL464>:
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffe0283d:	ed 1b 05                      	mov.l	20[r1], r11

ffe02840 <.LBB972>:
    volatile uint8_t uctmp = 0x00;
ffe02840:	3c 07 00                      	mov.b	#0, 7[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02843:	88 9e                         	mov.b	3[r1], r6
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02845:	88 99                         	mov.b	3[r1], r1

ffe02847 <.LBE972>:
    riic_return_t ret = RIIC_SUCCESS;
ffe02847:	66 0a                         	mov.l	#0, r10

ffe02849 <.LBB975>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02849:	5b 66                         	movu.b	r6, r6
ffe0284b:	6c 56                         	shll	#5, r6
ffe0284d:	73 66 12 83 08                	add	#0x88312, r6, r6

ffe02852 <.LVL467>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02852:	05 dc e7 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe02856 <.LVL468>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02856:	cc b5                         	mov.b	[r11], r5
ffe02858:	c3 65                         	mov.b	r5, [r6]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe0285a:	cc 65                         	mov.b	[r6], r5
ffe0285c:	81 8d                         	mov.b	r5, 7[r0]

ffe0285e <.LBE975>:
                    p_riic_info->cnt1st--;
ffe0285e:	2e ae                         	bra.b	ffe0280c <_Reset_Vector+0xffe02810>

ffe02860 <.LVL470>:
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data2nd);
ffe02860:	ed 7b 04                      	mov.l	16[r7], r11

ffe02863 <.LBB976>:
    volatile uint8_t uctmp = 0x00;
ffe02863:	3c 06 00                      	mov.b	#0, 6[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02866:	88 fe                         	mov.b	3[r7], r6
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02868:	88 f9                         	mov.b	3[r7], r1

ffe0286a <.LBE976>:
    riic_return_t ret = RIIC_SUCCESS;
ffe0286a:	66 0a                         	mov.l	#0, r10

ffe0286c <.LBB979>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe0286c:	5b 66                         	movu.b	r6, r6
ffe0286e:	6c 56                         	shll	#5, r6
ffe02870:	73 66 12 83 08                	add	#0x88312, r6, r6

ffe02875 <.LVL473>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02875:	05 b9 e7 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe02879 <.LVL474>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02879:	cc b5                         	mov.b	[r11], r5
ffe0287b:	c3 65                         	mov.b	r5, [r6]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe0287d:	cc 65                         	mov.b	[r6], r5
ffe0287f:	81 85                         	mov.b	r5, 6[r0]

ffe02881 <.LBE979>:
                    p_riic_info->cnt2nd--;
ffe02881:	a8 f5                         	mov.l	8[r7], r5
ffe02883:	60 15                         	sub	#1, r5
ffe02885:	a0 f5                         	mov.l	r5, 8[r7]
                    p_riic_info->p_data2nd++;
ffe02887:	a9 75                         	mov.l	16[r7], r5
ffe02889:	62 15                         	add	#1, r5
ffe0288b:	a1 75                         	mov.l	r5, 16[r7]
                    break;
ffe0288d:	38 64 fe                      	bra.w	ffe026f1 <_Reset_Vector+0xffe026f5>

ffe02890 <.LBB980>:
    riic_return_t ret = RIIC_SUCCESS;
ffe02890:	66 0a                         	mov.l	#0, r10

ffe02892 <.LBB983>:
    volatile uint8_t uctmp = 0x00;
ffe02892:	3c 02 00                      	mov.b	#0, 2[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02895:	88 9d                         	mov.b	3[r1], r5
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02897:	88 99                         	mov.b	3[r1], r1

ffe02899 <.LVL477>:
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02899:	5b 57                         	movu.b	r5, r7

ffe0289b <.LVL478>:
ffe0289b:	6c 57                         	shll	#5, r7
ffe0289d:	73 77 12 83 08                	add	#0x88312, r7, r7

ffe028a2 <.LVL479>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe028a2:	05 8c e7 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe028a6 <.LVL480>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe028a6:	f8 74 ff                      	mov.b	#255, [r7]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe028a9:	cc 77                         	mov.b	[r7], r7

ffe028ab <.LVL481>:
ffe028ab:	80 87                         	mov.b	r7, 2[r0]
ffe028ad:	38 44 fe                      	bra.w	ffe026f1 <_Reset_Vector+0xffe026f5>

ffe028b0 <_riic_after_send_slvadr>:
{
ffe028b0:	6e 6a                         	pushm	r6-r10
ffe028b2:	60 c0                         	sub	#12, r0

ffe028b4 <.LVL483>:
ffe028b4:	ef 17                         	mov.l	r1, r7
    volatile uint8_t uctmp = 0x00;
ffe028b6:	3c 08 00                      	mov.b	#0, 8[r0]
    switch (riic_api_info[p_riic_info->ch_no].N_Mode)
ffe028b9:	b0 9d                         	movu.b	3[r1], r5
ffe028bb:	6c 45                         	shll	#4, r5
ffe028bd:	70 55 24 00 00 00             	add	#36, r5, r5
ffe028c3:	ec 55                         	mov.l	[r5], r5
ffe028c5:	61 25                         	cmp	#2, r5
ffe028c7:	3a dd 00                      	beq.w	ffe029a4 <_Reset_Vector+0xffe029a8>
ffe028ca:	61 35                         	cmp	#3, r5
ffe028cc:	20 6a                         	beq.b	ffe02936 <_Reset_Vector+0xffe0293a>
ffe028ce:	61 15                         	cmp	#1, r5
ffe028d0:	16                            	beq.s	ffe028d6 <_Reset_Vector+0xffe028da>

ffe028d1 <.LVL484>:
            ret = RIIC_ERR_OTHER;
ffe028d1:	66 81                         	mov.l	#8, r1

ffe028d3 <.LVL485>:
} /* End of function riic_after_send_slvadr() */
ffe028d3:	3f 6a 08                      	rtsd	#32, r6-r10

ffe028d6 <.LVL486>:
            if (((uint8_t *) FIT_NO_PTR != (uint8_t *) p_riic_info->p_data1st)
ffe028d6:	ed 1a 05                      	mov.l	20[r1], r10
ffe028d9:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe028df:	3a 6e 01                      	beq.w	ffe02a4d <_Reset_Vector+0xffe02a51>
                    && ((uint8_t *) FIT_NO_PTR != (uint8_t *) p_riic_info->p_data2nd))
ffe028e2:	ed 1a 04                      	mov.l	16[r1], r10
ffe028e5:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe028eb:	3a 62 01                      	beq.w	ffe02a4d <_Reset_Vector+0xffe02a51>

ffe028ee <.LBB1028>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe028ee:	88 9d                         	mov.b	3[r1], r5

ffe028f0 <.LBB1031>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe028f0:	88 99                         	mov.b	3[r1], r1

ffe028f2 <.LVL489>:
ffe028f2:	75 42 52                      	mov.l	#82, r2

ffe028f5 <.LBB1034>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe028f5:	5b 55                         	movu.b	r5, r5
ffe028f7:	6c 45                         	shll	#4, r5

ffe028f9 <.LVL490>:
ffe028f9:	70 55 24 00 00 00             	add	#36, r5, r5
ffe028ff:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe02903:	3e 52 06                      	mov.l	#6, 8[r5]

ffe02906 <.LBB1035>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02906:	05 4e e7 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe0290a <.LBE1035>:
                if (0x00000000 != p_riic_info->cnt1st)
ffe0290a:	ed 7a 03                      	mov.l	12[r7], r10
ffe0290d:	61 0a                         	cmp	#0, r10
ffe0290f:	20 c2                         	beq.b	ffe028d1 <_Reset_Vector+0xffe028d5>
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffe02911:	a9 7e                         	mov.l	20[r7], r6

ffe02913 <.LBB1036>:
    volatile uint8_t uctmp = 0x00;
ffe02913:	3c 07 00                      	mov.b	#0, 7[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02916:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02919:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe0291b:	5b aa                         	movu.b	r10, r10
ffe0291d:	6c 5a                         	shll	#5, r10
ffe0291f:	73 aa 12 83 08                	add	#0x88312, r10, r10

ffe02924 <.LVL494>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02924:	05 0a e7 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe02928 <.LVL495>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02928:	cc 65                         	mov.b	[r6], r5

ffe0292a <.LBE1036>:
    riic_return_t ret = RIIC_SUCCESS;
ffe0292a:	66 01                         	mov.l	#0, r1

ffe0292c <.LBB1039>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe0292c:	c3 a5                         	mov.b	r5, [r10]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe0292e:	cc aa                         	mov.b	[r10], r10

ffe02930 <.LVL496>:
ffe02930:	c7 0a 07                      	mov.b	r10, 7[r0]

ffe02933 <.LBE1039>:
                    p_riic_info->cnt1st--;
ffe02933:	38 07 01                      	bra.w	ffe02a3a <_Reset_Vector+0xffe02a3e>

ffe02936 <.LVL498>:
            switch (riic_api_info[p_riic_info->ch_no].N_status)
ffe02936:	b0 9d                         	movu.b	3[r1], r5
ffe02938:	6c 45                         	shll	#4, r5
ffe0293a:	70 55 24 00 00 00             	add	#36, r5, r5
ffe02940:	a8 d5                         	mov.l	8[r5], r5
ffe02942:	61 45                         	cmp	#4, r5
ffe02944:	3a b8 00                      	beq.w	ffe029fc <_Reset_Vector+0xffe02a00>
ffe02947:	61 55                         	cmp	#5, r5
ffe02949:	21 88                         	bne.b	ffe028d1 <_Reset_Vector+0xffe028d5>

ffe0294b <.LBB1040>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe0294b:	88 9d                         	mov.b	3[r1], r5

ffe0294d <.LBB1043>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe0294d:	88 99                         	mov.b	3[r1], r1

ffe0294f <.LVL501>:
ffe0294f:	75 42 32                      	mov.l	#50, r2

ffe02952 <.LBB1046>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02952:	5b 55                         	movu.b	r5, r5
ffe02954:	6c 45                         	shll	#4, r5

ffe02956 <.LVL502>:
ffe02956:	70 55 24 00 00 00             	add	#36, r5, r5
ffe0295c:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe02960:	3e 52 07                      	mov.l	#7, 8[r5]

ffe02963 <.LBB1047>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02963:	05 f1 e6 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02967 <.LBE1047>:
                    if (2U >= p_riic_info->cnt2nd)
ffe02967:	ed 7a 02                      	mov.l	8[r7], r10
ffe0296a:	61 2a                         	cmp	#2, r10
ffe0296c:	24 16                         	bgtu.b	ffe02982 <_Reset_Vector+0xffe02986>

ffe0296e <.LBB1048>:
    volatile uint8_t uctmp = 0x00;
ffe0296e:	3c 03 00                      	mov.b	#0, 3[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe02971:	59 7a 03                      	movu.b	3[r7], r10
ffe02974:	6c 5a                         	shll	#5, r10
ffe02976:	73 aa 04 83 08                	add	#0x88304, r10, r10

ffe0297b <.LVL506>:
    (*picmr3_reg) |= RIIC_ICMR3_WAIT_SET;
ffe0297b:	f0 a6                         	bset	#6, [r10].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffe0297d:	cc aa                         	mov.b	[r10], r10

ffe0297f <.LVL507>:
ffe0297f:	c7 0a 03                      	mov.b	r10, 3[r0]

ffe02982 <.LVL508>:
                    if (0x00000001 >= p_riic_info->cnt2nd)
ffe02982:	ed 7a 02                      	mov.l	8[r7], r10
ffe02985:	61 1a                         	cmp	#1, r10
ffe02987:	24 05                         	bgtu.b	ffe0298c <_Reset_Vector+0xffe02990>
ffe02989:	38 32 01                      	bra.w	ffe02abb <_Reset_Vector+0xffe02abf>
ffe0298c:	76 10 01 00                   	nop	; mul	#1, r0

ffe02990 <.LBB1050>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe02990:	88 ff                         	mov.b	3[r7], r7

ffe02992 <.LBE1050>:
    riic_return_t ret = RIIC_SUCCESS;
ffe02992:	66 01                         	mov.l	#0, r1

ffe02994 <.LBB1053>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe02994:	5b 77                         	movu.b	r7, r7
ffe02996:	6c 57                         	shll	#5, r7
ffe02998:	73 77 13 83 08                	add	#0x88313, r7, r7

ffe0299d <.LVL511>:
    return *picdrr_reg;
ffe0299d:	cc 77                         	mov.b	[r7], r7

ffe0299f <.LBE1053>:
                    uctmp = riic_get_receiving_data(p_riic_info);
ffe0299f:	82 07                         	mov.b	r7, 8[r0]
} /* End of function riic_after_send_slvadr() */
ffe029a1:	3f 6a 08                      	rtsd	#32, r6-r10

ffe029a4 <.LBB1054>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe029a4:	88 9d                         	mov.b	3[r1], r5

ffe029a6 <.LBB1057>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe029a6:	88 99                         	mov.b	3[r1], r1

ffe029a8 <.LVL515>:
ffe029a8:	75 42 32                      	mov.l	#50, r2

ffe029ab <.LBB1060>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe029ab:	5b 55                         	movu.b	r5, r5
ffe029ad:	6c 45                         	shll	#4, r5

ffe029af <.LVL516>:
ffe029af:	70 55 24 00 00 00             	add	#36, r5, r5
ffe029b5:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe029b9:	3e 52 07                      	mov.l	#7, 8[r5]

ffe029bc <.LBB1061>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe029bc:	05 98 e6 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe029c0 <.LBE1061>:
            if (2U >= p_riic_info->cnt2nd)
ffe029c0:	ed 7a 02                      	mov.l	8[r7], r10
ffe029c3:	61 2a                         	cmp	#2, r10
ffe029c5:	24 15                         	bgtu.b	ffe029da <_Reset_Vector+0xffe029de>

ffe029c7 <.LBB1062>:
    volatile uint8_t uctmp = 0x00;
ffe029c7:	3c 05 00                      	mov.b	#0, 5[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe029ca:	b0 fd                         	movu.b	3[r7], r5
ffe029cc:	6c 55                         	shll	#5, r5
ffe029ce:	73 55 04 83 08                	add	#0x88304, r5, r5

ffe029d3 <.LVL520>:
    (*picmr3_reg) |= RIIC_ICMR3_WAIT_SET;
ffe029d3:	f0 56                         	bset	#6, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3. */
ffe029d5:	cc 5a                         	mov.b	[r5], r10
ffe029d7:	c7 0a 05                      	mov.b	r10, 5[r0]

ffe029da <.LVL521>:
            if (0x00000001 >= p_riic_info->cnt2nd)
ffe029da:	ed 7a 02                      	mov.l	8[r7], r10
ffe029dd:	61 1a                         	cmp	#1, r10
ffe029df:	24 b1                         	bgtu.b	ffe02990 <_Reset_Vector+0xffe02994>

ffe029e1 <.LBB1064>:
    volatile uint8_t uctmp = 0x00;
ffe029e1:	3c 01 00                      	mov.b	#0, 1[r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe029e4:	b0 fd                         	movu.b	3[r7], r5
ffe029e6:	6c 55                         	shll	#5, r5
ffe029e8:	73 55 04 83 08                	add	#0x88304, r5, r5

ffe029ed <.LVL523>:
    (*picmr3_reg) |= RIIC_ICMR3_RDRFS_SET;
ffe029ed:	f0 55                         	bset	#5, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled.                */
ffe029ef:	f0 54                         	bset	#4, [r5].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET; /* A 1 is sent as the acknowledge bit (NACK transmission).  */
ffe029f1:	f0 53                         	bset	#3, [r5].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled.               */
ffe029f3:	f0 5c                         	bclr	#4, [r5].b
    uctmp = *picmr3_reg; /* Reads ICMR3.                                             */
ffe029f5:	cc 5a                         	mov.b	[r5], r10
ffe029f7:	c7 0a 01                      	mov.b	r10, 1[r0]

ffe029fa <.LBB1066>:
    volatile uint8_t * const picdrr_reg = RIIC_ICDRR_ADR(p_riic_info->ch_no);
ffe029fa:	2e 96                         	bra.b	ffe02990 <_Reset_Vector+0xffe02994>

ffe029fc <.LBB1068>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe029fc:	88 9d                         	mov.b	3[r1], r5

ffe029fe <.LBB1071>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe029fe:	88 99                         	mov.b	3[r1], r1

ffe02a00 <.LVL527>:
ffe02a00:	75 42 52                      	mov.l	#82, r2

ffe02a03 <.LBB1074>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02a03:	5b 55                         	movu.b	r5, r5
ffe02a05:	6c 45                         	shll	#4, r5

ffe02a07 <.LVL528>:
ffe02a07:	70 55 24 00 00 00             	add	#36, r5, r5
ffe02a0d:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe02a11:	3e 52 06                      	mov.l	#6, 8[r5]

ffe02a14 <.LBB1075>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02a14:	05 40 e6 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02a18 <.LBE1075>:
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data1st);
ffe02a18:	a9 7e                         	mov.l	20[r7], r6

ffe02a1a <.LBB1076>:
    volatile uint8_t uctmp = 0x00;
ffe02a1a:	3c 04 00                      	mov.b	#0, 4[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02a1d:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02a20:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02a22:	5b aa                         	movu.b	r10, r10
ffe02a24:	6c 5a                         	shll	#5, r10
ffe02a26:	73 aa 12 83 08                	add	#0x88312, r10, r10

ffe02a2b <.LVL532>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02a2b:	05 03 e6 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe02a2f <.LVL533>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02a2f:	cc 65                         	mov.b	[r6], r5

ffe02a31 <.LBE1076>:
    riic_return_t ret = RIIC_SUCCESS;
ffe02a31:	66 01                         	mov.l	#0, r1

ffe02a33 <.LBB1079>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02a33:	c3 a5                         	mov.b	r5, [r10]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe02a35:	cc aa                         	mov.b	[r10], r10

ffe02a37 <.LVL534>:
ffe02a37:	c7 0a 04                      	mov.b	r10, 4[r0]

ffe02a3a <.LBE1079>:
                    p_riic_info->cnt1st--;
ffe02a3a:	ed 7a 03                      	mov.l	12[r7], r10
ffe02a3d:	60 1a                         	sub	#1, r10
ffe02a3f:	e7 7a 03                      	mov.l	r10, 12[r7]
                    p_riic_info->p_data1st++;
ffe02a42:	ed 7a 05                      	mov.l	20[r7], r10
ffe02a45:	62 1a                         	add	#1, r10
ffe02a47:	e7 7a 05                      	mov.l	r10, 20[r7]
} /* End of function riic_after_send_slvadr() */
ffe02a4a:	3f 6a 08                      	rtsd	#32, r6-r10

ffe02a4d <.LVL536>:
            else if (((uint8_t *) FIT_NO_PTR == p_riic_info->p_data1st)
ffe02a4d:	ed 7a 05                      	mov.l	20[r7], r10
ffe02a50:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe02a56:	3a 81 00                      	beq.w	ffe02ad7 <_Reset_Vector+0xffe02adb>
            else if (((uint8_t *) FIT_NO_PTR == p_riic_info->p_data1st)
ffe02a59:	ed 7a 05                      	mov.l	20[r7], r10
ffe02a5c:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe02a62:	3b 6f fe                      	bne.w	ffe028d1 <_Reset_Vector+0xffe028d5>
                    && ((uint8_t *) FIT_NO_PTR == p_riic_info->p_data2nd))
ffe02a65:	ed 7a 04                      	mov.l	16[r7], r10
ffe02a68:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe02a6e:	3b 63 fe                      	bne.w	ffe028d1 <_Reset_Vector+0xffe028d5>

ffe02a71 <.LBB1080>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe02a71:	cd 7a 03                      	mov.b	3[r7], r10

ffe02a74 <.LBB1083>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02a74:	88 f9                         	mov.b	3[r7], r1

ffe02a76 <.LVL539>:
ffe02a76:	75 42 1a                      	mov.l	#26, r2

ffe02a79 <.LBB1086>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02a79:	5b aa                         	movu.b	r10, r10
ffe02a7b:	6c 4a                         	shll	#4, r10

ffe02a7d <.LVL540>:
ffe02a7d:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe02a83:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffe02a87:	f9 a6 02 08                   	mov.l	#8, 8[r10]

ffe02a8b <.LBB1087>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02a8b:	05 c9 e5 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02a8f <.LBB1088>:
    volatile uint8_t uctmp = 0x00;
ffe02a8f:	3c 02 00                      	mov.b	#0, 2[r0]
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02a92:	cd 7a 03                      	mov.b	3[r7], r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02a95:	88 ff                         	mov.b	3[r7], r7

ffe02a97 <.LVL543>:
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02a97:	5b aa                         	movu.b	r10, r10
ffe02a99:	6c 5a                         	shll	#5, r10
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02a9b:	5b 77                         	movu.b	r7, r7
    volatile uint8_t * const picsr2_reg = RIIC_ICSR2_ADR(p_riic_info->ch_no);
ffe02a9d:	73 aa 09 83 08                	add	#0x88309, r10, r10

ffe02aa2 <.LVL544>:
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02aa2:	6c 57                         	shll	#5, r7
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe02aa4:	cc a5                         	mov.b	[r10], r5
    volatile uint8_t * const piccr2_reg = RIIC_ICCR2_ADR(p_riic_info->ch_no);
ffe02aa6:	73 77 01 83 08                	add	#0x88301, r7, r7

ffe02aab <.LVL545>:
    if (0x00 != (((*picsr2_reg) & RIIC_ICSR2_STOP_SET) >> 3U))
ffe02aab:	7c 35                         	btst	#3, r5
ffe02aad:	13                            	beq.s	ffe02ab0 <_Reset_Vector+0xffe02ab4>
        (*picsr2_reg) &= RIIC_ICSR2_STOP_CLR;
ffe02aae:	f0 ab                         	bclr	#3, [r10].b
    (*piccr2_reg) |= RIIC_ICCR2_SP; /* Sets ICCR2.SP bit. */
ffe02ab0:	f0 73                         	bset	#3, [r7].b
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe02ab2:	cc 77                         	mov.b	[r7], r7

ffe02ab4 <.LBE1088>:
    riic_return_t ret = RIIC_SUCCESS;
ffe02ab4:	66 01                         	mov.l	#0, r1

ffe02ab6 <.LBB1091>:
    uctmp = *piccr2_reg; /* Reads ICCR2. */
ffe02ab6:	80 87                         	mov.b	r7, 2[r0]

ffe02ab8 <.LBE1091>:
} /* End of function riic_after_send_slvadr() */
ffe02ab8:	3f 6a 08                      	rtsd	#32, r6-r10

ffe02abb <.LBB1092>:
    volatile uint8_t uctmp = 0x00;
ffe02abb:	f8 04 00                      	mov.b	#0, [r0]
    volatile uint8_t * const picmr3_reg = RIIC_ICMR3_ADR(p_riic_info->ch_no);
ffe02abe:	59 7a 03                      	movu.b	3[r7], r10
ffe02ac1:	6c 5a                         	shll	#5, r10
ffe02ac3:	73 aa 04 83 08                	add	#0x88304, r10, r10

ffe02ac8 <.LVL548>:
    (*picmr3_reg) |= RIIC_ICMR3_RDRFS_SET;
ffe02ac8:	f0 a5                         	bset	#5, [r10].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKWP_SET; /* Modification of the ACKBT bit is enabled.                */
ffe02aca:	f0 a4                         	bset	#4, [r10].b
    (*picmr3_reg) |= RIIC_ICMR3_ACKBT_SET; /* A 1 is sent as the acknowledge bit (NACK transmission).  */
ffe02acc:	f0 a3                         	bset	#3, [r10].b
    (*picmr3_reg) &= RIIC_ICMR3_ACKWP_CLR; /* Modification of the ACKBT bit is disabled.               */
ffe02ace:	f0 ac                         	bclr	#4, [r10].b
    uctmp = *picmr3_reg; /* Reads ICMR3.                                             */
ffe02ad0:	cc aa                         	mov.b	[r10], r10

ffe02ad2 <.LVL549>:
ffe02ad2:	c3 0a                         	mov.b	r10, [r0]
ffe02ad4:	38 bc fe                      	bra.w	ffe02990 <_Reset_Vector+0xffe02994>

ffe02ad7 <.LVL550>:
                    && ((uint8_t *) FIT_NO_PTR != p_riic_info->p_data2nd))
ffe02ad7:	ed 7a 04                      	mov.l	16[r7], r10
ffe02ada:	74 0a 00 00 00 10             	cmp	#0x10000000, r10
ffe02ae0:	3a 79 ff                      	beq.w	ffe02a59 <_Reset_Vector+0xffe02a5d>

ffe02ae3 <.LBB1094>:
    uint8_t ch_no = p_riic_info->ch_no;
ffe02ae3:	cd 7a 03                      	mov.b	3[r7], r10

ffe02ae6 <.LBB1097>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02ae6:	88 f9                         	mov.b	3[r7], r1

ffe02ae8 <.LVL553>:
ffe02ae8:	75 42 52                      	mov.l	#82, r2

ffe02aeb <.LBB1100>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02aeb:	5b aa                         	movu.b	r10, r10
ffe02aed:	6c 4a                         	shll	#4, r10

ffe02aef <.LVL554>:
ffe02aef:	70 aa 24 00 00 00             	add	#36, r10, r10
ffe02af5:	e5 aa 02 03                   	mov.l	8[r10], 12[r10]
    riic_api_info[ch_no].N_status = new_status;
ffe02af9:	f9 a6 02 06                   	mov.l	#6, 8[r10]

ffe02afd <.LBB1101>:
    riic_mcu_int_icier_setting(p_riic_info->ch_no, New_icier);
ffe02afd:	05 57 e5 ff                   	bsr.a	ffe01054 <_Reset_Vector+0xffe01058>

ffe02b01 <.LBE1101>:
                if (0x00000000 != p_riic_info->cnt2nd)
ffe02b01:	ed 7a 02                      	mov.l	8[r7], r10
ffe02b04:	61 0a                         	cmp	#0, r10
ffe02b06:	3a cb fd                      	beq.w	ffe028d1 <_Reset_Vector+0xffe028d5>
                    riic_set_sending_data(p_riic_info, p_riic_info->p_data2nd);
ffe02b09:	a9 76                         	mov.l	16[r7], r6

ffe02b0b <.LBB1102>:
    volatile uint8_t uctmp = 0x00;
ffe02b0b:	3c 06 00                      	mov.b	#0, 6[r0]
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02b0e:	cd 7a 03                      	mov.b	3[r7], r10
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02b11:	88 f9                         	mov.b	3[r7], r1
    volatile uint8_t * const picdrt_reg = RIIC_ICDRT_ADR(p_riic_info->ch_no);
ffe02b13:	5b aa                         	movu.b	r10, r10
ffe02b15:	6c 5a                         	shll	#5, r10
ffe02b17:	73 aa 12 83 08                	add	#0x88312, r10, r10

ffe02b1c <.LVL558>:
    riic_mcu_clear_ir_txi(p_riic_info->ch_no);
ffe02b1c:	05 12 e5 ff                   	bsr.a	ffe0102e <_Reset_Vector+0xffe01032>

ffe02b20 <.LVL559>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02b20:	cc 65                         	mov.b	[r6], r5

ffe02b22 <.LBE1102>:
    riic_return_t ret = RIIC_SUCCESS;
ffe02b22:	66 01                         	mov.l	#0, r1

ffe02b24 <.LBB1105>:
    *picdrt_reg = *p_data; /* Writes data to RIIC in order to transmit. */
ffe02b24:	c3 a5                         	mov.b	r5, [r10]
    uctmp = *picdrt_reg; /* Reads ICDRT. */
ffe02b26:	cc aa                         	mov.b	[r10], r10

ffe02b28 <.LVL560>:
ffe02b28:	c7 0a 06                      	mov.b	r10, 6[r0]

ffe02b2b <.LBE1105>:
                    p_riic_info->cnt2nd--;
ffe02b2b:	ed 7a 02                      	mov.l	8[r7], r10
ffe02b2e:	60 1a                         	sub	#1, r10
ffe02b30:	e7 7a 02                      	mov.l	r10, 8[r7]
                    p_riic_info->p_data2nd++;
ffe02b33:	ed 7a 04                      	mov.l	16[r7], r10
ffe02b36:	62 1a                         	add	#1, r10
ffe02b38:	e7 7a 04                      	mov.l	r10, 16[r7]
} /* End of function riic_after_send_slvadr() */
ffe02b3b:	3f 6a 08                      	rtsd	#32, r6-r10

ffe02b3e <.LFE25>:
ffe02b3e:	ef 00                         	nop	; mov.l	r0, r0

ffe02b40 <_riic1_eei_sub>:
 *                start condition detection, and stop condition detection.
 * Arguments    : None
 * Return Value : None
 **********************************************************************************************************************/
void riic1_eei_sub (void)
{
ffe02b40:	7e a7                         	push.l	r7
    #ifdef TN_RXA012A
    riic_timeout_counter_clear(1);
    #endif

    /* Checks Time Out. */
    if ((0U != RIIC1.ICSR2.BIT.TMOF) && (0U != RIIC1.ICIER.BIT.TMOIE))
ffe02b42:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffe02b47:	8a 5c                         	mov.b	9[r5], r4
ffe02b49:	7c 04                         	btst	#0, r4
ffe02b4b:	20 1d                         	beq.b	ffe02b68 <_Reset_Vector+0xffe02b6c>
ffe02b4d:	89 dc                         	mov.b	7[r5], r4
ffe02b4f:	7c 04                         	btst	#0, r4
ffe02b51:	20 17                         	beq.b	ffe02b68 <_Reset_Vector+0xffe02b6c>
    {
        /* all interrupt disable */
        RIIC1.ICIER.BIT.TMOIE = 0U;
ffe02b53:	f1 58 07                      	bclr	#0, 7[r5].b
        /* WAIT_LOOP */
        while (0U != RIIC1.ICIER.BIT.TMOIE)
ffe02b56:	ef 00                         	nop	; mov.l	r0, r0
ffe02b58:	89 dc                         	mov.b	7[r5], r4
ffe02b5a:	7c 04                         	btst	#0, r4
ffe02b5c:	21 fc                         	bne.b	ffe02b58 <_Reset_Vector+0xffe02b5c>
        {
            /* Do Nothing */
        }
        riic_api_event[1] = RIIC_EV_INT_TMO;
ffe02b5e:	fb 72 54 00 00 00             	mov.l	#84, r7
ffe02b64:	3e 71 0a                      	mov.l	#10, 4[r7]
ffe02b67:	03                            	nop
    }

    /* Checks Arbitration Lost. */
    if ((0U != RIIC1.ICSR2.BIT.AL) && (0U != RIIC1.ICIER.BIT.ALIE))
ffe02b68:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffe02b6d:	8a 5c                         	mov.b	9[r5], r4
ffe02b6f:	7c 14                         	btst	#1, r4
ffe02b71:	10                            	beq.s	ffe02b79 <_Reset_Vector+0xffe02b7d>
ffe02b72:	89 dc                         	mov.b	7[r5], r4
ffe02b74:	7c 14                         	btst	#1, r4
ffe02b76:	3b 04 01                      	bne.w	ffe02c7a <_Reset_Vector+0xffe02c7e>
ffe02b79:	fb 72 24 00 00 00             	mov.l	#36, r7
ffe02b7f:	03                            	nop
            riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
        }
    }

    /* Checks stop condition detection. */
    if ((0U != RIIC1.ICSR2.BIT.STOP) && (0U != RIIC1.ICIER.BIT.SPIE))
ffe02b80:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffe02b85:	8a 5c                         	mov.b	9[r5], r4
ffe02b87:	7c 34                         	btst	#3, r4
ffe02b89:	10                            	beq.s	ffe02b91 <_Reset_Vector+0xffe02b95>
ffe02b8a:	89 dd                         	mov.b	7[r5], r5
ffe02b8c:	7c 35                         	btst	#3, r5
ffe02b8e:	3b a1 00                      	bne.w	ffe02c2f <_Reset_Vector+0xffe02c33>
        /* Sets event flag. */
        riic_api_event[1] = RIIC_EV_INT_STOP;
    }

    /* Checks NACK reception. */
    if ((0U != RIIC1.ICSR2.BIT.NACKF) && (0U != RIIC1.ICIER.BIT.NAKIE))
ffe02b91:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffe02b96:	8a 5c                         	mov.b	9[r5], r4
ffe02b98:	7c 44                         	btst	#4, r4
ffe02b9a:	20 40                         	beq.b	ffe02bda <_Reset_Vector+0xffe02bde>
ffe02b9c:	89 dc                         	mov.b	7[r5], r4
ffe02b9e:	7c 44                         	btst	#4, r4
ffe02ba0:	20 3a                         	beq.b	ffe02bda <_Reset_Vector+0xffe02bde>
    {
        /* Prohibits NACK interrupt to generate stop condition. */
        RIIC1.ICIER.BIT.NAKIE = 0U;
ffe02ba2:	f1 5c 07                      	bclr	#4, 7[r5].b

        /* Prohibits these interrupt. */
        /* After NACK interrupt, these interrupts will occur when they do not stop the following interrupts. */
        RIIC1.ICIER.BIT.TEIE = 0U;
ffe02ba5:	f1 5e 07                      	bclr	#6, 7[r5].b
        RIIC1.ICIER.BIT.TIE = 0U;
ffe02ba8:	89 db                         	mov.b	7[r5], r3
        RIIC1.ICIER.BIT.RIE = 0U;
        /* WAIT_LOOP */
        while (((0U != RIIC1.ICIER.BIT.TEIE) || (0U != RIIC1.ICIER.BIT.TIE)) || (0U != RIIC1.ICIER.BIT.RIE) )
ffe02baa:	ef 54                         	mov.l	r5, r4
        RIIC1.ICIER.BIT.TIE = 0U;
ffe02bac:	7a 73                         	bclr	#7, r3
ffe02bae:	81 db                         	mov.b	r3, 7[r5]
        RIIC1.ICIER.BIT.RIE = 0U;
ffe02bb0:	f1 5d 07                      	bclr	#5, 7[r5].b
        while (((0U != RIIC1.ICIER.BIT.TEIE) || (0U != RIIC1.ICIER.BIT.TIE)) || (0U != RIIC1.ICIER.BIT.RIE) )
ffe02bb3:	77 10 01 00 00                	nop	; mul	#1, r0
ffe02bb8:	89 cd                         	mov.b	7[r4], r5
ffe02bba:	7c 65                         	btst	#6, r5
ffe02bbc:	21 fc                         	bne.b	ffe02bb8 <_Reset_Vector+0xffe02bbc>
ffe02bbe:	89 cd                         	mov.b	7[r4], r5
ffe02bc0:	7c 75                         	btst	#7, r5
ffe02bc2:	21 f6                         	bne.b	ffe02bb8 <_Reset_Vector+0xffe02bbc>
ffe02bc4:	89 cd                         	mov.b	7[r4], r5
ffe02bc6:	7c 55                         	btst	#5, r5
ffe02bc8:	21 f0                         	bne.b	ffe02bb8 <_Reset_Vector+0xffe02bbc>
        {
            /* Do Nothing */
        }

        if (0U == RIIC1.ICCR2.BIT.TRS)
ffe02bca:	88 4d                         	mov.b	1[r4], r5
ffe02bcc:	7c 55                         	btst	#5, r5
ffe02bce:	3a 12 01                      	beq.w	ffe02ce0 <_Reset_Vector+0xffe02ce4>
        {
            riic_mcu_clear_ir_rxi(1);
        }

        /* Sets event flag. */
        riic_api_event[1] = RIIC_EV_INT_NACK;
ffe02bd1:	fb 52 54 00 00 00             	mov.l	#84, r5
ffe02bd7:	3e 51 09                      	mov.l	#9, 4[r5]
    }

    /* Checks start condition detection. */
    if ((0U != RIIC1.ICSR2.BIT.START) && (0U != RIIC1.ICIER.BIT.STIE))
ffe02bda:	fb 4e 20 83 08                	mov.l	#0x88320, r4
ffe02bdf:	8a 4d                         	mov.b	9[r4], r5
ffe02be1:	7c 25                         	btst	#2, r5
ffe02be3:	17                            	beq.s	ffe02bea <_Reset_Vector+0xffe02bee>
ffe02be4:	89 cd                         	mov.b	7[r4], r5
ffe02be6:	7c 25                         	btst	#2, r5
ffe02be8:	21 27                         	bne.b	ffe02c0f <_Reset_Vector+0xffe02c13>

        /* Sets event flag. */
        riic_api_event[1] = RIIC_EV_INT_START;
    }

    switch (riic_api_info[1].N_Mode)
ffe02bea:	a9 77                         	mov.l	16[r7], r7
ffe02bec:	61 07                         	cmp	#0, r7
ffe02bee:	20 1e                         	beq.b	ffe02c0c <_Reset_Vector+0xffe02c10>
ffe02bf0:	61 37                         	cmp	#3, r7
ffe02bf2:	24 05                         	bgtu.b	ffe02bf7 <_Reset_Vector+0xffe02bfb>
ffe02bf4:	38 c0 00                      	bra.w	ffe02cb4 <_Reset_Vector+0xffe02cb8>
ffe02bf7:	61 67                         	cmp	#6, r7
ffe02bf9:	24 13                         	bgtu.b	ffe02c0c <_Reset_Vector+0xffe02c10>
        case RIIC_MODE_S_READY :
        case RIIC_MODE_S_SEND :
        case RIIC_MODE_S_RECEIVE :

            /* Slave mode data */
            p_riic_info = priic_info_s[1];
ffe02bfb:	fb 72 60 00 00 00             	mov.l	#96, r7
ffe02c01:	a8 79                         	mov.l	4[r7], r1

ffe02c03 <.LBB1546>:
    if (NULL == p_riic_info)
ffe02c03:	61 01                         	cmp	#0, r1
ffe02c05:	17                            	beq.s	ffe02c0c <_Reset_Vector+0xffe02c10>

ffe02c06 <.LBE1546>:
            return;
        break;
    }

    r_riic_advance(p_riic_info); /* Calls advance function */
} /* End of function riic1_eei_sub() */
ffe02c06:	7e b7                         	pop	r7

ffe02c08 <.LBB1550>:
        ret = riic_advance(p_riic_info);
ffe02c08:	04 30 e9 ff                   	bra.a	ffe01538 <_Reset_Vector+0xffe0153c>

ffe02c0c <.LBE1550>:
} /* End of function riic1_eei_sub() */
ffe02c0c:	3f 77 01                      	rtsd	#4, r7-r7
        RIIC1.ICIER.BIT.STIE = 0U;
ffe02c0f:	f1 4a 07                      	bclr	#2, 7[r4].b
        RIIC1.ICSR2.BIT.START = 0U;
ffe02c12:	f1 4a 09                      	bclr	#2, 9[r4].b
        while ((0U != RIIC1.ICSR2.BIT.START) || (0U != RIIC1.ICIER.BIT.STIE))
ffe02c15:	fc 13 00                      	nop	; max	r0, r0
ffe02c18:	8a 4d                         	mov.b	9[r4], r5
ffe02c1a:	7c 25                         	btst	#2, r5
ffe02c1c:	21 fc                         	bne.b	ffe02c18 <_Reset_Vector+0xffe02c1c>
ffe02c1e:	89 cd                         	mov.b	7[r4], r5
ffe02c20:	7c 25                         	btst	#2, r5
ffe02c22:	21 f6                         	bne.b	ffe02c18 <_Reset_Vector+0xffe02c1c>
        riic_api_event[1] = RIIC_EV_INT_START;
ffe02c24:	fb 52 54 00 00 00             	mov.l	#84, r5
ffe02c2a:	3e 51 03                      	mov.l	#3, 4[r5]
ffe02c2d:	2e bd                         	bra.b	ffe02bea <_Reset_Vector+0xffe02bee>
                || (RIIC_MODE_S_RECEIVE == riic_api_info[1].N_Mode))
ffe02c2f:	a9 75                         	mov.l	16[r7], r5
ffe02c31:	60 45                         	sub	#4, r5
        if (((RIIC_MODE_S_READY == riic_api_info[1].N_Mode) || (RIIC_MODE_S_SEND == riic_api_info[1].N_Mode))
ffe02c33:	61 25                         	cmp	#2, r5
ffe02c35:	24 05                         	bgtu.b	ffe02c3a <_Reset_Vector+0xffe02c3e>
ffe02c37:	38 8d 00                      	bra.w	ffe02cc4 <_Reset_Vector+0xffe02cc8>
        RIIC1.ICIER.BIT.SPIE = 0U;
ffe02c3a:	fb 4e 20 83 08                	mov.l	#0x88320, r4
ffe02c3f:	f1 4b 07                      	bclr	#3, 7[r4].b
        RIIC1.ICMR3.BIT.RDRFS = 0U; /* Refer to the technical update. */
ffe02c42:	f1 4d 04                      	bclr	#5, 4[r4].b
        RIIC1.ICMR3.BIT.ACKWP = 1U; /* Refer to the technical update. */
ffe02c45:	f1 44 04                      	bset	#4, 4[r4].b
        RIIC1.ICMR3.BIT.ACKBT = 0U; /* Refer to the technical update. */
ffe02c48:	f1 4b 04                      	bclr	#3, 4[r4].b
        RIIC1.ICMR3.BIT.ACKWP = 0U; /* Refer to the technical update. */
ffe02c4b:	f1 4c 04                      	bclr	#4, 4[r4].b
        while ((0U != RIIC1.ICMR3.BIT.RDRFS) || (0U != RIIC1.ICMR3.BIT.ACKBT))
ffe02c4e:	ef 00                         	nop	; mov.l	r0, r0
ffe02c50:	89 45                         	mov.b	4[r4], r5
ffe02c52:	7c 55                         	btst	#5, r5
ffe02c54:	21 fc                         	bne.b	ffe02c50 <_Reset_Vector+0xffe02c54>
ffe02c56:	89 45                         	mov.b	4[r4], r5
ffe02c58:	7c 35                         	btst	#3, r5
ffe02c5a:	21 f6                         	bne.b	ffe02c50 <_Reset_Vector+0xffe02c54>
        RIIC1.ICSR2.BIT.STOP = 0U;
ffe02c5c:	f1 4b 09                      	bclr	#3, 9[r4].b
        while (0U != RIIC1.ICSR2.BIT.STOP)
ffe02c5f:	fb 4e 20 83 08                	mov.l	#0x88320, r4
ffe02c64:	76 10 01 00                   	nop	; mul	#1, r0
ffe02c68:	8a 4d                         	mov.b	9[r4], r5
ffe02c6a:	7c 35                         	btst	#3, r5
ffe02c6c:	21 fc                         	bne.b	ffe02c68 <_Reset_Vector+0xffe02c6c>
        riic_api_event[1] = RIIC_EV_INT_STOP;
ffe02c6e:	fb 52 54 00 00 00             	mov.l	#84, r5
ffe02c74:	3e 51 07                      	mov.l	#7, 4[r5]
ffe02c77:	38 1a ff                      	bra.w	ffe02b91 <_Reset_Vector+0xffe02b95>
        RIIC1.ICIER.BIT.ALIE = 0U;
ffe02c7a:	f1 59 07                      	bclr	#1, 7[r5].b
        while (0U != RIIC1.ICIER.BIT.ALIE)
ffe02c7d:	fc 13 00                      	nop	; max	r0, r0
ffe02c80:	89 dc                         	mov.b	7[r5], r4
ffe02c82:	7c 14                         	btst	#1, r4
ffe02c84:	21 fc                         	bne.b	ffe02c80 <_Reset_Vector+0xffe02c84>
        if (RIIC_MODE_S_READY == riic_api_info[1].B_Mode)
ffe02c86:	fb 72 24 00 00 00             	mov.l	#36, r7
ffe02c8c:	a9 7d                         	mov.l	20[r7], r5
        riic_api_event[1] = RIIC_EV_INT_AL;
ffe02c8e:	fb 42 54 00 00 00             	mov.l	#84, r4
ffe02c94:	3e 41 08                      	mov.l	#8, 4[r4]
        if (RIIC_MODE_S_READY == riic_api_info[1].B_Mode)
ffe02c97:	61 45                         	cmp	#4, r5
ffe02c99:	3b e7 fe                      	bne.w	ffe02b80 <_Reset_Vector+0xffe02b84>
            riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
ffe02c9c:	fb 42 60 00 00 00             	mov.l	#96, r4
ffe02ca2:	a8 4b                         	mov.l	4[r4], r3

ffe02ca4 <.LBB1551>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe02ca4:	b0 bc                         	movu.b	3[r3], r4
ffe02ca6:	fb 22 0c 02 00 00             	mov.l	#524, r2
ffe02cac:	fe 04 25                      	mov.b	r5, [r4, r2]
    p_riic_info->dev_sts = status;
ffe02caf:	80 b5                         	mov.b	r5, 2[r3]
ffe02cb1:	38 cf fe                      	bra.w	ffe02b80 <_Reset_Vector+0xffe02b84>

ffe02cb4 <.LVL784>:
            p_riic_info = priic_info_m[1];
ffe02cb4:	fb 72 6c 00 00 00             	mov.l	#108, r7
ffe02cba:	a8 79                         	mov.l	4[r7], r1

ffe02cbc <.LBB1553>:
    if (NULL == p_riic_info)
ffe02cbc:	61 01                         	cmp	#0, r1
ffe02cbe:	3b 48 ff                      	bne.w	ffe02c06 <_Reset_Vector+0xffe02c0a>
ffe02cc1:	38 4b ff                      	bra.w	ffe02c0c <_Reset_Vector+0xffe02c10>

ffe02cc4 <.LBE1553>:
            riic_api_status_set(priic_info_s[1], RIIC_STS_SP_COND_WAIT);
ffe02cc4:	fb 52 60 00 00 00             	mov.l	#96, r5
ffe02cca:	a8 5d                         	mov.l	4[r5], r5

ffe02ccc <.LBB1554>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02ccc:	b0 dd                         	movu.b	3[r5], r5

ffe02cce <.LVL788>:
ffe02cce:	6c 45                         	shll	#4, r5
ffe02cd0:	70 55 24 00 00 00             	add	#36, r5, r5
ffe02cd6:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe02cda:	3e 52 08                      	mov.l	#8, 8[r5]
ffe02cdd:	38 5d ff                      	bra.w	ffe02c3a <_Reset_Vector+0xffe02c3e>

ffe02ce0 <.LVL789>:
            riic_mcu_clear_ir_rxi(1);
ffe02ce0:	66 11                         	mov.l	#1, r1
ffe02ce2:	05 5f e3 ff                   	bsr.a	ffe01041 <_Reset_Vector+0xffe01045>

ffe02ce6 <.LVL790>:
ffe02ce6:	38 eb fe                      	bra.w	ffe02bd1 <_Reset_Vector+0xffe02bd5>

ffe02ce9 <.LFE62>:
ffe02ce9:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe02cf0 <_riic1_txi_sub>:
    /* TXI processing is performed only when the following conditions are all met.                 */
    /*  - The address part of data has been received and the received address matches the RX's     */
    /*    own address.                                                                             */
    /*  - The RX device is in slave mode.                                                          */
    /*  - The RX device is in transmission mode (the R/W bit received is 'R' (slave transmission)) */
    tmp = RIIC1.ICCR2.BYTE;
ffe02cf0:	fb 5e 20 83 08                	mov.l	#0x88320, r5
ffe02cf5:	88 5d                         	mov.b	1[r5], r5

ffe02cf7 <.LVL791>:
    if ((RIIC_ICCR2_MST_SET != (tmp & RIIC_ICCR2_MST)) && (RIIC_ICCR2_TRS_SET == (tmp & RIIC_ICCR2_TRS)))
ffe02cf7:	75 25 60                      	and	#96, r5

ffe02cfa <.LVL792>:
ffe02cfa:	75 55 20                      	cmp	#32, r5
ffe02cfd:	20 03                         	beq.b	ffe02d00 <_Reset_Vector+0xffe02d04>
ffe02cff:	02                            	rts
        /* Processing when the addresses match (slave send specified) */

        /* Determines whether the state is arbitration-lost detected.                           */
        /* When an arbitration-lost is detected, the riic_after_receive_slvadr function is not  */
        /* executed. Thus the internal status needs to be changed to "RIIC_STS_SEND_DATA_WAIT". */
        if (RIIC_STS_AL == riic_api_info[1].N_status)
ffe02d00:	fb 42 24 00 00 00             	mov.l	#36, r4
ffe02d06:	a9 c5                         	mov.l	24[r4], r5
ffe02d08:	fb 32 60 00 00 00             	mov.l	#96, r3
ffe02d0e:	a8 39                         	mov.l	4[r3], r1
ffe02d10:	61 95                         	cmp	#9, r5
ffe02d12:	21 11                         	bne.b	ffe02d23 <_Reset_Vector+0xffe02d27>

ffe02d14 <.LBB1556>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02d14:	b0 9d                         	movu.b	3[r1], r5
ffe02d16:	6c 45                         	shll	#4, r5
ffe02d18:	4b 45                         	add	r4, r5
ffe02d1a:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe02d1e:	3e 52 06                      	mov.l	#6, 8[r5]
ffe02d21:	a9 c5                         	mov.l	24[r4], r5

ffe02d23 <.LVL794>:
        }

        /* Determines if the slave transmission is the first slave transmission.             */
        /* N_mode is updated from "RIIC_MODE_S_READY" to "RIIC_MODE_S_SEND" on the first TXI */
        /* interrupt after the slave transmission is determined.                             */
        if (RIIC_MODE_S_READY == riic_api_info[1].N_Mode)
ffe02d23:	a9 43                         	mov.l	16[r4], r3
ffe02d25:	61 43                         	cmp	#4, r3
ffe02d27:	1c                            	bne.s	ffe02d2b <_Reset_Vector+0xffe02d2f>
        {
            /* Processing for the first slave transmission */
            /* Sets the internal mode. */
            riic_api_info[1].N_Mode = RIIC_MODE_S_SEND; /* Set slave transmission mode. */
ffe02d28:	3e 44 05                      	mov.l	#5, 16[r4]
        }

        /* Sets event. */
        switch (riic_api_info[1].N_status)
ffe02d2b:	61 25                         	cmp	#2, r5
ffe02d2d:	20 1e                         	beq.b	ffe02d4b <_Reset_Vector+0xffe02d4f>
ffe02d2f:	61 65                         	cmp	#6, r5
ffe02d31:	20 0b                         	beq.b	ffe02d3c <_Reset_Vector+0xffe02d40>

ffe02d33 <.LBB1558>:
    if (NULL == p_riic_info)
ffe02d33:	61 01                         	cmp	#0, r1
ffe02d35:	20 ca                         	beq.b	ffe02cff <_Reset_Vector+0xffe02d03>
ffe02d37:	03                            	nop

ffe02d38 <.LVL796>:
        ret = riic_advance(p_riic_info);
ffe02d38:	04 00 e8 ff                   	bra.a	ffe01538 <_Reset_Vector+0xffe0153c>

ffe02d3c <.LBE1558>:
            break;

            case RIIC_STS_SEND_DATA_WAIT :

                /* Sets interrupted data sending. */
                riic_api_event[1] = RIIC_EV_INT_SEND;
ffe02d3c:	fb 52 54 00 00 00             	mov.l	#84, r5
ffe02d42:	3e 51 05                      	mov.l	#5, 4[r5]

ffe02d45 <.LBB1563>:
    if (NULL == p_riic_info)
ffe02d45:	61 01                         	cmp	#0, r1
ffe02d47:	21 f1                         	bne.b	ffe02d38 <_Reset_Vector+0xffe02d3c>
ffe02d49:	2e b6                         	bra.b	ffe02cff <_Reset_Vector+0xffe02d03>

ffe02d4b <.LBE1563>:
{
ffe02d4b:	7e a7                         	push.l	r7

ffe02d4d <.LBB1564>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe02d4d:	b0 9d                         	movu.b	3[r1], r5

ffe02d4f <.LBE1564>:
                riic_api_event[1] = RIIC_EV_INT_ADD;
ffe02d4f:	fb 42 54 00 00 00             	mov.l	#84, r4
ffe02d55:	3e 41 04                      	mov.l	#4, 4[r4]

ffe02d58 <.LBB1567>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe02d58:	fb 42 0c 02 00 00             	mov.l	#524, r4
ffe02d5e:	66 47                         	mov.l	#4, r7
ffe02d60:	fe 05 47                      	mov.b	r7, [r5, r4]
    p_riic_info->dev_sts = status;
ffe02d63:	80 97                         	mov.b	r7, 2[r1]

ffe02d65 <.LBB1568>:
        }

        r_riic_advance(priic_info_s[1]); /* Calls advance function */

    }
} /* End of function riic1_txi_sub() */
ffe02d65:	7e b7                         	pop	r7

ffe02d67 <.LBB1569>:
        ret = riic_advance(p_riic_info);
ffe02d67:	04 d1 e7 ff                   	bra.a	ffe01538 <_Reset_Vector+0xffe0153c>

ffe02d6b <.LBE1569>:
ffe02d6b:	77 10 01 00 00                	nop	; mul	#1, r0

ffe02d70 <_riic1_rxi_sub>:

    #ifdef TN_RXA012A
    riic_timeout_counter_clear(1);
    #endif

    if (RIIC_STS_AL == riic_api_info[1].N_status)
ffe02d70:	fb 42 24 00 00 00             	mov.l	#36, r4
ffe02d76:	a9 c3                         	mov.l	24[r4], r3
ffe02d78:	61 93                         	cmp	#9, r3
ffe02d7a:	21 19                         	bne.b	ffe02d93 <_Reset_Vector+0xffe02d97>
    {
        /* Sets the internal status. */
        riic_api_status_set(priic_info_s[1], RIIC_STS_IDLE_EN_SLV);
ffe02d7c:	fb 32 60 00 00 00             	mov.l	#96, r3
ffe02d82:	a8 3d                         	mov.l	4[r3], r5

ffe02d84 <.LBB1570>:
    riic_api_info[ch_no].B_status = riic_api_info[ch_no].N_status;
ffe02d84:	b0 dd                         	movu.b	3[r5], r5

ffe02d86 <.LVL804>:
ffe02d86:	6c 45                         	shll	#4, r5
ffe02d88:	4b 45                         	add	r4, r5
ffe02d8a:	e5 55 02 03                   	mov.l	8[r5], 12[r5]
    riic_api_info[ch_no].N_status = new_status;
ffe02d8e:	3e 52 02                      	mov.l	#2, 8[r5]
ffe02d91:	a9 c3                         	mov.l	24[r4], r3

ffe02d93 <.LVL805>:
    }

    if (RIIC_MODE_S_READY == riic_api_info[1].N_Mode)
ffe02d93:	a9 45                         	mov.l	16[r4], r5
ffe02d95:	61 45                         	cmp	#4, r5
ffe02d97:	20 72                         	beq.b	ffe02e09 <_Reset_Vector+0xffe02e0d>
    {
        /* Sets the internal mode. */
        riic_api_info[1].N_Mode = RIIC_MODE_S_RECEIVE;
    }

    if ((RIIC_STS_IDLE_EN_SLV == riic_api_info[1].N_status))
ffe02d99:	61 23                         	cmp	#2, r3
ffe02d9b:	20 26                         	beq.b	ffe02dc1 <_Reset_Vector+0xffe02dc5>
    {
        /* Updates the channel status. */
        riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
    }

    switch (riic_api_info[1].N_Mode)
ffe02d9d:	61 25                         	cmp	#2, r5
ffe02d9f:	23 69                         	bnc.b	ffe02e08 <_Reset_Vector+0xffe02e0c>
ffe02da1:	61 35                         	cmp	#3, r5
ffe02da3:	24 61                         	bgtu.b	ffe02e04 <_Reset_Vector+0xffe02e08>
    {
        case RIIC_MODE_M_RECEIVE :
        case RIIC_MODE_M_SEND_RECEIVE :

            /* Master mode data */
            p_riic_info = priic_info_m[1];
ffe02da5:	fb 52 6c 00 00 00             	mov.l	#108, r5
ffe02dab:	a8 59                         	mov.l	4[r5], r1

ffe02dad <.LVL806>:
        break;
ffe02dad:	fc 13 00                      	nop	; max	r0, r0
            return;
        break;
    }

    /* Sets interrupted data receiving. */
    riic_api_event[1] = RIIC_EV_INT_RECEIVE;
ffe02db0:	fb 52 54 00 00 00             	mov.l	#84, r5
ffe02db6:	3e 51 06                      	mov.l	#6, 4[r5]

ffe02db9 <.LBB1572>:
    if (NULL == p_riic_info)
ffe02db9:	61 01                         	cmp	#0, r1
ffe02dbb:	20 4d                         	beq.b	ffe02e08 <_Reset_Vector+0xffe02e0c>
        ret = riic_advance(p_riic_info);
ffe02dbd:	04 7b e7 ff                   	bra.a	ffe01538 <_Reset_Vector+0xffe0153c>

ffe02dc1 <.LBE1572>:
{
ffe02dc1:	7e a7                         	push.l	r7
        riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
ffe02dc3:	fb 32 60 00 00 00             	mov.l	#96, r3
ffe02dc9:	a8 3b                         	mov.l	4[r3], r3

ffe02dcb <.LBB1576>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe02dcb:	b0 bc                         	movu.b	3[r3], r4
ffe02dcd:	fb 22 0c 02 00 00             	mov.l	#524, r2
ffe02dd3:	66 47                         	mov.l	#4, r7
ffe02dd5:	fe 04 27                      	mov.b	r7, [r4, r2]
    p_riic_info->dev_sts = status;
ffe02dd8:	80 b7                         	mov.b	r7, 2[r3]

ffe02dda <.LBE1576>:
    switch (riic_api_info[1].N_Mode)
ffe02dda:	61 25                         	cmp	#2, r5
ffe02ddc:	23 25                         	bnc.b	ffe02e01 <_Reset_Vector+0xffe02e05>
ffe02dde:	61 35                         	cmp	#3, r5
ffe02de0:	24 1d                         	bgtu.b	ffe02dfd <_Reset_Vector+0xffe02e01>
            p_riic_info = priic_info_m[1];
ffe02de2:	fb 52 6c 00 00 00             	mov.l	#108, r5
ffe02de8:	a8 59                         	mov.l	4[r5], r1

ffe02dea <.LVL810>:
    riic_api_event[1] = RIIC_EV_INT_RECEIVE;
ffe02dea:	fb 52 54 00 00 00             	mov.l	#84, r5
ffe02df0:	3e 51 06                      	mov.l	#6, 4[r5]

ffe02df3 <.LBB1579>:
    if (NULL == p_riic_info)
ffe02df3:	61 01                         	cmp	#0, r1
ffe02df5:	20 0c                         	beq.b	ffe02e01 <_Reset_Vector+0xffe02e05>

ffe02df7 <.LBE1579>:

    r_riic_advance(p_riic_info); /* Calls advance function */
} /* End of function riic1_rxi_sub() */
ffe02df7:	7e b7                         	pop	r7

ffe02df9 <.LBB1580>:
        ret = riic_advance(p_riic_info);
ffe02df9:	04 3f e7 ff                   	bra.a	ffe01538 <_Reset_Vector+0xffe0153c>

ffe02dfd <.LBE1580>:
    switch (riic_api_info[1].N_Mode)
ffe02dfd:	61 65                         	cmp	#6, r5
ffe02dff:	20 38                         	beq.b	ffe02e37 <_Reset_Vector+0xffe02e3b>

ffe02e01 <.LVL813>:
} /* End of function riic1_rxi_sub() */
ffe02e01:	3f 77 01                      	rtsd	#4, r7-r7

ffe02e04 <.LVL814>:
    switch (riic_api_info[1].N_Mode)
ffe02e04:	61 65                         	cmp	#6, r5
ffe02e06:	20 26                         	beq.b	ffe02e2c <_Reset_Vector+0xffe02e30>
ffe02e08:	02                            	rts
        riic_api_info[1].N_Mode = RIIC_MODE_S_RECEIVE;
ffe02e09:	3e 44 06                      	mov.l	#6, 16[r4]
    if ((RIIC_STS_IDLE_EN_SLV == riic_api_info[1].N_status))
ffe02e0c:	61 23                         	cmp	#2, r3
        riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
ffe02e0e:	fb 32 60 00 00 00             	mov.l	#96, r3
    if ((RIIC_STS_IDLE_EN_SLV == riic_api_info[1].N_status))
ffe02e14:	15                            	beq.s	ffe02e19 <_Reset_Vector+0xffe02e1d>
            p_riic_info = priic_info_s[1];
ffe02e15:	a8 39                         	mov.l	4[r3], r1

ffe02e17 <.LVL815>:
        break;
ffe02e17:	2e 99                         	bra.b	ffe02db0 <_Reset_Vector+0xffe02db4>

ffe02e19 <.LVL816>:
        riic_set_ch_status(priic_info_s[1], RIIC_COMMUNICATION);
ffe02e19:	a8 3a                         	mov.l	4[r3], r2

ffe02e1b <.LBB1581>:
    g_riic_ChStatus[p_riic_info->ch_no] = status;
ffe02e1b:	b0 ac                         	movu.b	3[r2], r4
ffe02e1d:	fb 12 0c 02 00 00             	mov.l	#524, r1
ffe02e23:	fe 04 15                      	mov.b	r5, [r4, r1]
    p_riic_info->dev_sts = status;
ffe02e26:	80 a5                         	mov.b	r5, 2[r2]

ffe02e28 <.LBE1581>:
            p_riic_info = priic_info_s[1];
ffe02e28:	a8 39                         	mov.l	4[r3], r1

ffe02e2a <.LVL818>:
        break;
ffe02e2a:	2e 86                         	bra.b	ffe02db0 <_Reset_Vector+0xffe02db4>

ffe02e2c <.LVL819>:
ffe02e2c:	fb 32 60 00 00 00             	mov.l	#96, r3
            p_riic_info = priic_info_s[1];
ffe02e32:	a8 39                         	mov.l	4[r3], r1

ffe02e34 <.LVL820>:
        break;
ffe02e34:	38 7c ff                      	bra.w	ffe02db0 <_Reset_Vector+0xffe02db4>

ffe02e37 <.LVL821>:
ffe02e37:	fb 32 60 00 00 00             	mov.l	#96, r3

ffe02e3d <.LVL822>:
            p_riic_info = priic_info_s[1];
ffe02e3d:	a8 39                         	mov.l	4[r3], r1

ffe02e3f <.LVL823>:
        break;
ffe02e3f:	2e ab                         	bra.b	ffe02dea <_Reset_Vector+0xffe02dee>

ffe02e41 <.LFE64>:
ffe02e41:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe02e48 <_riic1_tei_sub>:
    #ifdef TN_RXA012A
    riic_timeout_counter_clear(1);
    #endif

    /* Clears ICSR2.TEND. */
    RIIC1.ICSR2.BIT.TEND = 0U;
ffe02e48:	fb 4e 20 83 08                	mov.l	#0x88320, r4
ffe02e4d:	f1 4e 09                      	bclr	#6, 9[r4].b
    /* WAIT_LOOP */
    while (0U != RIIC1.ICSR2.BIT.TEND)
ffe02e50:	8a 4d                         	mov.b	9[r4], r5
ffe02e52:	7c 65                         	btst	#6, r5
ffe02e54:	21 fc                         	bne.b	ffe02e50 <_Reset_Vector+0xffe02e54>
    {
        /* Do Nothing */
    }

    /* Sets event. */
    switch (riic_api_info[1].N_status)
ffe02e56:	fb 52 24 00 00 00             	mov.l	#36, r5
ffe02e5c:	a9 d5                         	mov.l	24[r5], r5
ffe02e5e:	61 45                         	cmp	#4, r5
ffe02e60:	23 18                         	bnc.b	ffe02e78 <_Reset_Vector+0xffe02e7c>
ffe02e62:	61 55                         	cmp	#5, r5
ffe02e64:	25 24                         	bleu.b	ffe02e88 <_Reset_Vector+0xffe02e8c>
ffe02e66:	61 65                         	cmp	#6, r5
ffe02e68:	21 10                         	bne.b	ffe02e78 <_Reset_Vector+0xffe02e7c>
        break;

        case RIIC_STS_SEND_DATA_WAIT :

            /* Sets interrupted data sending. */
            riic_api_event[1] = RIIC_EV_INT_SEND;
ffe02e6a:	fb 52 54 00 00 00             	mov.l	#84, r5
ffe02e70:	3e 51 05                      	mov.l	#5, 4[r5]

        break;
ffe02e73:	77 10 01 00 00                	nop	; mul	#1, r0
            /* Does nothing. */
        break;

    }

    r_riic_advance(priic_info_m[1]); /* Calls advance function */
ffe02e78:	fb 52 6c 00 00 00             	mov.l	#108, r5
ffe02e7e:	a8 59                         	mov.l	4[r5], r1

ffe02e80 <.LBB1582>:
    if (NULL == p_riic_info)
ffe02e80:	61 01                         	cmp	#0, r1
ffe02e82:	20 1b                         	beq.b	ffe02e9d <_Reset_Vector+0xffe02ea1>
        ret = riic_advance(p_riic_info);
ffe02e84:	04 b4 e6 ff                   	bra.a	ffe01538 <_Reset_Vector+0xffe0153c>

ffe02e88 <.LBE1582>:
            riic_api_event[1] = RIIC_EV_INT_ADD;
ffe02e88:	fb 52 54 00 00 00             	mov.l	#84, r5
ffe02e8e:	3e 51 04                      	mov.l	#4, 4[r5]
    r_riic_advance(priic_info_m[1]); /* Calls advance function */
ffe02e91:	fb 52 6c 00 00 00             	mov.l	#108, r5
ffe02e97:	a8 59                         	mov.l	4[r5], r1

ffe02e99 <.LBB1585>:
    if (NULL == p_riic_info)
ffe02e99:	61 01                         	cmp	#0, r1
ffe02e9b:	21 e9                         	bne.b	ffe02e84 <_Reset_Vector+0xffe02e88>

ffe02e9d <.LBE1585>:
} /* End of function riic1_tei_sub() */
ffe02e9d:	02                            	rts

ffe02e9e <.LFE65>:
ffe02e9e:	ef 00                         	nop	; mov.l	r0, r0

ffe02ea0 <_get_iclk_freq_hz>:
*                frequency at which it is currently running.
* Arguments    : None
* Return Value : uint32_t - the iclk frequency in Hz
***********************************************************************************************************************/
uint32_t get_iclk_freq_hz(void)
{
ffe02ea0:	60 c0                         	sub	#12, r0
    uint32_t sys_clock_src_freq;
    uint32_t pll_multiplier;
    uint32_t pll_source_freq;
    uint32_t hoco_frequency[3] = {16000000, 18000000, 20000000};
ffe02ea2:	f8 02 00 24 f4 00             	mov.l	#0xf42400, [r0]
ffe02ea8:	f9 02 01 80 a8 12 01          	mov.l	#0x112a880, 4[r0]

    /* Casting is valid because it matches the type to the retern value. */
    uint8_t  cksel = (uint8_t)SYSTEM.SCKCR3.BIT.CKSEL;
ffe02eaf:	fb 3e 00 00 08                	mov.l	#0x80000, r3
    uint32_t hoco_frequency[3] = {16000000, 18000000, 20000000};
ffe02eb4:	f9 02 02 00 2d 31 01          	mov.l	#0x1312d00, 8[r0]
    uint8_t  cksel = (uint8_t)SYSTEM.SCKCR3.BIT.CKSEL;
ffe02ebb:	9c bd                         	mov.w	38[r3], r5
ffe02ebd:	68 85                         	shlr	#8, r5
ffe02ebf:	64 75                         	and	#7, r5

ffe02ec1 <.LVL0>:

    switch (cksel)
ffe02ec1:	5b 54                         	movu.b	r5, r4
ffe02ec3:	61 14                         	cmp	#1, r4
ffe02ec5:	20 4e                         	beq.b	ffe02f13 <_Reset_Vector+0xffe02f17>
ffe02ec7:	61 05                         	cmp	#0, r5
ffe02ec9:	20 35                         	beq.b	ffe02efe <_Reset_Vector+0xffe02f02>
ffe02ecb:	61 34                         	cmp	#3, r4
ffe02ecd:	20 1c                         	beq.b	ffe02ee9 <_Reset_Vector+0xffe02eed>
ffe02ecf:	61 44                         	cmp	#4, r4
ffe02ed1:	20 5a                         	beq.b	ffe02f2b <_Reset_Vector+0xffe02f2f>
            /* Set HOCO frequency. */
            sys_clock_src_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
            break;

        case BSP_PRV_CKSEL_MAIN_OSC:
            sys_clock_src_freq = BSP_CFG_XTAL_HZ;
ffe02ed3:	fb 12 00 36 6e 01             	mov.l	#0x16e3600, r1

ffe02ed9 <.LVL1>:
            sys_clock_src_freq = BSP_CFG_XTAL_HZ;
            break;
    }

    /* Finally, divide the system clock source frequency by the currently set ICLK divider to get the ICLK frequency */
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffe02ed9:	fb 5e 00 00 08                	mov.l	#0x80000, r5

ffe02ede <.LVL2>:
ffe02ede:	aa 55                         	mov.l	32[r5], r5
ffe02ee0:	69 85                         	shlr	#24, r5
ffe02ee2:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffe02ee4:	fd 60 51                      	shlr	r5, r1

ffe02ee7 <.LVL3>:
ffe02ee7:	67 03                         	rtsd	#12

ffe02ee9 <.LVL4>:
            sys_clock_src_freq = BSP_SUB_CLOCK_HZ;
ffe02ee9:	fb 1e 00 80 00                	mov.l	#0x8000, r1

ffe02eee <.LVL5>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffe02eee:	fb 5e 00 00 08                	mov.l	#0x80000, r5

ffe02ef3 <.LVL6>:
ffe02ef3:	aa 55                         	mov.l	32[r5], r5
ffe02ef5:	69 85                         	shlr	#24, r5
ffe02ef7:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffe02ef9:	fd 60 51                      	shlr	r5, r1

ffe02efc <.LVL7>:
ffe02efc:	67 03                         	rtsd	#12

ffe02efe <.LVL8>:
            sys_clock_src_freq = BSP_LOCO_HZ;
ffe02efe:	fb 1e 80 a9 03                	mov.l	#0x3a980, r1

ffe02f03 <.LVL9>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffe02f03:	fb 5e 00 00 08                	mov.l	#0x80000, r5

ffe02f08 <.LVL10>:
ffe02f08:	aa 55                         	mov.l	32[r5], r5
ffe02f0a:	69 85                         	shlr	#24, r5
ffe02f0c:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffe02f0e:	fd 60 51                      	shlr	r5, r1

ffe02f11 <.LVL11>:
ffe02f11:	67 03                         	rtsd	#12

ffe02f13 <.LVL12>:
            sys_clock_src_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
ffe02f13:	cd 35 37                      	mov.b	55[r3], r5

ffe02f16 <.LVL13>:
ffe02f16:	64 35                         	and	#3, r5
ffe02f18:	fe 65 01                      	mov.l	[r5, r0], r1

ffe02f1b <.LVL14>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffe02f1b:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffe02f20:	aa 55                         	mov.l	32[r5], r5
ffe02f22:	69 85                         	shlr	#24, r5
ffe02f24:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffe02f26:	fd 60 51                      	shlr	r5, r1

ffe02f29 <.LVL15>:
ffe02f29:	67 03                         	rtsd	#12

ffe02f2b <.LVL16>:
            pll_multiplier = ((((uint32_t)(SYSTEM.PLLCR.BIT.STC + 1)) * BSP_PRV_NORMALIZE_X10) / 2);
ffe02f2b:	9d 35                         	mov.w	40[r3], r5

ffe02f2d <.LVL17>:
            if (0x1 == SYSTEM.PLLCR.BIT.PLLSRCSEL)
ffe02f2d:	9d 34                         	mov.w	40[r3], r4
            pll_multiplier = ((((uint32_t)(SYSTEM.PLLCR.BIT.STC + 1)) * BSP_PRV_NORMALIZE_X10) / 2);
ffe02f2f:	fd 88 51                      	shlr	#8, r5, r1
ffe02f32:	75 21 3f                      	and	#63, r1
ffe02f35:	62 11                         	add	#1, r1
ffe02f37:	63 a1                         	mul	#10, r1
ffe02f39:	fd 81 15                      	shlr	#1, r1, r5

ffe02f3c <.LVL18>:
            if (0x1 == SYSTEM.PLLCR.BIT.PLLSRCSEL)
ffe02f3c:	7c 44                         	btst	#4, r4
ffe02f3e:	21 2c                         	bne.b	ffe02f6a <_Reset_Vector+0xffe02f6e>
            pll_source_freq = BSP_CFG_XTAL_HZ;
ffe02f40:	fb 12 00 36 6e 01             	mov.l	#0x16e3600, r1

ffe02f46 <.LVL19>:
ffe02f46:	ef 00                         	nop	; mov.l	r0, r0
            sys_clock_src_freq = ((pll_source_freq / (((uint32_t)(SYSTEM.PLLCR.BIT.PLIDIV + 1)) * BSP_PRV_NORMALIZE_X10)) * pll_multiplier);
ffe02f48:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffe02f4d:	9d 44                         	mov.w	40[r4], r4
ffe02f4f:	64 34                         	and	#3, r4
ffe02f51:	62 14                         	add	#1, r4
ffe02f53:	63 a4                         	mul	#10, r4
ffe02f55:	fc 27 41                      	divu	r4, r1

ffe02f58 <.LVL20>:
ffe02f58:	4f 51                         	mul	r5, r1

ffe02f5a <.LVL21>:
    return (sys_clock_src_freq / (uint32_t)(1 << SYSTEM.SCKCR.BIT.ICK));
ffe02f5a:	fb 5e 00 00 08                	mov.l	#0x80000, r5

ffe02f5f <.LVL22>:
ffe02f5f:	aa 55                         	mov.l	32[r5], r5
ffe02f61:	69 85                         	shlr	#24, r5
ffe02f63:	64 f5                         	and	#15, r5
} /* End of function get_iclk_freq_hz() */
ffe02f65:	fd 60 51                      	shlr	r5, r1

ffe02f68 <.LVL23>:
ffe02f68:	67 03                         	rtsd	#12

ffe02f6a <.LVL24>:
                pll_source_freq = hoco_frequency[SYSTEM.HOCOCR2.BIT.HCFRQ];
ffe02f6a:	cd 34 37                      	mov.b	55[r3], r4
ffe02f6d:	64 34                         	and	#3, r4
ffe02f6f:	fe 64 01                      	mov.l	[r4, r0], r1

ffe02f72 <.LVL25>:
ffe02f72:	2e d6                         	bra.b	ffe02f48 <_Reset_Vector+0xffe02f4c>

ffe02f74 <.LFE3>:
ffe02f74:	76 10 01 00                   	nop	; mul	#1, r0

ffe02f78 <_mcu_clock_setup>:
* Return value : none
***********************************************************************************************************************/
void mcu_clock_setup(void)
{
    /* Switch to high-speed operation */
    operating_frequency_set();
ffe02f78:	fb 52 c8 5f e0 ff             	mov.l	#0xffe05fc8, r5
ffe02f7e:	ec 55                         	mov.l	[r5], r5
ffe02f80:	61 15                         	cmp	#1, r5
ffe02f82:	21 03                         	bne.b	ffe02f85 <_Reset_Vector+0xffe02f89>
ffe02f84:	02                            	rts
{
ffe02f85:	7e a7                         	push.l	r7
ffe02f87:	60 40                         	sub	#4, r0

ffe02f89 <.LBB6>:
{
    /* Used for constructing value to write to SCKCR, SCKCR2, and SCKCR3 registers. */
    uint32_t tmp_clock = 0;

    /* Protect off. */
    SYSTEM.PRCR.WORD = 0xA50B;
ffe02f89:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffe02f8e:	fa 59 ff 01 0b a5             	mov.w	#0xa50b, 1022[r5]

ffe02f94 <.LBB8>:
#if (BSP_CFG_SUB_CLOCK_OSCILLATE_ENABLE == 1) || (BSP_CFG_RTC_ENABLE == 1)
    uint8_t tmp;
#endif

    /* Main clock will be not oscillate in software standby or deep software standby modes. */
    SYSTEM.MOFCR.BIT.MOFXIN = 0;
ffe02f94:	f2 58 93 c2                   	bclr	#0, 49811[r5].b

    /* Set the oscillation source of the main clock oscillator. */
    SYSTEM.MOFCR.BIT.MOSEL = BSP_CFG_MAIN_CLOCK_SOURCE;
ffe02f98:	f2 5e 93 c2                   	bclr	#6, 49811[r5].b

#if BSP_CFG_HOCO_OSCILLATE_ENABLE == 1
    /* HOCO is chosen. Start it operating if it is not already operating. */
    if (1 == SYSTEM.HOCOCR.BIT.HCSTP)
ffe02f9c:	cd 54 36                      	mov.b	54[r5], r4
ffe02f9f:	64 14                         	and	#1, r4
ffe02fa1:	61 14                         	cmp	#1, r4
ffe02fa3:	3a 7b 01                      	beq.w	ffe0311e <_Reset_Vector+0xffe03122>
ffe02fa6:	ef 00                         	nop	; mov.l	r0, r0
            R_BSP_NOP();
        }
    }

    /* WAIT_LOOP */
    while(0 == SYSTEM.OSCOVFSR.BIT.HCOVF)
ffe02fa8:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffe02fad:	cd 54 3c                      	mov.b	60[r5], r4
ffe02fb0:	7c 34                         	btst	#3, r4
ffe02fb2:	21 0e                         	bne.b	ffe02fc0 <_Reset_Vector+0xffe02fc4>
    {
        /* The delay period needed is to make sure that the HOCO has stabilized.
           If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
        R_BSP_NOP();
ffe02fb4:	03                            	nop
    while(0 == SYSTEM.OSCOVFSR.BIT.HCOVF)
ffe02fb5:	cd 54 3c                      	mov.b	60[r5], r4
ffe02fb8:	7c 34                         	btst	#3, r4
ffe02fba:	20 fa                         	beq.b	ffe02fb4 <_Reset_Vector+0xffe02fb8>
ffe02fbc:	76 10 01 00                   	nop	; mul	#1, r0
#endif /* BSP_CFG_MAIN_CLOCK_OSCILLATE_ENABLE == 1 */

    /* Sub-clock setting. */

    /* Cold start setting */
    if (0 == SYSTEM.RSTSR1.BIT.CWSF)
ffe02fc0:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffe02fc5:	ce 75 91 c2                   	mov.b	49809[r7], r5
ffe02fc9:	7c 05                         	btst	#0, r5
ffe02fcb:	3b 2b 01                      	bne.w	ffe030f6 <_Reset_Vector+0xffe030fa>
    {
        /* Stop the sub-clock oscillator */
        /* RCR4 - RTC Control Register 4
        b7:b1    Reserved - The write value should be 0.
        b0       RCKSEL   - Count Source Select - Sub-clock oscillator is selected. */
        RTC.RCR4.BIT.RCKSEL = 0;
ffe02fce:	fb 4e 00 c4 08                	mov.l	#0x8c400, r4
ffe02fd3:	f1 48 28                      	bclr	#0, 40[r4].b

        /* WAIT_LOOP */
        for (i = 0; i < 4; i++)
ffe02fd6:	3c 01 00                      	mov.b	#0, 1[r0]
ffe02fd9:	b0 0f                         	movu.b	1[r0], r7
ffe02fdb:	61 37                         	cmp	#3, r7
ffe02fdd:	24 14                         	bgtu.b	ffe02ff1 <_Reset_Vector+0xffe02ff5>
ffe02fdf:	03                            	nop
        {
            /* dummy read four times */
            dummy = RTC.RCR4.BYTE;
ffe02fe0:	cd 45 28                      	mov.b	40[r4], r5
ffe02fe3:	c3 05                         	mov.b	r5, [r0]
        for (i = 0; i < 4; i++)
ffe02fe5:	88 0d                         	mov.b	1[r0], r5
ffe02fe7:	62 15                         	add	#1, r5
ffe02fe9:	80 0d                         	mov.b	r5, 1[r0]
ffe02feb:	b0 0d                         	movu.b	1[r0], r5
ffe02fed:	61 35                         	cmp	#3, r5
ffe02fef:	25 f1                         	bleu.b	ffe02fe0 <_Reset_Vector+0xffe02fe4>
        }

        /* Confirm that the written */
        if (0 != RTC.RCR4.BIT.RCKSEL)
ffe02ff1:	fb 7e 00 c4 08                	mov.l	#0x8c400, r7
ffe02ff6:	cd 75 28                      	mov.b	40[r7], r5
ffe02ff9:	7c 05                         	btst	#0, r5
ffe02ffb:	3b 1f 01                      	bne.w	ffe0311a <_Reset_Vector+0xffe0311e>
ffe02ffe:	ef 00                         	nop	; mov.l	r0, r0

        /* RCR3 - RTC Control Register 3
        b7:b4    Reserved - The write value should be 0.
        b3:b1    RTCDV    - Sub-clock oscillator Drive Ability Control.
        b0       RTCEN    - Sub-clock oscillator is stopped. */
        RTC.RCR3.BIT.RTCEN = 0;
ffe03000:	fb 4e 00 c4 08                	mov.l	#0x8c400, r4
ffe03005:	f1 48 26                      	bclr	#0, 38[r4].b

        /* WAIT_LOOP */
        for (i = 0; i < 4; i++)
ffe03008:	3c 01 00                      	mov.b	#0, 1[r0]
ffe0300b:	b0 0f                         	movu.b	1[r0], r7
ffe0300d:	61 37                         	cmp	#3, r7
ffe0300f:	24 13                         	bgtu.b	ffe03022 <_Reset_Vector+0xffe03026>
        {
            /* dummy read four times */
            dummy = RTC.RCR3.BYTE;
ffe03011:	cd 45 26                      	mov.b	38[r4], r5
ffe03014:	c3 05                         	mov.b	r5, [r0]
        for (i = 0; i < 4; i++)
ffe03016:	88 0d                         	mov.b	1[r0], r5
ffe03018:	62 15                         	add	#1, r5
ffe0301a:	80 0d                         	mov.b	r5, 1[r0]
ffe0301c:	b0 0d                         	movu.b	1[r0], r5
ffe0301e:	61 35                         	cmp	#3, r5
ffe03020:	25 f1                         	bleu.b	ffe03011 <_Reset_Vector+0xffe03015>
        }

        /* Confirm that the written */
        if (0 != RTC.RCR3.BIT.RTCEN)
ffe03022:	fb 7e 00 c4 08                	mov.l	#0x8c400, r7
ffe03027:	cd 75 26                      	mov.b	38[r7], r5
ffe0302a:	7c 05                         	btst	#0, r5
ffe0302c:	14                            	beq.s	ffe03030 <_Reset_Vector+0xffe03034>
        {
            R_BSP_NOP();
ffe0302d:	03                            	nop
ffe0302e:	ef 00                         	nop	; mov.l	r0, r0

        /* SOSCCR - Sub-Clock Oscillator Control Register
        b7:b1    Reserved - The write value should be 0.
        b0       SOSTP    - Sub-clock oscillator Stop - Sub-clock oscillator is stopped.
        NOTE: Please refer Tool News(TN-RX*-A0257A) for details. */
        SYSTEM.SOSCCR.BYTE = 0x01;
ffe03030:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffe03035:	f9 74 33 01                   	mov.b	#1, 51[r7]

        /* Dummy read and compare. cf."5. I/O Registers", "(2) Notes on writing to I/O registers" in User's manual.
           This is done to ensure that the register has been written before the next register access. The RX has a 
           pipeline architecture so the next instruction could be executed before the previous write had finished.
         */
        if (0x01 != SYSTEM.SOSCCR.BYTE)
ffe03039:	59 77 33                      	movu.b	51[r7], r7
ffe0303c:	61 17                         	cmp	#1, r7
ffe0303e:	20 03                         	beq.b	ffe03041 <_Reset_Vector+0xffe03045>
        {
            R_BSP_NOP();
ffe03040:	03                            	nop
        }

        /* WAIT_LOOP */
        while (0 != SYSTEM.OSCOVFSR.BIT.SOOVF)
ffe03041:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffe03046:	cd 45 3c                      	mov.b	60[r4], r5
ffe03049:	7c 15                         	btst	#1, r5
ffe0304b:	20 0d                         	beq.b	ffe03058 <_Reset_Vector+0xffe0305c>
        {        
            /* The delay period needed is to make sure that the sub-clock has stopped.
               If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
            R_BSP_NOP();
ffe0304d:	03                            	nop
        while (0 != SYSTEM.OSCOVFSR.BIT.SOOVF)
ffe0304e:	cd 45 3c                      	mov.b	60[r4], r5
ffe03051:	7c 15                         	btst	#1, r5
ffe03053:	21 fa                         	bne.b	ffe0304d <_Reset_Vector+0xffe03051>
ffe03055:	fc 13 00                      	nop	; max	r0, r0
    }

#if BSP_PRV_PLL_CLK_OPERATING == 1

    /* Set PLL Input Divisor. */
    SYSTEM.PLLCR.BIT.PLIDIV = BSP_CFG_PLL_DIV - 1;
ffe03058:	fb 5e 00 00 08                	mov.l	#0x80000, r5
ffe0305d:	9d 54                         	mov.w	40[r5], r4
ffe0305f:	75 24 fc                      	and	#-4, r4
ffe03062:	95 54                         	mov.w	r4, 40[r5]
    #if BSP_CFG_PLL_SRC == 0
    /* Clear PLL clock source if PLL clock source is Main clock. */
    SYSTEM.PLLCR.BIT.PLLSRCSEL = 0;
    #else
    /* Set PLL clock source if PLL clock source is HOCO clock. */
    SYSTEM.PLLCR.BIT.PLLSRCSEL = 1;
ffe03064:	9d 57                         	mov.w	40[r5], r7
ffe03066:	78 47                         	bset	#4, r7
ffe03068:	95 57                         	mov.w	r7, 40[r5]
    #endif

    /* Set PLL Multiplier. */
    SYSTEM.PLLCR.BIT.STC = ((uint8_t)((float)BSP_CFG_PLL_MUL * 2.0)) - 1;
ffe0306a:	9d 54                         	mov.w	40[r5], r4
ffe0306c:	76 24 ff c0                   	and	#0xffffc0ff, r4
ffe03070:	76 34 00 1d                   	or	#0x1d00, r4
ffe03074:	95 54                         	mov.w	r4, 40[r5]

    /* Set the PLL to operating. */
    SYSTEM.PLLCR2.BYTE = 0x00;
ffe03076:	f9 54 2a 00                   	mov.b	#0, 42[r5]

    /* WAIT_LOOP */
    while(0 == SYSTEM.OSCOVFSR.BIT.PLOVF)
ffe0307a:	cd 54 3c                      	mov.b	60[r5], r4
ffe0307d:	7c 24                         	btst	#2, r4
ffe0307f:	19                            	bne.s	ffe03088 <_Reset_Vector+0xffe0308c>
    {
        /* The delay period needed is to make sure that the PLL has stabilized.
           If you use simulator, the flag is not set to 1, resulting in an infinite loop. */
        R_BSP_NOP();
ffe03080:	03                            	nop
    while(0 == SYSTEM.OSCOVFSR.BIT.PLOVF)
ffe03081:	cd 54 3c                      	mov.b	60[r5], r4
ffe03084:	7c 24                         	btst	#2, r4
ffe03086:	20 fa                         	beq.b	ffe03080 <_Reset_Vector+0xffe03084>
       When setting ICLK to [50 MHz < ICLK <= 100 MHz], set the ROMWT.ROMWT[1:0] bits to 01b.
       When setting ICLK to [100 MHz < ICLK <= 120 MHz], set the ROMWT.ROMWT[1:0] bits to 10b. */
    if (BSP_ICLK_HZ > BSP_MCU_ROMWT_FREQ_THRESHOLD_02)
    {
        /* Set the ROMWT.ROMWT[1:0] bits to 10b. */
        SYSTEM.ROMWT.BYTE = 0x02;
ffe03088:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffe0308d:	fa 74 1c 10 02                	mov.b	#2, 4124[r7]

        /* Dummy read and compare. cf."5. I/O Registers", "(2) Notes on writing to I/O registers" in User's manual.
           This is done to ensure that the register has been written before the next register access. The RX has a 
           pipeline architecture so the next instruction could be executed before the previous write had finished.
        */
        if(0x02 == SYSTEM.ROMWT.BYTE)
ffe03092:	5a 75 1c 10                   	movu.b	4124[r7], r5
ffe03096:	61 25                         	cmp	#2, r5
ffe03098:	21 03                         	bne.b	ffe0309b <_Reset_Vector+0xffe0309f>
        {
            R_BSP_NOP();
ffe0309a:	03                            	nop

ffe0309b <.LBE8>:
    SYSTEM.SCKCR.LONG = tmp_clock;
ffe0309b:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffe030a0:	f9 72 08 22 12 c1 21          	mov.l	#0x21c11222, 32[r7]
    if(tmp_clock == SYSTEM.SCKCR.LONG)
ffe030a7:	aa 77                         	mov.l	32[r7], r7
ffe030a9:	74 07 22 12 c1 21             	cmp	#0x21c11222, r7
ffe030af:	21 03                         	bne.b	ffe030b2 <_Reset_Vector+0xffe030b6>
        R_BSP_NOP();
ffe030b1:	03                            	nop

ffe030b2 <.LVL28>:
    SYSTEM.SCKCR2.WORD = (uint16_t)tmp_clock;
ffe030b2:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffe030b7:	3d f2 11                      	mov.w	#17, 36[r7]
    if((uint16_t)tmp_clock == SYSTEM.SCKCR2.WORD)
ffe030ba:	bc f5                         	movu.w	36[r7], r5
ffe030bc:	75 55 11                      	cmp	#17, r5
ffe030bf:	21 03                         	bne.b	ffe030c2 <_Reset_Vector+0xffe030c6>
        R_BSP_NOP();
ffe030c1:	03                            	nop

ffe030c2 <.LVL29>:
    SYSTEM.SCKCR3.WORD = (uint16_t)tmp_clock;
ffe030c2:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffe030c7:	f9 79 13 00 04                	mov.w	#0x400, 38[r7]
    if((uint16_t)tmp_clock == SYSTEM.SCKCR3.WORD)
ffe030cc:	bc fd                         	movu.w	38[r7], r5
ffe030ce:	76 05 00 04                   	cmp	#0x400, r5
ffe030d2:	1e                            	bne.s	ffe030d8 <_Reset_Vector+0xffe030dc>
        R_BSP_NOP();
ffe030d3:	03                            	nop
ffe030d4:	76 10 01 00                   	nop	; mul	#1, r0
    SYSTEM.LOCOCR.BYTE = 0x01;
ffe030d8:	fb 7e 00 00 08                	mov.l	#0x80000, r7
    R_BSP_SoftwareDelay((uint32_t)25, BSP_DELAY_MICROSECS);
ffe030dd:	fb 2e 40 42 0f                	mov.l	#0xf4240, r2
ffe030e2:	75 41 19                      	mov.l	#25, r1
    SYSTEM.LOCOCR.BYTE = 0x01;
ffe030e5:	f9 74 34 01                   	mov.b	#1, 52[r7]
    R_BSP_SoftwareDelay((uint32_t)25, BSP_DELAY_MICROSECS);
ffe030e9:	05 1f 04 00                   	bsr.a	ffe03508 <_Reset_Vector+0xffe0350c>

ffe030ed <.LVL30>:
    SYSTEM.PRCR.WORD = 0xA500;
ffe030ed:	fa 79 ff 01 00 a5             	mov.w	#0xa500, 1022[r7]

ffe030f3 <.LBE6>:
} /* End of function mcu_clock_setup() */
ffe030f3:	3f 77 02                      	rtsd	#8, r7-r7

ffe030f6 <.LBB11>:
        SYSTEM.SOSCCR.BYTE = 0x01;
ffe030f6:	f9 74 33 01                   	mov.b	#1, 51[r7]
        if (0x01 != SYSTEM.SOSCCR.BYTE)
ffe030fa:	59 77 33                      	movu.b	51[r7], r7
ffe030fd:	61 17                         	cmp	#1, r7
ffe030ff:	20 03                         	beq.b	ffe03102 <_Reset_Vector+0xffe03106>
            R_BSP_NOP();
ffe03101:	03                            	nop
        while (0 != SYSTEM.OSCOVFSR.BIT.SOOVF)
ffe03102:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffe03107:	cd 45 3c                      	mov.b	60[r4], r5
ffe0310a:	7c 15                         	btst	#1, r5
ffe0310c:	3a 4c ff                      	beq.w	ffe03058 <_Reset_Vector+0xffe0305c>
            R_BSP_NOP();
ffe0310f:	03                            	nop
        while (0 != SYSTEM.OSCOVFSR.BIT.SOOVF)
ffe03110:	cd 45 3c                      	mov.b	60[r4], r5
ffe03113:	7c 15                         	btst	#1, r5
ffe03115:	21 fa                         	bne.b	ffe0310f <_Reset_Vector+0xffe03113>
ffe03117:	38 41 ff                      	bra.w	ffe03058 <_Reset_Vector+0xffe0305c>
            R_BSP_NOP();
ffe0311a:	03                            	nop
ffe0311b:	38 e5 fe                      	bra.w	ffe03000 <_Reset_Vector+0xffe03004>
        SYSTEM.HOCOPCR.BYTE = 0x00;
ffe0311e:	fa 54 94 c2 00                	mov.b	#0, 49812[r5]
        SYSTEM.HOCOCR.BYTE = 0x01;
ffe03123:	c7 54 36                      	mov.b	r4, 54[r5]
        while(1 == SYSTEM.OSCOVFSR.BIT.HCOVF)
ffe03126:	cd 54 3c                      	mov.b	60[r5], r4
ffe03129:	7c 34                         	btst	#3, r4
ffe0312b:	20 0d                         	beq.b	ffe03138 <_Reset_Vector+0xffe0313c>
            R_BSP_NOP();
ffe0312d:	03                            	nop
        while(1 == SYSTEM.OSCOVFSR.BIT.HCOVF)
ffe0312e:	cd 54 3c                      	mov.b	60[r5], r4
ffe03131:	7c 34                         	btst	#3, r4
ffe03133:	21 fa                         	bne.b	ffe0312d <_Reset_Vector+0xffe03131>
ffe03135:	fc 13 00                      	nop	; max	r0, r0
        SYSTEM.HOCOCR2.BYTE = 0x00;         //16MHz
ffe03138:	fb 7e 00 00 08                	mov.l	#0x80000, r7
ffe0313d:	f9 74 37 00                   	mov.b	#0, 55[r7]
        SYSTEM.HOCOCR.BYTE = 0x00;
ffe03141:	f9 74 36 00                   	mov.b	#0, 54[r7]
        if(0x00 == SYSTEM.HOCOCR.BYTE)
ffe03145:	59 77 36                      	movu.b	54[r7], r7
ffe03148:	61 07                         	cmp	#0, r7
ffe0314a:	3b 5e fe                      	bne.w	ffe02fa8 <_Reset_Vector+0xffe02fac>
            R_BSP_NOP();
ffe0314d:	03                            	nop
ffe0314e:	38 5a fe                      	bra.w	ffe02fa8 <_Reset_Vector+0xffe02fac>

ffe03151 <.LBE11>:
ffe03151:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe03158 <_bsp_non_existent_port_init>:
*                power.
* Arguments    : none
* Return Value : none
***********************************************************************************************************************/
void bsp_non_existent_port_init (void)
{
ffe03158:	6e 6d                         	pushm	r6-r13
ffe0315a:	60 40                         	sub	#4, r0
    /* OR in missing pin masks from above. */

    /* Set PORT0.PDR */
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
ffe0315c:	fb ae 00 c0 08                	mov.l	#0x8c000, r10

    /* Set PORT1.PDR */
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
ffe03161:	fb 7e 01 c0 08                	mov.l	#0x8c001, r7
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
ffe03166:	cc a4                         	mov.b	[r10], r4

    /* Set PORT2.PDR */
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
ffe03168:	fb 3e 02 c0 08                	mov.l	#0x8c002, r3

    /* Set PORT3.PDR */
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
ffe0316d:	fb de 03 c0 08                	mov.l	#0x8c003, r13

    /* Set PORT4.PDR */
    PORT4.PDR.BYTE |= BSP_PRV_PORT4_NE_PIN_MASK;
ffe03172:	fb 5e 04 c0 08                	mov.l	#0x8c004, r5
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
ffe03177:	75 34 5f                      	or	#95, r4

    /* Set PORT5.PDR */
    PORT5.PDR.BYTE |= BSP_PRV_PORT5_NE_PIN_MASK;
ffe0317a:	fb 8e 05 c0 08                	mov.l	#0x8c005, r8
    PORT0.PDR.BYTE |= BSP_PRV_PORT0_NE_PIN_MASK;
ffe0317f:	c3 a4                         	mov.b	r4, [r10]

    /* Set PORT6.PDR */
    PORT6.PDR.BYTE |= BSP_PRV_PORT6_NE_PIN_MASK;
ffe03181:	fb 9e 06 c0 08                	mov.l	#0x8c006, r9
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
ffe03186:	cc 74                         	mov.b	[r7], r4

    /* Set PORT7.PDR */
    PORT7.PDR.BYTE |= BSP_PRV_PORT7_NE_PIN_MASK;
ffe03188:	fb ce 07 c0 08                	mov.l	#0x8c007, r12

    /* Set PORT8.PDR */
    PORT8.PDR.BYTE |= BSP_PRV_PORT8_NE_PIN_MASK;
ffe0318d:	fb be 08 c0 08                	mov.l	#0x8c008, r11

    /* Set PORT9.PDR */
    PORT9.PDR.BYTE |= BSP_PRV_PORT9_NE_PIN_MASK;
ffe03192:	fb 6e 09 c0 08                	mov.l	#0x8c009, r6
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
ffe03197:	65 34                         	or	#3, r4

    /* Set PORTA.PDR */
    PORTA.PDR.BYTE |= BSP_PRV_PORTA_NE_PIN_MASK;
ffe03199:	fb ae 0a c0 08                	mov.l	#0x8c00a, r10
    PORT1.PDR.BYTE |= BSP_PRV_PORT1_NE_PIN_MASK;
ffe0319e:	c3 74                         	mov.b	r4, [r7]

    /* Set PORTB.PDR */
    PORTB.PDR.BYTE |= BSP_PRV_PORTB_NE_PIN_MASK;
ffe031a0:	fb 7e 0b c0 08                	mov.l	#0x8c00b, r7
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
ffe031a5:	cc 34                         	mov.b	[r3], r4

    /* Set PORTC.PDR */
    PORTC.PDR.BYTE |= BSP_PRV_PORTC_NE_PIN_MASK;
ffe031a7:	fb fe 0c c0 08                	mov.l	#0x8c00c, r15

    /* Set PORTD.PDR */
    PORTD.PDR.BYTE |= BSP_PRV_PORTD_NE_PIN_MASK;
ffe031ac:	fb ee 0d c0 08                	mov.l	#0x8c00d, r14

    /* Set PORTE.PDR */
    PORTE.PDR.BYTE |= BSP_PRV_PORTE_NE_PIN_MASK;
ffe031b1:	fb 1e 0e c0 08                	mov.l	#0x8c00e, r1
    PORT2.PDR.BYTE |= BSP_PRV_PORT2_NE_PIN_MASK;
ffe031b6:	c3 34                         	mov.b	r4, [r3]

    /* Set PORTF.PDR */
    PORTF.PDR.BYTE |= BSP_PRV_PORTF_NE_PIN_MASK;
ffe031b8:	fb 2e 0f c0 08                	mov.l	#0x8c00f, r2
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
ffe031bd:	c0 d0                         	mov.b	[r13], [r0]
#if defined(BSP_MCU_RX65N_2MB)

    /* Set PORTG.PDR */
    PORTG.PDR.BYTE |= BSP_PRV_PORTG_NE_PIN_MASK;
ffe031bf:	fb 3e 10 c0 08                	mov.l	#0x8c010, r3
#endif

    /* Set PORTJ.PDR */
    PORTJ.PDR.BYTE |= BSP_PRV_PORTJ_NE_PIN_MASK;
ffe031c4:	fb 4e 12 c0 08                	mov.l	#0x8c012, r4
    PORT3.PDR.BYTE |= BSP_PRV_PORT3_NE_PIN_MASK;
ffe031c9:	c0 0d                         	mov.b	[r0], [r13]
    PORT4.PDR.BYTE |= BSP_PRV_PORT4_NE_PIN_MASK;
ffe031cb:	cc 5d                         	mov.b	[r5], r13
ffe031cd:	c3 5d                         	mov.b	r13, [r5]
    PORT5.PDR.BYTE |= BSP_PRV_PORT5_NE_PIN_MASK;
ffe031cf:	cc 85                         	mov.b	[r8], r5
ffe031d1:	75 35 c0                      	or	#-64, r5
ffe031d4:	c3 85                         	mov.b	r5, [r8]
    PORT6.PDR.BYTE |= BSP_PRV_PORT6_NE_PIN_MASK;
ffe031d6:	cc 95                         	mov.b	[r9], r5
ffe031d8:	f8 94 ff                      	mov.b	#255, [r9]
    PORT7.PDR.BYTE |= BSP_PRV_PORT7_NE_PIN_MASK;
ffe031db:	cc c5                         	mov.b	[r12], r5
ffe031dd:	f8 c4 ff                      	mov.b	#255, [r12]
    PORT8.PDR.BYTE |= BSP_PRV_PORT8_NE_PIN_MASK;
ffe031e0:	cc b5                         	mov.b	[r11], r5
ffe031e2:	f8 b4 ff                      	mov.b	#255, [r11]
    PORT9.PDR.BYTE |= BSP_PRV_PORT9_NE_PIN_MASK;
ffe031e5:	cc 65                         	mov.b	[r6], r5
ffe031e7:	f8 64 ff                      	mov.b	#255, [r6]
    PORTA.PDR.BYTE |= BSP_PRV_PORTA_NE_PIN_MASK;
ffe031ea:	cc a5                         	mov.b	[r10], r5
ffe031ec:	c3 a5                         	mov.b	r5, [r10]
    PORTB.PDR.BYTE |= BSP_PRV_PORTB_NE_PIN_MASK;
ffe031ee:	cc 7a                         	mov.b	[r7], r10
ffe031f0:	c3 7a                         	mov.b	r10, [r7]
    PORTC.PDR.BYTE |= BSP_PRV_PORTC_NE_PIN_MASK;
ffe031f2:	cc f7                         	mov.b	[r15], r7
ffe031f4:	c3 f7                         	mov.b	r7, [r15]
    PORTD.PDR.BYTE |= BSP_PRV_PORTD_NE_PIN_MASK;
ffe031f6:	cc e7                         	mov.b	[r14], r7
ffe031f8:	c3 e7                         	mov.b	r7, [r14]
    PORTE.PDR.BYTE |= BSP_PRV_PORTE_NE_PIN_MASK;
ffe031fa:	cc 17                         	mov.b	[r1], r7
ffe031fc:	c3 17                         	mov.b	r7, [r1]
    PORTF.PDR.BYTE |= BSP_PRV_PORTF_NE_PIN_MASK;
ffe031fe:	cc 27                         	mov.b	[r2], r7
ffe03200:	f8 24 ff                      	mov.b	#255, [r2]
    PORTG.PDR.BYTE |= BSP_PRV_PORTG_NE_PIN_MASK;
ffe03203:	cc 37                         	mov.b	[r3], r7
ffe03205:	f8 34 ff                      	mov.b	#255, [r3]
    PORTJ.PDR.BYTE |= BSP_PRV_PORTJ_NE_PIN_MASK;
ffe03208:	cc 45                         	mov.b	[r4], r5
ffe0320a:	75 35 f7                      	or	#-9, r5
ffe0320d:	c3 45                         	mov.b	r5, [r4]
} /* End of function bsp_non_existent_port_init() */
ffe0320f:	3f 6d 09                      	rtsd	#36, r6-r13

ffe03212 <.LFE3>:
ffe03212:	00                            	brk
ffe03213:	00                            	brk
ffe03214:	00                            	brk
ffe03215:	00                            	brk
	...

ffe03218 <_bsp_interrupt_enable_disable>:
#ifdef __FPU
    uint32_t      tmp_fpsw;
#endif
    bsp_int_err_t err = BSP_INT_SUCCESS;

    switch (vector)
ffe03218:	61 31                         	cmp	#3, r1
ffe0321a:	20 4b                         	beq.b	ffe03265 <_Reset_Vector+0xffe03269>
ffe0321c:	61 b1                         	cmp	#11, r1
ffe0321e:	20 1a                         	beq.b	ffe03238 <_Reset_Vector+0xffe0323c>
ffe03220:	61 21                         	cmp	#2, r1
ffe03222:	14                            	beq.s	ffe03226 <_Reset_Vector+0xffe0322a>

ffe03223 <.LVL72>:
                ICU.NMIER.BIT.NMIEN = 1;
            }
            else
            {
                /* NMI pin interrupts cannot be disabled after being enabled. */
                err = BSP_INT_ERR_UNSUPPORTED;
ffe03223:	66 31                         	mov.l	#3, r1

ffe03225 <.LVL73>:
            err = BSP_INT_ERR_UNSUPPORTED;
            break;
    }

    return err;
} /* End of function bsp_interrupt_enable_disable() */
ffe03225:	02                            	rts

ffe03226 <.LVL74>:
            if (true == enable)
ffe03226:	5b 22                         	movu.b	r2, r2
ffe03228:	61 02                         	cmp	#0, r2
ffe0322a:	20 f9                         	beq.b	ffe03223 <_Reset_Vector+0xffe03227>
                ICU.NMIER.BIT.NMIEN = 1;
ffe0322c:	fb 5e 00 70 08                	mov.l	#0x87000, r5
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03231:	66 01                         	mov.l	#0, r1

ffe03233 <.LVL75>:
                ICU.NMIER.BIT.NMIEN = 1;
ffe03233:	f2 50 81 05                   	bset	#0, 1409[r5].b
ffe03237:	02                            	rts

ffe03238 <.LVL76>:
            if (true == enable)
ffe03238:	5b 22                         	movu.b	r2, r2
ffe0323a:	61 02                         	cmp	#0, r2
ffe0323c:	20 46                         	beq.b	ffe03282 <_Reset_Vector+0xffe03286>
                IR(BSC,BUSERR) = 0;
ffe0323e:	fb 5e 00 70 08                	mov.l	#0x87000, r5
                R_BSP_InterruptRequestEnable(VECT(BSC,BUSERR));
ffe03243:	75 41 10                      	mov.l	#16, r1

ffe03246 <.LVL77>:
                IR(BSC,BUSERR) = 0;
ffe03246:	f1 58 10                      	bclr	#0, 16[r5].b
                IPR(BSC,BUSERR) = 0x0F;
ffe03249:	ce 54 00 03                   	mov.b	768[r5], r4
ffe0324d:	65 f4                         	or	#15, r4
ffe0324f:	cb 54 00 03                   	mov.b	r4, 768[r5]
                R_BSP_InterruptRequestEnable(VECT(BSC,BUSERR));
ffe03253:	05 78 05 00                   	bsr.a	ffe037cb <_Reset_Vector+0xffe037cf>

ffe03257 <.LVL78>:
                BSC.BEREN.BIT.IGAEN = 1;
ffe03257:	fb 5e 00 13 08                	mov.l	#0x81300, r5
ffe0325c:	f1 50 04                      	bset	#0, 4[r5].b
                BSC.BEREN.BIT.TOEN = 1;
ffe0325f:	f1 51 04                      	bset	#1, 4[r5].b
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03262:	66 01                         	mov.l	#0, r1
ffe03264:	02                            	rts

ffe03265 <.LVL79>:
            tmp_fpsw = (uint32_t)R_BSP_GET_FPSW();
ffe03265:	fd 6a 35                      	mvfc	fpsw, r5

ffe03268 <.LVL80>:
            if (true == enable)
ffe03268:	5b 22                         	movu.b	r2, r2
ffe0326a:	61 02                         	cmp	#0, r2
ffe0326c:	20 0c                         	beq.b	ffe03278 <_Reset_Vector+0xffe0327c>
                R_BSP_SET_FPSW((tmp_fpsw | (uint32_t)BSP_PRV_FPU_EXCEPTIONS_ENABLE));
ffe0326e:	76 35 00 7c                   	or	#0x7c00, r5

ffe03272 <.LVL81>:
ffe03272:	fd 68 53                      	mvtc	r5, fpsw
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03275:	66 01                         	mov.l	#0, r1

ffe03277 <.LVL82>:
ffe03277:	02                            	rts

ffe03278 <.LVL83>:
                R_BSP_SET_FPSW((tmp_fpsw & (uint32_t)~BSP_PRV_FPU_EXCEPTIONS_ENABLE));
ffe03278:	76 25 ff 83                   	and	#0xffff83ff, r5

ffe0327c <.LVL84>:
ffe0327c:	fd 68 53                      	mvtc	r5, fpsw
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe0327f:	66 01                         	mov.l	#0, r1

ffe03281 <.LVL85>:
ffe03281:	02                            	rts

ffe03282 <.LVL86>:
                R_BSP_InterruptRequestDisable(VECT(BSC,BUSERR));
ffe03282:	75 41 10                      	mov.l	#16, r1

ffe03285 <.LVL87>:
ffe03285:	05 56 05 00                   	bsr.a	ffe037db <_Reset_Vector+0xffe037df>

ffe03289 <.LVL88>:
                BSC.BEREN.BIT.IGAEN = 0;
ffe03289:	fb 5e 00 13 08                	mov.l	#0x81300, r5
ffe0328e:	f1 58 04                      	bclr	#0, 4[r5].b
                BSC.BEREN.BIT.TOEN = 0;
ffe03291:	f1 59 04                      	bclr	#1, 4[r5].b
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03294:	66 01                         	mov.l	#0, r1
ffe03296:	02                            	rts

ffe03297 <.LFE9>:
ffe03297:	03                            	nop

ffe03298 <_bsp_mapped_interrupt_open>:
***********************************************************************************************************************/
void bsp_mapped_interrupt_open (void)
{
#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMT2_CMI2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMT2_CMI2) = BSP_PRV_INT_B_NUM_CMT2_CMI2;
ffe03298:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe0329d:	fa 54 80 07 01                	mov.b	#1, 1920[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMT3_CMI3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMT3_CMI3) = BSP_PRV_INT_B_NUM_CMT3_CMI3;
ffe032a2:	fa 54 81 07 02                	mov.b	#2, 1921[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_CMIA0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_CMIA0) = BSP_PRV_INT_B_NUM_TMR0_CMIA0;
ffe032a7:	fa 54 92 07 03                	mov.b	#3, 1938[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_CMIB0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_CMIB0) = BSP_PRV_INT_B_NUM_TMR0_CMIB0;
ffe032ac:	fa 54 93 07 04                	mov.b	#4, 1939[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_OVI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR0_OVI0) = BSP_PRV_INT_B_NUM_TMR0_OVI0;
ffe032b1:	fa 54 94 07 05                	mov.b	#5, 1940[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_CMIA1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_CMIA1) = BSP_PRV_INT_B_NUM_TMR1_CMIA1;
ffe032b6:	fa 54 95 07 06                	mov.b	#6, 1941[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_CMIB1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_CMIB1) = BSP_PRV_INT_B_NUM_TMR1_CMIB1;
ffe032bb:	fa 54 96 07 07                	mov.b	#7, 1942[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_OVI1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR1_OVI1) = BSP_PRV_INT_B_NUM_TMR1_OVI1;
ffe032c0:	fa 54 97 07 08                	mov.b	#8, 1943[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_CMIA2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_CMIA2) = BSP_PRV_INT_B_NUM_TMR2_CMIA2;
ffe032c5:	fa 54 98 07 09                	mov.b	#9, 1944[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_CMIB2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_CMIB2) = BSP_PRV_INT_B_NUM_TMR2_CMIB2;
ffe032ca:	fa 54 99 07 0a                	mov.b	#10, 1945[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_OVI2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR2_OVI2) = BSP_PRV_INT_B_NUM_TMR2_OVI2;
ffe032cf:	fa 54 9a 07 0b                	mov.b	#11, 1946[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_CMIA3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_CMIA3) = BSP_PRV_INT_B_NUM_TMR3_CMIA3;
ffe032d4:	fa 54 9b 07 0c                	mov.b	#12, 1947[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_CMIB3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_CMIB3) = BSP_PRV_INT_B_NUM_TMR3_CMIB3;
ffe032d9:	fa 54 9c 07 0d                	mov.b	#13, 1948[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_OVI3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TMR3_OVI3) = BSP_PRV_INT_B_NUM_TMR3_OVI3;
ffe032de:	fa 54 9d 07 0e                	mov.b	#14, 1949[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0A) = BSP_PRV_INT_B_NUM_TPU0_TGI0A;
ffe032e3:	fa 54 82 07 0f                	mov.b	#15, 1922[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0B) = BSP_PRV_INT_B_NUM_TPU0_TGI0B;
ffe032e8:	fa 54 83 07 10                	mov.b	#16, 1923[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0C)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0C) = BSP_PRV_INT_B_NUM_TPU0_TGI0C;
ffe032ed:	fa 54 84 07 11                	mov.b	#17, 1924[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0D)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TGI0D) = BSP_PRV_INT_B_NUM_TPU0_TGI0D;
ffe032f2:	fa 54 85 07 12                	mov.b	#18, 1925[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TCI0V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU0_TCI0V) = BSP_PRV_INT_B_NUM_TPU0_TCI0V;
ffe032f7:	fa 54 86 07 13                	mov.b	#19, 1926[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TGI1A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TGI1A) = BSP_PRV_INT_B_NUM_TPU1_TGI1A;
ffe032fc:	fa 54 90 07 14                	mov.b	#20, 1936[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TGI1B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TGI1B) = BSP_PRV_INT_B_NUM_TPU1_TGI1B;
ffe03301:	fa 54 87 07 15                	mov.b	#21, 1927[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TCI1V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TCI1V) = BSP_PRV_INT_B_NUM_TPU1_TCI1V;
ffe03306:	fa 54 88 07 16                	mov.b	#22, 1928[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TCI1U)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU1_TCI1U) = BSP_PRV_INT_B_NUM_TPU1_TCI1U;
ffe0330b:	fa 54 89 07 17                	mov.b	#23, 1929[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TGI2A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TGI2A) = BSP_PRV_INT_B_NUM_TPU2_TGI2A;
ffe03310:	fa 54 8a 07 18                	mov.b	#24, 1930[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TGI2B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TGI2B) = BSP_PRV_INT_B_NUM_TPU2_TGI2B;
ffe03315:	fa 54 8b 07 19                	mov.b	#25, 1931[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TCI2V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TCI2V) = BSP_PRV_INT_B_NUM_TPU2_TCI2V;
ffe0331a:	fa 54 8c 07 1a                	mov.b	#26, 1932[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TCI2U)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU2_TCI2U) = BSP_PRV_INT_B_NUM_TPU2_TCI2U;
ffe0331f:	fa 54 8d 07 1b                	mov.b	#27, 1933[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3A) = BSP_PRV_INT_B_NUM_TPU3_TGI3A;
ffe03324:	fa 54 8e 07 1c                	mov.b	#28, 1934[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3B) = BSP_PRV_INT_B_NUM_TPU3_TGI3B;
ffe03329:	fa 54 8f 07 1d                	mov.b	#29, 1935[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3C)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3C) = BSP_PRV_INT_B_NUM_TPU3_TGI3C;
ffe0332e:	fa 54 91 07 1e                	mov.b	#30, 1937[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3D)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TGI3D) = BSP_PRV_INT_B_NUM_TPU3_TGI3D;
ffe03333:	fa 54 9e 07 1f                	mov.b	#31, 1950[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TCI3V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU3_TCI3V) = BSP_PRV_INT_B_NUM_TPU3_TCI3V;
ffe03338:	fa 54 9f 07 20                	mov.b	#32, 1951[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TGI4A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TGI4A) = BSP_PRV_INT_B_NUM_TPU4_TGI4A;
ffe0333d:	fa 54 a0 07 21                	mov.b	#33, 1952[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TGI4B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TGI4B) = BSP_PRV_INT_B_NUM_TPU4_TGI4B;
ffe03342:	fa 54 a1 07 22                	mov.b	#34, 1953[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TCI4V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TCI4V) = BSP_PRV_INT_B_NUM_TPU4_TCI4V;
ffe03347:	fa 54 a2 07 23                	mov.b	#35, 1954[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TCI4U)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU4_TCI4U) = BSP_PRV_INT_B_NUM_TPU4_TCI4U;
ffe0334c:	fa 54 a3 07 24                	mov.b	#36, 1955[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TGI5A)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TGI5A) = BSP_PRV_INT_B_NUM_TPU5_TGI5A;
ffe03351:	fa 54 a4 07 25                	mov.b	#37, 1956[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TGI5B)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TGI5B) = BSP_PRV_INT_B_NUM_TPU5_TGI5B;
ffe03356:	fa 54 a5 07 26                	mov.b	#38, 1957[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TCI5V)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TCI5V) = BSP_PRV_INT_B_NUM_TPU5_TCI5V;
ffe0335b:	fa 54 a6 07 27                	mov.b	#39, 1958[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TCI5U)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TPU5_TCI5U) = BSP_PRV_INT_B_NUM_TPU5_TCI5U;
ffe03360:	fa 54 a7 07 28                	mov.b	#40, 1959[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_IC0I0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_IC0I0) = BSP_PRV_INT_B_NUM_CMTW0_IC0I0;
ffe03365:	fa 54 a8 07 29                	mov.b	#41, 1960[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_IC1I0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_IC1I0) = BSP_PRV_INT_B_NUM_CMTW0_IC1I0;
ffe0336a:	fa 54 a9 07 2a                	mov.b	#42, 1961[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_OC0I0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_OC0I0) = BSP_PRV_INT_B_NUM_CMTW0_OC0I0;
ffe0336f:	fa 54 aa 07 2b                	mov.b	#43, 1962[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_OC1I0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW0_OC1I0) = BSP_PRV_INT_B_NUM_CMTW0_OC1I0;
ffe03374:	fa 54 ab 07 2c                	mov.b	#44, 1963[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_IC0I1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_IC0I1) = BSP_PRV_INT_B_NUM_CMTW1_IC0I1;
ffe03379:	fa 54 ac 07 2d                	mov.b	#45, 1964[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_IC1I1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_IC1I1) = BSP_PRV_INT_B_NUM_CMTW1_IC1I1;
ffe0337e:	fa 54 ad 07 2e                	mov.b	#46, 1965[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_OC0I1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_OC0I1) = BSP_PRV_INT_B_NUM_CMTW1_OC0I1;
ffe03383:	fa 54 ae 07 2f                	mov.b	#47, 1966[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_OC1I1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CMTW1_OC1I1) = BSP_PRV_INT_B_NUM_CMTW1_OC1I1;
ffe03388:	fa 54 af 07 30                	mov.b	#48, 1967[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_RTC_CUP)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_RTC_CUP) = BSP_PRV_INT_B_NUM_RTC_CUP;
ffe0338d:	fa 54 b0 07 31                	mov.b	#49, 1968[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_RXF0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_RXF0) = BSP_PRV_INT_B_NUM_CAN0_RXF0;
ffe03392:	fa 54 b1 07 32                	mov.b	#50, 1969[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_TXF0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_TXF0) = BSP_PRV_INT_B_NUM_CAN0_TXF0;
ffe03397:	fa 54 b2 07 33                	mov.b	#51, 1970[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_RXM0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_RXM0) = BSP_PRV_INT_B_NUM_CAN0_RXM0;
ffe0339c:	fa 54 b3 07 34                	mov.b	#52, 1971[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_TXM0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN0_TXM0) = BSP_PRV_INT_B_NUM_CAN0_TXM0;
ffe033a1:	fa 54 b4 07 35                	mov.b	#53, 1972[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_RXF1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_RXF1) = BSP_PRV_INT_B_NUM_CAN1_RXF1;
ffe033a6:	fa 54 b5 07 36                	mov.b	#54, 1973[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_TXF1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_TXF1) = BSP_PRV_INT_B_NUM_CAN1_TXF1;
ffe033ab:	fa 54 b6 07 37                	mov.b	#55, 1974[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_RXM1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_RXM1) = BSP_PRV_INT_B_NUM_CAN1_RXM1;
ffe033b0:	fa 54 b7 07 38                	mov.b	#56, 1975[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_TXM1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_CAN1_TXM1) = BSP_PRV_INT_B_NUM_CAN1_TXM1;
ffe033b5:	fa 54 b8 07 39                	mov.b	#57, 1976[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_USB0_USBI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_USB0_USBI0) = BSP_PRV_INT_B_NUM_USB0_USBI0;
ffe033ba:	fa 54 b9 07 3e                	mov.b	#62, 1977[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12ADI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12ADI0) = BSP_PRV_INT_B_NUM_S12ADC0_S12ADI0;
ffe033bf:	fa 54 ba 07 40                	mov.b	#64, 1978[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12GBADI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12GBADI0) = BSP_PRV_INT_B_NUM_S12ADC0_S12GBADI0;
ffe033c4:	fa 54 bb 07 41                	mov.b	#65, 1979[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12GCADI0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC0_S12GCADI0) = BSP_PRV_INT_B_NUM_S12ADC0_S12GCADI0;
ffe033c9:	fa 54 bc 07 42                	mov.b	#66, 1980[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12ADI1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12ADI1) = BSP_PRV_INT_B_NUM_S12ADC1_S12ADI1;
ffe033ce:	fa 54 bd 07 44                	mov.b	#68, 1981[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12GBADI1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12GBADI1) = BSP_PRV_INT_B_NUM_S12ADC1_S12GBADI1;
ffe033d3:	fa 54 be 07 45                	mov.b	#69, 1982[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12GCADI1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_S12ADC1_S12GCADI1) = BSP_PRV_INT_B_NUM_S12ADC1_S12GCADI1;
ffe033d8:	fa 54 bf 07 46                	mov.b	#70, 1983[r5]
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_RNG_RNGEND) = BSP_PRV_INT_B_NUM_RNG_RNGEND;
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_ELC_ELSR18I)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_ELC_ELSR18I) = BSP_PRV_INT_B_NUM_ELC_ELSR18I;
ffe033dd:	fa 54 c0 07 4f                	mov.b	#79, 1984[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_ELC_ELSR19I)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_ELC_ELSR19I) = BSP_PRV_INT_B_NUM_ELC_ELSR19I;
ffe033e2:	fa 54 c1 07 50                	mov.b	#80, 1985[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_PROC_BUSY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_PROC_BUSY) = BSP_PRV_INT_B_NUM_TSIP_PROC_BUSY;
ffe033e7:	fa 54 c2 07 55                	mov.b	#85, 1986[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_ROMOK)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_ROMOK) = BSP_PRV_INT_B_NUM_TSIP_ROMOK;
ffe033ec:	fa 54 c3 07 56                	mov.b	#86, 1987[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_LONG_PLG)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_LONG_PLG) = BSP_PRV_INT_B_NUM_TSIP_LONG_PLG;
ffe033f1:	fa 54 c4 07 57                	mov.b	#87, 1988[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_TEST_BUSY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_TEST_BUSY) = BSP_PRV_INT_B_NUM_TSIP_TEST_BUSY;
ffe033f6:	fa 54 c5 07 58                	mov.b	#88, 1989[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY0) = BSP_PRV_INT_B_NUM_TSIP_WRRDY0;
ffe033fb:	fa 54 c6 07 59                	mov.b	#89, 1990[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY1) = BSP_PRV_INT_B_NUM_TSIP_WRRDY1;
ffe03400:	fa 54 c7 07 5a                	mov.b	#90, 1991[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_WRRDY4) = BSP_PRV_INT_B_NUM_TSIP_WRRDY4;
ffe03405:	fa 54 c8 07 5b                	mov.b	#91, 1992[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_RDRDY0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_RDRDY0) = BSP_PRV_INT_B_NUM_TSIP_RDRDY0;
ffe0340a:	fa 54 c9 07 5c                	mov.b	#92, 1993[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_RDRDY1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_RDRDY1) = BSP_PRV_INT_B_NUM_TSIP_RDRDY1;
ffe0340f:	fa 54 ca 07 5d                	mov.b	#93, 1994[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_INTEGRATE_WRRDY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_INTEGRATE_WRRDY) = BSP_PRV_INT_B_NUM_TSIP_INTEGRATE_WRRDY;
ffe03414:	fa 54 cb 07 5e                	mov.b	#94, 1995[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_INTEGRATE_RDRDY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_B, BSP_MAPPED_INT_CFG_B_VECT_TSIP_INTEGRATE_RDRDY) = BSP_PRV_INT_B_NUM_TSIP_INTEGRATE_RDRDY;
ffe03419:	fa 54 cc 07 5f                	mov.b	#95, 1996[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIA0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIA0) = BSP_PRV_INT_A_NUM_MTU0_TGIA0;
ffe0341e:	fa 54 d1 09 01                	mov.b	#1, 2513[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIB0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIB0) = BSP_PRV_INT_A_NUM_MTU0_TGIB0;
ffe03423:	fa 54 d2 09 02                	mov.b	#2, 2514[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIC0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIC0) = BSP_PRV_INT_A_NUM_MTU0_TGIC0;
ffe03428:	fa 54 d3 09 03                	mov.b	#3, 2515[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGID0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGID0) = BSP_PRV_INT_A_NUM_MTU0_TGID0;
ffe0342d:	fa 54 d4 09 04                	mov.b	#4, 2516[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TCIV0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TCIV0) = BSP_PRV_INT_A_NUM_MTU0_TCIV0;
ffe03432:	fa 54 d5 09 05                	mov.b	#5, 2517[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIE0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIE0) = BSP_PRV_INT_A_NUM_MTU0_TGIE0;
ffe03437:	fa 54 d6 09 06                	mov.b	#6, 2518[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIF0)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU0_TGIF0) = BSP_PRV_INT_A_NUM_MTU0_TGIF0;
ffe0343c:	fa 54 d7 09 07                	mov.b	#7, 2519[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIA1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIA1) = BSP_PRV_INT_A_NUM_MTU1_TGIA1;
ffe03441:	fa 54 d0 09 08                	mov.b	#8, 2512[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIB1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TGIB1) = BSP_PRV_INT_A_NUM_MTU1_TGIB1;
ffe03446:	fa 54 d8 09 09                	mov.b	#9, 2520[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIV1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIV1) = BSP_PRV_INT_A_NUM_MTU1_TCIV1;
ffe0344b:	fa 54 d9 09 0a                	mov.b	#10, 2521[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIU1)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU1_TCIU1) = BSP_PRV_INT_A_NUM_MTU1_TCIU1;
ffe03450:	fa 54 da 09 0b                	mov.b	#11, 2522[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIA2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIA2) = BSP_PRV_INT_A_NUM_MTU2_TGIA2;
ffe03455:	fa 54 db 09 0c                	mov.b	#12, 2523[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIB2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TGIB2) = BSP_PRV_INT_A_NUM_MTU2_TGIB2;
ffe0345a:	fa 54 dc 09 0d                	mov.b	#13, 2524[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIV2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIV2) = BSP_PRV_INT_A_NUM_MTU2_TCIV2;
ffe0345f:	fa 54 dd 09 0e                	mov.b	#14, 2525[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIU2)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU2_TCIU2) = BSP_PRV_INT_A_NUM_MTU2_TCIU2;
ffe03464:	fa 54 de 09 0f                	mov.b	#15, 2526[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIA3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIA3) = BSP_PRV_INT_A_NUM_MTU3_TGIA3;
ffe03469:	fa 54 df 09 10                	mov.b	#16, 2527[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIB3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIB3) = BSP_PRV_INT_A_NUM_MTU3_TGIB3;
ffe0346e:	fa 54 e0 09 11                	mov.b	#17, 2528[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIC3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGIC3) = BSP_PRV_INT_A_NUM_MTU3_TGIC3;
ffe03473:	fa 54 e1 09 12                	mov.b	#18, 2529[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGID3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TGID3) = BSP_PRV_INT_A_NUM_MTU3_TGID3;
ffe03478:	fa 54 e2 09 13                	mov.b	#19, 2530[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TCIV3)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU3_TCIV3) = BSP_PRV_INT_A_NUM_MTU3_TCIV3;
ffe0347d:	fa 54 e3 09 14                	mov.b	#20, 2531[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIA4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIA4) = BSP_PRV_INT_A_NUM_MTU4_TGIA4;
ffe03482:	fa 54 e4 09 15                	mov.b	#21, 2532[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIB4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIB4) = BSP_PRV_INT_A_NUM_MTU4_TGIB4;
ffe03487:	fa 54 e5 09 16                	mov.b	#22, 2533[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIC4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGIC4) = BSP_PRV_INT_A_NUM_MTU4_TGIC4;
ffe0348c:	fa 54 e6 09 17                	mov.b	#23, 2534[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGID4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TGID4) = BSP_PRV_INT_A_NUM_MTU4_TGID4;
ffe03491:	fa 54 e7 09 18                	mov.b	#24, 2535[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TCIV4)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU4_TCIV4) = BSP_PRV_INT_A_NUM_MTU4_TCIV4;
ffe03496:	fa 54 e8 09 19                	mov.b	#25, 2536[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIU5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIU5) = BSP_PRV_INT_A_NUM_MTU5_TGIU5;
ffe0349b:	fa 54 e9 09 1b                	mov.b	#27, 2537[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIV5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIV5) = BSP_PRV_INT_A_NUM_MTU5_TGIV5;
ffe034a0:	fa 54 ea 09 1c                	mov.b	#28, 2538[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIW5)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU5_TGIW5) = BSP_PRV_INT_A_NUM_MTU5_TGIW5;
ffe034a5:	fa 54 eb 09 1d                	mov.b	#29, 2539[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIA6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIA6) = BSP_PRV_INT_A_NUM_MTU6_TGIA6;
ffe034aa:	fa 54 ec 09 1e                	mov.b	#30, 2540[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIB6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIB6) = BSP_PRV_INT_A_NUM_MTU6_TGIB6;
ffe034af:	fa 54 ed 09 1f                	mov.b	#31, 2541[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIC6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGIC6) = BSP_PRV_INT_A_NUM_MTU6_TGIC6;
ffe034b4:	fa 54 ee 09 20                	mov.b	#32, 2542[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGID6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TGID6) = BSP_PRV_INT_A_NUM_MTU6_TGID6;
ffe034b9:	fa 54 ef 09 21                	mov.b	#33, 2543[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TCIV6)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU6_TCIV6) = BSP_PRV_INT_A_NUM_MTU6_TCIV6;
ffe034be:	fa 54 f0 09 22                	mov.b	#34, 2544[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIA7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIA7) = BSP_PRV_INT_A_NUM_MTU7_TGIA7;
ffe034c3:	fa 54 f1 09 23                	mov.b	#35, 2545[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIB7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIB7) = BSP_PRV_INT_A_NUM_MTU7_TGIB7;
ffe034c8:	fa 54 f2 09 24                	mov.b	#36, 2546[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIC7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGIC7) = BSP_PRV_INT_A_NUM_MTU7_TGIC7;
ffe034cd:	fa 54 f3 09 25                	mov.b	#37, 2547[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGID7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TGID7) = BSP_PRV_INT_A_NUM_MTU7_TGID7;
ffe034d2:	fa 54 f4 09 26                	mov.b	#38, 2548[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TCIV7)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU7_TCIV7) = BSP_PRV_INT_A_NUM_MTU7_TCIV7;
ffe034d7:	fa 54 f5 09 27                	mov.b	#39, 2549[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIA8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIA8) = BSP_PRV_INT_A_NUM_MTU8_TGIA8;
ffe034dc:	fa 54 f6 09 29                	mov.b	#41, 2550[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIB8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIB8) = BSP_PRV_INT_A_NUM_MTU8_TGIB8;
ffe034e1:	fa 54 f7 09 2a                	mov.b	#42, 2551[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIC8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGIC8) = BSP_PRV_INT_A_NUM_MTU8_TGIC8;
ffe034e6:	fa 54 f8 09 2b                	mov.b	#43, 2552[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGID8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TGID8) = BSP_PRV_INT_A_NUM_MTU8_TGID8;
ffe034eb:	fa 54 f9 09 2c                	mov.b	#44, 2553[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TCIV8)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_MTU8_TCIV8) = BSP_PRV_INT_A_NUM_MTU8_TCIV8;
ffe034f0:	fa 54 fa 09 2d                	mov.b	#45, 2554[r5]
#endif

#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_AES_AESRDY)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_AES_AESRDY) = BSP_PRV_INT_A_NUM_AES_AESRDY;
ffe034f5:	fa 54 fb 09 58                	mov.b	#88, 2555[r5]
#if BSP_PRV_VALID_MAP_INT(A, BSP_MAPPED_INT_CFG_A_VECT_AES_AESEND)
    /* Casting is valid because it matches the type to the right side or argument. */
    BSP_PRV_INT_SELECT(BSP_PRV_A, BSP_MAPPED_INT_CFG_A_VECT_AES_AESEND) = BSP_PRV_INT_A_NUM_AES_AESEND;
#endif

} /* End of function bsp_mapped_interrupt_open() */
ffe034fa:	02                            	rts

ffe034fb <_delay_wait>:
***********************************************************************************************************************/
R_BSP_PRAGMA_STATIC_INLINE_ASM(delay_wait)
void delay_wait (unsigned long loop_cnt)
{
    R_BSP_ASM_INTERNAL_USED(loop_cnt)
    R_BSP_ASM_BEGIN
ffe034fb:	2e 03                         	bra.b	ffe034fe <_Reset_Vector+0xffe03502>
ffe034fd:	03                            	nop
ffe034fe:	03                            	nop
ffe034ff:	60 11                         	sub	#1, r1
ffe03501:	21 fd                         	bne.b	ffe034fe <_Reset_Vector+0xffe03502>
ffe03503:	02                            	rts

ffe03504 <.LFE4>:
ffe03504:	00                            	brk
ffe03505:	00                            	brk
	...

ffe03508 <_R_BSP_SoftwareDelay>:
 * The actual delay time is plus the overhead at a specified duration. The overhead changes under the influence of 
 * the compiler, operating frequency and ROM cache. When the operating frequency is low, or the specified duration in 
 * units of microsecond level, please note that the error becomes large.
 */
bool R_BSP_SoftwareDelay(uint32_t delay, bsp_delay_units_t units)
{
ffe03508:	6e 7a                         	pushm	r7-r10
ffe0350a:	71 00 e4                      	add	#-28, r0, r0
ffe0350d:	ef 27                         	mov.l	r2, r7
ffe0350f:	ef 1a                         	mov.l	r1, r10
    volatile uint32_t loop_cnt;
    volatile uint64_t delay_cycles_64;
    volatile uint64_t loop_cnt_64;

#ifdef BSP_CFG_PARAM_CHECKING_ENABLE
    if ((BSP_DELAY_MICROSECS != units) && (BSP_DELAY_MILLISECS != units) && (BSP_DELAY_SECS != units))
ffe03511:	77 02 40 42 0f                	cmp	#0xf4240, r2
ffe03516:	20 6f                         	beq.b	ffe03585 <_Reset_Vector+0xffe03589>
ffe03518:	76 02 e8 03                   	cmp	#0x3e8, r2
ffe0351c:	16                            	beq.s	ffe03522 <_Reset_Vector+0xffe03526>
ffe0351d:	61 12                         	cmp	#1, r2
ffe0351f:	3b 9d 00                      	bne.w	ffe035bc <_Reset_Vector+0xffe035c0>

ffe03522 <.LBB4>:
    return get_iclk_freq_hz();  // Get the MCU specific ICLK frequency
ffe03522:	05 7e f9 ff                   	bsr.a	ffe02ea0 <_Reset_Vector+0xffe02ea4>

ffe03526 <.LBE4>:
    {
        return(false);
    }
#endif

    iclk_rate = R_BSP_GetIClkFreqHz();  /* Get the current ICLK frequency */
ffe03526:	a1 81                         	mov.l	r1, 24[r0]
        }
    }
    else
    {
        /* Casting is valid because it matches the type to the right side or argument. */
        delay_cycles_64 = (((uint64_t)iclk_rate * (uint64_t)delay) / units);
ffe03528:	ed 0e 06                      	mov.l	24[r0], r14
ffe0352b:	ef 73                         	mov.l	r7, r3
ffe0352d:	66 04                         	mov.l	#0, r4
ffe0352f:	fc 1f ae                      	emulu	r10, r14
ffe03532:	ef e1                         	mov.l	r14, r1
ffe03534:	ef f2                         	mov.l	r15, r2
ffe03536:	05 c2 22 00                   	bsr.a	ffe057f8 <_Reset_Vector+0xffe057fc>
ffe0353a:	a0 81                         	mov.l	r1, 8[r0]
ffe0353c:	a0 8a                         	mov.l	r2, 12[r0]

        if (delay_cycles_64 > BSP_PRV_OVERHEAD_CYCLES_64)
ffe0353e:	ed 0a 02                      	mov.l	8[r0], r10

ffe03541 <.LVL5>:
ffe03541:	a8 8f                         	mov.l	12[r0], r7

ffe03543 <.LVL6>:
ffe03543:	61 07                         	cmp	#0, r7
ffe03545:	21 7e                         	bne.b	ffe035c3 <_Reset_Vector+0xffe035c7>
ffe03547:	61 2a                         	cmp	#2, r10
ffe03549:	24 7a                         	bgtu.b	ffe035c3 <_Reset_Vector+0xffe035c7>
        {
            delay_cycles_64 -= BSP_PRV_OVERHEAD_CYCLES_64;
        }
        else
        {
            delay_cycles = 0;
ffe0354b:	3e 05 00                      	mov.l	#0, 20[r0]
        }

        loop_cnt_64 = delay_cycles_64 / CPU_CYCLES_PER_LOOP;
ffe0354e:	a8 87                         	mov.l	8[r0], r7
ffe03550:	a8 8d                         	mov.l	12[r0], r5
ffe03552:	68 27                         	shlr	#2, r7
ffe03554:	fd de 5a                      	shll	#30, r5, r10
ffe03557:	68 25                         	shlr	#2, r5
ffe03559:	57 a7                         	or	r10, r7
ffe0355b:	e3 07                         	mov.l	r7, [r0]
ffe0355d:	a0 0d                         	mov.l	r5, 4[r0]

        if ((loop_cnt_64 > 0xFFFFFFFFUL) || (0 == loop_cnt_64))
ffe0355f:	ec 07                         	mov.l	[r0], r7
ffe03561:	a8 0f                         	mov.l	4[r0], r7
ffe03563:	61 07                         	cmp	#0, r7
ffe03565:	21 57                         	bne.b	ffe035bc <_Reset_Vector+0xffe035c0>
ffe03567:	ec 07                         	mov.l	[r0], r7
ffe03569:	06 95 07 01                   	or	4[r0].l, r7
ffe0356d:	61 07                         	cmp	#0, r7
ffe0356f:	20 4d                         	beq.b	ffe035bc <_Reset_Vector+0xffe035c0>
             * also results in the minimum possible delay. */
            return(false);
        }

        /* Casting is valid because it matches the type to the right side or argument. */
        loop_cnt = (uint32_t)loop_cnt_64;
ffe03571:	ec 07                         	mov.l	[r0], r7
ffe03573:	ed 0a 01                      	mov.l	4[r0], r10
ffe03576:	a1 07                         	mov.l	r7, 16[r0]
    }

    delay_wait(loop_cnt);
ffe03578:	a9 01                         	mov.l	16[r0], r1
ffe0357a:	05 81 ff ff                   	bsr.a	ffe034fb <_Reset_Vector+0xffe034ff>

ffe0357e <.LVL7>:

    return(true);
ffe0357e:	66 11                         	mov.l	#1, r1
ffe03580:	5b 11                         	movu.b	r1, r1
} /* End of function R_BSP_SoftwareDelay() */
ffe03582:	3f 7a 0b                      	rtsd	#44, r7-r10

ffe03585 <.LBB7>:
    return get_iclk_freq_hz();  // Get the MCU specific ICLK frequency
ffe03585:	05 1b f9 ff                   	bsr.a	ffe02ea0 <_Reset_Vector+0xffe02ea4>

ffe03589 <.LBE7>:
    iclk_rate = R_BSP_GetIClkFreqHz();  /* Get the current ICLK frequency */
ffe03589:	a1 81                         	mov.l	r1, 24[r0]
         (delay <= (0xFFFFFFFFUL / iclk_rate)) )  /* Ensure (iclk_rate * delay) will not exceed 32 bits */
ffe0358b:	a9 84                         	mov.l	24[r0], r4
ffe0358d:	fc 1f a4                      	emulu	r10, r4
ffe03590:	61 05                         	cmp	#0, r5
ffe03592:	21 96                         	bne.b	ffe03528 <_Reset_Vector+0xffe0352c>
        delay_cycles = ((iclk_rate * delay) / units);
ffe03594:	ed 0e 06                      	mov.l	24[r0], r14
ffe03597:	4f ae                         	mul	r10, r14
ffe03599:	fb a2 83 de 1b 43             	mov.l	#0x431bde83, r10

ffe0359f <.LVL10>:
ffe0359f:	fc 1f ae                      	emulu	r10, r14
ffe035a2:	fd 92 f7                      	shlr	#18, r15, r7

ffe035a5 <.LVL11>:
ffe035a5:	a1 0f                         	mov.l	r7, 20[r0]
        if (delay_cycles > BSP_PRV_OVERHEAD_CYCLES)
ffe035a7:	a9 0f                         	mov.l	20[r0], r7
ffe035a9:	61 27                         	cmp	#2, r7
ffe035ab:	24 2b                         	bgtu.b	ffe035d6 <_Reset_Vector+0xffe035da>
            delay_cycles = 0;
ffe035ad:	3e 05 00                      	mov.l	#0, 20[r0]
        loop_cnt = delay_cycles / CPU_CYCLES_PER_LOOP;
ffe035b0:	a9 0f                         	mov.l	20[r0], r7
ffe035b2:	68 27                         	shlr	#2, r7
ffe035b4:	a1 07                         	mov.l	r7, 16[r0]
        if (0 == loop_cnt)
ffe035b6:	a9 07                         	mov.l	16[r0], r7
ffe035b8:	61 07                         	cmp	#0, r7
ffe035ba:	21 be                         	bne.b	ffe03578 <_Reset_Vector+0xffe0357c>
        return(false);
ffe035bc:	66 01                         	mov.l	#0, r1
ffe035be:	5b 11                         	movu.b	r1, r1
} /* End of function R_BSP_SoftwareDelay() */
ffe035c0:	3f 7a 0b                      	rtsd	#44, r7-r10
            delay_cycles_64 -= BSP_PRV_OVERHEAD_CYCLES_64;
ffe035c3:	ed 0a 02                      	mov.l	8[r0], r10
ffe035c6:	a8 8f                         	mov.l	12[r0], r7
ffe035c8:	71 a5 fe                      	add	#-2, r10, r5
ffe035cb:	fd 74 27 ff                   	adc	#-1, r7
ffe035cf:	a0 85                         	mov.l	r5, 8[r0]
ffe035d1:	a0 8f                         	mov.l	r7, 12[r0]
ffe035d3:	38 7b ff                      	bra.w	ffe0354e <_Reset_Vector+0xffe03552>
            delay_cycles -= BSP_PRV_OVERHEAD_CYCLES;
ffe035d6:	a9 0f                         	mov.l	20[r0], r7
ffe035d8:	60 27                         	sub	#2, r7
ffe035da:	a1 0f                         	mov.l	r7, 20[r0]
ffe035dc:	2e d4                         	bra.b	ffe035b0 <_Reset_Vector+0xffe035b4>

ffe035de <.LFE6>:
ffe035de:	ef 00                         	nop	; mov.l	r0, r0

ffe035e0 <_R_BSP_CpuInterruptLevelRead>:
{
    /* Use the compiler intrinsic function to read the CPU IPL. */
    uint32_t psw_value;

    /* Casting is valid because it matches the type to the right side or argument. */
    psw_value = (uint32_t)R_BSP_GET_PSW();
ffe035e0:	fd 6a 01                      	mvfc	psw, r1

ffe035e3 <.LVL2>:
    psw_value = psw_value & 0x0f000000;
    psw_value = psw_value >> 24;
ffe035e3:	69 81                         	shlr	#24, r1

ffe035e5 <.LVL3>:

    return psw_value;
} /* End of function R_BSP_CpuInterruptLevelRead() */
ffe035e5:	64 f1                         	and	#15, r1

ffe035e7 <.LVL4>:
ffe035e7:	02                            	rts

ffe035e8 <_R_BSP_CpuInterruptLevelWrite>:
       The MVTIPL instruction needs to set an immediate value to src. */

    ret = false;

    /* Read current processor mode. */
    pmode = (R_BSP_GET_PSW() & 0x00100000);
ffe035e8:	fd 6a 05                      	mvfc	psw, r5

ffe035eb <.LVL6>:

    /* Check current processor mode. */
    if (0 == pmode)
ffe035eb:	7d 45                         	btst	#20, r5
ffe035ed:	21 12                         	bne.b	ffe035ff <_Reset_Vector+0xffe03603>

ffe035ef <.LVL7>:
    {
        ret = true;

        /* Use the compiler intrinsic function to set the CPU IPL. */
        switch (level)
ffe035ef:	61 f1                         	cmp	#15, r1
ffe035f1:	24 0e                         	bgtu.b	ffe035ff <_Reset_Vector+0xffe03603>
ffe035f3:	6c 21                         	shll	#2, r1

ffe035f5 <.LVL8>:
ffe035f5:	70 11 00 66 e0 ff             	add	#0xffe06600, r1, r1
ffe035fb:	ec 15                         	mov.l	[r1], r5

ffe035fd <.LVL9>:
ffe035fd:	7f 05                         	jmp	r5

ffe035ff <.LVL10>:
                R_BSP_SET_IPL(15);
                break;
    #endif /* BSP_MCU_IPL_MAX */

            default:
                ret = false;
ffe035ff:	66 01                         	mov.l	#0, r1

ffe03601 <.LVL11>:
                break;
        }
    }

    return ret;
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03601:	64 11                         	and	#1, r1

ffe03603 <.LVL12>:
ffe03603:	02                            	rts

ffe03604 <.L11>:
                R_BSP_SET_IPL(14);
ffe03604:	75 70 0e                      	mvtipl	#14
        ret = true;
ffe03607:	66 11                         	mov.l	#1, r1

ffe03609 <.LVL14>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03609:	64 11                         	and	#1, r1

ffe0360b <.LVL15>:
ffe0360b:	02                            	rts

ffe0360c <.L9>:
                R_BSP_SET_IPL(15);
ffe0360c:	75 70 0f                      	mvtipl	#15
        ret = true;
ffe0360f:	66 11                         	mov.l	#1, r1

ffe03611 <.LVL16>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03611:	64 11                         	and	#1, r1

ffe03613 <.LVL17>:
ffe03613:	02                            	rts

ffe03614 <.L25>:
                R_BSP_SET_IPL(0);
ffe03614:	75 70 00                      	mvtipl	#0
        ret = true;
ffe03617:	66 11                         	mov.l	#1, r1

ffe03619 <.LVL18>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03619:	64 11                         	and	#1, r1

ffe0361b <.LVL19>:
ffe0361b:	02                            	rts

ffe0361c <.L24>:
                R_BSP_SET_IPL(1);
ffe0361c:	75 70 01                      	mvtipl	#1
        ret = true;
ffe0361f:	66 11                         	mov.l	#1, r1

ffe03621 <.LVL20>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03621:	64 11                         	and	#1, r1

ffe03623 <.LVL21>:
ffe03623:	02                            	rts

ffe03624 <.L23>:
                R_BSP_SET_IPL(2);
ffe03624:	75 70 02                      	mvtipl	#2
        ret = true;
ffe03627:	66 11                         	mov.l	#1, r1

ffe03629 <.LVL22>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03629:	64 11                         	and	#1, r1

ffe0362b <.LVL23>:
ffe0362b:	02                            	rts

ffe0362c <.L22>:
                R_BSP_SET_IPL(3);
ffe0362c:	75 70 03                      	mvtipl	#3
        ret = true;
ffe0362f:	66 11                         	mov.l	#1, r1

ffe03631 <.LVL24>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03631:	64 11                         	and	#1, r1

ffe03633 <.LVL25>:
ffe03633:	02                            	rts

ffe03634 <.L21>:
                R_BSP_SET_IPL(4);
ffe03634:	75 70 04                      	mvtipl	#4
        ret = true;
ffe03637:	66 11                         	mov.l	#1, r1

ffe03639 <.LVL26>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03639:	64 11                         	and	#1, r1

ffe0363b <.LVL27>:
ffe0363b:	02                            	rts

ffe0363c <.L20>:
                R_BSP_SET_IPL(5);
ffe0363c:	75 70 05                      	mvtipl	#5
        ret = true;
ffe0363f:	66 11                         	mov.l	#1, r1

ffe03641 <.LVL28>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03641:	64 11                         	and	#1, r1

ffe03643 <.LVL29>:
ffe03643:	02                            	rts

ffe03644 <.L19>:
                R_BSP_SET_IPL(6);
ffe03644:	75 70 06                      	mvtipl	#6
        ret = true;
ffe03647:	66 11                         	mov.l	#1, r1

ffe03649 <.LVL30>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03649:	64 11                         	and	#1, r1

ffe0364b <.LVL31>:
ffe0364b:	02                            	rts

ffe0364c <.L18>:
                R_BSP_SET_IPL(7);
ffe0364c:	75 70 07                      	mvtipl	#7
        ret = true;
ffe0364f:	66 11                         	mov.l	#1, r1

ffe03651 <.LVL32>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03651:	64 11                         	and	#1, r1

ffe03653 <.LVL33>:
ffe03653:	02                            	rts

ffe03654 <.L17>:
                R_BSP_SET_IPL(8);
ffe03654:	75 70 08                      	mvtipl	#8
        ret = true;
ffe03657:	66 11                         	mov.l	#1, r1

ffe03659 <.LVL34>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03659:	64 11                         	and	#1, r1

ffe0365b <.LVL35>:
ffe0365b:	02                            	rts

ffe0365c <.L16>:
                R_BSP_SET_IPL(9);
ffe0365c:	75 70 09                      	mvtipl	#9
        ret = true;
ffe0365f:	66 11                         	mov.l	#1, r1

ffe03661 <.LVL36>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03661:	64 11                         	and	#1, r1

ffe03663 <.LVL37>:
ffe03663:	02                            	rts

ffe03664 <.L15>:
                R_BSP_SET_IPL(10);
ffe03664:	75 70 0a                      	mvtipl	#10
        ret = true;
ffe03667:	66 11                         	mov.l	#1, r1

ffe03669 <.LVL38>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03669:	64 11                         	and	#1, r1

ffe0366b <.LVL39>:
ffe0366b:	02                            	rts

ffe0366c <.L14>:
                R_BSP_SET_IPL(11);
ffe0366c:	75 70 0b                      	mvtipl	#11
        ret = true;
ffe0366f:	66 11                         	mov.l	#1, r1

ffe03671 <.LVL40>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03671:	64 11                         	and	#1, r1

ffe03673 <.LVL41>:
ffe03673:	02                            	rts

ffe03674 <.L13>:
                R_BSP_SET_IPL(12);
ffe03674:	75 70 0c                      	mvtipl	#12
        ret = true;
ffe03677:	66 11                         	mov.l	#1, r1

ffe03679 <.LVL42>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03679:	64 11                         	and	#1, r1

ffe0367b <.LVL43>:
ffe0367b:	02                            	rts

ffe0367c <.L12>:
                R_BSP_SET_IPL(13);
ffe0367c:	75 70 0d                      	mvtipl	#13
        ret = true;
ffe0367f:	66 11                         	mov.l	#1, r1

ffe03681 <.LVL44>:
} /* End of function R_BSP_CpuInterruptLevelWrite() */
ffe03681:	64 11                         	and	#1, r1

ffe03683 <.LVL45>:
ffe03683:	02                            	rts

ffe03684 <.LFE6>:
ffe03684:	00                            	brk
ffe03685:	00                            	brk
	...

ffe03688 <_R_BSP_RegisterProtectEnable>:
 * The R_BSP_InterruptControl function used to secure atomicity in the critical section of the counter control with 
 * this function is valid only in supervisor mode. When this function is executed in user mode, the 
 * R_BSP_InterruptControl function is executed but atomicity is not to secure.
 */
void R_BSP_RegisterProtectEnable (bsp_reg_protect_t regs_to_protect)
{
ffe03688:	7e a7                         	push.l	r7
ffe0368a:	60 40                         	sub	#4, r0
ffe0368c:	ef 17                         	mov.l	r1, r7
    bsp_int_ctrl_t int_ctrl;

    /* Set IPL to the maximum value to disable all interrupts,
     * so the scheduler can not be scheduled in critical region.
     * Note: Please set this macro more than IPR for other FIT module interrupts. */
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe0368e:	ef 03                         	mov.l	r0, r3
ffe03690:	66 62                         	mov.l	#6, r2
ffe03692:	75 41 5e                      	mov.l	#94, r1

ffe03695 <.LVL47>:
ffe03695:	05 9b 01 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe03699 <.LVL48>:

    /* Is it safe to disable write access? */
    if (0 != s_protect_counters[regs_to_protect])
ffe03699:	fb 52 78 00 00 00             	mov.l	#120, r5
ffe0369f:	fe d7 54                      	movu.w	[r7, r5], r4
ffe036a2:	61 04                         	cmp	#0, r4
ffe036a4:	20 0c                         	beq.b	ffe036b0 <_Reset_Vector+0xffe036b4>
    {
        /* Decrement the protect counter */
        s_protect_counters[regs_to_protect]--;
ffe036a6:	fe 57 54                      	mov.w	[r7, r5], r4
ffe036a9:	60 14                         	sub	#1, r4
ffe036ab:	fe 17 54                      	mov.w	r4, [r7, r5]
ffe036ae:	ef 00                         	nop	; mov.l	r0, r0
    }

    /* Is it safe to disable write access? */
    if (0 == s_protect_counters[regs_to_protect])
ffe036b0:	fe d7 55                      	movu.w	[r7, r5], r5
ffe036b3:	61 05                         	cmp	#0, r5
ffe036b5:	21 24                         	bne.b	ffe036d9 <_Reset_Vector+0xffe036dd>
    {
        if (BSP_REG_PROTECT_MPC != regs_to_protect)
ffe036b7:	61 37                         	cmp	#3, r7
ffe036b9:	20 2e                         	beq.b	ffe036e7 <_Reset_Vector+0xffe036eb>
               b3     PRC3  - Please check the user's manual.
               b2     PRC2  - Please check the user's manual.
               b1     PRC1  - Please check the user's manual.
               b0     PRC0  - Please check the user's manual.
            */
            SYSTEM.PRCR.WORD = (uint16_t)((SYSTEM.PRCR.WORD | BSP_PRV_PRCR_KEY) & (~s_prcr_masks[regs_to_protect]));
ffe036bb:	fb 3e 00 00 08                	mov.l	#0x80000, r3
ffe036c0:	de 34 ff 01                   	mov.w	1022[r3], r4
ffe036c4:	fb 52 40 66 e0 ff             	mov.l	#0xffe06640, r5
ffe036ca:	fe 57 55                      	mov.w	[r7, r5], r5
ffe036cd:	76 34 00 a5                   	or	#0xffffa500, r4
ffe036d1:	7e 05                         	not	r5
ffe036d3:	53 45                         	and	r4, r5
ffe036d5:	db 35 ff 01                   	mov.w	r5, 1022[r3]
            MPC.PWPR.BIT.B0WI = 1;
        }
    }

    /* Restore the IPL. */
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe036d9:	ef 03                         	mov.l	r0, r3
ffe036db:	66 52                         	mov.l	#5, r2
ffe036dd:	75 41 5e                      	mov.l	#94, r1
ffe036e0:	05 50 01 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe036e4 <.LVL49>:
#else /* BSP_MCU_REGISTER_WRITE_PROTECTION */
    /* No registers to protect. */
    /* This code is only used to remove compiler info messages about this parameter not being used. */
    INTERNAL_NOT_USED(regs_to_protect);
#endif /* BSP_MCU_REGISTER_WRITE_PROTECTION */
} /* End of function R_BSP_RegisterProtectEnable() */
ffe036e4:	3f 77 02                      	rtsd	#8, r7-r7
            MPC.PWPR.BIT.B0WI = 0;
ffe036e7:	fb 7e 00 c1 08                	mov.l	#0x8c100, r7

ffe036ec <.LVL51>:
ffe036ec:	8f fd                         	mov.b	31[r7], r5
ffe036ee:	7a 75                         	bclr	#7, r5
ffe036f0:	87 fd                         	mov.b	r5, 31[r7]
            MPC.PWPR.BIT.PFSWE = 0;
ffe036f2:	f1 7e 1f                      	bclr	#6, 31[r7].b
            MPC.PWPR.BIT.B0WI = 1;
ffe036f5:	8f fd                         	mov.b	31[r7], r5
ffe036f7:	78 75                         	bset	#7, r5
ffe036f9:	87 fd                         	mov.b	r5, 31[r7]
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe036fb:	ef 03                         	mov.l	r0, r3
ffe036fd:	66 52                         	mov.l	#5, r2
ffe036ff:	75 41 5e                      	mov.l	#94, r1
ffe03702:	05 2e 01 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe03706 <.LVL52>:
} /* End of function R_BSP_RegisterProtectEnable() */
ffe03706:	3f 77 02                      	rtsd	#8, r7-r7

ffe03709 <.LFE7>:
ffe03709:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe03710 <_R_BSP_RegisterProtectDisable>:
 * @note The R_BSP_InterruptControl function used to secure atomicity in the critical section of the counter control 
 * with this function is valid only in supervisor mode. When this function is executed in user mode, the 
 * R_BSP_InterruptControl function is executed but atomicity is not to secure.
 */
void R_BSP_RegisterProtectDisable (bsp_reg_protect_t regs_to_unprotect)
{
ffe03710:	7e a7                         	push.l	r7
ffe03712:	60 40                         	sub	#4, r0
ffe03714:	ef 17                         	mov.l	r1, r7
    bsp_int_ctrl_t int_ctrl;

    /* Set IPL to the maximum value to disable all interrupts,
     * so the scheduler can not be scheduled in critical region.
     * Note: Please set this macro more than IPR for other FIT module interrupts. */
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_DISABLE, &int_ctrl);
ffe03716:	ef 03                         	mov.l	r0, r3
ffe03718:	66 62                         	mov.l	#6, r2
ffe0371a:	75 41 5e                      	mov.l	#94, r1

ffe0371d <.LVL54>:
ffe0371d:	05 13 01 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe03721 <.LVL55>:

    /* If this is first entry then disable protection. */
    if (0 == s_protect_counters[regs_to_unprotect])
ffe03721:	fb 52 78 00 00 00             	mov.l	#120, r5
ffe03727:	fe d7 54                      	movu.w	[r7, r5], r4
ffe0372a:	61 04                         	cmp	#0, r4
ffe0372c:	21 22                         	bne.b	ffe0374e <_Reset_Vector+0xffe03752>
    {
        if (BSP_REG_PROTECT_MPC != regs_to_unprotect)
ffe0372e:	61 37                         	cmp	#3, r7
ffe03730:	20 34                         	beq.b	ffe03764 <_Reset_Vector+0xffe03768>
               b3     PRC3  - Please check the user's manual.
               b2     PRC2  - Please check the user's manual.
               b1     PRC1  - Please check the user's manual.
               b0     PRC0  - Please check the user's manual.
            */
            SYSTEM.PRCR.WORD = (uint16_t)((SYSTEM.PRCR.WORD | BSP_PRV_PRCR_KEY) | s_prcr_masks[regs_to_unprotect]);
ffe03732:	fb 3e 00 00 08                	mov.l	#0x80000, r3
ffe03737:	de 32 ff 01                   	mov.w	1022[r3], r2
ffe0373b:	fb 42 40 66 e0 ff             	mov.l	#0xffe06640, r4
ffe03741:	fe 57 44                      	mov.w	[r7, r4], r4
ffe03744:	57 24                         	or	r2, r4
ffe03746:	76 34 00 a5                   	or	#0xffffa500, r4
ffe0374a:	db 34 ff 01                   	mov.w	r4, 1022[r3]

    /* Increment the protect counter */
    s_protect_counters[regs_to_unprotect]++;

    /* Restore the IPL. */
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe0374e:	ef 03                         	mov.l	r0, r3
ffe03750:	66 52                         	mov.l	#5, r2
ffe03752:	75 41 5e                      	mov.l	#94, r1
    s_protect_counters[regs_to_unprotect]++;
ffe03755:	fe 57 54                      	mov.w	[r7, r5], r4
ffe03758:	62 14                         	add	#1, r4
ffe0375a:	fe 17 54                      	mov.w	r4, [r7, r5]
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe0375d:	05 d3 00 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe03761 <.LVL56>:
#else /* BSP_MCU_REGISTER_WRITE_PROTECTION */
    /* No registers to protect. */
    /* This code is only used to remove compiler info messages about this parameter not being used. */
    INTERNAL_NOT_USED(regs_to_unprotect);
#endif /* BSP_MCU_REGISTER_WRITE_PROTECTION */
} /* End of function R_BSP_RegisterProtectDisable() */
ffe03761:	3f 77 02                      	rtsd	#8, r7-r7
            MPC.PWPR.BIT.B0WI = 0;
ffe03764:	fb 4e 00 c1 08                	mov.l	#0x8c100, r4
ffe03769:	8f cb                         	mov.b	31[r4], r3
ffe0376b:	7a 73                         	bclr	#7, r3
ffe0376d:	87 cb                         	mov.b	r3, 31[r4]
            MPC.PWPR.BIT.PFSWE = 1;
ffe0376f:	f1 46 1f                      	bset	#6, 31[r4].b
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe03772:	ef 03                         	mov.l	r0, r3
ffe03774:	66 52                         	mov.l	#5, r2
ffe03776:	75 41 5e                      	mov.l	#94, r1
    s_protect_counters[regs_to_unprotect]++;
ffe03779:	fe 57 54                      	mov.w	[r7, r5], r4
ffe0377c:	62 14                         	add	#1, r4
ffe0377e:	fe 17 54                      	mov.w	r4, [r7, r5]
    R_BSP_InterruptControl(BSP_INT_SRC_EMPTY, BSP_INT_CMD_FIT_INTERRUPT_ENABLE, &int_ctrl);
ffe03781:	05 af 00 00                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe03785 <.LVL58>:
} /* End of function R_BSP_RegisterProtectDisable() */
ffe03785:	3f 77 02                      	rtsd	#8, r7-r7

ffe03788 <_bsp_register_protect_open>:

    /* Initialize reference counters to 0. */
    /* WAIT_LOOP */
    for (i = 0; i < BSP_REG_PROTECT_TOTAL_ITEMS; i++)
    {
        s_protect_counters[i] = 0;
ffe03788:	fb 52 78 00 00 00             	mov.l	#120, r5
ffe0378e:	f8 55 00                      	mov.w	#0, [r5]

ffe03791 <.LVL61>:
ffe03791:	3d 51 00                      	mov.w	#0, 2[r5]

ffe03794 <.LVL62>:
ffe03794:	3d 52 00                      	mov.w	#0, 4[r5]

ffe03797 <.LVL63>:
ffe03797:	3d 53 00                      	mov.w	#0, 6[r5]

ffe0379a <.LVL64>:
    }
#else
    /* No registers to protect. */
#endif
} /* End of function bsp_register_protect_open() */
ffe0379a:	02                            	rts

ffe0379b <_bsp_ram_initialize>:
{
    uint32_t i;

    /* Initialize g_bsp_Locks to 0. */
    /* WAIT_LOOP */
    for (i = 0; i < BSP_NUM_LOCKS; i++)
ffe0379b:	fb 12 28 02 00 00             	mov.l	#552, r1
ffe037a1:	fb 3a d0 01                   	mov.l	#464, r3
ffe037a5:	66 02                         	mov.l	#0, r2
ffe037a7:	7f 88                         	sstr.b
    {
        g_bsp_Locks[i].lock = 0;
    }
} /* End of function bsp_ram_initialize() */
ffe037a9:	02                            	rts

ffe037aa <_R_BSP_InterruptControl.constprop.2>:
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffe037aa:	fb 52 80 00 00 00             	mov.l	#128, r5
ffe037b0:	fe 61 55                      	mov.l	[r1, r5], r5
ffe037b3:	fd 70 c5 ff ff ff ef          	tst	#0xefffffff, r5
ffe037ba:	20 0e                         	beq.b	ffe037c8 <_Reset_Vector+0xffe037cc>
bsp_int_err_t R_BSP_InterruptControl (bsp_int_src_t vector, bsp_int_cmd_t cmd, void * pdata)
ffe037bc:	60 40                         	sub	#4, r0
                cb_args.vector = vector;
ffe037be:	e3 01                         	mov.l	r1, [r0]
                g_bsp_vectors[vector](&cb_args);
ffe037c0:	ef 01                         	mov.l	r0, r1

ffe037c2 <.LVL1>:
ffe037c2:	7f 15                         	jsr	r5

ffe037c4 <.LVL2>:
    err = BSP_INT_SUCCESS;
ffe037c4:	66 01                         	mov.l	#0, r1
} /* End of function R_BSP_InterruptControl() */
ffe037c6:	67 01                         	rtsd	#4

ffe037c8 <.LVL3>:
                err = BSP_INT_ERR_NO_REGISTERED_CALLBACK;
ffe037c8:	66 11                         	mov.l	#1, r1

ffe037ca <.LVL4>:
} /* End of function R_BSP_InterruptControl() */
ffe037ca:	02                            	rts

ffe037cb <_R_BSP_InterruptRequestEnable>:
    ier_reg_num = vector >> 3;
ffe037cb:	fd 83 15                      	shlr	#3, r1, r5

ffe037ce <.LVL6>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe037ce:	66 72                         	mov.l	#7, r2
ffe037d0:	53 12                         	and	r1, r2

ffe037d2 <.LVL7>:
ffe037d2:	73 51 00 72 08                	add	#0x87200, r5, r1

ffe037d7 <.LVL8>:
ffe037d7:	04 81 04 00                   	bra.a	ffe03c58 <_Reset_Vector+0xffe03c5c>

ffe037db <_R_BSP_InterruptRequestDisable>:
    ier_reg_num = vector >> 3;
ffe037db:	fd 83 15                      	shlr	#3, r1, r5

ffe037de <.LVL11>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe037de:	66 72                         	mov.l	#7, r2
ffe037e0:	53 12                         	and	r1, r2

ffe037e2 <.LVL12>:
ffe037e2:	73 51 00 72 08                	add	#0x87200, r5, r1

ffe037e7 <.LVL13>:
ffe037e7:	04 75 04 00                   	bra.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe037eb <.LFE4>:
ffe037eb:	00                            	brk
ffe037ec:	00                            	brk
ffe037ed:	00                            	brk
	...

ffe037f0 <_bsp_interrupt_open>:
{
ffe037f0:	7e a7                         	push.l	r7

ffe037f2 <.LVL15>:
    for (i = 0; i < BSP_INT_SRC_TOTAL_ITEMS; i++)
ffe037f2:	fb 52 80 00 00 00             	mov.l	#128, r5

ffe037f8 <.LVL16>:
        g_bsp_vectors[i] = FIT_NO_FUNC;
ffe037f8:	fb 72 00 00 00 10             	mov.l	#0x10000000, r7
ffe037fe:	fd 22 57                      	mov.l	r7, [r5+]
    for (i = 0; i < BSP_INT_SRC_TOTAL_ITEMS; i++)
ffe03801:	74 05 fc 01 00 00             	cmp	#508, r5
ffe03807:	21 f1                         	bne.b	ffe037f8 <_Reset_Vector+0xffe037fc>
} /* End of function bsp_interrupt_open() */
ffe03809:	7e b7                         	pop	r7
    bsp_mapped_interrupt_open();
ffe0380b:	04 8d fa ff                   	bra.a	ffe03298 <_Reset_Vector+0xffe0329c>

ffe0380f <.LFE5>:
ffe0380f:	03                            	nop

ffe03810 <_R_BSP_InterruptWrite>:
        g_bsp_vectors[vector] = FIT_NO_FUNC;
ffe03810:	fd 70 c2 ff ff ff ef          	tst	#0xefffffff, r2
ffe03817:	fd 70 e2 00 00 00 10          	stz	#0x10000000, r2

ffe0381e <.LVL19>:
ffe0381e:	fb 52 80 00 00 00             	mov.l	#128, r5
ffe03824:	fe 21 52                      	mov.l	r2, [r1, r5]
} /* End of function R_BSP_InterruptWrite() */
ffe03827:	66 01                         	mov.l	#0, r1

ffe03829 <.LVL20>:
ffe03829:	02                            	rts

ffe0382a <.LFE6>:
ffe0382a:	00                            	brk
ffe0382b:	00                            	brk
ffe0382c:	00                            	brk
ffe0382d:	00                            	brk
	...

ffe03830 <_R_BSP_InterruptControl>:
{
ffe03830:	6e 7a                         	pushm	r7-r10
ffe03832:	60 80                         	sub	#8, r0

ffe03834 <.LVL26>:
ffe03834:	ef 17                         	mov.l	r1, r7
    switch (cmd)
ffe03836:	61 32                         	cmp	#3, r2
ffe03838:	3a 82 00                      	beq.w	ffe038ba <_Reset_Vector+0xffe038be>
ffe0383b:	ef 25                         	mov.l	r2, r5
ffe0383d:	24 24                         	bgtu.b	ffe03861 <_Reset_Vector+0xffe03865>
ffe0383f:	61 12                         	cmp	#1, r2
ffe03841:	20 61                         	beq.b	ffe038a2 <_Reset_Vector+0xffe038a6>
ffe03843:	24 6a                         	bgtu.b	ffe038ad <_Reset_Vector+0xffe038b1>
            if (((uint32_t)g_bsp_vectors[vector] != (uint32_t)NULL) && ((uint32_t)g_bsp_vectors[vector] != (uint32_t)FIT_NO_FUNC))
ffe03845:	fb a2 80 00 00 00             	mov.l	#128, r10
ffe0384b:	fe 61 aa                      	mov.l	[r1, r10], r10
ffe0384e:	fd 70 ca ff ff ff ef          	tst	#0xefffffff, r10
ffe03855:	20 49                         	beq.b	ffe0389e <_Reset_Vector+0xffe038a2>
                cb_args.vector = vector;
ffe03857:	e3 01                         	mov.l	r1, [r0]
                g_bsp_vectors[vector](&cb_args);
ffe03859:	ef 01                         	mov.l	r0, r1

ffe0385b <.LVL27>:
    err = BSP_INT_SUCCESS;
ffe0385b:	ef 27                         	mov.l	r2, r7

ffe0385d <.LVL28>:
                g_bsp_vectors[vector](&cb_args);
ffe0385d:	7f 1a                         	jsr	r10

ffe0385f <.LVL29>:
ffe0385f:	2e 3a                         	bra.b	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03861 <.LVL30>:
    switch (cmd)
ffe03861:	61 52                         	cmp	#5, r2
ffe03863:	3a cb 00                      	beq.w	ffe0392e <_Reset_Vector+0xffe03932>
ffe03866:	22 05                         	bc.b	ffe0386b <_Reset_Vector+0xffe0386f>
ffe03868:	38 f2 00                      	bra.w	ffe0395a <_Reset_Vector+0xffe0395e>
ffe0386b:	61 62                         	cmp	#6, r2
ffe0386d:	21 2a                         	bne.b	ffe03897 <_Reset_Vector+0xffe0389b>

ffe0386f <.LBB174>:
    if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
ffe0386f:	61 03                         	cmp	#0, r3
ffe03871:	20 26                         	beq.b	ffe03897 <_Reset_Vector+0xffe0389b>
ffe03873:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe03879:	20 1e                         	beq.b	ffe03897 <_Reset_Vector+0xffe0389b>
        pmode = (R_BSP_GET_PSW() & 0x00100000);
ffe0387b:	fd 6a 07                      	mvfc	psw, r7

ffe0387e <.LVL32>:
        if (0 == pmode)
ffe0387e:	7d 47                         	btst	#20, r7
ffe03880:	3b 1a 01                      	bne.w	ffe0399a <_Reset_Vector+0xffe0399e>

ffe03883 <.LBB176>:
                pdata->ipl = R_BSP_CpuInterruptLevelRead();
ffe03883:	a0 0b                         	mov.l	r3, 4[r0]
ffe03885:	05 5b fd ff                   	bsr.a	ffe035e0 <_Reset_Vector+0xffe035e4>

ffe03889 <.LVL34>:
ffe03889:	a8 0b                         	mov.l	4[r0], r3
ffe0388b:	e3 31                         	mov.l	r1, [r3]

ffe0388d <.LVL35>:
            if (pdata->ipl < BSP_CFG_FIT_IPL_MAX)
ffe0388d:	61 a1                         	cmp	#10, r1
ffe0388f:	24 05                         	bgtu.b	ffe03894 <_Reset_Vector+0xffe03898>
ffe03891:	38 46 01                      	bra.w	ffe039d7 <_Reset_Vector+0xffe039db>

ffe03894 <.LBB184>:
                    err = BSP_INT_ERR_INVALID_IPL;
ffe03894:	66 57                         	mov.l	#5, r7
ffe03896:	0b                            	bra.s	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03897 <.LBE184>:
                 err = BSP_INT_ERR_INVALID_ARG;
ffe03897:	66 27                         	mov.l	#2, r7

ffe03899 <.LVL38>:
} /* End of function R_BSP_InterruptControl() */
ffe03899:	ef 71                         	mov.l	r7, r1
ffe0389b:	3f 7a 06                      	rtsd	#24, r7-r10

ffe0389e <.LVL39>:
                err = BSP_INT_ERR_NO_REGISTERED_CALLBACK;
ffe0389e:	66 17                         	mov.l	#1, r7
ffe038a0:	2e f9                         	bra.b	ffe03899 <_Reset_Vector+0xffe0389d>
            err = bsp_interrupt_enable_disable(vector, true);
ffe038a2:	05 76 f9 ff                   	bsr.a	ffe03218 <_Reset_Vector+0xffe0321c>

ffe038a6 <.LVL40>:
ffe038a6:	ef 17                         	mov.l	r1, r7

ffe038a8 <.LVL41>:
} /* End of function R_BSP_InterruptControl() */
ffe038a8:	ef 71                         	mov.l	r7, r1
ffe038aa:	3f 7a 06                      	rtsd	#24, r7-r10

ffe038ad <.LVL42>:
            err = bsp_interrupt_enable_disable(vector, false);
ffe038ad:	66 02                         	mov.l	#0, r2

ffe038af <.LVL43>:
ffe038af:	05 69 f9 ff                   	bsr.a	ffe03218 <_Reset_Vector+0xffe0321c>

ffe038b3 <.LVL44>:
ffe038b3:	ef 17                         	mov.l	r1, r7

ffe038b5 <.LVL45>:
} /* End of function R_BSP_InterruptControl() */
ffe038b5:	ef 71                         	mov.l	r7, r1
ffe038b7:	3f 7a 06                      	rtsd	#24, r7-r10

ffe038ba <.LVL46>:
            if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
ffe038ba:	61 03                         	cmp	#0, r3
ffe038bc:	20 db                         	beq.b	ffe03897 <_Reset_Vector+0xffe0389b>
ffe038be:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe038c4:	20 d3                         	beq.b	ffe03897 <_Reset_Vector+0xffe0389b>
                err = bsp_gr_int_enable_disable(vector, true, ((bsp_int_ctrl_t *)pdata)->ipl);
ffe038c6:	ec 3a                         	mov.l	[r3], r10

ffe038c8 <.LBB195>:
    if ((true == enable) && ((BSP_MCU_IPL_MIN == ipl) || (ipl > BSP_MCU_IPL_MAX)))
ffe038c8:	71 a5 ff                      	add	#-1, r10, r5
ffe038cb:	61 e5                         	cmp	#14, r5
ffe038cd:	24 ca                         	bgtu.b	ffe03897 <_Reset_Vector+0xffe0389b>
    else if ((vector > BSP_INT_SRC_GR_INT_BE0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL0_TOP))
ffe038cf:	71 15 ef                      	add	#-17, r1, r5
ffe038d2:	61 15                         	cmp	#1, r5
ffe038d4:	24 05                         	bgtu.b	ffe038d9 <_Reset_Vector+0xffe038dd>
ffe038d6:	38 1f 01                      	bra.w	ffe039f5 <_Reset_Vector+0xffe039f9>

ffe038d9 <.LBB197>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL1_TOP))
ffe038d9:	71 15 ec                      	add	#-20, r1, r5
ffe038dc:	75 55 1c                      	cmp	#28, r5
ffe038df:	25 05                         	bleu.b	ffe038e4 <_Reset_Vector+0xffe038e8>
ffe038e1:	38 9a 01                      	bra.w	ffe03a7b <_Reset_Vector+0xffe03a7f>

ffe038e4 <.LBB199>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe038e4:	66 62                         	mov.l	#6, r2

ffe038e6 <.LVL50>:
ffe038e6:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe038eb <.LVL51>:
ffe038eb:	05 71 03 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe038ef <.LVL52>:
            IR(ICU, GROUPBL0)  = 0;
ffe038ef:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffe038f4 <.LVL53>:
ffe038f4:	f1 78 6e                      	bclr	#0, 110[r7].b
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
ffe038f7:	ce 75 6e 03                   	mov.b	878[r7], r5
ffe038fb:	64 f5                         	and	#15, r5
ffe038fd:	47 5a                         	cmp	r5, r10
ffe038ff:	24 05                         	bgtu.b	ffe03904 <_Reset_Vector+0xffe03908>
ffe03901:	38 d6 01                      	bra.w	ffe03ad7 <_Reset_Vector+0xffe03adb>
ffe03904:	66 f5                         	mov.l	#15, r5
ffe03906:	53 a5                         	and	r10, r5
ffe03908:	fb 4e 00 70 08                	mov.l	#0x87000, r4
ffe0390d:	66 fa                         	mov.l	#15, r10

ffe0390f <.LVL54>:
ffe0390f:	53 5a                         	and	r5, r10

ffe03911 <.LBB201>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03911:	66 62                         	mov.l	#6, r2

ffe03913 <.LBE201>:
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
ffe03913:	ce 45 6e 03                   	mov.b	878[r4], r5

ffe03917 <.LBB205>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03917:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe0391c <.LBE205>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe0391c:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
ffe0391e:	75 25 f0                      	and	#-16, r5
ffe03921:	57 a5                         	or	r10, r5
ffe03923:	cb 45 6e 03                   	mov.b	r5, 878[r4]

ffe03927 <.LBB206>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03927:	05 31 03 00                   	bsr.a	ffe03c58 <_Reset_Vector+0xffe03c5c>

ffe0392b <.LVL56>:
ffe0392b:	38 6e ff                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe0392e <.LBB256>:
    if(((uint32_t)NULL != (uint32_t)pdata) && ((uint32_t)FIT_NO_FUNC != (uint32_t)pdata))
ffe0392e:	61 03                         	cmp	#0, r3
ffe03930:	3a 67 ff                      	beq.w	ffe03897 <_Reset_Vector+0xffe0389b>
ffe03933:	74 03 00 00 00 10             	cmp	#0x10000000, r3
ffe03939:	3a 5e ff                      	beq.w	ffe03897 <_Reset_Vector+0xffe0389b>
        pmode = (R_BSP_GET_PSW() & 0x00100000);
ffe0393c:	fd 6a 07                      	mvfc	psw, r7

ffe0393f <.LVL58>:
        if (0 == pmode)
ffe0393f:	7d 47                         	btst	#20, r7
ffe03941:	21 59                         	bne.b	ffe0399a <_Reset_Vector+0xffe0399e>

ffe03943 <.LBB190>:
                ipl_value = pdata->ipl;
ffe03943:	ec 31                         	mov.l	[r3], r1

ffe03945 <.LVL60>:
            if (pdata->ipl < BSP_CFG_FIT_IPL_MAX)
ffe03945:	61 a1                         	cmp	#10, r1
ffe03947:	25 05                         	bleu.b	ffe0394c <_Reset_Vector+0xffe03950>
ffe03949:	38 4b ff                      	bra.w	ffe03894 <_Reset_Vector+0xffe03898>

ffe0394c <.LBB180>:
                ret = R_BSP_CpuInterruptLevelWrite(ipl_value);
ffe0394c:	05 9c fc ff                   	bsr.a	ffe035e8 <_Reset_Vector+0xffe035ec>

ffe03950 <.LVL62>:
                if (false == ret)
ffe03950:	61 01                         	cmp	#0, r1
ffe03952:	3a 42 ff                      	beq.w	ffe03894 <_Reset_Vector+0xffe03898>

ffe03955 <.LBB191>:
            err = BSP_INT_SUCCESS;
ffe03955:	66 07                         	mov.l	#0, r7
ffe03957:	38 42 ff                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe0395a <.LBB259>:
    else if ((vector > BSP_INT_SRC_GR_INT_BE0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL0_TOP))
ffe0395a:	71 1a ef                      	add	#-17, r1, r10
ffe0395d:	61 1a                         	cmp	#1, r10
ffe0395f:	25 40                         	bleu.b	ffe0399f <_Reset_Vector+0xffe039a3>

ffe03961 <.LBB261>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL0_TOP) && (vector < BSP_INT_SRC_GR_INT_BL1_TOP))
ffe03961:	71 1a ec                      	add	#-20, r1, r10
ffe03964:	75 5a 1c                      	cmp	#28, r10
ffe03967:	25 4a                         	bleu.b	ffe039b1 <_Reset_Vector+0xffe039b5>
    else if ((vector > BSP_INT_SRC_GR_INT_BL1_TOP) && (vector < BSP_INT_SRC_GR_INT_BL2_TOP))
ffe03969:	71 1a ce                      	add	#-50, r1, r10
ffe0396c:	75 5a 17                      	cmp	#23, r10
ffe0396f:	25 05                         	bleu.b	ffe03974 <_Reset_Vector+0xffe03978>
ffe03971:	38 ce 00                      	bra.w	ffe03a3f <_Reset_Vector+0xffe03a43>
            if (0 == ICU.GENBL1.LONG)
ffe03974:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffe03979:	ee a7 9d 01                   	mov.l	1652[r10], r7
ffe0397d:	61 07                         	cmp	#0, r7
ffe0397f:	21 2d                         	bne.b	ffe039ac <_Reset_Vector+0xffe039b0>

ffe03981 <.LBB263>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe03981:	66 72                         	mov.l	#7, r2

ffe03983 <.LVL66>:
ffe03983:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe03988 <.LVL67>:
ffe03988:	05 d4 02 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe0398c <.LVL68>:
                IPR(ICU, GROUPBL1) = 0;
ffe0398c:	ce a5 6f 03                   	mov.b	879[r10], r5
ffe03990:	75 25 f0                      	and	#-16, r5
ffe03993:	cb a5 6f 03                   	mov.b	r5, 879[r10]
ffe03997:	38 02 ff                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe0399a <.LBB285>:
            err = BSP_INT_ERR_UNSUPPORTED;
ffe0399a:	66 37                         	mov.l	#3, r7
ffe0399c:	38 fd fe                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe0399f <.LBB286>:
            if (0 == ICU.GENBE0.LONG)
ffe0399f:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffe039a4:	ee a7 90 01                   	mov.l	1600[r10], r7
ffe039a8:	61 07                         	cmp	#0, r7
ffe039aa:	20 32                         	beq.b	ffe039dc <_Reset_Vector+0xffe039e0>
                err = BSP_INT_ERR_GROUP_STILL_ENABLED;
ffe039ac:	ef 57                         	mov.l	r5, r7
ffe039ae:	38 eb fe                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe039b1 <.LBB276>:
            if (0 == ICU.GENBL0.LONG)
ffe039b1:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffe039b6:	ee a7 9c 01                   	mov.l	1648[r10], r7
ffe039ba:	61 07                         	cmp	#0, r7
ffe039bc:	21 f0                         	bne.b	ffe039ac <_Reset_Vector+0xffe039b0>

ffe039be <.LBB265>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe039be:	66 62                         	mov.l	#6, r2

ffe039c0 <.LVL73>:
ffe039c0:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe039c5 <.LVL74>:
ffe039c5:	05 97 02 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe039c9 <.LVL75>:
                IPR(ICU, GROUPBL0) = 0;
ffe039c9:	ce a5 6e 03                   	mov.b	878[r10], r5
ffe039cd:	75 25 f0                      	and	#-16, r5
ffe039d0:	cb a5 6e 03                   	mov.b	r5, 878[r10]
ffe039d4:	38 c5 fe                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe039d7 <.LBB181>:
                ret = R_BSP_CpuInterruptLevelWrite(ipl_value);
ffe039d7:	66 b1                         	mov.l	#11, r1
ffe039d9:	38 73 ff                      	bra.w	ffe0394c <_Reset_Vector+0xffe03950>

ffe039dc <.LBB277>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe039dc:	66 22                         	mov.l	#2, r2

ffe039de <.LVL78>:
ffe039de:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe039e3 <.LVL79>:
ffe039e3:	05 79 02 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe039e7 <.LVL80>:
                IPR(ICU, GROUPBE0) = 0;
ffe039e7:	ce a5 6a 03                   	mov.b	874[r10], r5
ffe039eb:	75 25 f0                      	and	#-16, r5
ffe039ee:	cb a5 6a 03                   	mov.b	r5, 874[r10]
ffe039f2:	38 a7 fe                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe039f5 <.LBB242>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe039f5:	66 22                         	mov.l	#2, r2

ffe039f7 <.LVL82>:
ffe039f7:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe039fc <.LVL83>:
ffe039fc:	05 60 02 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe03a00 <.LVL84>:
            IR(ICU, GROUPBE0)  = 0;
ffe03a00:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffe03a05 <.LVL85>:
ffe03a05:	f1 78 6a                      	bclr	#0, 106[r7].b
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
ffe03a08:	ce 75 6a 03                   	mov.b	874[r7], r5
ffe03a0c:	64 f5                         	and	#15, r5
ffe03a0e:	47 5a                         	cmp	r5, r10
ffe03a10:	24 05                         	bgtu.b	ffe03a15 <_Reset_Vector+0xffe03a19>
ffe03a12:	38 bc 00                      	bra.w	ffe03ace <_Reset_Vector+0xffe03ad2>
ffe03a15:	66 f5                         	mov.l	#15, r5
ffe03a17:	53 a5                         	and	r10, r5
ffe03a19:	fb 4e 00 70 08                	mov.l	#0x87000, r4
ffe03a1e:	66 fa                         	mov.l	#15, r10

ffe03a20 <.LVL86>:
ffe03a20:	53 5a                         	and	r5, r10

ffe03a22 <.LBB244>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03a22:	66 22                         	mov.l	#2, r2

ffe03a24 <.LBE244>:
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
ffe03a24:	ce 45 6a 03                   	mov.b	874[r4], r5

ffe03a28 <.LBB248>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03a28:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe03a2d <.LBE248>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03a2d:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
ffe03a2f:	75 25 f0                      	and	#-16, r5
ffe03a32:	57 a5                         	or	r10, r5
ffe03a34:	cb 45 6a 03                   	mov.b	r5, 874[r4]

ffe03a38 <.LBB249>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03a38:	05 20 02 00                   	bsr.a	ffe03c58 <_Reset_Vector+0xffe03c5c>

ffe03a3c <.LVL88>:
ffe03a3c:	38 5d fe                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03a3f <.LBB279>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL2_TOP) && (vector < BSP_INT_SRC_GR_INT_AL0_TOP))
ffe03a3f:	75 51 4b                      	cmp	#75, r1
ffe03a42:	3a fc 00                      	beq.w	ffe03b3e <_Reset_Vector+0xffe03b42>
    else if ((vector > BSP_INT_SRC_GR_INT_AL0_TOP) && (vector < BSP_INT_SRC_GR_INT_AL1_TOP))
ffe03a45:	71 1a b3                      	add	#-77, r1, r10
ffe03a48:	61 9a                         	cmp	#9, r10
ffe03a4a:	25 05                         	bleu.b	ffe03a4f <_Reset_Vector+0xffe03a53>
ffe03a4c:	38 19 01                      	bra.w	ffe03b65 <_Reset_Vector+0xffe03b69>
            if (0 == ICU.GENAL0.LONG)
ffe03a4f:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe03a54:	ee 77 1c 02                   	mov.l	2160[r7], r7
ffe03a58:	61 07                         	cmp	#0, r7
ffe03a5a:	3b 52 ff                      	bne.w	ffe039ac <_Reset_Vector+0xffe039b0>

ffe03a5d <.LBB267>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe03a5d:	66 02                         	mov.l	#0, r2

ffe03a5f <.LVL91>:
ffe03a5f:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffe03a64 <.LVL92>:
ffe03a64:	05 f8 01 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe03a68 <.LVL93>:
                IPR(ICU, GROUPAL0) = 0;
ffe03a68:	fb ae 00 70 08                	mov.l	#0x87000, r10

ffe03a6d <.LVL94>:
ffe03a6d:	ce a5 70 03                   	mov.b	880[r10], r5
ffe03a71:	75 25 f0                      	and	#-16, r5
ffe03a74:	cb a5 70 03                   	mov.b	r5, 880[r10]
ffe03a78:	38 21 fe                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03a7b <.LBB250>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL1_TOP) && (vector < BSP_INT_SRC_GR_INT_BL2_TOP))
ffe03a7b:	71 15 ce                      	add	#-50, r1, r5
ffe03a7e:	75 55 17                      	cmp	#23, r5
ffe03a81:	24 5f                         	bgtu.b	ffe03ae0 <_Reset_Vector+0xffe03ae4>

ffe03a83 <.LBB207>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe03a83:	66 72                         	mov.l	#7, r2

ffe03a85 <.LVL97>:
ffe03a85:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe03a8a <.LVL98>:
ffe03a8a:	05 d2 01 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe03a8e <.LVL99>:
            IR(ICU, GROUPBL1)  = 0;
ffe03a8e:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffe03a93 <.LVL100>:
ffe03a93:	f1 78 6f                      	bclr	#0, 111[r7].b
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
ffe03a96:	ce 75 6f 03                   	mov.b	879[r7], r5
ffe03a9a:	64 f5                         	and	#15, r5
ffe03a9c:	47 5a                         	cmp	r5, r10
ffe03a9e:	24 05                         	bgtu.b	ffe03aa3 <_Reset_Vector+0xffe03aa7>
ffe03aa0:	38 f6 00                      	bra.w	ffe03b96 <_Reset_Vector+0xffe03b9a>
ffe03aa3:	66 f4                         	mov.l	#15, r4
ffe03aa5:	53 a4                         	and	r10, r4
ffe03aa7:	03                            	nop
ffe03aa8:	fb 3e 00 70 08                	mov.l	#0x87000, r3
ffe03aad:	64 f4                         	and	#15, r4

ffe03aaf <.LBB209>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03aaf:	66 72                         	mov.l	#7, r2

ffe03ab1 <.LBE209>:
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
ffe03ab1:	ce 35 6f 03                   	mov.b	879[r3], r5

ffe03ab5 <.LBB213>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03ab5:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe03aba <.LBE213>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03aba:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
ffe03abc:	fb a6 f0                      	mov.l	#-16, r10

ffe03abf <.LVL101>:
ffe03abf:	53 5a                         	and	r5, r10
ffe03ac1:	57 4a                         	or	r4, r10
ffe03ac3:	cb 3a 6f 03                   	mov.b	r10, 879[r3]

ffe03ac7 <.LBB214>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03ac7:	05 91 01 00                   	bsr.a	ffe03c58 <_Reset_Vector+0xffe03c5c>

ffe03acb <.LVL103>:
ffe03acb:	38 ce fd                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03ace <.LBE214>:
            IPR(ICU, GROUPBE0) = (uint8_t)((ipl > IPR(ICU, GROUPBE0)) ? ipl : IPR(ICU, GROUPBE0));
ffe03ace:	ce 75 6a 03                   	mov.b	874[r7], r5
ffe03ad2:	64 f5                         	and	#15, r5
ffe03ad4:	38 45 ff                      	bra.w	ffe03a19 <_Reset_Vector+0xffe03a1d>

ffe03ad7 <.LBB251>:
            IPR(ICU, GROUPBL0) = (uint8_t)((ipl > IPR(ICU, GROUPBL0)) ? ipl : IPR(ICU, GROUPBL0));
ffe03ad7:	ce 75 6e 03                   	mov.b	878[r7], r5
ffe03adb:	64 f5                         	and	#15, r5
ffe03add:	38 2b fe                      	bra.w	ffe03908 <_Reset_Vector+0xffe0390c>

ffe03ae0 <.LVL106>:
    else if ((vector > BSP_INT_SRC_GR_INT_BL2_TOP) && (vector < BSP_INT_SRC_GR_INT_AL0_TOP))
ffe03ae0:	75 51 4b                      	cmp	#75, r1
ffe03ae3:	3a bc 00                      	beq.w	ffe03b9f <_Reset_Vector+0xffe03ba3>
    else if ((vector > BSP_INT_SRC_GR_INT_AL0_TOP) && (vector < BSP_INT_SRC_GR_INT_AL1_TOP))
ffe03ae6:	71 15 b3                      	add	#-77, r1, r5
ffe03ae9:	61 95                         	cmp	#9, r5
ffe03aeb:	25 05                         	bleu.b	ffe03af0 <_Reset_Vector+0xffe03af4>
ffe03aed:	38 f9 00                      	bra.w	ffe03be6 <_Reset_Vector+0xffe03bea>

ffe03af0 <.LBB215>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe03af0:	66 02                         	mov.l	#0, r2

ffe03af2 <.LVL108>:
ffe03af2:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffe03af7 <.LVL109>:
ffe03af7:	05 65 01 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe03afb <.LVL110>:
            IR(ICU, GROUPAL0)  = 0;
ffe03afb:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffe03b00 <.LVL111>:
ffe03b00:	f1 78 70                      	bclr	#0, 112[r7].b
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
ffe03b03:	ce 75 70 03                   	mov.b	880[r7], r5
ffe03b07:	64 f5                         	and	#15, r5
ffe03b09:	47 5a                         	cmp	r5, r10
ffe03b0b:	24 05                         	bgtu.b	ffe03b10 <_Reset_Vector+0xffe03b14>
ffe03b0d:	38 32 01                      	bra.w	ffe03c3f <_Reset_Vector+0xffe03c43>
ffe03b10:	66 f4                         	mov.l	#15, r4
ffe03b12:	53 a4                         	and	r10, r4
ffe03b14:	76 10 01 00                   	nop	; mul	#1, r0
ffe03b18:	fb 3e 00 70 08                	mov.l	#0x87000, r3
ffe03b1d:	64 f4                         	and	#15, r4

ffe03b1f <.LBB217>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03b1f:	66 02                         	mov.l	#0, r2

ffe03b21 <.LBE217>:
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
ffe03b21:	ce 35 70 03                   	mov.b	880[r3], r5

ffe03b25 <.LBB221>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03b25:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffe03b2a <.LBE221>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03b2a:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
ffe03b2c:	fb a6 f0                      	mov.l	#-16, r10

ffe03b2f <.LVL112>:
ffe03b2f:	53 5a                         	and	r5, r10
ffe03b31:	57 4a                         	or	r4, r10
ffe03b33:	cb 3a 70 03                   	mov.b	r10, 880[r3]

ffe03b37 <.LBB222>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03b37:	05 21 01 00                   	bsr.a	ffe03c58 <_Reset_Vector+0xffe03c5c>

ffe03b3b <.LVL114>:
ffe03b3b:	38 5e fd                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03b3e <.LBB280>:
            if (0 == ICU.GENBL2.LONG)
ffe03b3e:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffe03b43:	ee a7 9e 01                   	mov.l	1656[r10], r7
ffe03b47:	61 07                         	cmp	#0, r7
ffe03b49:	3b 63 fe                      	bne.w	ffe039ac <_Reset_Vector+0xffe039b0>

ffe03b4c <.LBB269>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe03b4c:	66 32                         	mov.l	#3, r2

ffe03b4e <.LVL117>:
ffe03b4e:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe03b53 <.LVL118>:
ffe03b53:	05 09 01 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe03b57 <.LVL119>:
                IPR(ICU, GROUPBL2) = 0;
ffe03b57:	ce a5 6b 03                   	mov.b	875[r10], r5
ffe03b5b:	75 25 f0                      	and	#-16, r5
ffe03b5e:	cb a5 6b 03                   	mov.b	r5, 875[r10]
ffe03b62:	38 37 fd                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03b65 <.LVL120>:
    else if ((vector > BSP_INT_SRC_GR_INT_AL1_TOP) && (vector < BSP_INT_SRC_GR_INT_END))
ffe03b65:	71 77 a8                      	add	#-88, r7, r7
ffe03b68:	61 47                         	cmp	#4, r7
ffe03b6a:	25 05                         	bleu.b	ffe03b6f <_Reset_Vector+0xffe03b73>
ffe03b6c:	38 2b fd                      	bra.w	ffe03897 <_Reset_Vector+0xffe0389b>
            if (0 == ICU.GENAL1.LONG)
ffe03b6f:	fb ae 00 70 08                	mov.l	#0x87000, r10
ffe03b74:	ee a7 1d 02                   	mov.l	2164[r10], r7
ffe03b78:	61 07                         	cmp	#0, r7
ffe03b7a:	3b 32 fe                      	bne.w	ffe039ac <_Reset_Vector+0xffe039b0>

ffe03b7d <.LBB271>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe03b7d:	66 12                         	mov.l	#1, r2

ffe03b7f <.LVL122>:
ffe03b7f:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffe03b84 <.LVL123>:
ffe03b84:	05 d8 00 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe03b88 <.LVL124>:
                IPR(ICU, GROUPAL1) = 0;
ffe03b88:	ce a5 71 03                   	mov.b	881[r10], r5
ffe03b8c:	75 25 f0                      	and	#-16, r5
ffe03b8f:	cb a5 71 03                   	mov.b	r5, 881[r10]
ffe03b93:	38 06 fd                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03b96 <.LBB252>:
            IPR(ICU, GROUPBL1) = (uint8_t)((ipl > IPR(ICU, GROUPBL1)) ? ipl : IPR(ICU, GROUPBL1));
ffe03b96:	ce 74 6f 03                   	mov.b	879[r7], r4
ffe03b9a:	64 f4                         	and	#15, r4
ffe03b9c:	38 0c ff                      	bra.w	ffe03aa8 <_Reset_Vector+0xffe03aac>

ffe03b9f <.LBB223>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe03b9f:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe03ba4 <.LVL127>:
ffe03ba4:	05 b8 00 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe03ba8 <.LVL128>:
            IR(ICU, GROUPBL2)  = 0;
ffe03ba8:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffe03bad <.LVL129>:
ffe03bad:	f1 78 6b                      	bclr	#0, 107[r7].b
            IPR(ICU, GROUPBL2) = (uint8_t)((ipl > IPR(ICU, GROUPBL2)) ? ipl : IPR(ICU, GROUPBL2));
ffe03bb0:	ce 75 6b 03                   	mov.b	875[r7], r5
ffe03bb4:	64 f5                         	and	#15, r5
ffe03bb6:	47 5a                         	cmp	r5, r10
ffe03bb8:	25 7f                         	bleu.b	ffe03c37 <_Reset_Vector+0xffe03c3b>
ffe03bba:	66 f4                         	mov.l	#15, r4
ffe03bbc:	53 a4                         	and	r10, r4
ffe03bbe:	ef 00                         	nop	; mov.l	r0, r0
ffe03bc0:	fb 3e 00 70 08                	mov.l	#0x87000, r3
ffe03bc5:	64 f4                         	and	#15, r4

ffe03bc7 <.LBB225>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03bc7:	66 32                         	mov.l	#3, r2

ffe03bc9 <.LBE225>:
            IPR(ICU, GROUPBL2) = (uint8_t)((ipl > IPR(ICU, GROUPBL2)) ? ipl : IPR(ICU, GROUPBL2));
ffe03bc9:	ce 35 6b 03                   	mov.b	875[r3], r5

ffe03bcd <.LBB229>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03bcd:	fb 1e 0d 72 08                	mov.l	#0x8720d, r1

ffe03bd2 <.LBE229>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03bd2:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPBL2) = (uint8_t)((ipl > IPR(ICU, GROUPBL2)) ? ipl : IPR(ICU, GROUPBL2));
ffe03bd4:	fb a6 f0                      	mov.l	#-16, r10

ffe03bd7 <.LVL130>:
ffe03bd7:	53 5a                         	and	r5, r10
ffe03bd9:	57 4a                         	or	r4, r10
ffe03bdb:	cb 3a 6b 03                   	mov.b	r10, 875[r3]

ffe03bdf <.LBB230>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03bdf:	05 79 00 00                   	bsr.a	ffe03c58 <_Reset_Vector+0xffe03c5c>

ffe03be3 <.LVL132>:
ffe03be3:	38 b6 fc                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03be6 <.LBE230>:
    else if ((vector > BSP_INT_SRC_GR_INT_AL1_TOP) && (vector < BSP_INT_SRC_GR_INT_END))
ffe03be6:	71 77 a8                      	add	#-88, r7, r7
ffe03be9:	61 47                         	cmp	#4, r7
ffe03beb:	25 05                         	bleu.b	ffe03bf0 <_Reset_Vector+0xffe03bf4>
ffe03bed:	38 aa fc                      	bra.w	ffe03897 <_Reset_Vector+0xffe0389b>

ffe03bf0 <.LBB231>:
    R_BSP_BIT_CLEAR(p_ier_addr, ien_bit_num);
ffe03bf0:	66 12                         	mov.l	#1, r2

ffe03bf2 <.LVL135>:
ffe03bf2:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffe03bf7 <.LVL136>:
ffe03bf7:	05 65 00 00                   	bsr.a	ffe03c5c <_Reset_Vector+0xffe03c60>

ffe03bfb <.LVL137>:
            IR(ICU, GROUPAL1)  = 0;
ffe03bfb:	fb 7e 00 70 08                	mov.l	#0x87000, r7

ffe03c00 <.LVL138>:
ffe03c00:	f1 78 71                      	bclr	#0, 113[r7].b
            IPR(ICU, GROUPAL1) = (uint8_t)((ipl > IPR(ICU, GROUPAL1)) ? ipl : IPR(ICU, GROUPAL1));
ffe03c03:	ce 75 71 03                   	mov.b	881[r7], r5
ffe03c07:	64 f5                         	and	#15, r5
ffe03c09:	47 5a                         	cmp	r5, r10
ffe03c0b:	25 42                         	bleu.b	ffe03c4d <_Reset_Vector+0xffe03c51>
ffe03c0d:	66 f5                         	mov.l	#15, r5
ffe03c0f:	53 a5                         	and	r10, r5
ffe03c11:	fb 4e 00 70 08                	mov.l	#0x87000, r4
ffe03c16:	66 fa                         	mov.l	#15, r10

ffe03c18 <.LVL139>:
ffe03c18:	53 5a                         	and	r5, r10

ffe03c1a <.LBB233>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03c1a:	66 12                         	mov.l	#1, r2

ffe03c1c <.LBE233>:
            IPR(ICU, GROUPAL1) = (uint8_t)((ipl > IPR(ICU, GROUPAL1)) ? ipl : IPR(ICU, GROUPAL1));
ffe03c1c:	ce 45 71 03                   	mov.b	881[r4], r5

ffe03c20 <.LBB237>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03c20:	fb 1e 0e 72 08                	mov.l	#0x8720e, r1

ffe03c25 <.LBE237>:
    bsp_int_err_t err = BSP_INT_SUCCESS;
ffe03c25:	66 07                         	mov.l	#0, r7
            IPR(ICU, GROUPAL1) = (uint8_t)((ipl > IPR(ICU, GROUPAL1)) ? ipl : IPR(ICU, GROUPAL1));
ffe03c27:	75 25 f0                      	and	#-16, r5
ffe03c2a:	57 5a                         	or	r5, r10
ffe03c2c:	cb 4a 71 03                   	mov.b	r10, 881[r4]

ffe03c30 <.LBB238>:
    R_BSP_BIT_SET(p_ier_addr, ien_bit_num);
ffe03c30:	05 28 00 00                   	bsr.a	ffe03c58 <_Reset_Vector+0xffe03c5c>

ffe03c34 <.LVL141>:
ffe03c34:	38 65 fc                      	bra.w	ffe03899 <_Reset_Vector+0xffe0389d>

ffe03c37 <.LBE238>:
            IPR(ICU, GROUPBL2) = (uint8_t)((ipl > IPR(ICU, GROUPBL2)) ? ipl : IPR(ICU, GROUPBL2));
ffe03c37:	ce 74 6b 03                   	mov.b	875[r7], r4
ffe03c3b:	64 f4                         	and	#15, r4
ffe03c3d:	2e 83                         	bra.b	ffe03bc0 <_Reset_Vector+0xffe03bc4>
            IPR(ICU, GROUPAL0) = (uint8_t)((ipl > IPR(ICU, GROUPAL0)) ? ipl : IPR(ICU, GROUPAL0));
ffe03c3f:	fb 7e 00 70 08                	mov.l	#0x87000, r7
ffe03c44:	ce 74 70 03                   	mov.b	880[r7], r4
ffe03c48:	64 f4                         	and	#15, r4
ffe03c4a:	38 ce fe                      	bra.w	ffe03b18 <_Reset_Vector+0xffe03b1c>
            IPR(ICU, GROUPAL1) = (uint8_t)((ipl > IPR(ICU, GROUPAL1)) ? ipl : IPR(ICU, GROUPAL1));
ffe03c4d:	ce 75 71 03                   	mov.b	881[r7], r5
ffe03c51:	64 f5                         	and	#15, r5
ffe03c53:	2e be                         	bra.b	ffe03c11 <_Reset_Vector+0xffe03c15>

ffe03c55 <.LBE252>:
ffe03c55:	fc 13 00                      	nop	; max	r0, r0

ffe03c58 <_R_BSP_BitSet>:
void R_BSP_BitSet(uint8_t *data, uint32_t bit)
{
    R_BSP_ASM_INTERNAL_USED(data)
    R_BSP_ASM_INTERNAL_USED(bit)

    R_BSP_ASM_BEGIN
ffe03c58:	fc 60 12                      	bset	r2, [r1].b
ffe03c5b:	02                            	rts

ffe03c5c <_R_BSP_BitClear>:
void R_BSP_BitClear(uint8_t *data, uint32_t bit)
{
    R_BSP_ASM_INTERNAL_USED(data)
    R_BSP_ASM_INTERNAL_USED(bit)

    R_BSP_ASM_BEGIN
ffe03c5c:	fc 64 12                      	bclr	r2, [r1].b
ffe03c5f:	02                            	rts

ffe03c60 <_PowerON_Reset_PC_Prg>:
#endif

#if defined(__CCRX__) || defined(__GNUC__)

    /* Initialize the Interrupt Table Register */
    R_BSP_SET_INTB(R_BSP_SECTOP_INTVECTTBL);
ffe03c60:	fd 73 0c c8 5b e0 ff          	mvtc	#0xffe05bc8, intb

#ifdef BSP_MCU_EXCEPTION_TABLE
    /* Initialize the Exception Table Register */
    R_BSP_SET_EXTB(R_BSP_SECTOP_EXCEPTVECTTBL);
ffe03c67:	fd 73 0d 80 ff ff ff          	mvtc	#-128, extb
#endif

#ifdef BSP_MCU_FLOATING_POINT
#ifdef __FPU
    /* Initialize the Floating-Point Status Word Register. */
    R_BSP_SET_FPSW(BSP_PRV_FPSW_INIT | BSP_PRV_FPU_ROUND | BSP_PRV_FPU_DENOM);
ffe03c6e:	fd 77 03 00                   	mvtc	#0, fpsw
#ifdef BSP_MCU_VBATT_INITIALIZE
    vbatt_voltage_stability_wait();
#endif

    /* Switch to high-speed operation */ 
    mcu_clock_setup();
ffe03c72:	05 06 f3 ff                   	bsr.a	ffe02f78 <_Reset_Vector+0xffe02f7c>

ffe03c76 <.LVL0>:
#if BSP_CFG_USER_WARM_START_CALLBACK_PRE_INITC_ENABLED == 1
    BSP_CFG_USER_WARM_START_PRE_C_FUNCTION();
#endif

    /* Initialize C runtime environment */
    _INITSCT();
ffe03c76:	05 9c c3 ff                   	bsr.a	ffe00012 <_Reset_Vector+0xffe00016>

ffe03c7a <.LVL1>:
    /* Initialize C++ global class object */
    _CALL_INIT();
#endif

    /* Initialize RAM */
    bsp_ram_initialize();
ffe03c7a:	05 21 fb ff                   	bsr.a	ffe0379b <_Reset_Vector+0xffe0379f>

ffe03c7e <.LVL2>:
    init_iolib();
#endif /* defined(__CCRX__) */
#endif

    /* Initialize MCU interrupt callbacks. */
    bsp_interrupt_open();
ffe03c7e:	05 72 fb ff                   	bsr.a	ffe037f0 <_Reset_Vector+0xffe037f4>

ffe03c82 <.LVL3>:

    /* Initialize register protection functionality. */
    bsp_register_protect_open();
ffe03c82:	05 06 fb ff                   	bsr.a	ffe03788 <_Reset_Vector+0xffe0378c>

ffe03c86 <.LVL4>:

    /* Configure the MCU and board hardware */
    hardware_setup();
ffe03c86:	05 22 00 00                   	bsr.a	ffe03ca8 <_Reset_Vector+0xffe03cac>

ffe03c8a <.LVL5>:

    /* Enable interrupt and select the I stack or the U stack */
    R_BSP_SET_PSW(BSP_PRV_PSW_INIT);
ffe03c8a:	fd 7f 00 00 00 03             	mvtc	#0x30000, psw
    #endif
#endif /* BSP_CFG_RUN_IN_USER_MODE */
#endif /* BSP_CFG_RTOS_USED */

    /* Enable the bus error interrupt to catch accesses to illegal/reserved areas of memory */
    R_BSP_InterruptControl(BSP_INT_SRC_BUS_ERROR, BSP_INT_CMD_INTERRUPT_ENABLE, FIT_NO_PTR);
ffe03c90:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe03c96:	66 12                         	mov.l	#1, r2
ffe03c98:	66 b1                         	mov.l	#11, r1
ffe03c9a:	05 96 fb ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe03c9e <.LVL6>:

#if (BSP_CFG_RTOS_USED == 0) || (BSP_CFG_RTOS_USED == 5)    /* Non-OS or Azure RTOS */
    /* Call the main program function (should not return) */
    R_BSP_MAIN_FUNCTION();
ffe03c9e:	05 ba 03 00                   	bsr.a	ffe04058 <_Reset_Vector+0xffe0405c>

ffe03ca2 <.LVL7>:
    /* Infinite loop is intended here. */
    /* WAIT_LOOP */
    while(1)
    {
        /* Infinite loop. Put a breakpoint here if you want to catch an exit of main(). */
        R_BSP_NOP();
ffe03ca2:	03                            	nop
ffe03ca3:	2e ff                         	bra.b	ffe03ca2 <_Reset_Vector+0xffe03ca6>

ffe03ca5 <.LFE3>:
ffe03ca5:	00                            	brk
	...

ffe03ca8 <_hardware_setup>:
{
/* When using the user startup program, disable the following code. */
#if BSP_CFG_STARTUP_DISABLE == 0
#if BSP_CFG_ROM_CACHE_ENABLE == 1
    /* Initialize ROM cache function */
    rom_cache_function_set();
ffe03ca8:	fb 52 c8 5f e0 ff             	mov.l	#0xffe05fc8, r5
ffe03cae:	ec 55                         	mov.l	[r5], r5
ffe03cb0:	61 15                         	cmp	#1, r5
ffe03cb2:	20 24                         	beq.b	ffe03cd6 <_Reset_Vector+0xffe03cda>

ffe03cb4 <.LBB14>:
* Return value : none
***********************************************************************************************************************/
static void rom_cache_function_set (void)
{
    /* Invalidates the contents of the ROM cache. */
    FLASH.ROMCIV.WORD = 0x0001;
ffe03cb4:	fb 5e 00 10 08                	mov.l	#0x81000, r5
    /* WAIT_LOOP */
    while (FLASH.ROMCIV.WORD != 0x0000)
ffe03cb9:	ef 54                         	mov.l	r5, r4
    FLASH.ROMCIV.WORD = 0x0001;
ffe03cbb:	3d 52 01                      	mov.w	#1, 4[r5]
    while (FLASH.ROMCIV.WORD != 0x0000)
ffe03cbe:	ef 00                         	nop	; mov.l	r0, r0
ffe03cc0:	b8 c5                         	movu.w	4[r4], r5
ffe03cc2:	61 05                         	cmp	#0, r5
ffe03cc4:	21 fc                         	bne.b	ffe03cc0 <_Reset_Vector+0xffe03cc4>
    }

    /* Enables the ROM cache. */
    FLASH.ROMCE.WORD = 0x0001;
    /* WAIT_LOOP */
    while (FLASH.ROMCE.WORD != 0x0001)
ffe03cc6:	fb 3e 00 10 08                	mov.l	#0x81000, r3
    FLASH.ROMCE.WORD = 0x0001;
ffe03ccb:	f8 45 01                      	mov.w	#1, [r4]
    while (FLASH.ROMCE.WORD != 0x0001)
ffe03cce:	ef 00                         	nop	; mov.l	r0, r0
ffe03cd0:	5c 35                         	movu.w	[r3], r5
ffe03cd2:	61 15                         	cmp	#1, r5
ffe03cd4:	21 fc                         	bne.b	ffe03cd0 <_Reset_Vector+0xffe03cd4>

ffe03cd6 <.LBB16>:
* Return value : none
***********************************************************************************************************************/
static void output_ports_configure(void)
{
    /* Add code here to setup additional output ports */
    R_BSP_NOP();
ffe03cd6:	03                            	nop

ffe03cd7 <.LBB18>:
* Return value : none
***********************************************************************************************************************/
static void interrupts_configure(void)
{
    /* Add code here to setup additional interrupts */
    R_BSP_NOP();
ffe03cd7:	03                            	nop

ffe03cd8 <.LBB20>:
static void peripheral_modules_enable(void)
{
    /* Add code here to enable peripherals used by the application */
#if BSP_CFG_CONFIGURATOR_SELECT == 1
    /* Smart Configurator initialization function */
    R_Systeminit();
ffe03cd8:	05 69 00 00                   	bsr.a	ffe03d41 <_Reset_Vector+0xffe03d45>

ffe03cdc <.LVL0>:
    bsp_non_existent_port_init();
ffe03cdc:	05 7c f4 ff                   	bsr.a	ffe03158 <_Reset_Vector+0xffe0315c>

ffe03ce0 <.LBB22>:
static void bsp_adc_initial_configure(void)
{
    uint32_t tmp_mstp;

    /* Protect off. */
    SYSTEM.PRCR.WORD = 0xA502;
ffe03ce0:	fb 4e 00 00 08                	mov.l	#0x80000, r4
ffe03ce5:	fa 49 ff 01 02 a5             	mov.w	#0xa502, 1022[r4]

    /* Store the value of the MSTPCR. */
    tmp_mstp = MSTP(S12AD1);
ffe03ceb:	a9 45                         	mov.l	16[r4], r5

    /* Release from the module-stop state */
    MSTP(S12AD1) = 0;
ffe03ced:	a9 43                         	mov.l	16[r4], r3
    tmp_mstp = MSTP(S12AD1);
ffe03cef:	69 05                         	shlr	#16, r5
    MSTP(S12AD1) = 0;
ffe03cf1:	7b 03                         	bclr	#16, r3
    tmp_mstp = MSTP(S12AD1);
ffe03cf3:	64 15                         	and	#1, r5

ffe03cf5 <.LVL2>:
    MSTP(S12AD1) = 0;
ffe03cf5:	a1 43                         	mov.l	r3, 16[r4]

    if(0 != MSTP(S12AD1))
ffe03cf7:	a9 44                         	mov.l	16[r4], r4
ffe03cf9:	7d 04                         	btst	#16, r4
ffe03cfb:	15                            	beq.s	ffe03d00 <_Reset_Vector+0xffe03d04>
    {
        R_BSP_NOP();
ffe03cfc:	03                            	nop
ffe03cfd:	fc 13 00                      	nop	; max	r0, r0
    }

    /* Writing to the A/D conversion time setting register is enabled. */
    S12AD1.ADSAMPR.BYTE = 0x03;
ffe03d00:	fb 3e 00 91 08                	mov.l	#0x89100, r3

    /* Writing to the A/D conversion time setting register is disabled. */
    S12AD1.ADSAMPR.BYTE = 0x02;

    /* Restore the value of the MSTPCR. */
    MSTP(S12AD1) = tmp_mstp;
ffe03d05:	fb 4e 00 00 08                	mov.l	#0x80000, r4

ffe03d0a <.LBB25>:
static void bsp_bsc_initial_configure(void)
{
    st_bsp_bsc_t bsp_bsc;

    /* Setting priority when bus right request contention occurs. */
    bsp_bsc.ebmapcr.u_long     = BSC.EBMAPCR.LONG;
ffe03d0a:	fb 2e 00 58 0c                	mov.l	#0xc5800, r2

ffe03d0f <.LBB28>:
    S12AD1.ADSAMPR.BYTE = 0x03;
ffe03d0f:	f9 34 63 03                   	mov.b	#3, 99[r3]
    S12AD1.ADSAM.WORD = 0x0020;
ffe03d13:	f9 35 37 20                   	mov.w	#32, 110[r3]
    S12AD1.ADSAMPR.BYTE = 0x02;
ffe03d17:	f9 34 63 02                   	mov.b	#2, 99[r3]
    MSTP(S12AD1) = tmp_mstp;
ffe03d1b:	a9 43                         	mov.l	16[r4], r3
ffe03d1d:	7c 05                         	btst	#0, r5
ffe03d1f:	fd f0 13                      	bmne	#16, r3
ffe03d22:	a1 43                         	mov.l	r3, 16[r4]
    SYSTEM.PRCR.WORD = 0xA500;
ffe03d24:	fa 49 ff 01 00 a5             	mov.w	#0xa500, 1022[r4]

ffe03d2a <.LBB29>:
    bsp_bsc.ebmapcr.u_long     = BSC.EBMAPCR.LONG;
ffe03d2a:	ec 25                         	mov.l	[r2], r5

ffe03d2c <.LVL3>:
    bsp_bsc.ebmapcr.bit.pr1sel = BSP_CFG_EBMAPCR_1ST_PRIORITY;
ffe03d2c:	77 25 88 88 f8                	and	#0xfff88888, r5
ffe03d31:	77 35 30 21 04                	or	#0x42130, r5
    bsp_bsc.ebmapcr.bit.pr3sel = BSP_CFG_EBMAPCR_3RD_PRIORITY;
    bsp_bsc.ebmapcr.bit.pr4sel = BSP_CFG_EBMAPCR_4TH_PRIORITY;
    bsp_bsc.ebmapcr.bit.pr5sel = BSP_CFG_EBMAPCR_5TH_PRIORITY;

    /* Set to EBMAPCR register */
    BSC.EBMAPCR.LONG = bsp_bsc.ebmapcr.u_long;
ffe03d36:	e3 25                         	mov.l	r5, [r2]

ffe03d38 <.LBE29>:
} /* End of function hardware_setup() */
ffe03d38:	02                            	rts

ffe03d39 <.LFE3>:
ffe03d39:	fd 70 40 00 00 00 80          	nop	; max	#0x80000000, r0

ffe03d40 <_r_undefined_exception>:

void r_undefined_exception(void)
{
    /* Start user code for r_undefined_exception. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffe03d40:	02                            	rts

ffe03d41 <_R_Systeminit>:
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void R_Systeminit(void)
{
ffe03d41:	6e 7a                         	pushm	r7-r10
    /* Enable writing to registers related to operating modes, LPC, CGC and software reset */
    SYSTEM.PRCR.WORD = 0xA50BU;
ffe03d43:	fb ae 00 00 08                	mov.l	#0x80000, r10

    /* Enable writing to MPC pin function control registers */
    MPC.PWPR.BIT.B0WI = 0U;
ffe03d48:	fb 7e 00 c1 08                	mov.l	#0x8c100, r7
    SYSTEM.PRCR.WORD = 0xA50BU;
ffe03d4d:	fa a9 ff 01 0b a5             	mov.w	#0xa50b, 1022[r10]
    MPC.PWPR.BIT.B0WI = 0U;
ffe03d53:	8f fd                         	mov.b	31[r7], r5
ffe03d55:	7a 75                         	bclr	#7, r5
ffe03d57:	87 fd                         	mov.b	r5, 31[r7]
    MPC.PWPR.BIT.PFSWE = 1U;
ffe03d59:	f1 76 1f                      	bset	#6, 31[r7].b

    /* Write 0 to the target bits in the POECR2 registers */
    POE3.POECR2.WORD = 0x0000U;
ffe03d5c:	fb 5e c0 c4 08                	mov.l	#0x8c4c0, r5
ffe03d61:	3d 56 00                      	mov.w	#0, 12[r5]

    /* Initialize clocks settings */
    R_CGC_Create();
ffe03d64:	05 59 00 00                   	bsr.a	ffe03dbd <_Reset_Vector+0xffe03dc1>

ffe03d68 <.LVL0>:

    /* Set peripheral settings */
    R_Config_SCI0_Create();
ffe03d68:	05 96 00 00                   	bsr.a	ffe03dfe <_Reset_Vector+0xffe03e02>

ffe03d6c <.LVL1>:
    R_Config_RIIC0_Create();
ffe03d6c:	05 19 01 00                   	bsr.a	ffe03e85 <_Reset_Vector+0xffe03e89>

ffe03d70 <.LVL2>:
    R_Config_MTU3_MTU4_Create();
ffe03d70:	05 99 01 00                   	bsr.a	ffe03f09 <_Reset_Vector+0xffe03f0d>

ffe03d74 <.LVL3>:

    /* Set interrupt settings */
    R_Interrupt_Create();
ffe03d74:	05 4e 00 00                   	bsr.a	ffe03dc2 <_Reset_Vector+0xffe03dc6>

ffe03d78 <.LVL4>:

    /* Register undefined interrupt */
    R_BSP_InterruptWrite(BSP_INT_SRC_UNDEFINED_INTERRUPT,(bsp_int_cb_t)r_undefined_exception);
ffe03d78:	fb 22 40 3d e0 ff             	mov.l	#0xffe03d40, r2
ffe03d7e:	66 a1                         	mov.l	#10, r1
ffe03d80:	05 90 fa ff                   	bsr.a	ffe03810 <_Reset_Vector+0xffe03814>

ffe03d84 <.LVL5>:

    /* Register group BL0 interrupt TEI0 (SCI0) */
    R_BSP_InterruptWrite(BSP_INT_SRC_BL0_SCI0_TEI0,(bsp_int_cb_t)r_Config_SCI0_transmitend_interrupt);
ffe03d84:	fb 22 18 04 e0 ff             	mov.l	#0xffe00418, r2
ffe03d8a:	75 41 14                      	mov.l	#20, r1
ffe03d8d:	05 83 fa ff                   	bsr.a	ffe03810 <_Reset_Vector+0xffe03814>

ffe03d91 <.LVL6>:

    /* Register group BL1 interrupt TEI0 (RIIC0) */
    R_BSP_InterruptWrite(BSP_INT_SRC_BL1_RIIC0_TEI0,(bsp_int_cb_t)r_Config_RIIC0_transmitend_interrupt);
ffe03d91:	fb 22 68 04 e0 ff             	mov.l	#0xffe00468, r2
ffe03d97:	75 41 3c                      	mov.l	#60, r1
ffe03d9a:	05 76 fa ff                   	bsr.a	ffe03810 <_Reset_Vector+0xffe03814>

ffe03d9e <.LVL7>:

    /* Register group BL1 interrupt EEI0 (RIIC0) */
    R_BSP_InterruptWrite(BSP_INT_SRC_BL1_RIIC0_EEI0,(bsp_int_cb_t)r_Config_RIIC0_error_interrupt);
ffe03d9e:	fb 22 a8 04 e0 ff             	mov.l	#0xffe004a8, r2
ffe03da4:	75 41 3d                      	mov.l	#61, r1
ffe03da7:	05 69 fa ff                   	bsr.a	ffe03810 <_Reset_Vector+0xffe03814>

ffe03dab <.LVL8>:

    /* Disable writing to MPC pin function control registers */
    MPC.PWPR.BIT.PFSWE = 0U;
ffe03dab:	f1 7e 1f                      	bclr	#6, 31[r7].b
    MPC.PWPR.BIT.B0WI = 1U;
ffe03dae:	8f fd                         	mov.b	31[r7], r5
ffe03db0:	78 75                         	bset	#7, r5
ffe03db2:	87 fd                         	mov.b	r5, 31[r7]

    /* Enable protection */
    SYSTEM.PRCR.WORD = 0xA500U;
ffe03db4:	fa a9 ff 01 00 a5             	mov.w	#0xa500, 1022[r10]
}
ffe03dba:	3f 7a 04                      	rtsd	#16, r7-r10

ffe03dbd <_R_CGC_Create>:
* Return Value : None
***********************************************************************************************************************/

void R_CGC_Create(void)
{
    R_CGC_Create_UserInit();
ffe03dbd:	04 04 00 00                   	bra.a	ffe03dc1 <_Reset_Vector+0xffe03dc5>

ffe03dc1 <_R_CGC_Create_UserInit>:

void R_CGC_Create_UserInit(void)
{
    /* Start user code for user init. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffe03dc1:	02                            	rts

ffe03dc2 <_R_Interrupt_Create>:
***********************************************************************************************************************/

void R_Interrupt_Create(void)
{
    /* Disable group BL0 interrupt*/
    IEN(ICU,GROUPBL0) = 0U;
ffe03dc2:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe03dc7:	f2 5e 0d 02                   	bclr	#6, 525[r5].b
    
    /* Disable group BL1 interrupt*/
    IEN(ICU,GROUPBL1) = 0U;
ffe03dcb:	ce 54 0d 02                   	mov.b	525[r5], r4
ffe03dcf:	7a 74                         	bclr	#7, r4
ffe03dd1:	cb 54 0d 02                   	mov.b	r4, 525[r5]
    

    /* Set group BL0 interrupt priority level */
    IPR(ICU,GROUPBL0) = _02_ICU_PRIORITY_LEVEL2;
ffe03dd5:	ce 54 6e 03                   	mov.b	878[r5], r4
ffe03dd9:	75 24 f0                      	and	#-16, r4
ffe03ddc:	78 14                         	bset	#1, r4
ffe03dde:	cb 54 6e 03                   	mov.b	r4, 878[r5]

    /* Set group BL1 interrupt priority level */
    IPR(ICU,GROUPBL1) = _03_ICU_PRIORITY_LEVEL3;
ffe03de2:	ce 54 6f 03                   	mov.b	879[r5], r4
ffe03de6:	75 24 f0                      	and	#-16, r4
ffe03de9:	65 34                         	or	#3, r4
ffe03deb:	cb 54 6f 03                   	mov.b	r4, 879[r5]

    /* Enable group BL0 interrupt */
    IEN(ICU,GROUPBL0) = 1U;
ffe03def:	f2 56 0d 02                   	bset	#6, 525[r5].b

    /* Enable group BL1 interrupt */
    IEN(ICU,GROUPBL1) = 1U;
ffe03df3:	ce 54 0d 02                   	mov.b	525[r5], r4
ffe03df7:	78 74                         	bset	#7, r4
ffe03df9:	cb 54 0d 02                   	mov.b	r4, 525[r5]
}
ffe03dfd:	02                            	rts

ffe03dfe <_R_Config_SCI0_Create>:
***********************************************************************************************************************/

void R_Config_SCI0_Create(void)
{
    /* Cancel SCI stop state */
    MSTP(SCI0) = 0U;
ffe03dfe:	fb 3e 00 00 08                	mov.l	#0x80000, r3

    /* Set interrupt priority */
    IPR(SCI0, RXI0) = _02_SCI_PRIORITY_LEVEL2;
ffe03e03:	fb 2e 00 70 08                	mov.l	#0x87000, r2
    MSTP(SCI0) = 0U;
ffe03e08:	ed 3e 05                      	mov.l	20[r3], r14
    IPR(SCI0, TXI0) = _02_SCI_PRIORITY_LEVEL2;

    /* Clear the control register */
    SCI0.SCR.BYTE = 0x00U;
ffe03e0b:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
    SCI0.SPMR.BYTE = _00_SCI_CLOCK_NOT_INVERTED | _00_SCI_CLOCK_NOT_DELAYED;
    SCI0.SCR.BYTE = _10_SCI_RECEIVE_ENABLE | _20_SCI_TRANSMIT_ENABLE | _40_SCI_RXI_ERI_ENABLE | _80_SCI_TXI_ENABLE | 
                    _04_SCI_TEI_INTERRUPT_ENABLE;

    /* Set SSCL0 pin */
    MPC.P33PFS.BYTE = 0x0BU;
ffe03e10:	fb 1e 00 c1 08                	mov.l	#0x8c100, r1
    PORT3.ODR0.BYTE |= 0x40U;
ffe03e15:	fb 4e 03 c0 08                	mov.l	#0x8c003, r4
    MSTP(SCI0) = 0U;
ffe03e1a:	7b fe                         	bclr	#31, r14
ffe03e1c:	e7 3e 05                      	mov.l	r14, 20[r3]
    IPR(SCI0, RXI0) = _02_SCI_PRIORITY_LEVEL2;
ffe03e1f:	ce 23 3a 03                   	mov.b	826[r2], r3
ffe03e23:	75 23 f0                      	and	#-16, r3
ffe03e26:	78 13                         	bset	#1, r3
ffe03e28:	cb 23 3a 03                   	mov.b	r3, 826[r2]
    IPR(SCI0, TXI0) = _02_SCI_PRIORITY_LEVEL2;
ffe03e2c:	ce 23 3b 03                   	mov.b	827[r2], r3
ffe03e30:	75 23 f0                      	and	#-16, r3
ffe03e33:	78 13                         	bset	#1, r3
ffe03e35:	cb 23 3b 03                   	mov.b	r3, 827[r2]
    SCI0.SCR.BYTE = 0x00U;
ffe03e39:	3c 52 00                      	mov.b	#0, 2[r5]
    SCI0.SIMR3.BYTE = _C0_SCI_SSCL_HIGH_IMPEDANCE | _30_SCI_SSDA_HIGH_IMPEDANCE;
ffe03e3c:	f9 54 0b f0                   	mov.b	#240, 11[r5]
    SCI0.SMR.BYTE = _00_SCI_CLOCK_PCLK | _00_SCI_ASYNCHRONOUS_OR_I2C_MODE;
ffe03e40:	f8 54 00                      	mov.b	#0, [r5]
    SCI0.SCMR.BIT.SMIF = 0U;
ffe03e43:	f1 58 06                      	bclr	#0, 6[r5].b
    SCI0.SCMR.BIT.SINV = 0U;
ffe03e46:	f1 5a 06                      	bclr	#2, 6[r5].b
    SCI0.SCMR.BIT.SDIR = 1U;
ffe03e49:	f1 53 06                      	bset	#3, 6[r5].b
    SCI0.BRR = 0x12U;
ffe03e4c:	3c 51 12                      	mov.b	#18, 1[r5]
    SCI0.SEMR.BYTE = _00_SCI_NOISE_FILTER_DISABLE | _00_SCI_BIT_MODULATION_DISABLE;
ffe03e4f:	3c 57 00                      	mov.b	#0, 7[r5]
    SCI0.SIMR1.BYTE |= (_01_SCI_IIC_MODE | _00_SCI_NONE);
ffe03e52:	f1 50 09                      	bset	#0, 9[r5].b
    SCI0.SIMR2.BYTE |= (_00_SCI_ACK_NACK_INTERRUPTS | _02_SCI_SYNCHRONIZATION | _20_SCI_NACK_TRANSMISSION);
ffe03e55:	8a d3                         	mov.b	10[r5], r3
ffe03e57:	75 33 22                      	or	#34, r3
ffe03e5a:	82 d3                         	mov.b	r3, 10[r5]
    SCI0.SPMR.BYTE = _00_SCI_CLOCK_NOT_INVERTED | _00_SCI_CLOCK_NOT_DELAYED;
ffe03e5c:	3c 5d 00                      	mov.b	#0, 13[r5]
    SCI0.SCR.BYTE = _10_SCI_RECEIVE_ENABLE | _20_SCI_TRANSMIT_ENABLE | _40_SCI_RXI_ERI_ENABLE | _80_SCI_TXI_ENABLE | 
ffe03e5f:	f9 54 02 f4                   	mov.b	#244, 2[r5]
    MPC.P33PFS.BYTE = 0x0BU;
ffe03e63:	f9 14 5b 0b                   	mov.b	#11, 91[r1]
    PORT3.ODR0.BYTE |= 0x40U;
ffe03e67:	f1 46 83                      	bset	#6, 131[r4].b
    PORT3.PMR.BYTE |= 0x08U;
ffe03e6a:	f1 43 60                      	bset	#3, 96[r4].b

    /* Set SSDA0 pin */
    MPC.P32PFS.BYTE = 0x0BU;
ffe03e6d:	f9 14 5a 0b                   	mov.b	#11, 90[r1]
    PORT3.ODR0.BYTE |= 0x10U;
ffe03e71:	f1 44 83                      	bset	#4, 131[r4].b
    PORT3.PMR.BYTE |= 0x04U;
ffe03e74:	f1 42 60                      	bset	#2, 96[r4].b

    R_Config_SCI0_Create_UserInit();
ffe03e77:	04 0d 00 00                   	bra.a	ffe03e84 <_Reset_Vector+0xffe03e88>

ffe03e7b <_R_Config_SCI0_IIC_StopCondition>:
* Return Value : None
***********************************************************************************************************************/

void R_Config_SCI0_IIC_StopCondition(void)
{
    SCI0.SIMR3.BYTE = _04_SCI_STOP_CONDITION_ON | _10_SCI_SSDA_START_RESTART_STOP_CONDITION | 
ffe03e7b:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffe03e80:	3c 5b 54                      	mov.b	#84, 11[r5]
                      _40_SCI_SSCL_START_RESTART_STOP_CONDITION;
}
ffe03e83:	02                            	rts

ffe03e84 <_R_Config_SCI0_Create_UserInit>:
}
ffe03e84:	02                            	rts

ffe03e85 <_R_Config_RIIC0_Create>:
***********************************************************************************************************************/

void R_Config_RIIC0_Create(void)
{
    /* Cancel RIIC stop state */
    MSTP(RIIC0) = 0U;
ffe03e85:	fb 2e 00 00 08                	mov.l	#0x80000, r2
    RIIC0.ICCR1.BIT.ICE = 0U;
ffe03e8a:	fb 5e 00 83 08                	mov.l	#0x88300, r5
    MSTP(RIIC0) = 0U;
ffe03e8f:	ed 2e 05                      	mov.l	20[r2], r14

    /* Cancel internal reset */
    RIIC0.ICCR1.BIT.IICRST = 0U;

    /* Set interrupt priority */
    IPR(RIIC0, RXI0) = _02_IIC_PRIORITY_LEVEL2;
ffe03e92:	fb 3e 00 70 08                	mov.l	#0x87000, r3
    IPR(RIIC0, TXI0) = _02_IIC_PRIORITY_LEVEL2;

    /* Set SCL0 pin */
    MPC.P12PFS.BYTE = 0x0FU;
ffe03e97:	fb 1e 00 c1 08                	mov.l	#0x8c100, r1
    PORT1.PMR.BYTE |= 0x04U;
ffe03e9c:	fb 4e 01 c0 08                	mov.l	#0x8c001, r4
    MSTP(RIIC0) = 0U;
ffe03ea1:	7b 5e                         	bclr	#21, r14
ffe03ea3:	e7 2e 05                      	mov.l	r14, 20[r2]
    RIIC0.ICCR1.BIT.ICE = 0U;
ffe03ea6:	cc 52                         	mov.b	[r5], r2
ffe03ea8:	7a 72                         	bclr	#7, r2
ffe03eaa:	c3 52                         	mov.b	r2, [r5]
    RIIC0.ICCR1.BIT.IICRST = 1U;
ffe03eac:	f0 56                         	bset	#6, [r5].b
    RIIC0.ICCR1.BIT.ICE = 1U;
ffe03eae:	cc 52                         	mov.b	[r5], r2
ffe03eb0:	78 72                         	bset	#7, r2
ffe03eb2:	c3 52                         	mov.b	r2, [r5]
    RIIC0.ICMR1.BYTE |= _70_IIC_PCLK_DIV_128;
ffe03eb4:	88 d2                         	mov.b	2[r5], r2
ffe03eb6:	75 32 70                      	or	#112, r2
ffe03eb9:	80 d2                         	mov.b	r2, 2[r5]
    RIIC0.ICBRL.BYTE = _F6_IIC0_SCL_LOW_LEVEL_PERIOD;
ffe03ebb:	f9 54 10 f6                   	mov.b	#246, 16[r5]
    RIIC0.ICBRH.BYTE = _F6_IIC0_SCL_HIGH_LEVEL_PERIOD;
ffe03ebf:	f9 54 11 f6                   	mov.b	#246, 17[r5]
    RIIC0.ICMR2.BYTE = 0x00U;
ffe03ec3:	3c 53 00                      	mov.b	#0, 3[r5]
    RIIC0.ICMR3.BIT.NF = _00_IIC_NOISE_FILTER_1;
ffe03ec6:	89 52                         	mov.b	4[r5], r2
ffe03ec8:	75 22 fc                      	and	#-4, r2
ffe03ecb:	81 52                         	mov.b	r2, 4[r5]
    RIIC0.ICMR3.BIT.SMBS = 0U;
ffe03ecd:	89 52                         	mov.b	4[r5], r2
ffe03ecf:	7a 72                         	bclr	#7, r2
ffe03ed1:	81 52                         	mov.b	r2, 4[r5]
    RIIC0.ICFER.BYTE = _00_IIC_TIMEOUT_FUNCTION_DISABLE | _02_IIC_MASTER_ARBITRATION_ENABLE | 
ffe03ed3:	3c 55 72                      	mov.b	#114, 5[r5]
    RIIC0.ICIER.BYTE = _02_IIC_ARBITRATION_LOST_INTERRUPT_ENABLE | _04_IIC_START_CONDITION_INTERRUPT_ENABLE | 
ffe03ed6:	f9 54 07 fe                   	mov.b	#254, 7[r5]
    RIIC0.ICCR1.BIT.IICRST = 0U;
ffe03eda:	f0 5e                         	bclr	#6, [r5].b
    IPR(RIIC0, RXI0) = _02_IIC_PRIORITY_LEVEL2;
ffe03edc:	ce 35 34 03                   	mov.b	820[r3], r5
ffe03ee0:	75 25 f0                      	and	#-16, r5
ffe03ee3:	78 15                         	bset	#1, r5
ffe03ee5:	cb 35 34 03                   	mov.b	r5, 820[r3]
    IPR(RIIC0, TXI0) = _02_IIC_PRIORITY_LEVEL2;
ffe03ee9:	ce 35 35 03                   	mov.b	821[r3], r5
ffe03eed:	75 25 f0                      	and	#-16, r5
ffe03ef0:	78 15                         	bset	#1, r5
ffe03ef2:	cb 35 35 03                   	mov.b	r5, 821[r3]
    MPC.P12PFS.BYTE = 0x0FU;
ffe03ef6:	f9 14 4a 0f                   	mov.b	#15, 74[r1]
    PORT1.PMR.BYTE |= 0x04U;
ffe03efa:	f1 42 60                      	bset	#2, 96[r4].b

    /* Set SDA0 pin */
    MPC.P13PFS.BYTE = 0x0FU;
ffe03efd:	f9 14 4b 0f                   	mov.b	#15, 75[r1]
    PORT1.PMR.BYTE |= 0x08U;
ffe03f01:	f1 43 60                      	bset	#3, 96[r4].b

    R_Config_RIIC0_Create_UserInit();
ffe03f04:	04 04 00 00                   	bra.a	ffe03f08 <_Reset_Vector+0xffe03f0c>

ffe03f08 <_R_Config_RIIC0_Create_UserInit>:
}
ffe03f08:	02                            	rts

ffe03f09 <_R_Config_MTU3_MTU4_Create>:
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void R_Config_MTU3_MTU4_Create(void)
{
ffe03f09:	7e a7                         	push.l	r7
    /* Release MTU channel 3 from stop state */
    MSTP(MTU3) = 0U;
ffe03f0b:	fb ee 00 00 08                	mov.l	#0x80000, r14

    /* Enable read/write to MTU3, MTU4 registers */
    MTU.TRWERA.BIT.RWE = 1U;
ffe03f10:	fb 5e 0a 12 0c                	mov.l	#0xc120a, r5
    MSTP(MTU3) = 0U;
ffe03f15:	ed ef 04                      	mov.l	16[r14], r15
    /* Stop MTU channel 3 counter */
    MTU.TSTRA.BIT.CST3 = 0U;
    MTU.TSTRA.BIT.CST4 = 0U;

    /* Set TGIA3 interrupt priority level */
    ICU.SLIAR223.BYTE = 0x10U;
ffe03f18:	fb 3e 00 70 08                	mov.l	#0x87000, r3
    /* Set TCIV4 interrupt priority level */
    ICU.SLIAR232.BYTE = 0x19U;
    IPR(PERIA, INTA232) = _0F_MTU_PRIORITY_LEVEL15;

    /* MTU channel 3 is used as complementary PWM mode 1 */
    MTU3.TIER.BYTE = 0x00U;
ffe03f1d:	fb 4e 00 12 0c                	mov.l	#0xc1200, r4

    /* Disable read/write to MTU3, MTU4 registers */
    MTU.TRWERA.BIT.RWE = 0U;

    /* Set MTIOC3B pin */
    MPC.P22PFS.BYTE = 0x01U;
ffe03f22:	fb 1e 00 c1 08                	mov.l	#0x8c100, r1
    MSTP(MTU3) = 0U;
ffe03f27:	7a 9f                         	bclr	#9, r15
    PORT2.PMR.BYTE |= 0x04U;
ffe03f29:	fb 2e 02 c0 08                	mov.l	#0x8c002, r2
    MPC.P24PFS.BYTE = 0x01U;
    PORT2.PMR.BYTE |= 0x10U;

    /* Set MTIOC4B pin */
    MPC.P17PFS.BYTE = 0x08U;
    PORT1.PMR.BYTE |= 0x80U;
ffe03f2e:	fb 7e 01 c0 08                	mov.l	#0x8c001, r7
    MSTP(MTU3) = 0U;
ffe03f33:	e7 ef 04                      	mov.l	r15, 16[r14]
    MTU.TRWERA.BIT.RWE = 1U;
ffe03f36:	f1 50 7a                      	bset	#0, 122[r5].b
    MTU.TSTRA.BIT.CST3 = 0U;
ffe03f39:	f1 5e 76                      	bclr	#6, 118[r5].b
    MTU.TSTRA.BIT.CST4 = 0U;
ffe03f3c:	cd 5e 76                      	mov.b	118[r5], r14
    MPC.P25PFS.BYTE = 0x01U;
    PORT2.PMR.BYTE |= 0x20U;

    /* Set MTIOC4D pin */
    MPC.P31PFS.BYTE = 0x01U;
    PORT3.PMR.BYTE |= 0x02U;
ffe03f3f:	fb fe 03 c0 08                	mov.l	#0x8c003, r15
    MTU.TSTRA.BIT.CST4 = 0U;
ffe03f44:	7a 7e                         	bclr	#7, r14
ffe03f46:	c7 5e 76                      	mov.b	r14, 118[r5]
    ICU.SLIAR223.BYTE = 0x10U;
ffe03f49:	fa 34 df 09 10                	mov.b	#16, 2527[r3]
    IPR(PERIA, INTA223) = _0F_MTU_PRIORITY_LEVEL15;
ffe03f4e:	ce 3e df 03                   	mov.b	991[r3], r14
ffe03f52:	65 fe                         	or	#15, r14
ffe03f54:	cb 3e df 03                   	mov.b	r14, 991[r3]
    ICU.SLIAR224.BYTE = 0x11U;
ffe03f58:	fa 34 e0 09 11                	mov.b	#17, 2528[r3]
    IPR(PERIA, INTA224) = _0F_MTU_PRIORITY_LEVEL15;
ffe03f5d:	ce 3e e0 03                   	mov.b	992[r3], r14
ffe03f61:	65 fe                         	or	#15, r14
ffe03f63:	cb 3e e0 03                   	mov.b	r14, 992[r3]
    ICU.SLIAR228.BYTE = 0x15U;
ffe03f67:	fa 34 e4 09 15                	mov.b	#21, 2532[r3]
    IPR(PERIA, INTA228) = _0F_MTU_PRIORITY_LEVEL15;
ffe03f6c:	ce 3e e4 03                   	mov.b	996[r3], r14
ffe03f70:	65 fe                         	or	#15, r14
ffe03f72:	cb 3e e4 03                   	mov.b	r14, 996[r3]
    ICU.SLIAR229.BYTE = 0x16U;
ffe03f76:	fa 34 e5 09 16                	mov.b	#22, 2533[r3]
    IPR(PERIA, INTA229) = _0F_MTU_PRIORITY_LEVEL15;
ffe03f7b:	ce 3e e5 03                   	mov.b	997[r3], r14
ffe03f7f:	65 fe                         	or	#15, r14
ffe03f81:	cb 3e e5 03                   	mov.b	r14, 997[r3]
    ICU.SLIAR232.BYTE = 0x19U;
ffe03f85:	fa 34 e8 09 19                	mov.b	#25, 2536[r3]
    IPR(PERIA, INTA232) = _0F_MTU_PRIORITY_LEVEL15;
ffe03f8a:	ce 3e e8 03                   	mov.b	1000[r3], r14
ffe03f8e:	65 fe                         	or	#15, r14
ffe03f90:	cb 3e e8 03                   	mov.b	r14, 1000[r3]
    MTU3.TIER.BYTE = 0x00U;
ffe03f94:	3c 48 00                      	mov.b	#0, 8[r4]
    MTU4.TIER.BYTE = 0x00U;
ffe03f97:	3c 49 00                      	mov.b	#0, 9[r4]
    MTU.TITCR1A.BIT.T3AEN = 0U;
ffe03f9a:	cd 53 26                      	mov.b	38[r5], r3
ffe03f9d:	7a 73                         	bclr	#7, r3
ffe03f9f:	c7 53 26                      	mov.b	r3, 38[r5]
    MTU.TITCR1A.BIT.T4VEN = 0U;
ffe03fa2:	f1 5b 26                      	bclr	#3, 38[r5].b
    MTU3.TCR.BYTE = _00_MTU_PCLK_1 | _00_MTU_CKCL_DIS;
ffe03fa5:	f8 44 00                      	mov.b	#0, [r4]
    MTU4.TCR.BYTE = _00_MTU_PCLK_1;
ffe03fa8:	3c 41 00                      	mov.b	#0, 1[r4]
    MTU3.TCR2.BYTE = _00_MTU_PCLK_1;
ffe03fab:	f9 44 4c 00                   	mov.b	#0, 76[r4]
    MTU4.TCR2.BYTE = _00_MTU_PCLK_1;
ffe03faf:	f9 44 4d 00                   	mov.b	#0, 77[r4]
    MTU.TGCRA.BYTE = _80_MTU_BDC_OUT;
ffe03fb3:	f9 54 03 80                   	mov.b	#128, 3[r5]
    MTU3.TCNT = _04B0_3TCNT_VALUE;
ffe03fb7:	f9 49 08 b0 04                	mov.w	#0x4b0, 16[r4]
    MTU4.TCNT = 0x0000U;
ffe03fbc:	3d 49 00                      	mov.w	#0, 18[r4]
    MTU.TSYRA.BIT.SYNC3 = 0U;
ffe03fbf:	f1 5e 77                      	bclr	#6, 119[r5].b
    MTU.TSYRA.BIT.SYNC4 = 0U;
ffe03fc2:	cd 53 77                      	mov.b	119[r5], r3
ffe03fc5:	7a 73                         	bclr	#7, r3
ffe03fc7:	c7 53 77                      	mov.b	r3, 119[r5]
    MTU3.TGRB = _0064_3TGRB_VALUE;
ffe03fca:	3d 4d 64                      	mov.w	#100, 26[r4]
    MTU3.TGRD = _0064_3TGRB_VALUE;
ffe03fcd:	3d c3 64                      	mov.w	#100, 38[r4]
    MTU4.TGRA = _0064_4TGRA_VALUE;
ffe03fd0:	3d 4e 64                      	mov.w	#100, 28[r4]
    MTU4.TGRC = _0064_4TGRA_VALUE;
ffe03fd3:	3d c4 64                      	mov.w	#100, 40[r4]
    MTU4.TGRB = _0064_4TGRB_VALUE;
ffe03fd6:	3d 4f 64                      	mov.w	#100, 30[r4]
    MTU4.TGRD = _0064_4TGRB_VALUE;
ffe03fd9:	3d c5 64                      	mov.w	#100, 42[r4]
    MTU.TDERA.BIT.TDER = 1U;
ffe03fdc:	f1 50 2a                      	bset	#0, 42[r5].b
    MTU.TDDRA = _04B0_TDDRA_VALUE;
ffe03fdf:	f9 59 06 b0 04                	mov.w	#0x4b0, 12[r5]
    MTU.TCDRA = _2EE0_TCDRA_VALUE;
ffe03fe4:	f9 59 05 e0 2e                	mov.w	#0x2ee0, 10[r5]
    MTU.TCBRA = _2EE0_TCDRA_VALUE;
ffe03fe9:	f9 59 0c e0 2e                	mov.w	#0x2ee0, 24[r5]
    MTU3.TGRA = _1C20_SUM_VALUE;
ffe03fee:	f9 49 0c 20 1c                	mov.w	#0x1c20, 24[r4]
    MTU3.TGRC = _1C20_SUM_VALUE;
ffe03ff3:	f9 49 12 20 1c                	mov.w	#0x1c20, 36[r4]
    MTU.TOCR1A.BYTE = _00_MTU_PSYE_DISABLE | _08_MTU_TOCL_DISABLE | _04_MTU_TOCS_TOCR2;
ffe03ff8:	3c 54 0c                      	mov.b	#12, 4[r5]
    MTU.TOCR2A.BYTE = _00_MTU_TOLBR_DIS | _00_MTU_OLS3N_HL | _00_MTU_OLS3P_HL | _00_MTU_OLS2N_HL | _00_MTU_OLS2P_HL | 
ffe03ffb:	3c 55 00                      	mov.b	#0, 5[r5]
    MTU.TOLBRA.BYTE = MTU.TOCR2A.BYTE & 0x3FU;
ffe03ffe:	89 5b                         	mov.b	5[r5], r3
ffe04000:	75 23 3f                      	and	#63, r3
ffe04003:	c7 53 2c                      	mov.b	r3, 44[r5]
    MTU3.TIER.BYTE = _01_MTU_TGIEA_ENABLE | _02_MTU_TGIEB_ENABLE | _00_MTU_TTGE_DISABLE;
ffe04006:	3c 48 03                      	mov.b	#3, 8[r4]
    MTU4.TIER.BYTE = _01_MTU_TGIEA_ENABLE | _02_MTU_TGIEB_ENABLE | _10_MTU_TCIEV_ENABLE | _00_MTU_TTGE2_DISABLE;
ffe04009:	3c 49 13                      	mov.b	#19, 9[r4]
    MTU.TITMRA.BIT.TITM = 0U;
ffe0400c:	f1 58 30                      	bclr	#0, 48[r5].b
    MTU.TITCR1A.BYTE = _00_MTU_TACOR_3_6_SKIP_COUNT_0 | _00_MTU_TVCOR_4_7_SKIP_COUNT_0;
ffe0400f:	f9 54 26 00                   	mov.b	#0, 38[r5]
    MTU3.TMDR1.BYTE = _0D_MTU_CMT1 | _10_MTU_BFA_BUFFER | _20_MTU_BFB_BUFFER;
ffe04013:	3c 42 3d                      	mov.b	#61, 2[r4]
    MTU.TOERA.BYTE = _E0_MTU_OE4D_ENABLE | _D0_MTU_OE4C_ENABLE | _C8_MTU_OE3D_ENABLE | _C4_MTU_OE4B_ENABLE | 
ffe04016:	f8 54 ff                      	mov.b	#255, [r5]
    MTU.TRWERA.BIT.RWE = 0U;
ffe04019:	f1 58 7a                      	bclr	#0, 122[r5].b
    MPC.P22PFS.BYTE = 0x01U;
ffe0401c:	f9 14 52 01                   	mov.b	#1, 82[r1]
    PORT2.PMR.BYTE |= 0x04U;
ffe04020:	f1 22 60                      	bset	#2, 96[r2].b
    MPC.P23PFS.BYTE = 0x01U;
ffe04023:	f9 14 53 01                   	mov.b	#1, 83[r1]
    PORT2.PMR.BYTE |= 0x08U;
ffe04027:	f1 23 60                      	bset	#3, 96[r2].b
    MPC.P24PFS.BYTE = 0x01U;
ffe0402a:	f9 14 54 01                   	mov.b	#1, 84[r1]
    PORT2.PMR.BYTE |= 0x10U;
ffe0402e:	f1 24 60                      	bset	#4, 96[r2].b
    MPC.P17PFS.BYTE = 0x08U;
ffe04031:	f9 14 4f 08                   	mov.b	#8, 79[r1]
    PORT1.PMR.BYTE |= 0x80U;
ffe04035:	cd 75 60                      	mov.b	96[r7], r5
ffe04038:	75 35 80                      	or	#-128, r5
ffe0403b:	c7 75 60                      	mov.b	r5, 96[r7]
    MPC.P25PFS.BYTE = 0x01U;
ffe0403e:	f9 14 55 01                   	mov.b	#1, 85[r1]
    PORT2.PMR.BYTE |= 0x20U;
ffe04042:	f1 25 60                      	bset	#5, 96[r2].b
    MPC.P31PFS.BYTE = 0x01U;
ffe04045:	f9 14 59 01                   	mov.b	#1, 89[r1]
    PORT3.PMR.BYTE |= 0x02U;
ffe04049:	f1 f1 60                      	bset	#1, 96[r15].b

    R_Config_MTU3_MTU4_Create_UserInit();
}
ffe0404c:	7e b7                         	pop	r7
    R_Config_MTU3_MTU4_Create_UserInit();
ffe0404e:	04 04 00 00                   	bra.a	ffe04052 <_Reset_Vector+0xffe04056>

ffe04052 <_R_Config_MTU3_MTU4_Create_UserInit>:

void R_Config_MTU3_MTU4_Create_UserInit(void)
{
    /* Start user code for user init. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffe04052:	02                            	rts

ffe04053 <.LFE3>:
ffe04053:	00                            	brk
ffe04054:	00                            	brk
ffe04055:	00                            	brk
	...

ffe04058 <_main>:
#define VECT_TRAP_4 4
#endif

void main(void)
{
    R_BSP_SET_IPL( MY_BSP_CFG_UNNESTED_IPL_MAX - 1 );
ffe04058:	75 70 08                      	mvtipl	#8
    R_BSP_INT( VECT( TRAP, 0 ) );
ffe0405b:	75 60 00                      	int #0
    R_BSP_INT( VECT( TRAP, 1 ) );
ffe0405e:	75 60 01                      	int #1
    R_BSP_INT( VECT( TRAP, 2 ) );
ffe04061:	75 60 02                      	int #2
#if defined(__BANK)
    R_BSP_INT( VECT( TRAP, 3 ) );
    R_BSP_INT( VECT( TRAP, 4 ) );
#endif

    R_BSP_SET_IPL( MY_BSP_CFG_UNNESTED_IPL_MAX );
ffe04064:	75 70 09                      	mvtipl	#9
    R_BSP_INT( VECT( TRAP, 0 ) );
ffe04067:	75 60 00                      	int #0
    R_BSP_INT( VECT( TRAP, 1 ) );
ffe0406a:	75 60 01                      	int #1
    R_BSP_INT( VECT( TRAP, 2 ) );
ffe0406d:	75 60 02                      	int #2
#if defined(__BANK)
    R_BSP_INT( VECT( TRAP, 3 ) );
    R_BSP_INT( VECT( TRAP, 4 ) );
#endif

    R_BSP_SET_IPL( MY_BSP_CFG_UNNESTED_IPL_MAX + 1 );
ffe04070:	75 70 0a                      	mvtipl	#10
    R_BSP_INT( VECT( TRAP, 0 ) );
ffe04073:	75 60 00                      	int #0
    R_BSP_INT( VECT( TRAP, 1 ) );
ffe04076:	75 60 01                      	int #1
    R_BSP_INT( VECT( TRAP, 2 ) );
ffe04079:	75 60 02                      	int #2
    R_BSP_INT( VECT( TRAP, 3 ) );
    R_BSP_INT( VECT( TRAP, 4 ) );
#endif
#endif

    R_BSP_NOP();
ffe0407c:	03                            	nop
ffe0407d:	fc 13 00                      	nop	; max	r0, r0
#if defined(__RXV3)
    fp_Check_Using_DSQRT_FSQRT = &Check_Using_DSQRT_FSQRT;
    fp_Check_Not_Using_DSQRT_FSQRT = &Check_Not_Using_DSQRT_FSQRT;
#endif

    for(;;);
ffe04080:	2e 00                         	bra.b	ffe04080 <_Reset_Vector+0xffe04084>

ffe04082 <.LFE3>:
ffe04082:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe04088 <__sci_iic_int_sci_iic1_txi_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(sci_iic_int_sci_iic1_txi_isr, VECT_SCI1_TXI1)
ffe04088:	7e a1                         	push.l	r1
ffe0408a:	fd 6a 01                      	mvfc	psw, r1
ffe0408d:	69 81                         	shlr	#24, r1
ffe0408f:	64 f1                         	and	#15, r1
ffe04091:	61 91                         	cmp	#9, r1
ffe04093:	22 05                         	bc.b	ffe04098 <_Reset_Vector+0xffe0409c>
ffe04095:	75 70 09                      	mvtipl	#9
ffe04098:	7f a8                         	setpsw	i
ffe0409a:	7e b1                         	pop	r1
ffe0409c:	2e 02                         	bra.b	ffe0409e <_Reset_Vector+0xffe040a2>

ffe0409e <_sci_iic_int_sci_iic1_txi_isr>:
{
ffe0409e:	6e ef                         	pushm	r14-r15
ffe040a0:	6e 15                         	pushm	r1-r5
ffe040a2:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe040a5:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe040a8:	7e a1                         	push.l	r1
ffe040aa:	7e a2                         	push.l	r2
ffe040ac:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe040af:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe040b2:	7e a1                         	push.l	r1
ffe040b4:	7e a2                         	push.l	r2
ffe040b6:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe040b9:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe040bc:	7e a1                         	push.l	r1
ffe040be:	7e a2                         	push.l	r2
    r_sci_iic_txi_isr_processing(SCI_IIC_NUM_CH1);
ffe040c0:	66 11                         	mov.l	#1, r1
ffe040c2:	05 76 ce ff                   	bsr.a	ffe00f38 <_Reset_Vector+0xffe00f3c>

ffe040c6 <.LVL115>:
    r_sci_iic_advance(g_sci_iic_handles[SCI_IIC_NUM_CH1]->psci_iic_info_ch);
ffe040c6:	fb 52 04 00 00 00             	mov.l	#4, r5
ffe040cc:	a9 d1                         	mov.l	24[r5], r1
ffe040ce:	05 12 cd ff                   	bsr.a	ffe00de0 <_Reset_Vector+0xffe00de4>

ffe040d2 <.LVL116>:
} /* End of function sci_iic_int_sci_iic1_txi_isr() */
ffe040d2:	7e b2                         	pop	r2
ffe040d4:	7e b1                         	pop	r1
ffe040d6:	fd 17 81                      	mvtachi	r1, a1
ffe040d9:	fd 17 b2                      	mvtacgu	r2, a1
ffe040dc:	7e b2                         	pop	r2
ffe040de:	7e b1                         	pop	r1
ffe040e0:	fd 17 31                      	mvtacgu	r1, a0
ffe040e3:	fd 17 92                      	mvtaclo	r2, a1
ffe040e6:	7e b2                         	pop	r2
ffe040e8:	7e b1                         	pop	r1
ffe040ea:	fd 17 11                      	mvtaclo	r1, a0
ffe040ed:	fd 17 02                      	mvtachi	r2, a0
ffe040f0:	6f 15                         	popm	r1-r5
ffe040f2:	6f ef                         	popm	r14-r15
ffe040f4:	7f 95                         	rte

ffe040f6 <__riic1_txi_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(riic1_txi_isr, VECT(RIIC1,TXI1))
ffe040f6:	7e a1                         	push.l	r1
ffe040f8:	fd 6a 01                      	mvfc	psw, r1
ffe040fb:	69 81                         	shlr	#24, r1
ffe040fd:	64 f1                         	and	#15, r1
ffe040ff:	61 91                         	cmp	#9, r1
ffe04101:	22 05                         	bc.b	ffe04106 <_Reset_Vector+0xffe0410a>
ffe04103:	75 70 09                      	mvtipl	#9
ffe04106:	7f a8                         	setpsw	i
ffe04108:	7e b1                         	pop	r1
ffe0410a:	2e 02                         	bra.b	ffe0410c <_Reset_Vector+0xffe04110>

ffe0410c <_riic1_txi_isr>:
{
ffe0410c:	6e ef                         	pushm	r14-r15
ffe0410e:	6e 15                         	pushm	r1-r5
ffe04110:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe04113:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe04116:	7e a1                         	push.l	r1
ffe04118:	7e a2                         	push.l	r2
ffe0411a:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe0411d:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe04120:	7e a1                         	push.l	r1
ffe04122:	7e a2                         	push.l	r2
ffe04124:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe04127:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe0412a:	7e a1                         	push.l	r1
ffe0412c:	7e a2                         	push.l	r2
    riic1_txi_sub();
ffe0412e:	05 c2 eb ff                   	bsr.a	ffe02cf0 <_Reset_Vector+0xffe02cf4>

ffe04132 <.LVL84>:
} /* End of function riic1_txi_isr() */
ffe04132:	7e b2                         	pop	r2
ffe04134:	7e b1                         	pop	r1
ffe04136:	fd 17 81                      	mvtachi	r1, a1
ffe04139:	fd 17 b2                      	mvtacgu	r2, a1
ffe0413c:	7e b2                         	pop	r2
ffe0413e:	7e b1                         	pop	r1
ffe04140:	fd 17 31                      	mvtacgu	r1, a0
ffe04143:	fd 17 92                      	mvtaclo	r2, a1
ffe04146:	7e b2                         	pop	r2
ffe04148:	7e b1                         	pop	r1
ffe0414a:	fd 17 11                      	mvtaclo	r1, a0
ffe0414d:	fd 17 02                      	mvtachi	r2, a0
ffe04150:	6f 15                         	popm	r1-r5
ffe04152:	6f ef                         	popm	r14-r15
ffe04154:	7f 95                         	rte

ffe04156 <__riic1_rxi_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(riic1_rxi_isr, VECT(RIIC1,RXI1))
ffe04156:	7e a1                         	push.l	r1
ffe04158:	fd 6a 01                      	mvfc	psw, r1
ffe0415b:	69 81                         	shlr	#24, r1
ffe0415d:	64 f1                         	and	#15, r1
ffe0415f:	61 91                         	cmp	#9, r1
ffe04161:	22 05                         	bc.b	ffe04166 <_Reset_Vector+0xffe0416a>
ffe04163:	75 70 09                      	mvtipl	#9
ffe04166:	7f a8                         	setpsw	i
ffe04168:	7e b1                         	pop	r1
ffe0416a:	2e 02                         	bra.b	ffe0416c <_Reset_Vector+0xffe04170>

ffe0416c <_riic1_rxi_isr>:
{
ffe0416c:	6e ef                         	pushm	r14-r15
ffe0416e:	6e 15                         	pushm	r1-r5
ffe04170:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe04173:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe04176:	7e a1                         	push.l	r1
ffe04178:	7e a2                         	push.l	r2
ffe0417a:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe0417d:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe04180:	7e a1                         	push.l	r1
ffe04182:	7e a2                         	push.l	r2
ffe04184:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe04187:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe0418a:	7e a1                         	push.l	r1
ffe0418c:	7e a2                         	push.l	r2
    riic1_rxi_sub();
ffe0418e:	05 e2 eb ff                   	bsr.a	ffe02d70 <_Reset_Vector+0xffe02d74>

ffe04192 <.LVL85>:
} /* End of function riic1_rxi_isr() */
ffe04192:	7e b2                         	pop	r2
ffe04194:	7e b1                         	pop	r1
ffe04196:	fd 17 81                      	mvtachi	r1, a1
ffe04199:	fd 17 b2                      	mvtacgu	r2, a1
ffe0419c:	7e b2                         	pop	r2
ffe0419e:	7e b1                         	pop	r1
ffe041a0:	fd 17 31                      	mvtacgu	r1, a0
ffe041a3:	fd 17 92                      	mvtaclo	r2, a1
ffe041a6:	7e b2                         	pop	r2
ffe041a8:	7e b1                         	pop	r1
ffe041aa:	fd 17 11                      	mvtaclo	r1, a0
ffe041ad:	fd 17 02                      	mvtachi	r2, a0
ffe041b0:	6f 15                         	popm	r1-r5
ffe041b2:	6f ef                         	popm	r14-r15
ffe041b4:	7f 95                         	rte

ffe041b6 <.LFE24>:
	...

ffe041b8 <__group_bl0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_bl0_handler_isr, VECT(ICU,GROUPBL0))
ffe041b8:	7e a1                         	push.l	r1
ffe041ba:	fd 6a 01                      	mvfc	psw, r1
ffe041bd:	69 81                         	shlr	#24, r1
ffe041bf:	64 f1                         	and	#15, r1
ffe041c1:	61 91                         	cmp	#9, r1
ffe041c3:	22 05                         	bc.b	ffe041c8 <_Reset_Vector+0xffe041cc>
ffe041c5:	75 70 09                      	mvtipl	#9
ffe041c8:	7f a8                         	setpsw	i
ffe041ca:	7e b1                         	pop	r1
ffe041cc:	2e 02                         	bra.b	ffe041ce <_Reset_Vector+0xffe041d2>

ffe041ce <_group_bl0_handler_isr>:
*                NOTE: The interrupt request flag must be cleared in the peripheral.
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_bl0_handler_isr (void)
{
ffe041ce:	6e ef                         	pushm	r14-r15
ffe041d0:	6e 15                         	pushm	r1-r5
ffe041d2:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe041d5:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe041d8:	7e a1                         	push.l	r1
ffe041da:	7e a2                         	push.l	r2
ffe041dc:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe041df:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe041e2:	7e a1                         	push.l	r1
ffe041e4:	7e a2                         	push.l	r2
ffe041e6:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe041e9:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe041ec:	7e a1                         	push.l	r1
ffe041ee:	7e a2                         	push.l	r2
    /* BL0 IS1 */
    if (1 == ICU.GRPBL0.BIT.IS1)
ffe041f0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe041f5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe041f9:	7c 15                         	btst	#1, r5
ffe041fb:	3b e7 01                      	bne.w	ffe043e2 <_Reset_Vector+0xffe043e6>
        /* BSP_INT_SRC_BL0_SCI0_ERI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI0_ERI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS0 */
    if (1 == ICU.GRPBL0.BIT.IS0)
ffe041fe:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04203:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04207:	7c 05                         	btst	#0, r5
ffe04209:	3b f7 01                      	bne.w	ffe04400 <_Reset_Vector+0xffe04404>
ffe0420c:	76 10 01 00                   	nop	; mul	#1, r0
        /* BSP_INT_SRC_BL0_SCI0_TEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS3 */
    if (1 == ICU.GRPBL0.BIT.IS3)
ffe04210:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04215:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04219:	7c 35                         	btst	#3, r5
ffe0421b:	3b 05 02                      	bne.w	ffe04420 <_Reset_Vector+0xffe04424>
ffe0421e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI1_ERI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_ERI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS2 */
    if (1 == ICU.GRPBL0.BIT.IS2)
ffe04220:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04225:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04229:	7c 25                         	btst	#2, r5
ffe0422b:	3b 15 02                      	bne.w	ffe04440 <_Reset_Vector+0xffe04444>
ffe0422e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI1_TEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS5 */
    if (1 == ICU.GRPBL0.BIT.IS5)
ffe04230:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04235:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04239:	7c 55                         	btst	#5, r5
ffe0423b:	3b 25 02                      	bne.w	ffe04460 <_Reset_Vector+0xffe04464>
ffe0423e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI2_ERI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI2_ERI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS4 */
    if (1 == ICU.GRPBL0.BIT.IS4)
ffe04240:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04245:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04249:	7c 45                         	btst	#4, r5
ffe0424b:	3b 35 02                      	bne.w	ffe04480 <_Reset_Vector+0xffe04484>
ffe0424e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI2_TEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI2_TEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS7 */
    if (1 == ICU.GRPBL0.BIT.IS7)
ffe04250:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04255:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04259:	7c 75                         	btst	#7, r5
ffe0425b:	3b 45 02                      	bne.w	ffe044a0 <_Reset_Vector+0xffe044a4>
ffe0425e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI3_ERI3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI3_ERI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS6 */
    if (1 == ICU.GRPBL0.BIT.IS6)
ffe04260:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04265:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04269:	7c 65                         	btst	#6, r5
ffe0426b:	3b 55 02                      	bne.w	ffe044c0 <_Reset_Vector+0xffe044c4>
ffe0426e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI3_TEI3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI3_TEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS9 */
    if (1 == ICU.GRPBL0.BIT.IS9)
ffe04270:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04275:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04279:	7c 95                         	btst	#9, r5
ffe0427b:	3b 65 02                      	bne.w	ffe044e0 <_Reset_Vector+0xffe044e4>
ffe0427e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI4_ERI4 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI4_ERI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS8 */
    if (1 == ICU.GRPBL0.BIT.IS8)
ffe04280:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04285:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04289:	7c 85                         	btst	#8, r5
ffe0428b:	3b 75 02                      	bne.w	ffe04500 <_Reset_Vector+0xffe04504>
ffe0428e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI4_TEI4 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI4_TEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS11 */
    if (1 == ICU.GRPBL0.BIT.IS11)
ffe04290:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04295:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04299:	7c b5                         	btst	#11, r5
ffe0429b:	3b 85 02                      	bne.w	ffe04520 <_Reset_Vector+0xffe04524>
ffe0429e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI5_ERI5 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_ERI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS10 */
    if (1 == ICU.GRPBL0.BIT.IS10)
ffe042a0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe042a5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe042a9:	7c a5                         	btst	#10, r5
ffe042ab:	3b 95 02                      	bne.w	ffe04540 <_Reset_Vector+0xffe04544>
ffe042ae:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI5_TEI5 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_TEI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS13 */
    if (1 == ICU.GRPBL0.BIT.IS13)
ffe042b0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe042b5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe042b9:	7c d5                         	btst	#13, r5
ffe042bb:	3b a5 02                      	bne.w	ffe04560 <_Reset_Vector+0xffe04564>
ffe042be:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI6_ERI6 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_ERI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS12 */
    if (1 == ICU.GRPBL0.BIT.IS12)
ffe042c0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe042c5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe042c9:	7c c5                         	btst	#12, r5
ffe042cb:	3b b5 02                      	bne.w	ffe04580 <_Reset_Vector+0xffe04584>
ffe042ce:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI6_TEI6 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_TEI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS15 */
    if (1 == ICU.GRPBL0.BIT.IS15)
ffe042d0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe042d5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe042d9:	7c f5                         	btst	#15, r5
ffe042db:	3b c5 02                      	bne.w	ffe045a0 <_Reset_Vector+0xffe045a4>
ffe042de:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI7_ERI7 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI7_ERI7, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS14 */
    if (1 == ICU.GRPBL0.BIT.IS14)
ffe042e0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe042e5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe042e9:	7c e5                         	btst	#14, r5
ffe042eb:	3b d5 02                      	bne.w	ffe045c0 <_Reset_Vector+0xffe045c4>
ffe042ee:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI7_TEI7 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI7_TEI7, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS17 */
    if (1 == ICU.GRPBL0.BIT.IS17)
ffe042f0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe042f5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe042f9:	7d 15                         	btst	#17, r5
ffe042fb:	3b e5 02                      	bne.w	ffe045e0 <_Reset_Vector+0xffe045e4>
ffe042fe:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_ERI12 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_ERI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS16 */
    if (1 == ICU.GRPBL0.BIT.IS16)
ffe04300:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04305:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04309:	7d 05                         	btst	#16, r5
ffe0430b:	3b f5 02                      	bne.w	ffe04600 <_Reset_Vector+0xffe04604>
ffe0430e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_TEI12 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_TEI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS18 */
    if (1 == ICU.GRPBL0.BIT.IS18)
ffe04310:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04315:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04319:	7d 25                         	btst	#18, r5
ffe0431b:	3b 05 03                      	bne.w	ffe04620 <_Reset_Vector+0xffe04624>
ffe0431e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS19 */
    if (1 == ICU.GRPBL0.BIT.IS19)
ffe04320:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04325:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04329:	7d 35                         	btst	#19, r5
ffe0432b:	3b 15 03                      	bne.w	ffe04640 <_Reset_Vector+0xffe04644>
ffe0432e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS20 */
    if (1 == ICU.GRPBL0.BIT.IS20)
ffe04330:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04335:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04339:	7d 45                         	btst	#20, r5
ffe0433b:	3b 25 03                      	bne.w	ffe04660 <_Reset_Vector+0xffe04664>
ffe0433e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS21 */
    if (1 == ICU.GRPBL0.BIT.IS21)
ffe04340:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04345:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04349:	7d 55                         	btst	#21, r5
ffe0434b:	3b 35 03                      	bne.w	ffe04680 <_Reset_Vector+0xffe04684>
ffe0434e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_SCI12_SCIX3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS24 */
    if (1 == ICU.GRPBL0.BIT.IS24)
ffe04350:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04355:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04359:	7d 85                         	btst	#24, r5
ffe0435b:	3b 45 03                      	bne.w	ffe046a0 <_Reset_Vector+0xffe046a4>
ffe0435e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_QSPI_QSPSSLI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_QSPI_QSPSSLI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS26 */
    if (1 == ICU.GRPBL0.BIT.IS26)
ffe04360:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04365:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04369:	7d a5                         	btst	#26, r5
ffe0436b:	3b 55 03                      	bne.w	ffe046c0 <_Reset_Vector+0xffe046c4>
ffe0436e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_FERRI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_FERRI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS27 */
    if (1 == ICU.GRPBL0.BIT.IS27)
ffe04370:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04375:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04379:	7d b5                         	btst	#27, r5
ffe0437b:	3b 65 03                      	bne.w	ffe046e0 <_Reset_Vector+0xffe046e4>
ffe0437e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_MENDI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_MENDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS28 */
    if (1 == ICU.GRPBL0.BIT.IS28)
ffe04380:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04385:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04389:	7d c5                         	btst	#28, r5
ffe0438b:	3b 75 03                      	bne.w	ffe04700 <_Reset_Vector+0xffe04704>
ffe0438e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_CAC_OVFI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_OVFI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS29 */
    if (1 == ICU.GRPBL0.BIT.IS29)
ffe04390:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04395:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04399:	7d d5                         	btst	#29, r5
ffe0439b:	3b 85 03                      	bne.w	ffe04720 <_Reset_Vector+0xffe04724>
ffe0439e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL0_DOC_DOPCI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_DOC_DOPCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS31 */
    if (1 == ICU.GRPBL0.BIT.IS31)
ffe043a0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe043a5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe043a9:	61 05                         	cmp	#0, r5
ffe043ab:	28 05                         	bge.b	ffe043b0 <_Reset_Vector+0xffe043b4>
ffe043ad:	38 93 03                      	bra.w	ffe04740 <_Reset_Vector+0xffe04744>
        /* BSP_INT_SRC_BL0_PDC_PCERI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_PDC_PCERI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL0 IS30 */
    if (1 == ICU.GRPBL0.BIT.IS30)
ffe043b0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe043b5:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe043b9:	7d e5                         	btst	#30, r5
ffe043bb:	3b a5 03                      	bne.w	ffe04760 <_Reset_Vector+0xffe04764>
    {
        /* BSP_INT_SRC_BL0_PDC_PCFEI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_PDC_PCFEI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_bl0_handler_isr() */
ffe043be:	7e b2                         	pop	r2
ffe043c0:	7e b1                         	pop	r1
ffe043c2:	fd 17 81                      	mvtachi	r1, a1
ffe043c5:	fd 17 b2                      	mvtacgu	r2, a1
ffe043c8:	7e b2                         	pop	r2
ffe043ca:	7e b1                         	pop	r1
ffe043cc:	fd 17 31                      	mvtacgu	r1, a0
ffe043cf:	fd 17 92                      	mvtaclo	r2, a1
ffe043d2:	7e b2                         	pop	r2
ffe043d4:	7e b1                         	pop	r1
ffe043d6:	fd 17 11                      	mvtaclo	r1, a0
ffe043d9:	fd 17 02                      	mvtachi	r2, a0
ffe043dc:	6f 15                         	popm	r1-r5
ffe043de:	6f ef                         	popm	r14-r15
ffe043e0:	7f 95                         	rte
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI0_ERI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe043e2:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe043e8:	66 02                         	mov.l	#0, r2
ffe043ea:	75 41 15                      	mov.l	#21, r1
ffe043ed:	05 43 f4 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe043f1 <.LVL0>:
    if (1 == ICU.GRPBL0.BIT.IS0)
ffe043f1:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe043f6:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe043fa:	7c 05                         	btst	#0, r5
ffe043fc:	3a 14 fe                      	beq.w	ffe04210 <_Reset_Vector+0xffe04214>
ffe043ff:	03                            	nop
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04400:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04406:	66 02                         	mov.l	#0, r2
ffe04408:	75 41 14                      	mov.l	#20, r1
ffe0440b:	05 25 f4 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0440f <.LVL1>:
    if (1 == ICU.GRPBL0.BIT.IS3)
ffe0440f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04414:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04418:	7c 35                         	btst	#3, r5
ffe0441a:	3a 06 fe                      	beq.w	ffe04220 <_Reset_Vector+0xffe04224>
ffe0441d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_ERI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04420:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04426:	66 02                         	mov.l	#0, r2
ffe04428:	75 41 17                      	mov.l	#23, r1
ffe0442b:	05 05 f4 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0442f <.LVL2>:
    if (1 == ICU.GRPBL0.BIT.IS2)
ffe0442f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04434:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04438:	7c 25                         	btst	#2, r5
ffe0443a:	3a f6 fd                      	beq.w	ffe04230 <_Reset_Vector+0xffe04234>
ffe0443d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04440:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04446:	66 02                         	mov.l	#0, r2
ffe04448:	75 41 16                      	mov.l	#22, r1
ffe0444b:	05 e5 f3 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0444f <.LVL3>:
    if (1 == ICU.GRPBL0.BIT.IS5)
ffe0444f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04454:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04458:	7c 55                         	btst	#5, r5
ffe0445a:	3a e6 fd                      	beq.w	ffe04240 <_Reset_Vector+0xffe04244>
ffe0445d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI2_ERI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04460:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04466:	66 02                         	mov.l	#0, r2
ffe04468:	75 41 19                      	mov.l	#25, r1
ffe0446b:	05 c5 f3 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0446f <.LVL4>:
    if (1 == ICU.GRPBL0.BIT.IS4)
ffe0446f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04474:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04478:	7c 45                         	btst	#4, r5
ffe0447a:	3a d6 fd                      	beq.w	ffe04250 <_Reset_Vector+0xffe04254>
ffe0447d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI2_TEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04480:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04486:	66 02                         	mov.l	#0, r2
ffe04488:	75 41 18                      	mov.l	#24, r1
ffe0448b:	05 a5 f3 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0448f <.LVL5>:
    if (1 == ICU.GRPBL0.BIT.IS7)
ffe0448f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04494:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04498:	7c 75                         	btst	#7, r5
ffe0449a:	3a c6 fd                      	beq.w	ffe04260 <_Reset_Vector+0xffe04264>
ffe0449d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI3_ERI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe044a0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe044a6:	66 02                         	mov.l	#0, r2
ffe044a8:	75 41 1b                      	mov.l	#27, r1
ffe044ab:	05 85 f3 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe044af <.LVL6>:
    if (1 == ICU.GRPBL0.BIT.IS6)
ffe044af:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe044b4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe044b8:	7c 65                         	btst	#6, r5
ffe044ba:	3a b6 fd                      	beq.w	ffe04270 <_Reset_Vector+0xffe04274>
ffe044bd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI3_TEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe044c0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe044c6:	66 02                         	mov.l	#0, r2
ffe044c8:	75 41 1a                      	mov.l	#26, r1
ffe044cb:	05 65 f3 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe044cf <.LVL7>:
    if (1 == ICU.GRPBL0.BIT.IS9)
ffe044cf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe044d4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe044d8:	7c 95                         	btst	#9, r5
ffe044da:	3a a6 fd                      	beq.w	ffe04280 <_Reset_Vector+0xffe04284>
ffe044dd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI4_ERI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe044e0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe044e6:	66 02                         	mov.l	#0, r2
ffe044e8:	75 41 1d                      	mov.l	#29, r1
ffe044eb:	05 45 f3 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe044ef <.LVL8>:
    if (1 == ICU.GRPBL0.BIT.IS8)
ffe044ef:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe044f4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe044f8:	7c 85                         	btst	#8, r5
ffe044fa:	3a 96 fd                      	beq.w	ffe04290 <_Reset_Vector+0xffe04294>
ffe044fd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI4_TEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04500:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04506:	66 02                         	mov.l	#0, r2
ffe04508:	75 41 1c                      	mov.l	#28, r1
ffe0450b:	05 25 f3 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0450f <.LVL9>:
    if (1 == ICU.GRPBL0.BIT.IS11)
ffe0450f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04514:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04518:	7c b5                         	btst	#11, r5
ffe0451a:	3a 86 fd                      	beq.w	ffe042a0 <_Reset_Vector+0xffe042a4>
ffe0451d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_ERI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04520:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04526:	66 02                         	mov.l	#0, r2
ffe04528:	75 41 1f                      	mov.l	#31, r1
ffe0452b:	05 05 f3 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0452f <.LVL10>:
    if (1 == ICU.GRPBL0.BIT.IS10)
ffe0452f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04534:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04538:	7c a5                         	btst	#10, r5
ffe0453a:	3a 76 fd                      	beq.w	ffe042b0 <_Reset_Vector+0xffe042b4>
ffe0453d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI5_TEI5, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04540:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04546:	66 02                         	mov.l	#0, r2
ffe04548:	75 41 1e                      	mov.l	#30, r1
ffe0454b:	05 e5 f2 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0454f <.LVL11>:
    if (1 == ICU.GRPBL0.BIT.IS13)
ffe0454f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04554:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04558:	7c d5                         	btst	#13, r5
ffe0455a:	3a 66 fd                      	beq.w	ffe042c0 <_Reset_Vector+0xffe042c4>
ffe0455d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_ERI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04560:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04566:	66 02                         	mov.l	#0, r2
ffe04568:	75 41 21                      	mov.l	#33, r1
ffe0456b:	05 c5 f2 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0456f <.LVL12>:
    if (1 == ICU.GRPBL0.BIT.IS12)
ffe0456f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04574:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04578:	7c c5                         	btst	#12, r5
ffe0457a:	3a 56 fd                      	beq.w	ffe042d0 <_Reset_Vector+0xffe042d4>
ffe0457d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI6_TEI6, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04580:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04586:	66 02                         	mov.l	#0, r2
ffe04588:	75 41 20                      	mov.l	#32, r1
ffe0458b:	05 a5 f2 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0458f <.LVL13>:
    if (1 == ICU.GRPBL0.BIT.IS15)
ffe0458f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04594:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04598:	7c f5                         	btst	#15, r5
ffe0459a:	3a 46 fd                      	beq.w	ffe042e0 <_Reset_Vector+0xffe042e4>
ffe0459d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI7_ERI7, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe045a0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe045a6:	66 02                         	mov.l	#0, r2
ffe045a8:	75 41 23                      	mov.l	#35, r1
ffe045ab:	05 85 f2 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe045af <.LVL14>:
    if (1 == ICU.GRPBL0.BIT.IS14)
ffe045af:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe045b4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe045b8:	7c e5                         	btst	#14, r5
ffe045ba:	3a 36 fd                      	beq.w	ffe042f0 <_Reset_Vector+0xffe042f4>
ffe045bd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI7_TEI7, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe045c0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe045c6:	66 02                         	mov.l	#0, r2
ffe045c8:	75 41 22                      	mov.l	#34, r1
ffe045cb:	05 65 f2 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe045cf <.LVL15>:
    if (1 == ICU.GRPBL0.BIT.IS17)
ffe045cf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe045d4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe045d8:	7d 15                         	btst	#17, r5
ffe045da:	3a 26 fd                      	beq.w	ffe04300 <_Reset_Vector+0xffe04304>
ffe045dd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_ERI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe045e0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe045e6:	66 02                         	mov.l	#0, r2
ffe045e8:	75 41 25                      	mov.l	#37, r1
ffe045eb:	05 45 f2 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe045ef <.LVL16>:
    if (1 == ICU.GRPBL0.BIT.IS16)
ffe045ef:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe045f4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe045f8:	7d 05                         	btst	#16, r5
ffe045fa:	3a 16 fd                      	beq.w	ffe04310 <_Reset_Vector+0xffe04314>
ffe045fd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_TEI12, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04600:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04606:	66 02                         	mov.l	#0, r2
ffe04608:	75 41 24                      	mov.l	#36, r1
ffe0460b:	05 25 f2 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0460f <.LVL17>:
    if (1 == ICU.GRPBL0.BIT.IS18)
ffe0460f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04614:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04618:	7d 25                         	btst	#18, r5
ffe0461a:	3a 06 fd                      	beq.w	ffe04320 <_Reset_Vector+0xffe04324>
ffe0461d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04620:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04626:	66 02                         	mov.l	#0, r2
ffe04628:	75 41 26                      	mov.l	#38, r1
ffe0462b:	05 05 f2 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0462f <.LVL18>:
    if (1 == ICU.GRPBL0.BIT.IS19)
ffe0462f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04634:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04638:	7d 35                         	btst	#19, r5
ffe0463a:	3a f6 fc                      	beq.w	ffe04330 <_Reset_Vector+0xffe04334>
ffe0463d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04640:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04646:	66 02                         	mov.l	#0, r2
ffe04648:	75 41 27                      	mov.l	#39, r1
ffe0464b:	05 e5 f1 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0464f <.LVL19>:
    if (1 == ICU.GRPBL0.BIT.IS20)
ffe0464f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04654:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04658:	7d 45                         	btst	#20, r5
ffe0465a:	3a e6 fc                      	beq.w	ffe04340 <_Reset_Vector+0xffe04344>
ffe0465d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04660:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04666:	66 02                         	mov.l	#0, r2
ffe04668:	75 41 28                      	mov.l	#40, r1
ffe0466b:	05 c5 f1 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0466f <.LVL20>:
    if (1 == ICU.GRPBL0.BIT.IS21)
ffe0466f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04674:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04678:	7d 55                         	btst	#21, r5
ffe0467a:	3a d6 fc                      	beq.w	ffe04350 <_Reset_Vector+0xffe04354>
ffe0467d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_SCI12_SCIX3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04680:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04686:	66 02                         	mov.l	#0, r2
ffe04688:	75 41 29                      	mov.l	#41, r1
ffe0468b:	05 a5 f1 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0468f <.LVL21>:
    if (1 == ICU.GRPBL0.BIT.IS24)
ffe0468f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04694:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04698:	7d 85                         	btst	#24, r5
ffe0469a:	3a c6 fc                      	beq.w	ffe04360 <_Reset_Vector+0xffe04364>
ffe0469d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_QSPI_QSPSSLI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe046a0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe046a6:	66 02                         	mov.l	#0, r2
ffe046a8:	75 41 2a                      	mov.l	#42, r1
ffe046ab:	05 85 f1 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe046af <.LVL22>:
    if (1 == ICU.GRPBL0.BIT.IS26)
ffe046af:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe046b4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe046b8:	7d a5                         	btst	#26, r5
ffe046ba:	3a b6 fc                      	beq.w	ffe04370 <_Reset_Vector+0xffe04374>
ffe046bd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_FERRI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe046c0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe046c6:	66 02                         	mov.l	#0, r2
ffe046c8:	75 41 2b                      	mov.l	#43, r1
ffe046cb:	05 65 f1 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe046cf <.LVL23>:
    if (1 == ICU.GRPBL0.BIT.IS27)
ffe046cf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe046d4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe046d8:	7d b5                         	btst	#27, r5
ffe046da:	3a a6 fc                      	beq.w	ffe04380 <_Reset_Vector+0xffe04384>
ffe046dd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_MENDI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe046e0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe046e6:	66 02                         	mov.l	#0, r2
ffe046e8:	75 41 2c                      	mov.l	#44, r1
ffe046eb:	05 45 f1 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe046ef <.LVL24>:
    if (1 == ICU.GRPBL0.BIT.IS28)
ffe046ef:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe046f4:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe046f8:	7d c5                         	btst	#28, r5
ffe046fa:	3a 96 fc                      	beq.w	ffe04390 <_Reset_Vector+0xffe04394>
ffe046fd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_CAC_OVFI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04700:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04706:	66 02                         	mov.l	#0, r2
ffe04708:	75 41 2d                      	mov.l	#45, r1
ffe0470b:	05 25 f1 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0470f <.LVL25>:
    if (1 == ICU.GRPBL0.BIT.IS29)
ffe0470f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04714:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04718:	7d d5                         	btst	#29, r5
ffe0471a:	3a 86 fc                      	beq.w	ffe043a0 <_Reset_Vector+0xffe043a4>
ffe0471d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_DOC_DOPCI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04720:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04726:	66 02                         	mov.l	#0, r2
ffe04728:	75 41 2e                      	mov.l	#46, r1
ffe0472b:	05 05 f1 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0472f <.LVL26>:
    if (1 == ICU.GRPBL0.BIT.IS31)
ffe0472f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04734:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04738:	61 05                         	cmp	#0, r5
ffe0473a:	29 05                         	blt.b	ffe0473f <_Reset_Vector+0xffe04743>
ffe0473c:	38 74 fc                      	bra.w	ffe043b0 <_Reset_Vector+0xffe043b4>
ffe0473f:	03                            	nop
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_PDC_PCERI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04740:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04746:	66 02                         	mov.l	#0, r2
ffe04748:	75 41 30                      	mov.l	#48, r1
ffe0474b:	05 e5 f0 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0474f <.LVL27>:
    if (1 == ICU.GRPBL0.BIT.IS30)
ffe0474f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04754:	ee 55 8c 01                   	mov.l	1584[r5], r5
ffe04758:	7d e5                         	btst	#30, r5
ffe0475a:	3a 64 fc                      	beq.w	ffe043be <_Reset_Vector+0xffe043c2>
ffe0475d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL0_PDC_PCFEI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04760:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04766:	66 02                         	mov.l	#0, r2
ffe04768:	75 41 2f                      	mov.l	#47, r1
ffe0476b:	05 c5 f0 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0476f <.LVL28>:
} /* End of function group_bl0_handler_isr() */
ffe0476f:	38 4f fc                      	bra.w	ffe043be <_Reset_Vector+0xffe043c2>

ffe04772 <.LFE10>:
ffe04772:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe04778 <__group_bl1_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_bl1_handler_isr, VECT(ICU,GROUPBL1))
ffe04778:	7e a1                         	push.l	r1
ffe0477a:	fd 6a 01                      	mvfc	psw, r1
ffe0477d:	69 81                         	shlr	#24, r1
ffe0477f:	64 f1                         	and	#15, r1
ffe04781:	61 91                         	cmp	#9, r1
ffe04783:	22 05                         	bc.b	ffe04788 <_Reset_Vector+0xffe0478c>
ffe04785:	75 70 09                      	mvtipl	#9
ffe04788:	7f a8                         	setpsw	i
ffe0478a:	7e b1                         	pop	r1
ffe0478c:	2e 02                         	bra.b	ffe0478e <_Reset_Vector+0xffe04792>

ffe0478e <_group_bl1_handler_isr>:
*                NOTE: The interrupt request flag must be cleared in the peripheral.
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_bl1_handler_isr (void)
{
ffe0478e:	6e ef                         	pushm	r14-r15
ffe04790:	6e 15                         	pushm	r1-r5
ffe04792:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe04795:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe04798:	7e a1                         	push.l	r1
ffe0479a:	7e a2                         	push.l	r2
ffe0479c:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe0479f:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe047a2:	7e a1                         	push.l	r1
ffe047a4:	7e a2                         	push.l	r2
ffe047a6:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe047a9:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe047ac:	7e a1                         	push.l	r1
ffe047ae:	7e a2                         	push.l	r2
    /* BL1 IS3 */
    if (1 == ICU.GRPBL1.BIT.IS3)
ffe047b0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe047b5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe047b9:	7c 35                         	btst	#3, r5
ffe047bb:	3b 97 01                      	bne.w	ffe04952 <_Reset_Vector+0xffe04956>
        /* BSP_INT_SRC_BL1_SDHI_CDETI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_CDETI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS4 */
    if (1 == ICU.GRPBL1.BIT.IS4)
ffe047be:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe047c3:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe047c7:	7c 45                         	btst	#4, r5
ffe047c9:	3b a7 01                      	bne.w	ffe04970 <_Reset_Vector+0xffe04974>
ffe047cc:	76 10 01 00                   	nop	; mul	#1, r0
        /* BSP_INT_SRC_BL1_SDHI_CACI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_CACI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS5 */
    if (1 == ICU.GRPBL1.BIT.IS5)
ffe047d0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe047d5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe047d9:	7c 55                         	btst	#5, r5
ffe047db:	3b b5 01                      	bne.w	ffe04990 <_Reset_Vector+0xffe04994>
ffe047de:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SDHI_SDACI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_SDACI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS6 */
    if (1 == ICU.GRPBL1.BIT.IS6)
ffe047e0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe047e5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe047e9:	7c 65                         	btst	#6, r5
ffe047eb:	3b c5 01                      	bne.w	ffe049b0 <_Reset_Vector+0xffe049b4>
ffe047ee:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_MMCIF_CDETIO */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_CDETIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS7 */
    if (1 == ICU.GRPBL1.BIT.IS7)
ffe047f0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe047f5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe047f9:	7c 75                         	btst	#7, r5
ffe047fb:	3b d5 01                      	bne.w	ffe049d0 <_Reset_Vector+0xffe049d4>
ffe047fe:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_MMCIF_ERRIO */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_ERRIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS8 */
    if (1 == ICU.GRPBL1.BIT.IS8)
ffe04800:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04805:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04809:	7c 85                         	btst	#8, r5
ffe0480b:	3b e5 01                      	bne.w	ffe049f0 <_Reset_Vector+0xffe049f4>
ffe0480e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_MMCIF_ACCIO */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_ACCIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS9 */
    if (1 == ICU.GRPBL1.BIT.IS9)
ffe04810:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04815:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04819:	7c 95                         	btst	#9, r5
ffe0481b:	3b f5 01                      	bne.w	ffe04a10 <_Reset_Vector+0xffe04a14>
ffe0481e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS10 */
    if (1 == ICU.GRPBL1.BIT.IS10)
ffe04820:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04825:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04829:	7c a5                         	btst	#10, r5
ffe0482b:	3b 05 02                      	bne.w	ffe04a30 <_Reset_Vector+0xffe04a34>
ffe0482e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS11 */
    if (1 == ICU.GRPBL1.BIT.IS11)
ffe04830:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04835:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04839:	7c b5                         	btst	#11, r5
ffe0483b:	3b 15 02                      	bne.w	ffe04a50 <_Reset_Vector+0xffe04a54>
ffe0483e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI3 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS12 */
    if (1 == ICU.GRPBL1.BIT.IS12)
ffe04840:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04845:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04849:	7c c5                         	btst	#12, r5
ffe0484b:	3b 25 02                      	bne.w	ffe04a70 <_Reset_Vector+0xffe04a74>
ffe0484e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_POE3_OEI4 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS14 */
    if (1 == ICU.GRPBL1.BIT.IS14)
ffe04850:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04855:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04859:	7c e5                         	btst	#14, r5
ffe0485b:	3b 35 02                      	bne.w	ffe04a90 <_Reset_Vector+0xffe04a94>
ffe0485e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC0_EEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_EEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS13 */
    if (1 == ICU.GRPBL1.BIT.IS13)
ffe04860:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04865:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04869:	7c d5                         	btst	#13, r5
ffe0486b:	3b 45 02                      	bne.w	ffe04ab0 <_Reset_Vector+0xffe04ab4>
ffe0486e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC0_TEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS16 */
    if (1 == ICU.GRPBL1.BIT.IS16)
ffe04870:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04875:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04879:	7d 05                         	btst	#16, r5
ffe0487b:	3b 55 02                      	bne.w	ffe04ad0 <_Reset_Vector+0xffe04ad4>
ffe0487e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC2_EEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC2_EEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS15 */
    if (1 == ICU.GRPBL1.BIT.IS15)
ffe04880:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04885:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04889:	7c f5                         	btst	#15, r5
ffe0488b:	3b 65 02                      	bne.w	ffe04af0 <_Reset_Vector+0xffe04af4>
ffe0488e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC2_TEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC2_TEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS20 */
    if (1 == ICU.GRPBL1.BIT.IS20)
ffe04890:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04895:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04899:	7d 45                         	btst	#20, r5
ffe0489b:	3b 75 02                      	bne.w	ffe04b10 <_Reset_Vector+0xffe04b14>
ffe0489e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD0_S12CMPAI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS21 */
    if (1 == ICU.GRPBL1.BIT.IS21)
ffe048a0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe048a5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe048a9:	7d 55                         	btst	#21, r5
ffe048ab:	3b 85 02                      	bne.w	ffe04b30 <_Reset_Vector+0xffe04b34>
ffe048ae:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD0_S12CMPBI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS22 */
    if (1 == ICU.GRPBL1.BIT.IS22)
ffe048b0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe048b5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe048b9:	7d 65                         	btst	#22, r5
ffe048bb:	3b 95 02                      	bne.w	ffe04b50 <_Reset_Vector+0xffe04b54>
ffe048be:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD1_S12CMPAI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPAI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS23 */
    if (1 == ICU.GRPBL1.BIT.IS23)
ffe048c0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe048c5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe048c9:	7d 75                         	btst	#23, r5
ffe048cb:	3b a5 02                      	bne.w	ffe04b70 <_Reset_Vector+0xffe04b74>
ffe048ce:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_S12AD1_S12CMPBI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPBI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS25 */
    if (1 == ICU.GRPBL1.BIT.IS25)
ffe048d0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe048d5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe048d9:	7d 95                         	btst	#25, r5
ffe048db:	3b b5 02                      	bne.w	ffe04b90 <_Reset_Vector+0xffe04b94>
ffe048de:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SCI8_ERI8 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI8_ERI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS24 */
    if (1 == ICU.GRPBL1.BIT.IS24)
ffe048e0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe048e5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe048e9:	7d 85                         	btst	#24, r5
ffe048eb:	3b c5 02                      	bne.w	ffe04bb0 <_Reset_Vector+0xffe04bb4>
ffe048ee:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SCI8_TEI8 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI8_TEI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS27 */
    if (1 == ICU.GRPBL1.BIT.IS27)
ffe048f0:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe048f5:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe048f9:	7d b5                         	btst	#27, r5
ffe048fb:	3b d5 02                      	bne.w	ffe04bd0 <_Reset_Vector+0xffe04bd4>
ffe048fe:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SCI9_ERI9 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI9_ERI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS26 */
    if (1 == ICU.GRPBL1.BIT.IS26)
ffe04900:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04905:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04909:	7d a5                         	btst	#26, r5
ffe0490b:	3b e5 02                      	bne.w	ffe04bf0 <_Reset_Vector+0xffe04bf4>
ffe0490e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_SCI9_TEI9 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI9_TEI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS29 */
    if (1 == ICU.GRPBL1.BIT.IS29)
ffe04910:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04915:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04919:	7d d5                         	btst	#29, r5
ffe0491b:	3b f5 02                      	bne.w	ffe04c10 <_Reset_Vector+0xffe04c14>
ffe0491e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_BL1_RIIC1_EEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC1_EEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BL1 IS28 */
    if (1 == ICU.GRPBL1.BIT.IS28)
ffe04920:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04925:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04929:	7d c5                         	btst	#28, r5
ffe0492b:	3b 05 03                      	bne.w	ffe04c30 <_Reset_Vector+0xffe04c34>
    {
        /* BSP_INT_SRC_BL1_RIIC1_TEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_bl1_handler_isr() */
ffe0492e:	7e b2                         	pop	r2
ffe04930:	7e b1                         	pop	r1
ffe04932:	fd 17 81                      	mvtachi	r1, a1
ffe04935:	fd 17 b2                      	mvtacgu	r2, a1
ffe04938:	7e b2                         	pop	r2
ffe0493a:	7e b1                         	pop	r1
ffe0493c:	fd 17 31                      	mvtacgu	r1, a0
ffe0493f:	fd 17 92                      	mvtaclo	r2, a1
ffe04942:	7e b2                         	pop	r2
ffe04944:	7e b1                         	pop	r1
ffe04946:	fd 17 11                      	mvtaclo	r1, a0
ffe04949:	fd 17 02                      	mvtachi	r2, a0
ffe0494c:	6f 15                         	popm	r1-r5
ffe0494e:	6f ef                         	popm	r14-r15
ffe04950:	7f 95                         	rte
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_CDETI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04952:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04958:	66 02                         	mov.l	#0, r2
ffe0495a:	75 41 32                      	mov.l	#50, r1
ffe0495d:	05 d3 ee ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04961 <.LVL29>:
    if (1 == ICU.GRPBL1.BIT.IS4)
ffe04961:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04966:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe0496a:	7c 45                         	btst	#4, r5
ffe0496c:	3a 64 fe                      	beq.w	ffe047d0 <_Reset_Vector+0xffe047d4>
ffe0496f:	03                            	nop
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_CACI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04970:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04976:	66 02                         	mov.l	#0, r2
ffe04978:	75 41 33                      	mov.l	#51, r1
ffe0497b:	05 b5 ee ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0497f <.LVL30>:
    if (1 == ICU.GRPBL1.BIT.IS5)
ffe0497f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04984:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04988:	7c 55                         	btst	#5, r5
ffe0498a:	3a 56 fe                      	beq.w	ffe047e0 <_Reset_Vector+0xffe047e4>
ffe0498d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SDHI_SDACI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04990:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04996:	66 02                         	mov.l	#0, r2
ffe04998:	75 41 34                      	mov.l	#52, r1
ffe0499b:	05 95 ee ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe0499f <.LVL31>:
    if (1 == ICU.GRPBL1.BIT.IS6)
ffe0499f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe049a4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe049a8:	7c 65                         	btst	#6, r5
ffe049aa:	3a 46 fe                      	beq.w	ffe047f0 <_Reset_Vector+0xffe047f4>
ffe049ad:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_CDETIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe049b0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe049b6:	66 02                         	mov.l	#0, r2
ffe049b8:	75 41 35                      	mov.l	#53, r1
ffe049bb:	05 75 ee ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe049bf <.LVL32>:
    if (1 == ICU.GRPBL1.BIT.IS7)
ffe049bf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe049c4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe049c8:	7c 75                         	btst	#7, r5
ffe049ca:	3a 36 fe                      	beq.w	ffe04800 <_Reset_Vector+0xffe04804>
ffe049cd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_ERRIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe049d0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe049d6:	66 02                         	mov.l	#0, r2
ffe049d8:	75 41 36                      	mov.l	#54, r1
ffe049db:	05 55 ee ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe049df <.LVL33>:
    if (1 == ICU.GRPBL1.BIT.IS8)
ffe049df:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe049e4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe049e8:	7c 85                         	btst	#8, r5
ffe049ea:	3a 26 fe                      	beq.w	ffe04810 <_Reset_Vector+0xffe04814>
ffe049ed:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_MMCIF_ACCIO, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe049f0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe049f6:	66 02                         	mov.l	#0, r2
ffe049f8:	75 41 37                      	mov.l	#55, r1
ffe049fb:	05 35 ee ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe049ff <.LVL34>:
    if (1 == ICU.GRPBL1.BIT.IS9)
ffe049ff:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04a04:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04a08:	7c 95                         	btst	#9, r5
ffe04a0a:	3a 16 fe                      	beq.w	ffe04820 <_Reset_Vector+0xffe04824>
ffe04a0d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04a10:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04a16:	66 02                         	mov.l	#0, r2
ffe04a18:	75 41 38                      	mov.l	#56, r1
ffe04a1b:	05 15 ee ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04a1f <.LVL35>:
    if (1 == ICU.GRPBL1.BIT.IS10)
ffe04a1f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04a24:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04a28:	7c a5                         	btst	#10, r5
ffe04a2a:	3a 06 fe                      	beq.w	ffe04830 <_Reset_Vector+0xffe04834>
ffe04a2d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04a30:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04a36:	66 02                         	mov.l	#0, r2
ffe04a38:	75 41 39                      	mov.l	#57, r1
ffe04a3b:	05 f5 ed ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04a3f <.LVL36>:
    if (1 == ICU.GRPBL1.BIT.IS11)
ffe04a3f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04a44:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04a48:	7c b5                         	btst	#11, r5
ffe04a4a:	3a f6 fd                      	beq.w	ffe04840 <_Reset_Vector+0xffe04844>
ffe04a4d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI3, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04a50:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04a56:	66 02                         	mov.l	#0, r2
ffe04a58:	75 41 3a                      	mov.l	#58, r1
ffe04a5b:	05 d5 ed ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04a5f <.LVL37>:
    if (1 == ICU.GRPBL1.BIT.IS12)
ffe04a5f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04a64:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04a68:	7c c5                         	btst	#12, r5
ffe04a6a:	3a e6 fd                      	beq.w	ffe04850 <_Reset_Vector+0xffe04854>
ffe04a6d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_POE3_OEI4, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04a70:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04a76:	66 02                         	mov.l	#0, r2
ffe04a78:	75 41 3b                      	mov.l	#59, r1
ffe04a7b:	05 b5 ed ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04a7f <.LVL38>:
    if (1 == ICU.GRPBL1.BIT.IS14)
ffe04a7f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04a84:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04a88:	7c e5                         	btst	#14, r5
ffe04a8a:	3a d6 fd                      	beq.w	ffe04860 <_Reset_Vector+0xffe04864>
ffe04a8d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_EEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04a90:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04a96:	66 02                         	mov.l	#0, r2
ffe04a98:	75 41 3d                      	mov.l	#61, r1
ffe04a9b:	05 95 ed ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04a9f <.LVL39>:
    if (1 == ICU.GRPBL1.BIT.IS13)
ffe04a9f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04aa4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04aa8:	7c d5                         	btst	#13, r5
ffe04aaa:	3a c6 fd                      	beq.w	ffe04870 <_Reset_Vector+0xffe04874>
ffe04aad:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC0_TEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04ab0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04ab6:	66 02                         	mov.l	#0, r2
ffe04ab8:	75 41 3c                      	mov.l	#60, r1
ffe04abb:	05 75 ed ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04abf <.LVL40>:
    if (1 == ICU.GRPBL1.BIT.IS16)
ffe04abf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04ac4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04ac8:	7d 05                         	btst	#16, r5
ffe04aca:	3a b6 fd                      	beq.w	ffe04880 <_Reset_Vector+0xffe04884>
ffe04acd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC2_EEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04ad0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04ad6:	66 02                         	mov.l	#0, r2
ffe04ad8:	75 41 3f                      	mov.l	#63, r1
ffe04adb:	05 55 ed ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04adf <.LVL41>:
    if (1 == ICU.GRPBL1.BIT.IS15)
ffe04adf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04ae4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04ae8:	7c f5                         	btst	#15, r5
ffe04aea:	3a a6 fd                      	beq.w	ffe04890 <_Reset_Vector+0xffe04894>
ffe04aed:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC2_TEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04af0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04af6:	66 02                         	mov.l	#0, r2
ffe04af8:	75 41 3e                      	mov.l	#62, r1
ffe04afb:	05 35 ed ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04aff <.LVL42>:
    if (1 == ICU.GRPBL1.BIT.IS20)
ffe04aff:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04b04:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04b08:	7d 45                         	btst	#20, r5
ffe04b0a:	3a 96 fd                      	beq.w	ffe048a0 <_Reset_Vector+0xffe048a4>
ffe04b0d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPAI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04b10:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04b16:	66 02                         	mov.l	#0, r2
ffe04b18:	75 41 40                      	mov.l	#64, r1
ffe04b1b:	05 15 ed ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04b1f <.LVL43>:
    if (1 == ICU.GRPBL1.BIT.IS21)
ffe04b1f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04b24:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04b28:	7d 55                         	btst	#21, r5
ffe04b2a:	3a 86 fd                      	beq.w	ffe048b0 <_Reset_Vector+0xffe048b4>
ffe04b2d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD0_S12CMPBI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04b30:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04b36:	66 02                         	mov.l	#0, r2
ffe04b38:	75 41 41                      	mov.l	#65, r1
ffe04b3b:	05 f5 ec ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04b3f <.LVL44>:
    if (1 == ICU.GRPBL1.BIT.IS22)
ffe04b3f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04b44:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04b48:	7d 65                         	btst	#22, r5
ffe04b4a:	3a 76 fd                      	beq.w	ffe048c0 <_Reset_Vector+0xffe048c4>
ffe04b4d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPAI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04b50:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04b56:	66 02                         	mov.l	#0, r2
ffe04b58:	75 41 42                      	mov.l	#66, r1
ffe04b5b:	05 d5 ec ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04b5f <.LVL45>:
    if (1 == ICU.GRPBL1.BIT.IS23)
ffe04b5f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04b64:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04b68:	7d 75                         	btst	#23, r5
ffe04b6a:	3a 66 fd                      	beq.w	ffe048d0 <_Reset_Vector+0xffe048d4>
ffe04b6d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_S12AD1_S12CMPBI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04b70:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04b76:	66 02                         	mov.l	#0, r2
ffe04b78:	75 41 43                      	mov.l	#67, r1
ffe04b7b:	05 b5 ec ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04b7f <.LVL46>:
    if (1 == ICU.GRPBL1.BIT.IS25)
ffe04b7f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04b84:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04b88:	7d 95                         	btst	#25, r5
ffe04b8a:	3a 56 fd                      	beq.w	ffe048e0 <_Reset_Vector+0xffe048e4>
ffe04b8d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI8_ERI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04b90:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04b96:	66 02                         	mov.l	#0, r2
ffe04b98:	75 41 45                      	mov.l	#69, r1
ffe04b9b:	05 95 ec ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04b9f <.LVL47>:
    if (1 == ICU.GRPBL1.BIT.IS24)
ffe04b9f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04ba4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04ba8:	7d 85                         	btst	#24, r5
ffe04baa:	3a 46 fd                      	beq.w	ffe048f0 <_Reset_Vector+0xffe048f4>
ffe04bad:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI8_TEI8, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04bb0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04bb6:	66 02                         	mov.l	#0, r2
ffe04bb8:	75 41 44                      	mov.l	#68, r1
ffe04bbb:	05 75 ec ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04bbf <.LVL48>:
    if (1 == ICU.GRPBL1.BIT.IS27)
ffe04bbf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04bc4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04bc8:	7d b5                         	btst	#27, r5
ffe04bca:	3a 36 fd                      	beq.w	ffe04900 <_Reset_Vector+0xffe04904>
ffe04bcd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI9_ERI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04bd0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04bd6:	66 02                         	mov.l	#0, r2
ffe04bd8:	75 41 47                      	mov.l	#71, r1
ffe04bdb:	05 55 ec ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04bdf <.LVL49>:
    if (1 == ICU.GRPBL1.BIT.IS26)
ffe04bdf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04be4:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04be8:	7d a5                         	btst	#26, r5
ffe04bea:	3a 26 fd                      	beq.w	ffe04910 <_Reset_Vector+0xffe04914>
ffe04bed:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_SCI9_TEI9, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04bf0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04bf6:	66 02                         	mov.l	#0, r2
ffe04bf8:	75 41 46                      	mov.l	#70, r1
ffe04bfb:	05 35 ec ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04bff <.LVL50>:
    if (1 == ICU.GRPBL1.BIT.IS29)
ffe04bff:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04c04:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04c08:	7d d5                         	btst	#29, r5
ffe04c0a:	3a 16 fd                      	beq.w	ffe04920 <_Reset_Vector+0xffe04924>
ffe04c0d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC1_EEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04c10:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04c16:	66 02                         	mov.l	#0, r2
ffe04c18:	75 41 49                      	mov.l	#73, r1
ffe04c1b:	05 15 ec ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04c1f <.LVL51>:
    if (1 == ICU.GRPBL1.BIT.IS28)
ffe04c1f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04c24:	ee 55 8d 01                   	mov.l	1588[r5], r5
ffe04c28:	7d c5                         	btst	#28, r5
ffe04c2a:	3a 04 fd                      	beq.w	ffe0492e <_Reset_Vector+0xffe04932>
ffe04c2d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BL1_RIIC1_TEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04c30:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04c36:	66 02                         	mov.l	#0, r2
ffe04c38:	75 41 48                      	mov.l	#72, r1
ffe04c3b:	05 f5 eb ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04c3f <.LVL52>:
} /* End of function group_bl1_handler_isr() */
ffe04c3f:	38 ef fc                      	bra.w	ffe0492e <_Reset_Vector+0xffe04932>

ffe04c42 <.LFE11>:
ffe04c42:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe04c48 <__group_bl2_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_bl2_handler_isr, VECT(ICU,GROUPBL2))
ffe04c48:	7e a1                         	push.l	r1
ffe04c4a:	fd 6a 01                      	mvfc	psw, r1
ffe04c4d:	69 81                         	shlr	#24, r1
ffe04c4f:	64 f1                         	and	#15, r1
ffe04c51:	61 91                         	cmp	#9, r1
ffe04c53:	22 05                         	bc.b	ffe04c58 <_Reset_Vector+0xffe04c5c>
ffe04c55:	75 70 09                      	mvtipl	#9
ffe04c58:	7f a8                         	setpsw	i
ffe04c5a:	7e b1                         	pop	r1
ffe04c5c:	2e 02                         	bra.b	ffe04c5e <_Reset_Vector+0xffe04c62>

ffe04c5e <_group_bl2_handler_isr>:
*                NOTE: The interrupt request flag must be cleared in the peripheral.
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_bl2_handler_isr (void)
{
ffe04c5e:	6e ef                         	pushm	r14-r15
ffe04c60:	6e 15                         	pushm	r1-r5
ffe04c62:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe04c65:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe04c68:	7e a1                         	push.l	r1
ffe04c6a:	7e a2                         	push.l	r2
ffe04c6c:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe04c6f:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe04c72:	7e a1                         	push.l	r1
ffe04c74:	7e a2                         	push.l	r2
ffe04c76:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe04c79:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe04c7c:	7e a1                         	push.l	r1
ffe04c7e:	7e a2                         	push.l	r2
    /* BL2 IS0 */
    if (1 == ICU.GRPBL2.BIT.IS0)
ffe04c80:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04c85:	ee 55 8e 01                   	mov.l	1592[r5], r5
ffe04c89:	7c 05                         	btst	#0, r5
ffe04c8b:	21 26                         	bne.b	ffe04cb1 <_Reset_Vector+0xffe04cb5>
    {
        /* BSP_INT_SRC_BL2_SDSI_SDIOI */
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_SDSI_SDIOI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_bl2_handler_isr() */
ffe04c8d:	7e b2                         	pop	r2
ffe04c8f:	7e b1                         	pop	r1
ffe04c91:	fd 17 81                      	mvtachi	r1, a1
ffe04c94:	fd 17 b2                      	mvtacgu	r2, a1
ffe04c97:	7e b2                         	pop	r2
ffe04c99:	7e b1                         	pop	r1
ffe04c9b:	fd 17 31                      	mvtacgu	r1, a0
ffe04c9e:	fd 17 92                      	mvtaclo	r2, a1
ffe04ca1:	7e b2                         	pop	r2
ffe04ca3:	7e b1                         	pop	r1
ffe04ca5:	fd 17 11                      	mvtaclo	r1, a0
ffe04ca8:	fd 17 02                      	mvtachi	r2, a0
ffe04cab:	6f 15                         	popm	r1-r5
ffe04cad:	6f ef                         	popm	r14-r15
ffe04caf:	7f 95                         	rte
        R_BSP_InterruptControl(BSP_INT_SRC_BL2_SDSI_SDIOI, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04cb1:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04cb7:	66 02                         	mov.l	#0, r2
ffe04cb9:	75 41 4b                      	mov.l	#75, r1
ffe04cbc:	05 74 eb ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04cc0 <.LVL53>:
} /* End of function group_bl2_handler_isr() */
ffe04cc0:	2e cd                         	bra.b	ffe04c8d <_Reset_Vector+0xffe04c91>

ffe04cc2 <.LFE12>:
ffe04cc2:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe04cc8 <__group_al0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_al0_handler_isr, VECT(ICU,GROUPAL0))
ffe04cc8:	7e a1                         	push.l	r1
ffe04cca:	fd 6a 01                      	mvfc	psw, r1
ffe04ccd:	69 81                         	shlr	#24, r1
ffe04ccf:	64 f1                         	and	#15, r1
ffe04cd1:	61 91                         	cmp	#9, r1
ffe04cd3:	22 05                         	bc.b	ffe04cd8 <_Reset_Vector+0xffe04cdc>
ffe04cd5:	75 70 09                      	mvtipl	#9
ffe04cd8:	7f a8                         	setpsw	i
ffe04cda:	7e b1                         	pop	r1
ffe04cdc:	2e 02                         	bra.b	ffe04cde <_Reset_Vector+0xffe04ce2>

ffe04cde <_group_al0_handler_isr>:
*                NOTE: The interrupt request flag must be cleared in the peripheral.
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_al0_handler_isr (void)
{
ffe04cde:	6e ef                         	pushm	r14-r15
ffe04ce0:	6e 15                         	pushm	r1-r5
ffe04ce2:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe04ce5:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe04ce8:	7e a1                         	push.l	r1
ffe04cea:	7e a2                         	push.l	r2
ffe04cec:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe04cef:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe04cf2:	7e a1                         	push.l	r1
ffe04cf4:	7e a2                         	push.l	r2
ffe04cf6:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe04cf9:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe04cfc:	7e a1                         	push.l	r1
ffe04cfe:	7e a2                         	push.l	r2
    /* AL0 IS9 */
    if (1 == ICU.GRPAL0.BIT.IS9)
ffe04d00:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d05:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d09:	7c 95                         	btst	#9, r5
ffe04d0b:	3b b7 00                      	bne.w	ffe04dc2 <_Reset_Vector+0xffe04dc6>
        /* BSP_INT_SRC_AL0_SCI10_ERI10 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI10_ERI10, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS8 */
    if (1 == ICU.GRPAL0.BIT.IS8)
ffe04d0e:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d13:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d17:	7c 85                         	btst	#8, r5
ffe04d19:	3b c7 00                      	bne.w	ffe04de0 <_Reset_Vector+0xffe04de4>
ffe04d1c:	76 10 01 00                   	nop	; mul	#1, r0
        /* BSP_INT_SRC_AL0_SCI10_TEI10 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI10_TEI10, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS13 */
    if (1 == ICU.GRPAL0.BIT.IS13)
ffe04d20:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d25:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d29:	7c d5                         	btst	#13, r5
ffe04d2b:	3b d5 00                      	bne.w	ffe04e00 <_Reset_Vector+0xffe04e04>
ffe04d2e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI11_ERI11 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_ERI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS12 */
    if (1 == ICU.GRPAL0.BIT.IS12)
ffe04d30:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d35:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d39:	7c c5                         	btst	#12, r5
ffe04d3b:	3b e5 00                      	bne.w	ffe04e20 <_Reset_Vector+0xffe04e24>
ffe04d3e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_SCI11_TEI11 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_TEI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS17 */
    if (1 == ICU.GRPAL0.BIT.IS17)
ffe04d40:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d45:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d49:	7d 15                         	btst	#17, r5
ffe04d4b:	3b f5 00                      	bne.w	ffe04e40 <_Reset_Vector+0xffe04e44>
ffe04d4e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI0_SPEI0 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS16 */
    if (1 == ICU.GRPAL0.BIT.IS16)
ffe04d50:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d55:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d59:	7d 05                         	btst	#16, r5
ffe04d5b:	3b 05 01                      	bne.w	ffe04e60 <_Reset_Vector+0xffe04e64>
ffe04d5e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI0_SPII0 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPII0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS19 */
    if (1 == ICU.GRPAL0.BIT.IS19)
ffe04d60:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d65:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d69:	7d 35                         	btst	#19, r5
ffe04d6b:	3b 15 01                      	bne.w	ffe04e80 <_Reset_Vector+0xffe04e84>
ffe04d6e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI1_SPEI1 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI1_SPEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS18 */
    if (1 == ICU.GRPAL0.BIT.IS18)
ffe04d70:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d75:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d79:	7d 25                         	btst	#18, r5
ffe04d7b:	3b 25 01                      	bne.w	ffe04ea0 <_Reset_Vector+0xffe04ea4>
ffe04d7e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI1_SPII1 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI1_SPII1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS21 */
    if (1 == ICU.GRPAL0.BIT.IS21)
ffe04d80:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d85:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d89:	7d 55                         	btst	#21, r5
ffe04d8b:	3b 35 01                      	bne.w	ffe04ec0 <_Reset_Vector+0xffe04ec4>
ffe04d8e:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL0_RSPI2_SPEI2 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI2_SPEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL0 IS20 */
    if (1 == ICU.GRPAL0.BIT.IS20)
ffe04d90:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04d95:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04d99:	7d 45                         	btst	#20, r5
ffe04d9b:	3b 45 01                      	bne.w	ffe04ee0 <_Reset_Vector+0xffe04ee4>
    {
        /* BSP_INT_SRC_AL0_RSPI2_SPII2 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI2_SPII2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_al0_handler_isr() */
ffe04d9e:	7e b2                         	pop	r2
ffe04da0:	7e b1                         	pop	r1
ffe04da2:	fd 17 81                      	mvtachi	r1, a1
ffe04da5:	fd 17 b2                      	mvtacgu	r2, a1
ffe04da8:	7e b2                         	pop	r2
ffe04daa:	7e b1                         	pop	r1
ffe04dac:	fd 17 31                      	mvtacgu	r1, a0
ffe04daf:	fd 17 92                      	mvtaclo	r2, a1
ffe04db2:	7e b2                         	pop	r2
ffe04db4:	7e b1                         	pop	r1
ffe04db6:	fd 17 11                      	mvtaclo	r1, a0
ffe04db9:	fd 17 02                      	mvtachi	r2, a0
ffe04dbc:	6f 15                         	popm	r1-r5
ffe04dbe:	6f ef                         	popm	r14-r15
ffe04dc0:	7f 95                         	rte
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI10_ERI10, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04dc2:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04dc8:	66 02                         	mov.l	#0, r2
ffe04dca:	75 41 4e                      	mov.l	#78, r1
ffe04dcd:	05 63 ea ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04dd1 <.LVL54>:
    if (1 == ICU.GRPAL0.BIT.IS8)
ffe04dd1:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04dd6:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04dda:	7c 85                         	btst	#8, r5
ffe04ddc:	3a 44 ff                      	beq.w	ffe04d20 <_Reset_Vector+0xffe04d24>
ffe04ddf:	03                            	nop
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI10_TEI10, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04de0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04de6:	66 02                         	mov.l	#0, r2
ffe04de8:	75 41 4d                      	mov.l	#77, r1
ffe04deb:	05 45 ea ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04def <.LVL55>:
    if (1 == ICU.GRPAL0.BIT.IS13)
ffe04def:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04df4:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04df8:	7c d5                         	btst	#13, r5
ffe04dfa:	3a 36 ff                      	beq.w	ffe04d30 <_Reset_Vector+0xffe04d34>
ffe04dfd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_ERI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04e00:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04e06:	66 02                         	mov.l	#0, r2
ffe04e08:	75 41 50                      	mov.l	#80, r1
ffe04e0b:	05 25 ea ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04e0f <.LVL56>:
    if (1 == ICU.GRPAL0.BIT.IS12)
ffe04e0f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04e14:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04e18:	7c c5                         	btst	#12, r5
ffe04e1a:	3a 26 ff                      	beq.w	ffe04d40 <_Reset_Vector+0xffe04d44>
ffe04e1d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_SCI11_TEI11, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04e20:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04e26:	66 02                         	mov.l	#0, r2
ffe04e28:	75 41 4f                      	mov.l	#79, r1
ffe04e2b:	05 05 ea ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04e2f <.LVL57>:
    if (1 == ICU.GRPAL0.BIT.IS17)
ffe04e2f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04e34:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04e38:	7d 15                         	btst	#17, r5
ffe04e3a:	3a 16 ff                      	beq.w	ffe04d50 <_Reset_Vector+0xffe04d54>
ffe04e3d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPEI0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04e40:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04e46:	66 02                         	mov.l	#0, r2
ffe04e48:	75 41 52                      	mov.l	#82, r1
ffe04e4b:	05 e5 e9 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04e4f <.LVL58>:
    if (1 == ICU.GRPAL0.BIT.IS16)
ffe04e4f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04e54:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04e58:	7d 05                         	btst	#16, r5
ffe04e5a:	3a 06 ff                      	beq.w	ffe04d60 <_Reset_Vector+0xffe04d64>
ffe04e5d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI0_SPII0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04e60:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04e66:	66 02                         	mov.l	#0, r2
ffe04e68:	75 41 51                      	mov.l	#81, r1
ffe04e6b:	05 c5 e9 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04e6f <.LVL59>:
    if (1 == ICU.GRPAL0.BIT.IS19)
ffe04e6f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04e74:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04e78:	7d 35                         	btst	#19, r5
ffe04e7a:	3a f6 fe                      	beq.w	ffe04d70 <_Reset_Vector+0xffe04d74>
ffe04e7d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI1_SPEI1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04e80:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04e86:	66 02                         	mov.l	#0, r2
ffe04e88:	75 41 54                      	mov.l	#84, r1
ffe04e8b:	05 a5 e9 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04e8f <.LVL60>:
    if (1 == ICU.GRPAL0.BIT.IS18)
ffe04e8f:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04e94:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04e98:	7d 25                         	btst	#18, r5
ffe04e9a:	3a e6 fe                      	beq.w	ffe04d80 <_Reset_Vector+0xffe04d84>
ffe04e9d:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI1_SPII1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04ea0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04ea6:	66 02                         	mov.l	#0, r2
ffe04ea8:	75 41 53                      	mov.l	#83, r1
ffe04eab:	05 85 e9 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04eaf <.LVL61>:
    if (1 == ICU.GRPAL0.BIT.IS21)
ffe04eaf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04eb4:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04eb8:	7d 55                         	btst	#21, r5
ffe04eba:	3a d6 fe                      	beq.w	ffe04d90 <_Reset_Vector+0xffe04d94>
ffe04ebd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI2_SPEI2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04ec0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04ec6:	66 02                         	mov.l	#0, r2
ffe04ec8:	75 41 56                      	mov.l	#86, r1
ffe04ecb:	05 65 e9 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04ecf <.LVL62>:
    if (1 == ICU.GRPAL0.BIT.IS20)
ffe04ecf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04ed4:	ee 55 0c 02                   	mov.l	2096[r5], r5
ffe04ed8:	7d 45                         	btst	#20, r5
ffe04eda:	3a c4 fe                      	beq.w	ffe04d9e <_Reset_Vector+0xffe04da2>
ffe04edd:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL0_RSPI2_SPII2, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04ee0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04ee6:	66 02                         	mov.l	#0, r2
ffe04ee8:	75 41 55                      	mov.l	#85, r1
ffe04eeb:	05 45 e9 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04eef <.LVL63>:
} /* End of function group_al0_handler_isr() */
ffe04eef:	38 af fe                      	bra.w	ffe04d9e <_Reset_Vector+0xffe04da2>

ffe04ef2 <.LFE13>:
ffe04ef2:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe04ef8 <__group_al1_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_al1_handler_isr, VECT(ICU,GROUPAL1))
ffe04ef8:	7e a1                         	push.l	r1
ffe04efa:	fd 6a 01                      	mvfc	psw, r1
ffe04efd:	69 81                         	shlr	#24, r1
ffe04eff:	64 f1                         	and	#15, r1
ffe04f01:	61 91                         	cmp	#9, r1
ffe04f03:	22 05                         	bc.b	ffe04f08 <_Reset_Vector+0xffe04f0c>
ffe04f05:	75 70 09                      	mvtipl	#9
ffe04f08:	7f a8                         	setpsw	i
ffe04f0a:	7e b1                         	pop	r1
ffe04f0c:	2e 02                         	bra.b	ffe04f0e <_Reset_Vector+0xffe04f12>

ffe04f0e <_group_al1_handler_isr>:
*                NOTE: The interrupt request flag must be cleared in the peripheral.
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_al1_handler_isr (void)
{
ffe04f0e:	6e ef                         	pushm	r14-r15
ffe04f10:	6e 15                         	pushm	r1-r5
ffe04f12:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe04f15:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe04f18:	7e a1                         	push.l	r1
ffe04f1a:	7e a2                         	push.l	r2
ffe04f1c:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe04f1f:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe04f22:	7e a1                         	push.l	r1
ffe04f24:	7e a2                         	push.l	r2
ffe04f26:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe04f29:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe04f2c:	7e a1                         	push.l	r1
ffe04f2e:	7e a2                         	push.l	r2
    /* AL1 IS4 */
    if (1 == ICU.GRPAL1.BIT.IS4)
ffe04f30:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04f35:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe04f39:	7c 45                         	btst	#4, r5
ffe04f3b:	21 5f                         	bne.b	ffe04f9a <_Reset_Vector+0xffe04f9e>
        /* BSP_INT_SRC_AL1_EDMAC0_EINT0 */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_EDMAC0_EINT0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL1 IS9 */
    if (1 == ICU.GRPAL1.BIT.IS9)
ffe04f3d:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04f42:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe04f46:	7c 95                         	btst	#9, r5
ffe04f48:	21 70                         	bne.b	ffe04fb8 <_Reset_Vector+0xffe04fbc>
        /* BSP_INT_SRC_AL1_GLCDC_GR1UF */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_GR1UF, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL1 IS10 */
    if (1 == ICU.GRPAL1.BIT.IS10)
ffe04f4a:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04f4f:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe04f53:	7c a5                         	btst	#10, r5
ffe04f55:	3b 83 00                      	bne.w	ffe04fd8 <_Reset_Vector+0xffe04fdc>
        /* BSP_INT_SRC_AL1_GLCDC_GR2UF */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_GR2UF, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL1 IS8 */
    if (1 == ICU.GRPAL1.BIT.IS8)
ffe04f58:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04f5d:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe04f61:	7c 85                         	btst	#8, r5
ffe04f63:	3b 95 00                      	bne.w	ffe04ff8 <_Reset_Vector+0xffe04ffc>
ffe04f66:	ef 00                         	nop	; mov.l	r0, r0
        /* BSP_INT_SRC_AL1_GLCDC_VPOS */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_VPOS, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* AL1 IS11 */
    if (1 == ICU.GRPAL1.BIT.IS11)
ffe04f68:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04f6d:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe04f71:	7c b5                         	btst	#11, r5
ffe04f73:	3b a5 00                      	bne.w	ffe05018 <_Reset_Vector+0xffe0501c>
    {
        /* BSP_INT_SRC_AL1_DRW2D_DRW_IRQ */
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_DRW2D_DRW_IRQ, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_al1_handler_isr() */
ffe04f76:	7e b2                         	pop	r2
ffe04f78:	7e b1                         	pop	r1
ffe04f7a:	fd 17 81                      	mvtachi	r1, a1
ffe04f7d:	fd 17 b2                      	mvtacgu	r2, a1
ffe04f80:	7e b2                         	pop	r2
ffe04f82:	7e b1                         	pop	r1
ffe04f84:	fd 17 31                      	mvtacgu	r1, a0
ffe04f87:	fd 17 92                      	mvtaclo	r2, a1
ffe04f8a:	7e b2                         	pop	r2
ffe04f8c:	7e b1                         	pop	r1
ffe04f8e:	fd 17 11                      	mvtaclo	r1, a0
ffe04f91:	fd 17 02                      	mvtachi	r2, a0
ffe04f94:	6f 15                         	popm	r1-r5
ffe04f96:	6f ef                         	popm	r14-r15
ffe04f98:	7f 95                         	rte
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_EDMAC0_EINT0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04f9a:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04fa0:	66 02                         	mov.l	#0, r2
ffe04fa2:	75 41 58                      	mov.l	#88, r1
ffe04fa5:	05 8b e8 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04fa9 <.LVL64>:
    if (1 == ICU.GRPAL1.BIT.IS9)
ffe04fa9:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04fae:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe04fb2:	7c 95                         	btst	#9, r5
ffe04fb4:	20 96                         	beq.b	ffe04f4a <_Reset_Vector+0xffe04f4e>
ffe04fb6:	ef 00                         	nop	; mov.l	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_GR1UF, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04fb8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04fbe:	66 02                         	mov.l	#0, r2
ffe04fc0:	75 41 5a                      	mov.l	#90, r1
ffe04fc3:	05 6d e8 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04fc7 <.LVL65>:
    if (1 == ICU.GRPAL1.BIT.IS10)
ffe04fc7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04fcc:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe04fd0:	7c a5                         	btst	#10, r5
ffe04fd2:	20 86                         	beq.b	ffe04f58 <_Reset_Vector+0xffe04f5c>
ffe04fd4:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_GR2UF, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04fd8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04fde:	66 02                         	mov.l	#0, r2
ffe04fe0:	75 41 5b                      	mov.l	#91, r1
ffe04fe3:	05 4d e8 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe04fe7 <.LVL66>:
    if (1 == ICU.GRPAL1.BIT.IS8)
ffe04fe7:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe04fec:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe04ff0:	7c 85                         	btst	#8, r5
ffe04ff2:	3a 76 ff                      	beq.w	ffe04f68 <_Reset_Vector+0xffe04f6c>
ffe04ff5:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_GLCDC_VPOS, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe04ff8:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe04ffe:	66 02                         	mov.l	#0, r2
ffe05000:	75 41 59                      	mov.l	#89, r1
ffe05003:	05 2d e8 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe05007 <.LVL67>:
    if (1 == ICU.GRPAL1.BIT.IS11)
ffe05007:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe0500c:	ee 55 0d 02                   	mov.l	2100[r5], r5
ffe05010:	7c b5                         	btst	#11, r5
ffe05012:	3a 64 ff                      	beq.w	ffe04f76 <_Reset_Vector+0xffe04f7a>
ffe05015:	fc 13 00                      	nop	; max	r0, r0
        R_BSP_InterruptControl(BSP_INT_SRC_AL1_DRW2D_DRW_IRQ, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe05018:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
ffe0501e:	66 02                         	mov.l	#0, r2
ffe05020:	75 41 5c                      	mov.l	#92, r1
ffe05023:	05 0d e8 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe05027 <.LVL68>:
} /* End of function group_al1_handler_isr() */
ffe05027:	38 4f ff                      	bra.w	ffe04f76 <_Reset_Vector+0xffe04f7a>

ffe0502a <.LFE14>:
ffe0502a:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe05030 <__group_be0_handler_isr>:
R_BSP_PRAGMA_STATIC_INTERRUPT(group_be0_handler_isr, VECT(ICU,GROUPBE0))
ffe05030:	7e a1                         	push.l	r1
ffe05032:	fd 6a 01                      	mvfc	psw, r1
ffe05035:	69 81                         	shlr	#24, r1
ffe05037:	64 f1                         	and	#15, r1
ffe05039:	61 91                         	cmp	#9, r1
ffe0503b:	22 05                         	bc.b	ffe05040 <_Reset_Vector+0xffe05044>
ffe0503d:	75 70 09                      	mvtipl	#9
ffe05040:	7f a8                         	setpsw	i
ffe05042:	7e b1                         	pop	r1
ffe05044:	2e 02                         	bra.b	ffe05046 <_Reset_Vector+0xffe0504a>

ffe05046 <_group_be0_handler_isr>:
*                NOTE: The interrupt request flag must be cleared in the peripheral.
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/
R_BSP_ATTRIB_STATIC_INTERRUPT void group_be0_handler_isr (void)
{
ffe05046:	6e ef                         	pushm	r14-r15
ffe05048:	6e 15                         	pushm	r1-r5
ffe0504a:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe0504d:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe05050:	7e a1                         	push.l	r1
ffe05052:	7e a2                         	push.l	r2
ffe05054:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe05057:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe0505a:	7e a1                         	push.l	r1
ffe0505c:	7e a2                         	push.l	r2
ffe0505e:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe05061:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe05064:	7e a1                         	push.l	r1
ffe05066:	7e a2                         	push.l	r2
    /* BE0 IS0 */
    if (1 == ICU.GRPBE0.BIT.IS0)
ffe05068:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe0506d:	ee 54 80 01                   	mov.l	1536[r5], r4
ffe05071:	7c 04                         	btst	#0, r4
ffe05073:	21 33                         	bne.b	ffe050a6 <_Reset_Vector+0xffe050aa>
        /* BSP_INT_SRC_BE0_CAN0_ERS0 */
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }

    /* BE0 IS1 */
    if (1 == ICU.GRPBE0.BIT.IS1)
ffe05075:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe0507a:	ee 54 80 01                   	mov.l	1536[r5], r4
ffe0507e:	7c 14                         	btst	#1, r4
ffe05080:	21 50                         	bne.b	ffe050d0 <_Reset_Vector+0xffe050d4>
        ICU.GCRBE0.BIT.CLR1 = 1;

        /* BSP_INT_SRC_BE0_CAN1_ERS1 */
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN1_ERS1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
    }
} /* End of function group_be0_handler_isr() */
ffe05082:	7e b2                         	pop	r2
ffe05084:	7e b1                         	pop	r1
ffe05086:	fd 17 81                      	mvtachi	r1, a1
ffe05089:	fd 17 b2                      	mvtacgu	r2, a1
ffe0508c:	7e b2                         	pop	r2
ffe0508e:	7e b1                         	pop	r1
ffe05090:	fd 17 31                      	mvtacgu	r1, a0
ffe05093:	fd 17 92                      	mvtaclo	r2, a1
ffe05096:	7e b2                         	pop	r2
ffe05098:	7e b1                         	pop	r1
ffe0509a:	fd 17 11                      	mvtaclo	r1, a0
ffe0509d:	fd 17 02                      	mvtachi	r2, a0
ffe050a0:	6f 15                         	popm	r1-r5
ffe050a2:	6f ef                         	popm	r14-r15
ffe050a4:	7f 95                         	rte
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe050a6:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
        ICU.GCRBE0.BIT.CLR0 = 1;
ffe050ac:	ee 54 a0 01                   	mov.l	1664[r5], r4
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe050b0:	66 02                         	mov.l	#0, r2
ffe050b2:	75 41 11                      	mov.l	#17, r1
        ICU.GCRBE0.BIT.CLR0 = 1;
ffe050b5:	78 04                         	bset	#0, r4
ffe050b7:	eb 54 a0 01                   	mov.l	r4, 1664[r5]
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN0_ERS0, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe050bb:	05 75 e7 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe050bf <.LVL69>:
    if (1 == ICU.GRPBE0.BIT.IS1)
ffe050bf:	fb 5e 00 70 08                	mov.l	#0x87000, r5
ffe050c4:	ee 54 80 01                   	mov.l	1536[r5], r4
ffe050c8:	7c 14                         	btst	#1, r4
ffe050ca:	20 b8                         	beq.b	ffe05082 <_Reset_Vector+0xffe05086>
ffe050cc:	76 10 01 00                   	nop	; mul	#1, r0
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN1_ERS1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe050d0:	fb 32 00 00 00 10             	mov.l	#0x10000000, r3
        ICU.GCRBE0.BIT.CLR1 = 1;
ffe050d6:	ee 54 a0 01                   	mov.l	1664[r5], r4
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN1_ERS1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe050da:	66 02                         	mov.l	#0, r2
ffe050dc:	75 41 12                      	mov.l	#18, r1
        ICU.GCRBE0.BIT.CLR1 = 1;
ffe050df:	78 14                         	bset	#1, r4
ffe050e1:	eb 54 a0 01                   	mov.l	r4, 1664[r5]
        R_BSP_InterruptControl(BSP_INT_SRC_BE0_CAN1_ERS1, BSP_INT_CMD_CALL_CALLBACK, FIT_NO_PTR);
ffe050e5:	05 4b e7 ff                   	bsr.a	ffe03830 <_Reset_Vector+0xffe03834>

ffe050e9 <.LVL70>:
} /* End of function group_be0_handler_isr() */
ffe050e9:	2e 99                         	bra.b	ffe05082 <_Reset_Vector+0xffe05086>

ffe050eb <.LFE15>:
ffe050eb:	77 10 01 00 00                	nop	; mul	#1, r0

ffe050f0 <_r_Config_SCI0_transmit_interrupt>:
void r_Config_SCI0_transmit_interrupt(void)
ffe050f0:	7e a1                         	push.l	r1
ffe050f2:	fd 6a 01                      	mvfc	psw, r1
ffe050f5:	69 81                         	shlr	#24, r1
ffe050f7:	64 f1                         	and	#15, r1
ffe050f9:	61 91                         	cmp	#9, r1
ffe050fb:	22 05                         	bc.b	ffe05100 <_Reset_Vector+0xffe05104>
ffe050fd:	75 70 09                      	mvtipl	#9
ffe05100:	7f a8                         	setpsw	i
ffe05102:	7e b1                         	pop	r1
ffe05104:	2e 02                         	bra.b	ffe05106 <_Reset_Vector+0xffe0510a>

ffe05106 <__r_Config_SCI0_transmit_interrupt>:
{
ffe05106:	6e ef                         	pushm	r14-r15
ffe05108:	6e 15                         	pushm	r1-r5
ffe0510a:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe0510d:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe05110:	7e a1                         	push.l	r1
ffe05112:	7e a2                         	push.l	r2
ffe05114:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe05117:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe0511a:	7e a1                         	push.l	r1
ffe0511c:	7e a2                         	push.l	r2
ffe0511e:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe05121:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe05124:	7e a1                         	push.l	r1
ffe05126:	7e a2                         	push.l	r2
    if (1U == SCI0.SISR.BIT.IICACKR)
ffe05128:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffe0512d:	8b 54                         	mov.b	12[r5], r4
ffe0512f:	7c 04                         	btst	#0, r4
ffe05131:	20 20                         	beq.b	ffe05151 <_Reset_Vector+0xffe05155>
        *gp_sci0_rx_address = SCI0.RDR;
ffe05133:	fb 42 f8 03 00 00             	mov.l	#0x3f8, r4
ffe05139:	89 5b                         	mov.b	5[r5], r3
ffe0513b:	ec 45                         	mov.l	[r4], r5
        g_sci0_rx_count++;
ffe0513d:	fb 22 02 04 00 00             	mov.l	#0x402, r2
        *gp_sci0_rx_address = SCI0.RDR;
ffe05143:	c3 53                         	mov.b	r3, [r5]
        gp_sci0_rx_address++;
ffe05145:	ec 43                         	mov.l	[r4], r3
        g_sci0_rx_count++;
ffe05147:	dc 25                         	mov.w	[r2], r5
        gp_sci0_rx_address++;
ffe05149:	62 13                         	add	#1, r3
        g_sci0_rx_count++;
ffe0514b:	62 15                         	add	#1, r5
        gp_sci0_rx_address++;
ffe0514d:	e3 43                         	mov.l	r3, [r4]
        g_sci0_rx_count++;
ffe0514f:	d3 25                         	mov.w	r5, [r2]
    g_sci0_iic_cycle_flag = _00_SCI_IIC_STOP_CYCLE;
ffe05151:	fb 52 01 04 00 00             	mov.l	#0x401, r5
ffe05157:	f8 54 00                      	mov.b	#0, [r5]
    R_Config_SCI0_IIC_StopCondition();
ffe0515a:	05 21 ed ff                   	bsr.a	ffe03e7b <_Reset_Vector+0xffe03e7f>

ffe0515e <.LVL0>:
}
ffe0515e:	7e b2                         	pop	r2
ffe05160:	7e b1                         	pop	r1
ffe05162:	fd 17 81                      	mvtachi	r1, a1
ffe05165:	fd 17 b2                      	mvtacgu	r2, a1
ffe05168:	7e b2                         	pop	r2
ffe0516a:	7e b1                         	pop	r1
ffe0516c:	fd 17 31                      	mvtacgu	r1, a0
ffe0516f:	fd 17 92                      	mvtaclo	r2, a1
ffe05172:	7e b2                         	pop	r2
ffe05174:	7e b1                         	pop	r1
ffe05176:	fd 17 11                      	mvtaclo	r1, a0
ffe05179:	fd 17 02                      	mvtachi	r2, a0
ffe0517c:	6f 15                         	popm	r1-r5
ffe0517e:	6f ef                         	popm	r14-r15
ffe05180:	7f 95                         	rte

ffe05182 <.LFE5>:
ffe05182:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe05188 <_r_Config_SCI0_receive_interrupt>:
* Description  : This function is RXI0 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_SCI0_receive_interrupt(void)
ffe05188:	7e a1                         	push.l	r1
ffe0518a:	fd 6a 01                      	mvfc	psw, r1
ffe0518d:	69 81                         	shlr	#24, r1
ffe0518f:	64 f1                         	and	#15, r1
ffe05191:	61 91                         	cmp	#9, r1
ffe05193:	22 05                         	bc.b	ffe05198 <_Reset_Vector+0xffe0519c>
ffe05195:	75 70 09                      	mvtipl	#9
ffe05198:	7f a8                         	setpsw	i
ffe0519a:	7e b1                         	pop	r1
ffe0519c:	2e 02                         	bra.b	ffe0519e <_Reset_Vector+0xffe051a2>

ffe0519e <__r_Config_SCI0_receive_interrupt>:
{
ffe0519e:	6e ef                         	pushm	r14-r15
ffe051a0:	6e 15                         	pushm	r1-r5
ffe051a2:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe051a5:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe051a8:	7e a1                         	push.l	r1
ffe051aa:	7e a2                         	push.l	r2
ffe051ac:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe051af:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe051b2:	7e a1                         	push.l	r1
ffe051b4:	7e a2                         	push.l	r2
ffe051b6:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe051b9:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe051bc:	7e a1                         	push.l	r1
ffe051be:	7e a2                         	push.l	r2
ffe051c0:	60 40                         	sub	#4, r0
    volatile uint8_t dummy;

    if (0U == SCI0.SISR.BIT.IICACKR)
ffe051c2:	fb 4e 00 a0 08                	mov.l	#0x8a000, r4
ffe051c7:	8b 45                         	mov.b	12[r4], r5
ffe051c9:	7c 05                         	btst	#0, r5
ffe051cb:	21 74                         	bne.b	ffe0523f <_Reset_Vector+0xffe05243>
    {
        if (_80_SCI_IIC_TRANSMISSION == g_sci0_iic_transmit_receive_flag)
ffe051cd:	fb 32 fc 03 00 00             	mov.l	#0x3fc, r3
ffe051d3:	58 35                         	movu.b	[r3], r5
ffe051d5:	75 55 80                      	cmp	#128, r5
ffe051d8:	20 44                         	beq.b	ffe0521c <_Reset_Vector+0xffe05220>
                /* Generate stop condition */
                g_sci0_iic_cycle_flag = _00_SCI_IIC_STOP_CYCLE;
                R_Config_SCI0_IIC_StopCondition();
            }
        }
        else if (_00_SCI_IIC_RECEPTION == g_sci0_iic_transmit_receive_flag)
ffe051da:	58 35                         	movu.b	[r3], r5
ffe051dc:	61 05                         	cmp	#0, r5
ffe051de:	21 6e                         	bne.b	ffe0524c <_Reset_Vector+0xffe05250>
        {
            if (0U == SCI0.SIMR2.BIT.IICACKT)
ffe051e0:	8a c5                         	mov.b	10[r4], r5
ffe051e2:	7c 55                         	btst	#5, r5
ffe051e4:	3a 8e 00                      	beq.w	ffe05272 <_Reset_Vector+0xffe05276>
                    g_sci0_rx_count++;
                }
            }
            else
            {
                dummy = SCI0.RDR;
ffe051e7:	89 4d                         	mov.b	5[r4], r5
ffe051e9:	fb 22 08 04 00 00             	mov.l	#0x408, r2
ffe051ef:	fb 32 02 04 00 00             	mov.l	#0x402, r3
ffe051f5:	c3 05                         	mov.b	r5, [r0]
ffe051f7:	03                            	nop
            }

            if (0U == g_sci0_rx_count)
ffe051f8:	5c 35                         	movu.w	[r3], r5
ffe051fa:	61 05                         	cmp	#0, r5
ffe051fc:	3b ac 00                      	bne.w	ffe052a8 <_Reset_Vector+0xffe052ac>
            {
                if(1U == g_sci0_rx_length)
ffe051ff:	5c 25                         	movu.w	[r2], r5
ffe05201:	61 15                         	cmp	#1, r5
                {
                    SCI0.SIMR2.BIT.IICACKT = 1U;
ffe05203:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
                if(1U == g_sci0_rx_length)
ffe05208:	3a b4 00                      	beq.w	ffe052bc <_Reset_Vector+0xffe052c0>
                }
                else
                {
                    SCI0.SIMR2.BIT.IICACKT = 0U; 
ffe0520b:	f1 5d 0a                      	bclr	#5, 10[r5].b
                    SCI0.SCR.BIT.RIE = 1U;
ffe0520e:	f1 56 02                      	bset	#6, 2[r5].b
            {
                /* Do nothing */
            }

            /* Write dummy */
            SCI0.TDR = 0xFFU;
ffe05211:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffe05216:	f9 54 03 ff                   	mov.b	#255, 3[r5]
ffe0521a:	2e 32                         	bra.b	ffe0524c <_Reset_Vector+0xffe05250>
            if (g_sci0_tx_count > 0U)
ffe0521c:	fb 32 fe 03 00 00             	mov.l	#0x3fe, r3
ffe05222:	5c 35                         	movu.w	[r3], r5
ffe05224:	61 05                         	cmp	#0, r5
ffe05226:	20 19                         	beq.b	ffe0523f <_Reset_Vector+0xffe05243>
                SCI0.TDR = *gp_sci0_tx_address;
ffe05228:	fb 12 04 04 00 00             	mov.l	#0x404, r1
ffe0522e:	ec 12                         	mov.l	[r1], r2
ffe05230:	fd 28 25                      	mov.b	[r2+], r5
ffe05233:	80 cd                         	mov.b	r5, 3[r4]
                g_sci0_tx_count--;
ffe05235:	dc 35                         	mov.w	[r3], r5
                gp_sci0_tx_address++;
ffe05237:	e3 12                         	mov.l	r2, [r1]
                g_sci0_tx_count--;
ffe05239:	60 15                         	sub	#1, r5
ffe0523b:	d3 35                         	mov.w	r5, [r3]
ffe0523d:	2e 0f                         	bra.b	ffe0524c <_Reset_Vector+0xffe05250>
        }
    }
    else
    {
        /* Generate stop condition */
        g_sci0_iic_cycle_flag = _00_SCI_IIC_STOP_CYCLE;
ffe0523f:	fb 52 01 04 00 00             	mov.l	#0x401, r5
ffe05245:	f8 54 00                      	mov.b	#0, [r5]
        R_Config_SCI0_IIC_StopCondition();
ffe05248:	05 33 ec ff                   	bsr.a	ffe03e7b <_Reset_Vector+0xffe03e7f>

ffe0524c <.LVL1>:
    }
}
ffe0524c:	62 40                         	add	#4, r0
ffe0524e:	7e b2                         	pop	r2
ffe05250:	7e b1                         	pop	r1
ffe05252:	fd 17 81                      	mvtachi	r1, a1
ffe05255:	fd 17 b2                      	mvtacgu	r2, a1
ffe05258:	7e b2                         	pop	r2
ffe0525a:	7e b1                         	pop	r1
ffe0525c:	fd 17 31                      	mvtacgu	r1, a0
ffe0525f:	fd 17 92                      	mvtaclo	r2, a1
ffe05262:	7e b2                         	pop	r2
ffe05264:	7e b1                         	pop	r1
ffe05266:	fd 17 11                      	mvtaclo	r1, a0
ffe05269:	fd 17 02                      	mvtachi	r2, a0
ffe0526c:	6f 15                         	popm	r1-r5
ffe0526e:	6f ef                         	popm	r14-r15
ffe05270:	7f 95                         	rte
                if (g_sci0_rx_length > g_sci0_rx_count)
ffe05272:	fb 22 08 04 00 00             	mov.l	#0x408, r2
ffe05278:	fb 32 02 04 00 00             	mov.l	#0x402, r3
ffe0527e:	dc 21                         	mov.w	[r2], r1
ffe05280:	dc 35                         	mov.w	[r3], r5
ffe05282:	5f 11                         	movu.w	r1, r1
ffe05284:	5f 55                         	movu.w	r5, r5
ffe05286:	47 51                         	cmp	r5, r1
ffe05288:	24 05                         	bgtu.b	ffe0528d <_Reset_Vector+0xffe05291>
ffe0528a:	38 6e ff                      	bra.w	ffe051f8 <_Reset_Vector+0xffe051fc>
                    *gp_sci0_rx_address = SCI0.RDR;
ffe0528d:	fb 12 f8 03 00 00             	mov.l	#0x3f8, r1
ffe05293:	89 4c                         	mov.b	5[r4], r4
ffe05295:	ec 15                         	mov.l	[r1], r5
ffe05297:	c3 54                         	mov.b	r4, [r5]
                    gp_sci0_rx_address++;
ffe05299:	ec 14                         	mov.l	[r1], r4
                    g_sci0_rx_count++;
ffe0529b:	dc 35                         	mov.w	[r3], r5
                    gp_sci0_rx_address++;
ffe0529d:	62 14                         	add	#1, r4
                    g_sci0_rx_count++;
ffe0529f:	62 15                         	add	#1, r5
                    gp_sci0_rx_address++;
ffe052a1:	e3 14                         	mov.l	r4, [r1]
                    g_sci0_rx_count++;
ffe052a3:	d3 35                         	mov.w	r5, [r3]
ffe052a5:	38 53 ff                      	bra.w	ffe051f8 <_Reset_Vector+0xffe051fc>
            else if (g_sci0_rx_length == (g_sci0_rx_count + 1))
ffe052a8:	dc 24                         	mov.w	[r2], r4
ffe052aa:	dc 35                         	mov.w	[r3], r5
ffe052ac:	5f 44                         	movu.w	r4, r4
ffe052ae:	5f 55                         	movu.w	r5, r5
ffe052b0:	62 15                         	add	#1, r5
ffe052b2:	47 54                         	cmp	r5, r4
ffe052b4:	3b 5d ff                      	bne.w	ffe05211 <_Reset_Vector+0xffe05215>
                 SCI0.SIMR2.BIT.IICACKT = 1U;
ffe052b7:	fb 5e 00 a0 08                	mov.l	#0x8a000, r5
ffe052bc:	f1 55 0a                      	bset	#5, 10[r5].b
ffe052bf:	38 52 ff                      	bra.w	ffe05211 <_Reset_Vector+0xffe05215>

ffe052c2 <.LFE8>:
ffe052c2:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe052c8 <_r_Config_RIIC0_transmit_interrupt>:
void r_Config_RIIC0_transmit_interrupt(void)
ffe052c8:	7e a1                         	push.l	r1
ffe052ca:	fd 6a 01                      	mvfc	psw, r1
ffe052cd:	69 81                         	shlr	#24, r1
ffe052cf:	64 f1                         	and	#15, r1
ffe052d1:	61 91                         	cmp	#9, r1
ffe052d3:	22 05                         	bc.b	ffe052d8 <_Reset_Vector+0xffe052dc>
ffe052d5:	75 70 09                      	mvtipl	#9
ffe052d8:	7f a8                         	setpsw	i
ffe052da:	7e b1                         	pop	r1
ffe052dc:	2e 02                         	bra.b	ffe052de <_Reset_Vector+0xffe052e2>

ffe052de <__r_Config_RIIC0_transmit_interrupt>:
{
ffe052de:	6e 15                         	pushm	r1-r5
ffe052e0:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe052e3:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe052e6:	6e 12                         	pushm	r1-r2
ffe052e8:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe052eb:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe052ee:	6e 12                         	pushm	r1-r2
ffe052f0:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe052f3:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe052f6:	6e 12                         	pushm	r1-r2
    if (_0D_IIC_MASTER_TRANSMIT == g_riic0_mode_flag)
ffe052f8:	fb 42 10 04 00 00             	mov.l	#0x410, r4
ffe052fe:	58 45                         	movu.b	[r4], r5
ffe05300:	61 d5                         	cmp	#13, r5
ffe05302:	20 5f                         	beq.b	ffe05361 <_Reset_Vector+0xffe05365>
    else if (_0C_IIC_MASTER_RECEIVE == g_riic0_mode_flag)
ffe05304:	58 45                         	movu.b	[r4], r5
ffe05306:	61 c5                         	cmp	#12, r5
ffe05308:	20 1e                         	beq.b	ffe05326 <_Reset_Vector+0xffe0532a>
}
ffe0530a:	6f 12                         	popm	r1-r2
ffe0530c:	fd 17 81                      	mvtachi	r1, a1
ffe0530f:	fd 17 b2                      	mvtacgu	r2, a1
ffe05312:	6f 12                         	popm	r1-r2
ffe05314:	fd 17 31                      	mvtacgu	r1, a0
ffe05317:	fd 17 92                      	mvtaclo	r2, a1
ffe0531a:	6f 12                         	popm	r1-r2
ffe0531c:	fd 17 11                      	mvtaclo	r1, a0
ffe0531f:	fd 17 02                      	mvtachi	r2, a0
ffe05322:	6f 15                         	popm	r1-r5
ffe05324:	7f 95                         	rte
        if (_00_IIC_MASTER_SENDS_ADR_7_R == g_riic0_state)
ffe05326:	fb 42 24 04 00 00             	mov.l	#0x424, r4
ffe0532c:	58 45                         	movu.b	[r4], r5
ffe0532e:	61 05                         	cmp	#0, r5
ffe05330:	20 7b                         	beq.b	ffe053ab <_Reset_Vector+0xffe053af>
        else if (_02_IIC_MASTER_SENDS_ADR_10A_W == g_riic0_state)
ffe05332:	58 45                         	movu.b	[r4], r5
ffe05334:	61 25                         	cmp	#2, r5
ffe05336:	3a 1d 01                      	beq.w	ffe05453 <_Reset_Vector+0xffe05457>
        else if (_04_IIC_MASTER_SENDS_ADR_10B == g_riic0_state)
ffe05339:	58 45                         	movu.b	[r4], r5
ffe0533b:	61 45                         	cmp	#4, r5
ffe0533d:	3a 01 01                      	beq.w	ffe0543e <_Reset_Vector+0xffe05442>
        else if (_03_IIC_MASTER_SENDS_ADR_10A_R == g_riic0_state)
ffe05340:	58 45                         	movu.b	[r4], r5
ffe05342:	61 35                         	cmp	#3, r5
ffe05344:	21 c6                         	bne.b	ffe0530a <_Reset_Vector+0xffe0530e>
            RIIC0.ICDRT = (uint8_t)(((g_riic0_slave_address & 0x0300U) >> 7U) | 0x00F1U);
ffe05346:	fb 52 16 04 00 00             	mov.l	#0x416, r5
ffe0534c:	dc 55                         	mov.w	[r5], r5
ffe0534e:	68 75                         	shlr	#7, r5
ffe05350:	64 65                         	and	#6, r5
ffe05352:	75 35 f1                      	or	#-15, r5
ffe05355:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffe0535a:	84 b5                         	mov.b	r5, 18[r3]
            g_riic0_state = _08_IIC_MASTER_RECEIVES_START;
ffe0535c:	f8 44 08                      	mov.b	#8, [r4]
}
ffe0535f:	2e ab                         	bra.b	ffe0530a <_Reset_Vector+0xffe0530e>
        if (_01_IIC_MASTER_SENDS_ADR_7_W == g_riic0_state)
ffe05361:	fb 52 24 04 00 00             	mov.l	#0x424, r5
ffe05367:	58 54                         	movu.b	[r5], r4
ffe05369:	61 14                         	cmp	#1, r4
ffe0536b:	3a 8e 00                      	beq.w	ffe053f9 <_Reset_Vector+0xffe053fd>
        else if (_02_IIC_MASTER_SENDS_ADR_10A_W == g_riic0_state)
ffe0536e:	58 54                         	movu.b	[r5], r4
ffe05370:	61 24                         	cmp	#2, r4
ffe05372:	20 6b                         	beq.b	ffe053dd <_Reset_Vector+0xffe053e1>
        else if (_04_IIC_MASTER_SENDS_ADR_10B == g_riic0_state)
ffe05374:	58 54                         	movu.b	[r5], r4
ffe05376:	61 44                         	cmp	#4, r4
ffe05378:	3a b1 00                      	beq.w	ffe05429 <_Reset_Vector+0xffe0542d>
        else if (_05_IIC_MASTER_SENDS_DATA == g_riic0_state)
ffe0537b:	58 54                         	movu.b	[r5], r4
ffe0537d:	61 54                         	cmp	#5, r4
ffe0537f:	21 8b                         	bne.b	ffe0530a <_Reset_Vector+0xffe0530e>
            if (0U < g_riic0_tx_count)
ffe05381:	fb 32 12 04 00 00             	mov.l	#0x412, r3
ffe05387:	5c 34                         	movu.w	[r3], r4
ffe05389:	61 04                         	cmp	#0, r4
ffe0538b:	3a e4 00                      	beq.w	ffe0546f <_Reset_Vector+0xffe05473>
                RIIC0.ICDRT = *gp_riic0_tx_address;
ffe0538e:	fb 22 0c 04 00 00             	mov.l	#0x40c, r2
ffe05394:	ec 24                         	mov.l	[r2], r4
ffe05396:	fd 28 41                      	mov.b	[r4+], r1
ffe05399:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe0539e:	84 d1                         	mov.b	r1, 18[r5]
                g_riic0_tx_count--;
ffe053a0:	dc 35                         	mov.w	[r3], r5
                gp_riic0_tx_address++;
ffe053a2:	e3 24                         	mov.l	r4, [r2]
                g_riic0_tx_count--;
ffe053a4:	60 15                         	sub	#1, r5
ffe053a6:	d3 35                         	mov.w	r5, [r3]
ffe053a8:	38 62 ff                      	bra.w	ffe0530a <_Reset_Vector+0xffe0530e>
            RIIC0.ICDRT = (uint8_t)((g_riic0_slave_address << 1U) | 0x0001U);
ffe053ab:	fb 52 16 04 00 00             	mov.l	#0x416, r5
ffe053b1:	dc 55                         	mov.w	[r5], r5
ffe053b3:	6c 15                         	shll	#1, r5
ffe053b5:	78 05                         	bset	#0, r5
ffe053b7:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffe053bc:	84 b5                         	mov.b	r5, 18[r3]
            g_riic0_state = _08_IIC_MASTER_RECEIVES_START;
ffe053be:	f8 44 08                      	mov.b	#8, [r4]
}
ffe053c1:	6f 12                         	popm	r1-r2
ffe053c3:	fd 17 81                      	mvtachi	r1, a1
ffe053c6:	fd 17 b2                      	mvtacgu	r2, a1
ffe053c9:	6f 12                         	popm	r1-r2
ffe053cb:	fd 17 31                      	mvtacgu	r1, a0
ffe053ce:	fd 17 92                      	mvtaclo	r2, a1
ffe053d1:	6f 12                         	popm	r1-r2
ffe053d3:	fd 17 11                      	mvtaclo	r1, a0
ffe053d6:	fd 17 02                      	mvtachi	r2, a0
ffe053d9:	6f 15                         	popm	r1-r5
ffe053db:	7f 95                         	rte
            RIIC0.ICDRT = (uint8_t)(((g_riic0_slave_address & 0x0300U) >> 7U) | 0x00F0U);
ffe053dd:	fb 42 16 04 00 00             	mov.l	#0x416, r4
ffe053e3:	dc 44                         	mov.w	[r4], r4
ffe053e5:	68 74                         	shlr	#7, r4
ffe053e7:	64 64                         	and	#6, r4
ffe053e9:	75 34 f0                      	or	#-16, r4
ffe053ec:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffe053f1:	84 b4                         	mov.b	r4, 18[r3]
            g_riic0_state = _04_IIC_MASTER_SENDS_ADR_10B;
ffe053f3:	f8 54 04                      	mov.b	#4, [r5]
ffe053f6:	38 14 ff                      	bra.w	ffe0530a <_Reset_Vector+0xffe0530e>
            RIIC0.ICDRT = (uint8_t)(g_riic0_slave_address << 1U);
ffe053f9:	fb 42 16 04 00 00             	mov.l	#0x416, r4
ffe053ff:	dc 44                         	mov.w	[r4], r4
ffe05401:	6c 14                         	shll	#1, r4
ffe05403:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffe05408:	84 b4                         	mov.b	r4, 18[r3]
            g_riic0_state = _05_IIC_MASTER_SENDS_DATA;
ffe0540a:	f8 54 05                      	mov.b	#5, [r5]
}
ffe0540d:	6f 12                         	popm	r1-r2
ffe0540f:	fd 17 81                      	mvtachi	r1, a1
ffe05412:	fd 17 b2                      	mvtacgu	r2, a1
ffe05415:	6f 12                         	popm	r1-r2
ffe05417:	fd 17 31                      	mvtacgu	r1, a0
ffe0541a:	fd 17 92                      	mvtaclo	r2, a1
ffe0541d:	6f 12                         	popm	r1-r2
ffe0541f:	fd 17 11                      	mvtaclo	r1, a0
ffe05422:	fd 17 02                      	mvtachi	r2, a0
ffe05425:	6f 15                         	popm	r1-r5
ffe05427:	7f 95                         	rte
            RIIC0.ICDRT = (uint8_t)(g_riic0_slave_address & 0x00FFU);
ffe05429:	fb 42 16 04 00 00             	mov.l	#0x416, r4
ffe0542f:	dc 43                         	mov.w	[r4], r3
ffe05431:	fb 4e 00 83 08                	mov.l	#0x88300, r4
ffe05436:	84 c3                         	mov.b	r3, 18[r4]
            g_riic0_state = _05_IIC_MASTER_SENDS_DATA;
ffe05438:	f8 54 05                      	mov.b	#5, [r5]
ffe0543b:	38 cf fe                      	bra.w	ffe0530a <_Reset_Vector+0xffe0530e>
            RIIC0.ICDRT = (uint8_t)(g_riic0_slave_address & 0x00FFU);
ffe0543e:	fb 52 16 04 00 00             	mov.l	#0x416, r5
ffe05444:	dc 53                         	mov.w	[r5], r3
ffe05446:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe0544b:	84 d3                         	mov.b	r3, 18[r5]
            g_riic0_state = _0E_IIC_MASTER_RECEIVES_RESTART;
ffe0544d:	f8 44 0e                      	mov.b	#14, [r4]
ffe05450:	38 ba fe                      	bra.w	ffe0530a <_Reset_Vector+0xffe0530e>
            RIIC0.ICDRT = (uint8_t)(((g_riic0_slave_address & 0x0300U) >> 7U) | 0x00F0U);
ffe05453:	fb 52 16 04 00 00             	mov.l	#0x416, r5
ffe05459:	dc 55                         	mov.w	[r5], r5
ffe0545b:	68 75                         	shlr	#7, r5
ffe0545d:	64 65                         	and	#6, r5
ffe0545f:	75 35 f0                      	or	#-16, r5
ffe05462:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffe05467:	84 b5                         	mov.b	r5, 18[r3]
            g_riic0_state = _04_IIC_MASTER_SENDS_ADR_10B;
ffe05469:	f8 44 04                      	mov.b	#4, [r4]
ffe0546c:	38 9e fe                      	bra.w	ffe0530a <_Reset_Vector+0xffe0530e>
                g_riic0_state = _06_IIC_MASTER_SENDS_END;
ffe0546f:	f8 54 06                      	mov.b	#6, [r5]
ffe05472:	38 98 fe                      	bra.w	ffe0530a <_Reset_Vector+0xffe0530e>

ffe05475 <.LFE5>:
ffe05475:	fc 13 00                      	nop	; max	r0, r0

ffe05478 <_r_Config_RIIC0_receive_interrupt>:
void r_Config_RIIC0_receive_interrupt(void)
ffe05478:	7e a1                         	push.l	r1
ffe0547a:	fd 6a 01                      	mvfc	psw, r1
ffe0547d:	69 81                         	shlr	#24, r1
ffe0547f:	64 f1                         	and	#15, r1
ffe05481:	61 91                         	cmp	#9, r1
ffe05483:	22 05                         	bc.b	ffe05488 <_Reset_Vector+0xffe0548c>
ffe05485:	75 70 09                      	mvtipl	#9
ffe05488:	7f a8                         	setpsw	i
ffe0548a:	7e b1                         	pop	r1
ffe0548c:	2e 02                         	bra.b	ffe0548e <_Reset_Vector+0xffe05492>

ffe0548e <__r_Config_RIIC0_receive_interrupt>:
{
ffe0548e:	6e ef                         	pushm	r14-r15
ffe05490:	6e 15                         	pushm	r1-r5
ffe05492:	fd 1f 11                      	mvfaclo	#0, a0, r1
ffe05495:	fd 1f 02                      	mvfachi	#0, a0, r2
ffe05498:	7e a1                         	push.l	r1
ffe0549a:	7e a2                         	push.l	r2
ffe0549c:	fd 1f 31                      	mvfacgu	#0, a0, r1
ffe0549f:	fd 1f 92                      	mvfaclo	#0, a1, r2
ffe054a2:	7e a1                         	push.l	r1
ffe054a4:	7e a2                         	push.l	r2
ffe054a6:	fd 1f 81                      	mvfachi	#0, a1, r1
ffe054a9:	fd 1f b2                      	mvfacgu	#0, a1, r2
ffe054ac:	7e a1                         	push.l	r1
ffe054ae:	7e a2                         	push.l	r2
ffe054b0:	60 40                         	sub	#4, r0
    if (_08_IIC_MASTER_RECEIVES_START == g_riic0_state)
ffe054b2:	fb 42 24 04 00 00             	mov.l	#0x424, r4
ffe054b8:	58 45                         	movu.b	[r4], r5
ffe054ba:	61 85                         	cmp	#8, r5
ffe054bc:	3a b8 00                      	beq.w	ffe05574 <_Reset_Vector+0xffe05578>
    else if (_09_IIC_MASTER_RECEIVES_DATA == g_riic0_state)
ffe054bf:	58 45                         	movu.b	[r4], r5
ffe054c1:	61 95                         	cmp	#9, r5
ffe054c3:	20 5d                         	beq.b	ffe05520 <_Reset_Vector+0xffe05524>
    else if (_0A_IIC_MASTER_RECEIVES_STOPPING == g_riic0_state)
ffe054c5:	58 45                         	movu.b	[r4], r5
ffe054c7:	61 a5                         	cmp	#10, r5
ffe054c9:	21 31                         	bne.b	ffe054fa <_Reset_Vector+0xffe054fe>
        RIIC0.ICSR2.BIT.STOP = 0U;
ffe054cb:	fb 5e 00 83 08                	mov.l	#0x88300, r5
        *gp_riic0_rx_address = RIIC0.ICDRR;
ffe054d0:	fb 32 1c 04 00 00             	mov.l	#0x41c, r3
        RIIC0.ICSR2.BIT.STOP = 0U;
ffe054d6:	f1 5b 09                      	bclr	#3, 9[r5].b
        RIIC0.ICCR2.BIT.SP = 1U;
ffe054d9:	f1 53 01                      	bset	#3, 1[r5].b
        *gp_riic0_rx_address = RIIC0.ICDRR;
ffe054dc:	8c d9                         	mov.b	19[r5], r1
ffe054de:	ec 32                         	mov.l	[r3], r2
        g_riic0_rx_count++;
ffe054e0:	fb e2 18 04 00 00             	mov.l	#0x418, r14
        *gp_riic0_rx_address = RIIC0.ICDRR;
ffe054e6:	c3 21                         	mov.b	r1, [r2]
        g_riic0_rx_count++;
ffe054e8:	dc e1                         	mov.w	[r14], r1
        gp_riic0_rx_address++;
ffe054ea:	ec 32                         	mov.l	[r3], r2
        g_riic0_rx_count++;
ffe054ec:	62 11                         	add	#1, r1
        gp_riic0_rx_address++;
ffe054ee:	62 12                         	add	#1, r2
        g_riic0_rx_count++;
ffe054f0:	d3 e1                         	mov.w	r1, [r14]
        gp_riic0_rx_address++;
ffe054f2:	e3 32                         	mov.l	r2, [r3]
        RIIC0.ICMR3.BIT.WAIT = 0U;
ffe054f4:	f1 5e 04                      	bclr	#6, 4[r5].b
        g_riic0_state = _0B_IIC_MASTER_RECEIVES_STOP;
ffe054f7:	f8 44 0b                      	mov.b	#11, [r4]
}
ffe054fa:	62 40                         	add	#4, r0
ffe054fc:	7e b2                         	pop	r2
ffe054fe:	7e b1                         	pop	r1
ffe05500:	fd 17 81                      	mvtachi	r1, a1
ffe05503:	fd 17 b2                      	mvtacgu	r2, a1
ffe05506:	7e b2                         	pop	r2
ffe05508:	7e b1                         	pop	r1
ffe0550a:	fd 17 31                      	mvtacgu	r1, a0
ffe0550d:	fd 17 92                      	mvtaclo	r2, a1
ffe05510:	7e b2                         	pop	r2
ffe05512:	7e b1                         	pop	r1
ffe05514:	fd 17 11                      	mvtaclo	r1, a0
ffe05517:	fd 17 02                      	mvtachi	r2, a0
ffe0551a:	6f 15                         	popm	r1-r5
ffe0551c:	6f ef                         	popm	r14-r15
ffe0551e:	7f 95                         	rte
        if (g_riic0_rx_count < g_riic0_rx_length)
ffe05520:	fb 22 18 04 00 00             	mov.l	#0x418, r2
ffe05526:	fb 12 22 04 00 00             	mov.l	#0x422, r1
ffe0552c:	dc 23                         	mov.w	[r2], r3
ffe0552e:	dc 15                         	mov.w	[r1], r5
ffe05530:	5f 33                         	movu.w	r3, r3
ffe05532:	5f 55                         	movu.w	r5, r5
ffe05534:	47 53                         	cmp	r5, r3
ffe05536:	22 c4                         	bc.b	ffe054fa <_Reset_Vector+0xffe054fe>
            if (g_riic0_rx_count == (g_riic0_rx_length - 3))
ffe05538:	dc 23                         	mov.w	[r2], r3
ffe0553a:	dc 15                         	mov.w	[r1], r5
ffe0553c:	fb e2 1c 04 00 00             	mov.l	#0x41c, r14
ffe05542:	5f 55                         	movu.w	r5, r5
ffe05544:	5f 33                         	movu.w	r3, r3
ffe05546:	60 35                         	sub	#3, r5
ffe05548:	ec ef                         	mov.l	[r14], r15
ffe0554a:	47 53                         	cmp	r5, r3
ffe0554c:	3a 8c 00                      	beq.w	ffe055d8 <_Reset_Vector+0xffe055dc>
            else if (g_riic0_rx_count == (g_riic0_rx_length - 2))
ffe0554f:	dc 23                         	mov.w	[r2], r3
ffe05551:	dc 15                         	mov.w	[r1], r5
ffe05553:	5f 33                         	movu.w	r3, r3
ffe05555:	5f 55                         	movu.w	r5, r5
ffe05557:	60 25                         	sub	#2, r5
ffe05559:	47 53                         	cmp	r5, r3
                RIIC0.ICMR3.BIT.ACKWP = 1U;
ffe0555b:	fb 5e 00 83 08                	mov.l	#0x88300, r5
            else if (g_riic0_rx_count == (g_riic0_rx_length - 2))
ffe05560:	20 60                         	beq.b	ffe055c0 <_Reset_Vector+0xffe055c4>
                *gp_riic0_rx_address = RIIC0.ICDRR;
ffe05562:	8c dd                         	mov.b	19[r5], r5
ffe05564:	c3 f5                         	mov.b	r5, [r15]
                gp_riic0_rx_address++;
ffe05566:	ec e4                         	mov.l	[r14], r4
                g_riic0_rx_count++;
ffe05568:	dc 25                         	mov.w	[r2], r5
                gp_riic0_rx_address++;
ffe0556a:	62 14                         	add	#1, r4
                g_riic0_rx_count++;
ffe0556c:	62 15                         	add	#1, r5
                gp_riic0_rx_address++;
ffe0556e:	e3 e4                         	mov.l	r4, [r14]
                g_riic0_rx_count++;
ffe05570:	d3 25                         	mov.w	r5, [r2]
ffe05572:	2e 88                         	bra.b	ffe054fa <_Reset_Vector+0xffe054fe>
        if ((2U == g_riic0_rx_length) || (1U == g_riic0_rx_length))
ffe05574:	fb 52 22 04 00 00             	mov.l	#0x422, r5
ffe0557a:	5c 53                         	movu.w	[r5], r3
ffe0557c:	61 23                         	cmp	#2, r3
ffe0557e:	20 38                         	beq.b	ffe055b6 <_Reset_Vector+0xffe055ba>
ffe05580:	5c 53                         	movu.w	[r5], r3
ffe05582:	61 13                         	cmp	#1, r3
ffe05584:	20 32                         	beq.b	ffe055b6 <_Reset_Vector+0xffe055ba>
ffe05586:	ef 00                         	nop	; mov.l	r0, r0
        if (1U == g_riic0_rx_length)
ffe05588:	5c 53                         	movu.w	[r5], r3
ffe0558a:	61 13                         	cmp	#1, r3
ffe0558c:	21 0d                         	bne.b	ffe05599 <_Reset_Vector+0xffe0559d>
            RIIC0.ICMR3.BIT.ACKWP = 1U;
ffe0558e:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffe05593:	f1 34 04                      	bset	#4, 4[r3].b
            RIIC0.ICMR3.BIT.ACKBT = 1U;
ffe05596:	f1 33 04                      	bset	#3, 4[r3].b
        dummy = RIIC0.ICDRR;
ffe05599:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffe0559e:	8c bb                         	mov.b	19[r3], r3
ffe055a0:	c3 03                         	mov.b	r3, [r0]
        g_riic0_state = _09_IIC_MASTER_RECEIVES_DATA;
ffe055a2:	f8 44 09                      	mov.b	#9, [r4]
        if (1U == g_riic0_rx_length)
ffe055a5:	5c 55                         	movu.w	[r5], r5
ffe055a7:	61 15                         	cmp	#1, r5
ffe055a9:	3b 51 ff                      	bne.w	ffe054fa <_Reset_Vector+0xffe054fe>
ffe055ac:	76 10 01 00                   	nop	; mul	#1, r0
                g_riic0_state = _0A_IIC_MASTER_RECEIVES_STOPPING;
ffe055b0:	f8 44 0a                      	mov.b	#10, [r4]
ffe055b3:	38 47 ff                      	bra.w	ffe054fa <_Reset_Vector+0xffe054fe>
            RIIC0.ICMR3.BIT.WAIT = 1U;
ffe055b6:	fb 3e 00 83 08                	mov.l	#0x88300, r3
ffe055bb:	f1 36 04                      	bset	#6, 4[r3].b
ffe055be:	2e ca                         	bra.b	ffe05588 <_Reset_Vector+0xffe0558c>
                RIIC0.ICMR3.BIT.ACKWP = 1U;
ffe055c0:	f1 54 04                      	bset	#4, 4[r5].b
                RIIC0.ICMR3.BIT.ACKBT = 1U;
ffe055c3:	f1 53 04                      	bset	#3, 4[r5].b
                *gp_riic0_rx_address = RIIC0.ICDRR;
ffe055c6:	8c dd                         	mov.b	19[r5], r5
ffe055c8:	c3 f5                         	mov.b	r5, [r15]
                g_riic0_rx_count++;
ffe055ca:	dc 23                         	mov.w	[r2], r3
                gp_riic0_rx_address++;
ffe055cc:	ec e5                         	mov.l	[r14], r5
                g_riic0_rx_count++;
ffe055ce:	62 13                         	add	#1, r3
                gp_riic0_rx_address++;
ffe055d0:	62 15                         	add	#1, r5
                g_riic0_rx_count++;
ffe055d2:	d3 23                         	mov.w	r3, [r2]
                gp_riic0_rx_address++;
ffe055d4:	e3 e5                         	mov.l	r5, [r14]
ffe055d6:	2e da                         	bra.b	ffe055b0 <_Reset_Vector+0xffe055b4>
                RIIC0.ICMR3.BIT.WAIT = 1U;
ffe055d8:	fb 5e 00 83 08                	mov.l	#0x88300, r5
ffe055dd:	f1 56 04                      	bset	#6, 4[r5].b
                *gp_riic0_rx_address = RIIC0.ICDRR;
ffe055e0:	2e 82                         	bra.b	ffe05562 <_Reset_Vector+0xffe05566>

ffe055e2 <.LFE8>:
ffe055e2:	74 10 01 00 00 00             	nop	; mul	#1, r0

ffe055e8 <_r_Config_MTU3_MTU4_tgia3_interrupt>:
* Description  : This function is TGIA3 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_tgia3_interrupt(void)
ffe055e8:	7f a8                         	setpsw	i
ffe055ea:	2e 02                         	bra.b	ffe055ec <_Reset_Vector+0xffe055f0>

ffe055ec <__r_Config_MTU3_MTU4_tgia3_interrupt>:
{
ffe055ec:	6e de                         	pushm	r13-r14
ffe055ee:	fd 1f 1d                      	mvfaclo	#0, a0, r13
ffe055f1:	fd 1f 0e                      	mvfachi	#0, a0, r14
ffe055f4:	6e de                         	pushm	r13-r14
ffe055f6:	fd 1f 3d                      	mvfacgu	#0, a0, r13
ffe055f9:	fd 1f 9e                      	mvfaclo	#0, a1, r14
ffe055fc:	6e de                         	pushm	r13-r14
ffe055fe:	fd 1f 8d                      	mvfachi	#0, a1, r13
ffe05601:	fd 1f be                      	mvfacgu	#0, a1, r14
ffe05604:	6e de                         	pushm	r13-r14
    /* Start user code for r_Config_MTU3_MTU4_tgia3_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffe05606:	6f de                         	popm	r13-r14
ffe05608:	fd 17 8d                      	mvtachi	r13, a1
ffe0560b:	fd 17 be                      	mvtacgu	r14, a1
ffe0560e:	6f de                         	popm	r13-r14
ffe05610:	fd 17 3d                      	mvtacgu	r13, a0
ffe05613:	fd 17 9e                      	mvtaclo	r14, a1
ffe05616:	6f de                         	popm	r13-r14
ffe05618:	fd 17 1d                      	mvtaclo	r13, a0
ffe0561b:	fd 17 0e                      	mvtachi	r14, a0
ffe0561e:	6f de                         	popm	r13-r14
ffe05620:	7f 95                         	rte

ffe05622 <_r_Config_MTU3_MTU4_c4_tgia4_interrupt>:
* Description  : This function is TGIA4 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_c4_tgia4_interrupt(void)
ffe05622:	7f a8                         	setpsw	i
ffe05624:	2e 02                         	bra.b	ffe05626 <_Reset_Vector+0xffe0562a>

ffe05626 <__r_Config_MTU3_MTU4_c4_tgia4_interrupt>:
{
ffe05626:	6e de                         	pushm	r13-r14
ffe05628:	fd 1f 1d                      	mvfaclo	#0, a0, r13
ffe0562b:	fd 1f 0e                      	mvfachi	#0, a0, r14
ffe0562e:	6e de                         	pushm	r13-r14
ffe05630:	fd 1f 3d                      	mvfacgu	#0, a0, r13
ffe05633:	fd 1f 9e                      	mvfaclo	#0, a1, r14
ffe05636:	6e de                         	pushm	r13-r14
ffe05638:	fd 1f 8d                      	mvfachi	#0, a1, r13
ffe0563b:	fd 1f be                      	mvfacgu	#0, a1, r14
ffe0563e:	6e de                         	pushm	r13-r14
    /* Start user code for r_Config_MTU3_MTU4_c4_tgia4_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffe05640:	6f de                         	popm	r13-r14
ffe05642:	fd 17 8d                      	mvtachi	r13, a1
ffe05645:	fd 17 be                      	mvtacgu	r14, a1
ffe05648:	6f de                         	popm	r13-r14
ffe0564a:	fd 17 3d                      	mvtacgu	r13, a0
ffe0564d:	fd 17 9e                      	mvtaclo	r14, a1
ffe05650:	6f de                         	popm	r13-r14
ffe05652:	fd 17 1d                      	mvtaclo	r13, a0
ffe05655:	fd 17 0e                      	mvtachi	r14, a0
ffe05658:	6f de                         	popm	r13-r14
ffe0565a:	7f 95                         	rte

ffe0565c <_r_Config_MTU3_MTU4_tgib3_interrupt>:
* Description  : This function is TGIB3 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_tgib3_interrupt(void)
ffe0565c:	7f a8                         	setpsw	i
ffe0565e:	2e 02                         	bra.b	ffe05660 <_Reset_Vector+0xffe05664>

ffe05660 <__r_Config_MTU3_MTU4_tgib3_interrupt>:
{
ffe05660:	6e de                         	pushm	r13-r14
ffe05662:	fd 1f 1d                      	mvfaclo	#0, a0, r13
ffe05665:	fd 1f 0e                      	mvfachi	#0, a0, r14
ffe05668:	6e de                         	pushm	r13-r14
ffe0566a:	fd 1f 3d                      	mvfacgu	#0, a0, r13
ffe0566d:	fd 1f 9e                      	mvfaclo	#0, a1, r14
ffe05670:	6e de                         	pushm	r13-r14
ffe05672:	fd 1f 8d                      	mvfachi	#0, a1, r13
ffe05675:	fd 1f be                      	mvfacgu	#0, a1, r14
ffe05678:	6e de                         	pushm	r13-r14
    /* Start user code for r_Config_MTU3_MTU4_tgib3_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffe0567a:	6f de                         	popm	r13-r14
ffe0567c:	fd 17 8d                      	mvtachi	r13, a1
ffe0567f:	fd 17 be                      	mvtacgu	r14, a1
ffe05682:	6f de                         	popm	r13-r14
ffe05684:	fd 17 3d                      	mvtacgu	r13, a0
ffe05687:	fd 17 9e                      	mvtaclo	r14, a1
ffe0568a:	6f de                         	popm	r13-r14
ffe0568c:	fd 17 1d                      	mvtaclo	r13, a0
ffe0568f:	fd 17 0e                      	mvtachi	r14, a0
ffe05692:	6f de                         	popm	r13-r14
ffe05694:	7f 95                         	rte

ffe05696 <_r_Config_MTU3_MTU4_c4_tgib4_interrupt>:
* Description  : This function is TGIB4 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_c4_tgib4_interrupt(void)
ffe05696:	7f a8                         	setpsw	i
ffe05698:	2e 02                         	bra.b	ffe0569a <_Reset_Vector+0xffe0569e>

ffe0569a <__r_Config_MTU3_MTU4_c4_tgib4_interrupt>:
{
ffe0569a:	6e de                         	pushm	r13-r14
ffe0569c:	fd 1f 1d                      	mvfaclo	#0, a0, r13
ffe0569f:	fd 1f 0e                      	mvfachi	#0, a0, r14
ffe056a2:	6e de                         	pushm	r13-r14
ffe056a4:	fd 1f 3d                      	mvfacgu	#0, a0, r13
ffe056a7:	fd 1f 9e                      	mvfaclo	#0, a1, r14
ffe056aa:	6e de                         	pushm	r13-r14
ffe056ac:	fd 1f 8d                      	mvfachi	#0, a1, r13
ffe056af:	fd 1f be                      	mvfacgu	#0, a1, r14
ffe056b2:	6e de                         	pushm	r13-r14
    /* Start user code for r_Config_MTU3_MTU4_c4_tgib4_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffe056b4:	6f de                         	popm	r13-r14
ffe056b6:	fd 17 8d                      	mvtachi	r13, a1
ffe056b9:	fd 17 be                      	mvtacgu	r14, a1
ffe056bc:	6f de                         	popm	r13-r14
ffe056be:	fd 17 3d                      	mvtacgu	r13, a0
ffe056c1:	fd 17 9e                      	mvtaclo	r14, a1
ffe056c4:	6f de                         	popm	r13-r14
ffe056c6:	fd 17 1d                      	mvtaclo	r13, a0
ffe056c9:	fd 17 0e                      	mvtachi	r14, a0
ffe056cc:	6f de                         	popm	r13-r14
ffe056ce:	7f 95                         	rte

ffe056d0 <_r_Config_MTU3_MTU4_c4_tciv4_interrupt>:
* Description  : This function is TCIV4 interrupt service routine
* Arguments    : None
* Return Value : None
***********************************************************************************************************************/

void r_Config_MTU3_MTU4_c4_tciv4_interrupt(void)
ffe056d0:	7f a8                         	setpsw	i
ffe056d2:	2e 02                         	bra.b	ffe056d4 <_Reset_Vector+0xffe056d8>

ffe056d4 <__r_Config_MTU3_MTU4_c4_tciv4_interrupt>:
{
ffe056d4:	6e de                         	pushm	r13-r14
ffe056d6:	fd 1f 1d                      	mvfaclo	#0, a0, r13
ffe056d9:	fd 1f 0e                      	mvfachi	#0, a0, r14
ffe056dc:	6e de                         	pushm	r13-r14
ffe056de:	fd 1f 3d                      	mvfacgu	#0, a0, r13
ffe056e1:	fd 1f 9e                      	mvfaclo	#0, a1, r14
ffe056e4:	6e de                         	pushm	r13-r14
ffe056e6:	fd 1f 8d                      	mvfachi	#0, a1, r13
ffe056e9:	fd 1f be                      	mvfacgu	#0, a1, r14
ffe056ec:	6e de                         	pushm	r13-r14
    /* Start user code for r_Config_MTU3_MTU4_c4_tciv4_interrupt. Do not edit comment generated here */
    /* End user code. Do not edit comment generated here */
}
ffe056ee:	6f de                         	popm	r13-r14
ffe056f0:	fd 17 8d                      	mvtachi	r13, a1
ffe056f3:	fd 17 be                      	mvtacgu	r14, a1
ffe056f6:	6f de                         	popm	r13-r14
ffe056f8:	fd 17 3d                      	mvtacgu	r13, a0
ffe056fb:	fd 17 9e                      	mvtaclo	r14, a1
ffe056fe:	6f de                         	popm	r13-r14
ffe05700:	fd 17 1d                      	mvtaclo	r13, a0
ffe05703:	fd 17 0e                      	mvtachi	r14, a0
ffe05706:	6f de                         	popm	r13-r14
ffe05708:	7f 95                         	rte

ffe0570a <__trap0_isr>:
#endif
#endif

uint32_t debug = 0x5a5a5a5a;

R_BSP_PRAGMA_STATIC_INTERRUPT(trap0_isr, VECT(TRAP, 0))
ffe0570a:	7e a1                         	push.l	r1
ffe0570c:	fd 6a 01                      	mvfc	psw, r1
ffe0570f:	69 81                         	shlr	#24, r1
ffe05711:	64 f1                         	and	#15, r1
ffe05713:	61 91                         	cmp	#9, r1
ffe05715:	22 05                         	bc.b	ffe0571a <_Reset_Vector+0xffe0571e>
ffe05717:	75 70 09                      	mvtipl	#9
ffe0571a:	7f a8                         	setpsw	i
ffe0571c:	7e b1                         	pop	r1
ffe0571e:	2e 02                         	bra.b	ffe05720 <_Reset_Vector+0xffe05724>

ffe05720 <_trap0_isr>:
R_BSP_ATTRIB_STATIC_INTERRUPT void trap0_isr(void)
{
ffe05720:	6e 56                         	pushm	r5-r6
ffe05722:	fd 1f 15                      	mvfaclo	#0, a0, r5
ffe05725:	fd 1f 06                      	mvfachi	#0, a0, r6
ffe05728:	6e 56                         	pushm	r5-r6
ffe0572a:	fd 1f 35                      	mvfacgu	#0, a0, r5
ffe0572d:	fd 1f 96                      	mvfaclo	#0, a1, r6
ffe05730:	6e 56                         	pushm	r5-r6
ffe05732:	fd 1f 85                      	mvfachi	#0, a1, r5
ffe05735:	fd 1f b6                      	mvfacgu	#0, a1, r6
ffe05738:	6e 56                         	pushm	r5-r6
    debug = 0; _acc_();
ffe0573a:	fb 52 20 00 00 00             	mov.l	#32, r5
ffe05740:	f8 56 00                      	mov.l	#0, [r5]
}
ffe05743:	6f 56                         	popm	r5-r6
ffe05745:	fd 17 85                      	mvtachi	r5, a1
ffe05748:	fd 17 b6                      	mvtacgu	r6, a1
ffe0574b:	6f 56                         	popm	r5-r6
ffe0574d:	fd 17 35                      	mvtacgu	r5, a0
ffe05750:	fd 17 96                      	mvtaclo	r6, a1
ffe05753:	6f 56                         	popm	r5-r6
ffe05755:	fd 17 15                      	mvtaclo	r5, a0
ffe05758:	fd 17 06                      	mvtachi	r6, a0
ffe0575b:	6f 56                         	popm	r5-r6
ffe0575d:	7f 95                         	rte

ffe0575f <_trap1_isr>:

void trap1_isr(void) __attribute__ ((interrupt(".rvectors", VECT(TRAP, 1))));
/**/
#define trap1_isr(...) R_CG_ATTRIB_INTERRUPT_EHI(trap1_isr, __VA_ARGS__)
/**/
void trap1_isr(void)
ffe0575f:	7e a1                         	push.l	r1
ffe05761:	fd 6a 01                      	mvfc	psw, r1
ffe05764:	69 81                         	shlr	#24, r1
ffe05766:	64 f1                         	and	#15, r1
ffe05768:	61 91                         	cmp	#9, r1
ffe0576a:	22 05                         	bc.b	ffe0576f <_Reset_Vector+0xffe05773>
ffe0576c:	75 70 09                      	mvtipl	#9
ffe0576f:	7f a8                         	setpsw	i
ffe05771:	7e b1                         	pop	r1
ffe05773:	2e 02                         	bra.b	ffe05775 <_Reset_Vector+0xffe05779>

ffe05775 <__trap1_isr>:
{
ffe05775:	6e 56                         	pushm	r5-r6
ffe05777:	fd 1f 15                      	mvfaclo	#0, a0, r5
ffe0577a:	fd 1f 06                      	mvfachi	#0, a0, r6
ffe0577d:	6e 56                         	pushm	r5-r6
ffe0577f:	fd 1f 35                      	mvfacgu	#0, a0, r5
ffe05782:	fd 1f 96                      	mvfaclo	#0, a1, r6
ffe05785:	6e 56                         	pushm	r5-r6
ffe05787:	fd 1f 85                      	mvfachi	#0, a1, r5
ffe0578a:	fd 1f b6                      	mvfacgu	#0, a1, r6
ffe0578d:	6e 56                         	pushm	r5-r6
    debug = 1; _acc_();
ffe0578f:	fb 52 20 00 00 00             	mov.l	#32, r5
ffe05795:	f8 56 01                      	mov.l	#1, [r5]
}
ffe05798:	6f 56                         	popm	r5-r6
ffe0579a:	fd 17 85                      	mvtachi	r5, a1
ffe0579d:	fd 17 b6                      	mvtacgu	r6, a1
ffe057a0:	6f 56                         	popm	r5-r6
ffe057a2:	fd 17 35                      	mvtacgu	r5, a0
ffe057a5:	fd 17 96                      	mvtaclo	r6, a1
ffe057a8:	6f 56                         	popm	r5-r6
ffe057aa:	fd 17 15                      	mvtaclo	r5, a0
ffe057ad:	fd 17 06                      	mvtachi	r6, a0
ffe057b0:	6f 56                         	popm	r5-r6
ffe057b2:	7f 95                         	rte

ffe057b4 <_trap2_isr>:

void trap2_isr(void) __attribute__ ((interrupt(".rvectors", VECT(TRAP, 2))));
/**/
#define trap2_isr(...) R_CG_ATTRIB_INTERRUPT_EI(trap2_isr, __VA_ARGS__)
/**/
void trap2_isr(void)
ffe057b4:	7f a8                         	setpsw	i
ffe057b6:	2e 02                         	bra.b	ffe057b8 <_Reset_Vector+0xffe057bc>

ffe057b8 <__trap2_isr>:
{
ffe057b8:	6e 56                         	pushm	r5-r6
ffe057ba:	fd 1f 15                      	mvfaclo	#0, a0, r5
ffe057bd:	fd 1f 06                      	mvfachi	#0, a0, r6
ffe057c0:	6e 56                         	pushm	r5-r6
ffe057c2:	fd 1f 35                      	mvfacgu	#0, a0, r5
ffe057c5:	fd 1f 96                      	mvfaclo	#0, a1, r6
ffe057c8:	6e 56                         	pushm	r5-r6
ffe057ca:	fd 1f 85                      	mvfachi	#0, a1, r5
ffe057cd:	fd 1f b6                      	mvfacgu	#0, a1, r6
ffe057d0:	6e 56                         	pushm	r5-r6
    debug = 2; _acc_();
ffe057d2:	fb 52 20 00 00 00             	mov.l	#32, r5
ffe057d8:	f8 56 02                      	mov.l	#2, [r5]
}
ffe057db:	6f 56                         	popm	r5-r6
ffe057dd:	fd 17 85                      	mvtachi	r5, a1
ffe057e0:	fd 17 b6                      	mvtacgu	r6, a1
ffe057e3:	6f 56                         	popm	r5-r6
ffe057e5:	fd 17 35                      	mvtacgu	r5, a0
ffe057e8:	fd 17 96                      	mvtaclo	r6, a1
ffe057eb:	6f 56                         	popm	r5-r6
ffe057ed:	fd 17 15                      	mvtaclo	r5, a0
ffe057f0:	fd 17 06                      	mvtachi	r6, a0
ffe057f3:	6f 56                         	popm	r5-r6
ffe057f5:	7f 95                         	rte

ffe057f7 <.LFE9>:
	...

ffe057f8 <__COM_DIV64u>:
ffe057f8:	6e 6c                         	pushm	r6-r12
ffe057fa:	61 04                         	cmp	#0, r4
ffe057fc:	3b 6e 01                      	bne.w	ffe0596a <_Reset_Vector+0xffe0596e>
ffe057ff:	ef 45                         	mov.l	r4, r5
ffe05801:	ef 3f                         	mov.l	r3, r15
ffe05803:	ef 17                         	mov.l	r1, r7
ffe05805:	47 23                         	cmp	r2, r3
ffe05807:	24 05                         	bgtu.b	ffe0580c <_Reset_Vector+0xffe05810>
ffe05809:	38 b6 00                      	bra.w	ffe058bf <_Reset_Vector+0xffe058c3>
ffe0580c:	ef 2a                         	mov.l	r2, r10
ffe0580e:	77 03 ff ff 00                	cmp	#0xffff, r3
ffe05813:	24 05                         	bgtu.b	ffe05818 <_Reset_Vector+0xffe0581c>
ffe05815:	38 bd 01                      	bra.w	ffe059d2 <_Reset_Vector+0xffe059d6>
ffe05818:	74 03 ff ff ff 00             	cmp	#0xffffff, r3
ffe0581e:	24 05                         	bgtu.b	ffe05823 <_Reset_Vector+0xffe05827>
ffe05820:	38 69 03                      	bra.w	ffe05b89 <_Reset_Vector+0xffe05b8d>
ffe05823:	fd 98 36                      	shlr	#24, r3, r6
ffe05826:	75 45 18                      	mov.l	#24, r5
ffe05829:	fb 42 48 66 e0 ff             	mov.l	#0xffe06648, r4
ffe0582f:	fe c6 44                      	movu.b	[r6, r4], r4
ffe05832:	4b 45                         	add	r4, r5
ffe05834:	75 46 20                      	mov.l	#32, r6
ffe05837:	43 56                         	sub	r5, r6
ffe05839:	20 18                         	beq.b	ffe05851 <_Reset_Vector+0xffe05855>
ffe0583b:	ef 2e                         	mov.l	r2, r14
ffe0583d:	fd 62 6e                      	shll	r6, r14
ffe05840:	ef 1a                         	mov.l	r1, r10
ffe05842:	fd 60 5a                      	shlr	r5, r10
ffe05845:	ef 3f                         	mov.l	r3, r15
ffe05847:	fd 62 6f                      	shll	r6, r15
ffe0584a:	57 ea                         	or	r14, r10
ffe0584c:	ef 17                         	mov.l	r1, r7
ffe0584e:	fd 62 67                      	shll	r6, r7
ffe05851:	fd 90 f2                      	shlr	#16, r15, r2
ffe05854:	fb 6e ff ff 00                	mov.l	#0xffff, r6
ffe05859:	53 f6                         	and	r15, r6
ffe0585b:	ef a5                         	mov.l	r10, r5
ffe0585d:	fc 27 25                      	divu	r2, r5
ffe05860:	ff 34 25                      	mul 	r2, r5, r4
ffe05863:	43 4a                         	sub	r4, r10
ffe05865:	fd d0 a4                      	shll	#16, r10, r4
ffe05868:	fd 90 7a                      	shlr	#16, r7, r10
ffe0586b:	ff 33 56                      	mul 	r5, r6, r3
ffe0586e:	57 4a                         	or	r4, r10
ffe05870:	47 a3                         	cmp	r10, r3
ffe05872:	25 14                         	bleu.b	ffe05886 <_Reset_Vector+0xffe0588a>
ffe05874:	4b fa                         	add	r15, r10
ffe05876:	71 54 ff                      	add	#-1, r5, r4
ffe05879:	47 af                         	cmp	r10, r15
ffe0587b:	24 09                         	bgtu.b	ffe05884 <_Reset_Vector+0xffe05888>
ffe0587d:	47 a3                         	cmp	r10, r3
ffe0587f:	25 05                         	bleu.b	ffe05884 <_Reset_Vector+0xffe05888>
ffe05881:	38 34 03                      	bra.w	ffe05bb5 <_Reset_Vector+0xffe05bb9>
ffe05884:	ef 45                         	mov.l	r4, r5
ffe05886:	43 3a                         	sub	r3, r10
ffe05888:	77 27 ff ff 00                	and	#0xffff, r7
ffe0588d:	ef a1                         	mov.l	r10, r1
ffe0588f:	fc 27 21                      	divu	r2, r1
ffe05892:	4f 12                         	mul	r1, r2
ffe05894:	43 2a                         	sub	r2, r10
ffe05896:	ef 13                         	mov.l	r1, r3
ffe05898:	6d 0a                         	shll	#16, r10
ffe0589a:	ff 32 16                      	mul 	r1, r6, r2
ffe0589d:	57 a7                         	or	r10, r7
ffe0589f:	47 72                         	cmp	r7, r2
ffe058a1:	25 14                         	bleu.b	ffe058b5 <_Reset_Vector+0xffe058b9>
ffe058a3:	4b f7                         	add	r15, r7
ffe058a5:	71 1a ff                      	add	#-1, r1, r10
ffe058a8:	47 7f                         	cmp	r7, r15
ffe058aa:	24 09                         	bgtu.b	ffe058b3 <_Reset_Vector+0xffe058b7>
ffe058ac:	47 72                         	cmp	r7, r2
ffe058ae:	25 05                         	bleu.b	ffe058b3 <_Reset_Vector+0xffe058b7>
ffe058b0:	38 00 03                      	bra.w	ffe05bb0 <_Reset_Vector+0xffe05bb4>
ffe058b3:	ef a3                         	mov.l	r10, r3
ffe058b5:	fd d0 51                      	shll	#16, r5, r1
ffe058b8:	66 02                         	mov.l	#0, r2
ffe058ba:	57 31                         	or	r3, r1
ffe058bc:	3f 6c 07                      	rtsd	#28, r6-r12
ffe058bf:	61 03                         	cmp	#0, r3
ffe058c1:	1f                            	bne.s	ffe058c8 <_Reset_Vector+0xffe058cc>
ffe058c2:	66 1f                         	mov.l	#1, r15
ffe058c4:	fd 74 9f 00                   	divu	#0, r15
ffe058c8:	77 0f ff ff 00                	cmp	#0xffff, r15
ffe058cd:	24 05                         	bgtu.b	ffe058d2 <_Reset_Vector+0xffe058d6>
ffe058cf:	38 f3 00                      	bra.w	ffe059c2 <_Reset_Vector+0xffe059c6>
ffe058d2:	74 0f ff ff ff 00             	cmp	#0xffffff, r15
ffe058d8:	24 05                         	bgtu.b	ffe058dd <_Reset_Vector+0xffe058e1>
ffe058da:	38 a6 02                      	bra.w	ffe05b80 <_Reset_Vector+0xffe05b84>
ffe058dd:	fd 98 f4                      	shlr	#24, r15, r4
ffe058e0:	75 45 18                      	mov.l	#24, r5
ffe058e3:	77 10 01 00 00                	nop	; mul	#1, r0
ffe058e8:	fb a2 48 66 e0 ff             	mov.l	#0xffe06648, r10
ffe058ee:	fe c4 a4                      	movu.b	[r4, r10], r4
ffe058f1:	4b 54                         	add	r5, r4
ffe058f3:	75 43 20                      	mov.l	#32, r3
ffe058f6:	43 43                         	sub	r4, r3
ffe058f8:	3b ea 00                      	bne.w	ffe059e2 <_Reset_Vector+0xffe059e6>
ffe058fb:	ff 0e f2                      	sub	r15, r2, r14
ffe058fe:	fd 90 f6                      	shlr	#16, r15, r6
ffe05901:	fb ae ff ff 00                	mov.l	#0xffff, r10
ffe05906:	53 fa                         	and	r15, r10
ffe05908:	66 12                         	mov.l	#1, r2
ffe0590a:	ef e5                         	mov.l	r14, r5
ffe0590c:	fc 27 65                      	divu	r6, r5
ffe0590f:	ff 34 65                      	mul 	r6, r5, r4
ffe05912:	43 4e                         	sub	r4, r14
ffe05914:	6d 0e                         	shll	#16, r14
ffe05916:	fd 90 74                      	shlr	#16, r7, r4
ffe05919:	ff 33 a5                      	mul 	r10, r5, r3
ffe0591c:	57 e4                         	or	r14, r4
ffe0591e:	47 43                         	cmp	r4, r3
ffe05920:	25 14                         	bleu.b	ffe05934 <_Reset_Vector+0xffe05938>
ffe05922:	4b f4                         	add	r15, r4
ffe05924:	71 51 ff                      	add	#-1, r5, r1
ffe05927:	47 4f                         	cmp	r4, r15
ffe05929:	24 09                         	bgtu.b	ffe05932 <_Reset_Vector+0xffe05936>
ffe0592b:	47 43                         	cmp	r4, r3
ffe0592d:	25 05                         	bleu.b	ffe05932 <_Reset_Vector+0xffe05936>
ffe0592f:	38 8d 02                      	bra.w	ffe05bbc <_Reset_Vector+0xffe05bc0>
ffe05932:	ef 15                         	mov.l	r1, r5
ffe05934:	43 34                         	sub	r3, r4
ffe05936:	77 27 ff ff 00                	and	#0xffff, r7
ffe0593b:	ef 41                         	mov.l	r4, r1
ffe0593d:	fc 27 61                      	divu	r6, r1
ffe05940:	4f 16                         	mul	r1, r6
ffe05942:	43 64                         	sub	r6, r4
ffe05944:	ef 13                         	mov.l	r1, r3
ffe05946:	6d 04                         	shll	#16, r4
ffe05948:	4f 1a                         	mul	r1, r10
ffe0594a:	57 74                         	or	r7, r4
ffe0594c:	47 4a                         	cmp	r4, r10
ffe0594e:	25 14                         	bleu.b	ffe05962 <_Reset_Vector+0xffe05966>
ffe05950:	4b f4                         	add	r15, r4
ffe05952:	71 17 ff                      	add	#-1, r1, r7
ffe05955:	47 4f                         	cmp	r4, r15
ffe05957:	24 09                         	bgtu.b	ffe05960 <_Reset_Vector+0xffe05964>
ffe05959:	47 4a                         	cmp	r4, r10
ffe0595b:	25 05                         	bleu.b	ffe05960 <_Reset_Vector+0xffe05964>
ffe0595d:	38 4e 02                      	bra.w	ffe05bab <_Reset_Vector+0xffe05baf>
ffe05960:	ef 73                         	mov.l	r7, r3
ffe05962:	fd d0 51                      	shll	#16, r5, r1
ffe05965:	57 31                         	or	r3, r1
ffe05967:	3f 6c 07                      	rtsd	#28, r6-r12
ffe0596a:	47 24                         	cmp	r2, r4
ffe0596c:	24 40                         	bgtu.b	ffe059ac <_Reset_Vector+0xffe059b0>
ffe0596e:	77 04 ff ff 00                	cmp	#0xffff, r4
ffe05973:	25 40                         	bleu.b	ffe059b3 <_Reset_Vector+0xffe059b7>
ffe05975:	74 04 ff ff ff 00             	cmp	#0xffffff, r4
ffe0597b:	24 05                         	bgtu.b	ffe05980 <_Reset_Vector+0xffe05984>
ffe0597d:	38 e7 01                      	bra.w	ffe05b64 <_Reset_Vector+0xffe05b68>
ffe05980:	fd 98 45                      	shlr	#24, r4, r5
ffe05983:	75 4a 18                      	mov.l	#24, r10
ffe05986:	ef 00                         	nop	; mov.l	r0, r0
ffe05988:	fb 72 48 66 e0 ff             	mov.l	#0xffe06648, r7
ffe0598e:	fe c5 75                      	movu.b	[r5, r7], r5
ffe05991:	4b a5                         	add	r10, r5
ffe05993:	75 4a 20                      	mov.l	#32, r10
ffe05996:	43 5a                         	sub	r5, r10
ffe05998:	3b dd 00                      	bne.w	ffe05a75 <_Reset_Vector+0xffe05a79>
ffe0599b:	47 24                         	cmp	r2, r4
ffe0599d:	22 05                         	bc.b	ffe059a2 <_Reset_Vector+0xffe059a6>
ffe0599f:	38 ce 01                      	bra.w	ffe05b6d <_Reset_Vector+0xffe05b71>
ffe059a2:	47 13                         	cmp	r1, r3
ffe059a4:	fc db 15                      	scleu.l	r1
ffe059a7:	66 02                         	mov.l	#0, r2
ffe059a9:	3f 6c 07                      	rtsd	#28, r6-r12
ffe059ac:	66 02                         	mov.l	#0, r2
ffe059ae:	66 01                         	mov.l	#0, r1
ffe059b0:	3f 6c 07                      	rtsd	#28, r6-r12
ffe059b3:	75 54 ff                      	cmp	#255, r4
ffe059b6:	24 05                         	bgtu.b	ffe059bb <_Reset_Vector+0xffe059bf>
ffe059b8:	38 bc 01                      	bra.w	ffe05b74 <_Reset_Vector+0xffe05b78>
ffe059bb:	fd 88 45                      	shlr	#8, r4, r5
ffe059be:	66 8a                         	mov.l	#8, r10
ffe059c0:	2e c8                         	bra.b	ffe05988 <_Reset_Vector+0xffe0598c>
ffe059c2:	75 5f ff                      	cmp	#255, r15
ffe059c5:	24 05                         	bgtu.b	ffe059ca <_Reset_Vector+0xffe059ce>
ffe059c7:	38 cb 01                      	bra.w	ffe05b92 <_Reset_Vector+0xffe05b96>
ffe059ca:	fd 88 f4                      	shlr	#8, r15, r4
ffe059cd:	66 85                         	mov.l	#8, r5
ffe059cf:	38 19 ff                      	bra.w	ffe058e8 <_Reset_Vector+0xffe058ec>
ffe059d2:	75 53 ff                      	cmp	#255, r3
ffe059d5:	24 05                         	bgtu.b	ffe059da <_Reset_Vector+0xffe059de>
ffe059d7:	38 a4 01                      	bra.w	ffe05b7b <_Reset_Vector+0xffe05b7f>
ffe059da:	fd 88 36                      	shlr	#8, r3, r6
ffe059dd:	66 85                         	mov.l	#8, r5
ffe059df:	38 4a fe                      	bra.w	ffe05829 <_Reset_Vector+0xffe0582d>
ffe059e2:	fd 62 3f                      	shll	r3, r15
ffe059e5:	ef 25                         	mov.l	r2, r5
ffe059e7:	fd 60 45                      	shlr	r4, r5
ffe059ea:	fd 90 f6                      	shlr	#16, r15, r6
ffe059ed:	ef 2e                         	mov.l	r2, r14
ffe059ef:	fd 62 3e                      	shll	r3, r14
ffe059f2:	ef 57                         	mov.l	r5, r7
ffe059f4:	fc 27 67                      	divu	r6, r7
ffe059f7:	ef 12                         	mov.l	r1, r2
ffe059f9:	fd 60 42                      	shlr	r4, r2
ffe059fc:	ff 3b 67                      	mul 	r6, r7, r11
ffe059ff:	57 2e                         	or	r2, r14
ffe05a01:	43 b5                         	sub	r11, r5
ffe05a03:	fb ae ff ff 00                	mov.l	#0xffff, r10
ffe05a08:	53 fa                         	and	r15, r10
ffe05a0a:	ef 74                         	mov.l	r7, r4
ffe05a0c:	6d 05                         	shll	#16, r5
ffe05a0e:	fd 90 e7                      	shlr	#16, r14, r7
ffe05a11:	ff 32 4a                      	mul 	r4, r10, r2
ffe05a14:	57 75                         	or	r7, r5
ffe05a16:	ef 17                         	mov.l	r1, r7
ffe05a18:	fd 62 37                      	shll	r3, r7
ffe05a1b:	47 52                         	cmp	r5, r2
ffe05a1d:	25 19                         	bleu.b	ffe05a36 <_Reset_Vector+0xffe05a3a>
ffe05a1f:	4b f5                         	add	r15, r5
ffe05a21:	71 43 ff                      	add	#-1, r4, r3
ffe05a24:	47 5f                         	cmp	r5, r15
ffe05a26:	25 05                         	bleu.b	ffe05a2b <_Reset_Vector+0xffe05a2f>
ffe05a28:	38 7e 01                      	bra.w	ffe05ba6 <_Reset_Vector+0xffe05baa>
ffe05a2b:	47 52                         	cmp	r5, r2
ffe05a2d:	24 05                         	bgtu.b	ffe05a32 <_Reset_Vector+0xffe05a36>
ffe05a2f:	38 77 01                      	bra.w	ffe05ba6 <_Reset_Vector+0xffe05baa>
ffe05a32:	60 24                         	sub	#2, r4
ffe05a34:	4b f5                         	add	r15, r5
ffe05a36:	43 25                         	sub	r2, r5
ffe05a38:	fb 3e ff ff 00                	mov.l	#0xffff, r3
ffe05a3d:	53 e3                         	and	r14, r3
ffe05a3f:	ef 52                         	mov.l	r5, r2
ffe05a41:	fc 27 62                      	divu	r6, r2
ffe05a44:	ff 3e 62                      	mul 	r6, r2, r14
ffe05a47:	43 e5                         	sub	r14, r5
ffe05a49:	fd d0 5e                      	shll	#16, r5, r14
ffe05a4c:	ff 35 2a                      	mul 	r2, r10, r5
ffe05a4f:	57 3e                         	or	r3, r14
ffe05a51:	47 e5                         	cmp	r14, r5
ffe05a53:	25 19                         	bleu.b	ffe05a6c <_Reset_Vector+0xffe05a70>
ffe05a55:	4b fe                         	add	r15, r14
ffe05a57:	71 23 ff                      	add	#-1, r2, r3
ffe05a5a:	47 ef                         	cmp	r14, r15
ffe05a5c:	25 05                         	bleu.b	ffe05a61 <_Reset_Vector+0xffe05a65>
ffe05a5e:	38 3e 01                      	bra.w	ffe05b9c <_Reset_Vector+0xffe05ba0>
ffe05a61:	47 e5                         	cmp	r14, r5
ffe05a63:	24 05                         	bgtu.b	ffe05a68 <_Reset_Vector+0xffe05a6c>
ffe05a65:	38 37 01                      	bra.w	ffe05b9c <_Reset_Vector+0xffe05ba0>
ffe05a68:	60 22                         	sub	#2, r2
ffe05a6a:	4b fe                         	add	r15, r14
ffe05a6c:	6d 04                         	shll	#16, r4
ffe05a6e:	43 5e                         	sub	r5, r14
ffe05a70:	57 42                         	or	r4, r2
ffe05a72:	38 98 fe                      	bra.w	ffe0590a <_Reset_Vector+0xffe0590e>
ffe05a75:	fd 62 a4                      	shll	r10, r4
ffe05a78:	ef 37                         	mov.l	r3, r7
ffe05a7a:	fd 60 57                      	shlr	r5, r7
ffe05a7d:	57 74                         	or	r7, r4
ffe05a7f:	ef 27                         	mov.l	r2, r7
ffe05a81:	fd 60 57                      	shlr	r5, r7
ffe05a84:	fd 90 4f                      	shlr	#16, r4, r15
ffe05a87:	ef 2e                         	mov.l	r2, r14
ffe05a89:	fd 62 ae                      	shll	r10, r14
ffe05a8c:	ef 76                         	mov.l	r7, r6
ffe05a8e:	fc 27 f6                      	divu	r15, r6
ffe05a91:	ef 12                         	mov.l	r1, r2
ffe05a93:	fd 60 52                      	shlr	r5, r2
ffe05a96:	ff 35 f6                      	mul 	r15, r6, r5
ffe05a99:	57 e2                         	or	r14, r2
ffe05a9b:	43 57                         	sub	r5, r7
ffe05a9d:	fb be ff ff 00                	mov.l	#0xffff, r11
ffe05aa2:	53 4b                         	and	r4, r11
ffe05aa4:	6d 07                         	shll	#16, r7
ffe05aa6:	fd 90 2c                      	shlr	#16, r2, r12
ffe05aa9:	ff 35 6b                      	mul 	r6, r11, r5
ffe05aac:	57 c7                         	or	r12, r7
ffe05aae:	ef 3c                         	mov.l	r3, r12
ffe05ab0:	fd 62 ac                      	shll	r10, r12
ffe05ab3:	47 75                         	cmp	r7, r5
ffe05ab5:	25 19                         	bleu.b	ffe05ace <_Reset_Vector+0xffe05ad2>
ffe05ab7:	4b 47                         	add	r4, r7
ffe05ab9:	71 63 ff                      	add	#-1, r6, r3
ffe05abc:	47 74                         	cmp	r7, r4
ffe05abe:	25 05                         	bleu.b	ffe05ac3 <_Reset_Vector+0xffe05ac7>
ffe05ac0:	38 e1 00                      	bra.w	ffe05ba1 <_Reset_Vector+0xffe05ba5>
ffe05ac3:	47 75                         	cmp	r7, r5
ffe05ac5:	24 05                         	bgtu.b	ffe05aca <_Reset_Vector+0xffe05ace>
ffe05ac7:	38 da 00                      	bra.w	ffe05ba1 <_Reset_Vector+0xffe05ba5>
ffe05aca:	60 26                         	sub	#2, r6
ffe05acc:	4b 47                         	add	r4, r7
ffe05ace:	43 57                         	sub	r5, r7
ffe05ad0:	fb ee ff ff 00                	mov.l	#0xffff, r14
ffe05ad5:	53 2e                         	and	r2, r14
ffe05ad7:	ef 75                         	mov.l	r7, r5
ffe05ad9:	fc 27 f5                      	divu	r15, r5
ffe05adc:	ff 32 f5                      	mul 	r15, r5, r2
ffe05adf:	43 27                         	sub	r2, r7
ffe05ae1:	fd d0 72                      	shll	#16, r7, r2
ffe05ae4:	4f 5b                         	mul	r5, r11
ffe05ae6:	57 e2                         	or	r14, r2
ffe05ae8:	47 2b                         	cmp	r2, r11
ffe05aea:	25 19                         	bleu.b	ffe05b03 <_Reset_Vector+0xffe05b07>
ffe05aec:	4b 42                         	add	r4, r2
ffe05aee:	71 57 ff                      	add	#-1, r5, r7
ffe05af1:	47 24                         	cmp	r2, r4
ffe05af3:	25 05                         	bleu.b	ffe05af8 <_Reset_Vector+0xffe05afc>
ffe05af5:	38 a2 00                      	bra.w	ffe05b97 <_Reset_Vector+0xffe05b9b>
ffe05af8:	47 2b                         	cmp	r2, r11
ffe05afa:	24 05                         	bgtu.b	ffe05aff <_Reset_Vector+0xffe05b03>
ffe05afc:	38 9b 00                      	bra.w	ffe05b97 <_Reset_Vector+0xffe05b9b>
ffe05aff:	60 25                         	sub	#2, r5
ffe05b01:	4b 42                         	add	r4, r2
ffe05b03:	fd d0 63                      	shll	#16, r6, r3
ffe05b06:	fb 6e ff ff 00                	mov.l	#0xffff, r6
ffe05b0b:	53 c6                         	and	r12, r6
ffe05b0d:	57 53                         	or	r5, r3
ffe05b0f:	fd 90 ce                      	shlr	#16, r12, r14
ffe05b12:	fb 7e ff ff 00                	mov.l	#0xffff, r7
ffe05b17:	53 37                         	and	r3, r7
ffe05b19:	fd 90 3c                      	shlr	#16, r3, r12
ffe05b1c:	ff 34 67                      	mul 	r6, r7, r4
ffe05b1f:	4f c6                         	mul	r12, r6
ffe05b21:	4f e7                         	mul	r14, r7
ffe05b23:	fd 90 45                      	shlr	#16, r4, r5
ffe05b26:	4b 67                         	add	r6, r7
ffe05b28:	43 b2                         	sub	r11, r2
ffe05b2a:	4b 57                         	add	r5, r7
ffe05b2c:	4f ec                         	mul	r14, r12
ffe05b2e:	47 76                         	cmp	r7, r6
ffe05b30:	25 08                         	bleu.b	ffe05b38 <_Reset_Vector+0xffe05b3c>
ffe05b32:	73 cc 00 00 01                	add	#0x10000, r12, r12
ffe05b37:	03                            	nop
ffe05b38:	fd 90 75                      	shlr	#16, r7, r5
ffe05b3b:	4b 5c                         	add	r5, r12
ffe05b3d:	47 c2                         	cmp	r12, r2
ffe05b3f:	23 1d                         	bnc.b	ffe05b5c <_Reset_Vector+0xffe05b60>
ffe05b41:	10                            	beq.s	ffe05b49 <_Reset_Vector+0xffe05b4d>
ffe05b42:	ef 31                         	mov.l	r3, r1
ffe05b44:	66 02                         	mov.l	#0, r2
ffe05b46:	3f 6c 07                      	rtsd	#28, r6-r12
ffe05b49:	fd d0 75                      	shll	#16, r7, r5
ffe05b4c:	77 24 ff ff 00                	and	#0xffff, r4
ffe05b51:	ef 17                         	mov.l	r1, r7
ffe05b53:	fd 62 a7                      	shll	r10, r7
ffe05b56:	4b 45                         	add	r4, r5
ffe05b58:	47 57                         	cmp	r5, r7
ffe05b5a:	22 e8                         	bc.b	ffe05b42 <_Reset_Vector+0xffe05b46>
ffe05b5c:	71 31 ff                      	add	#-1, r3, r1
ffe05b5f:	66 02                         	mov.l	#0, r2
ffe05b61:	3f 6c 07                      	rtsd	#28, r6-r12
ffe05b64:	fd 90 45                      	shlr	#16, r4, r5
ffe05b67:	75 4a 10                      	mov.l	#16, r10
ffe05b6a:	38 1e fe                      	bra.w	ffe05988 <_Reset_Vector+0xffe0598c>
ffe05b6d:	66 02                         	mov.l	#0, r2
ffe05b6f:	66 11                         	mov.l	#1, r1
ffe05b71:	3f 6c 07                      	rtsd	#28, r6-r12
ffe05b74:	ef 45                         	mov.l	r4, r5
ffe05b76:	66 0a                         	mov.l	#0, r10
ffe05b78:	38 10 fe                      	bra.w	ffe05988 <_Reset_Vector+0xffe0598c>
ffe05b7b:	ef 36                         	mov.l	r3, r6
ffe05b7d:	38 ac fc                      	bra.w	ffe05829 <_Reset_Vector+0xffe0582d>
ffe05b80:	fd 90 f4                      	shlr	#16, r15, r4
ffe05b83:	75 45 10                      	mov.l	#16, r5
ffe05b86:	38 62 fd                      	bra.w	ffe058e8 <_Reset_Vector+0xffe058ec>
ffe05b89:	fd 90 36                      	shlr	#16, r3, r6
ffe05b8c:	75 45 10                      	mov.l	#16, r5
ffe05b8f:	38 9a fc                      	bra.w	ffe05829 <_Reset_Vector+0xffe0582d>
ffe05b92:	ef f4                         	mov.l	r15, r4
ffe05b94:	38 54 fd                      	bra.w	ffe058e8 <_Reset_Vector+0xffe058ec>
ffe05b97:	ef 75                         	mov.l	r7, r5
ffe05b99:	38 6a ff                      	bra.w	ffe05b03 <_Reset_Vector+0xffe05b07>
ffe05b9c:	ef 32                         	mov.l	r3, r2
ffe05b9e:	38 ce fe                      	bra.w	ffe05a6c <_Reset_Vector+0xffe05a70>
ffe05ba1:	ef 36                         	mov.l	r3, r6
ffe05ba3:	38 2b ff                      	bra.w	ffe05ace <_Reset_Vector+0xffe05ad2>
ffe05ba6:	ef 34                         	mov.l	r3, r4
ffe05ba8:	38 8e fe                      	bra.w	ffe05a36 <_Reset_Vector+0xffe05a3a>
ffe05bab:	60 23                         	sub	#2, r3
ffe05bad:	38 b5 fd                      	bra.w	ffe05962 <_Reset_Vector+0xffe05966>
ffe05bb0:	60 23                         	sub	#2, r3
ffe05bb2:	38 03 fd                      	bra.w	ffe058b5 <_Reset_Vector+0xffe058b9>
ffe05bb5:	60 25                         	sub	#2, r5
ffe05bb7:	4b fa                         	add	r15, r10
ffe05bb9:	38 cd fc                      	bra.w	ffe05886 <_Reset_Vector+0xffe0588a>
ffe05bbc:	60 25                         	sub	#2, r5
ffe05bbe:	4b f4                         	add	r15, r4
ffe05bc0:	38 74 fd                      	bra.w	ffe05934 <_Reset_Vector+0xffe05938>
ffe05bc3:	77 10 01 00 00                	nop	; mul	#1, r0
